var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
import { ref, unref, getCurrentScope, onScopeDispose, getCurrentInstance, onUnmounted, computed, watch as watch$1, defineComponent, watchEffect, onMounted, openBlock, createElementBlock, normalizeStyle as normalizeStyle$1, toDisplayString, nextTick as nextTick$1, createElementVNode, renderSlot, createTextVNode, pushScopeId, popScopeId, createBlock, withCtx, h as h$1, onUpdated, onBeforeUnmount, onBeforeUpdate, withDirectives, vShow, createVNode as createVNode$1, Fragment, renderList, createStaticVNode, warn as warn$1, inject, isRef, onBeforeMount, provide, mergeProps, useAttrs as useAttrs$1, useSlots, shallowRef, toRef, normalizeClass, createCommentVNode, resolveDynamicComponent, withModifiers, Transition, resolveComponent, reactive, cloneVNode, Text, Comment, Teleport, readonly, resolveDirective, vModelCheckbox, toRefs, withKeys, vModelRadio, vModelText, createSlots, toRaw, triggerRef, normalizeProps, guardReactiveProps, TransitionGroup } from "vue";
function tryOnScopeDispose$1(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
const isClient$1 = typeof window !== "undefined";
const isFunction$4 = (val) => typeof val === "function";
const isNumber$3 = (val) => typeof val === "number";
const clamp$1 = (n, min3, max3) => Math.min(max3, Math.max(min3, n));
const noop$3 = () => {
};
function createFilterWrapper(filter2, fn2) {
  function wrapper(...args) {
    filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer2;
  let maxTimer;
  const filter2 = (invoke) => {
    const duration = unref(ms);
    const maxDuration = unref(options.maxWait);
    if (timer2)
      clearTimeout(timer2);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer2)
          clearTimeout(timer2);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer2 = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter2;
}
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer2;
  let preventLeading = !leading;
  const clear2 = () => {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = void 0;
    }
  };
  const filter2 = (invoke) => {
    const duration = unref(ms);
    const elapsed = Date.now() - lastExec;
    clear2();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration) {
      lastExec = Date.now();
      if (preventLeading)
        preventLeading = false;
      else
        invoke();
    }
    if (trailing) {
      timer2 = setTimeout(() => {
        lastExec = Date.now();
        if (!leading)
          preventLeading = true;
        clear2();
        invoke();
      }, duration);
    }
    if (!leading && !timer2)
      timer2 = setTimeout(() => preventLeading = true, duration);
  };
  return filter2;
}
function identity$2(arg) {
  return arg;
}
function useDebounceFn(fn2, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn2);
}
function useThrottleFn(fn2, ms = 200, trailing = true, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn2);
}
function tryOnUnmounted(fn2) {
  if (getCurrentInstance())
    onUnmounted(fn2);
}
function useTimeoutFn$2(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer2 = null;
  function clear2() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear2();
  }
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer2 = setTimeout(() => {
      isPending.value = false;
      timer2 = null;
      cb(...args);
    }, unref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient$1)
      start2();
  }
  tryOnScopeDispose$1(stop2);
  return {
    isPending,
    start: start2,
    stop: stop2
  };
}
const defaultWindow$1 = isClient$1 ? window : void 0;
const _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey$1 = "__vueuse_ssr_handlers__";
_global$1[globalKey$1] = _global$1[globalKey$1] || {};
_global$1[globalKey$1];
function useRafFn(fn2, options = {}) {
  const {
    immediate = true,
    window: window2 = defaultWindow$1
  } = options;
  const isActive = ref(false);
  function loop2() {
    if (!isActive.value || !window2)
      return;
    fn2();
    window2.requestAnimationFrame(loop2);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      loop2();
    }
  }
  function pause() {
    isActive.value = false;
  }
  if (immediate)
    resume();
  tryOnScopeDispose$1(pause);
  return {
    isActive,
    pause,
    resume
  };
}
var _a$2, _b$2;
isClient$1 && (window == null ? void 0 : window.navigator) && ((_a$2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a$2.platform) && /iP(ad|hone|od)/.test((_b$2 = window == null ? void 0 : window.navigator) == null ? void 0 : _b$2.platform);
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key2, value) => key2 in obj ? __defProp$3(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __spreadValues$3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$3.call(b2, prop))
      __defNormalProp$3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b2)) {
      if (__propIsEnum$3.call(b2, prop))
        __defNormalProp$3(a2, prop, b2[prop]);
    }
  return a2;
};
const initialRect = {
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
  height: 0,
  width: 0
};
__spreadValues$3({
  text: ""
}, initialRect);
const TransitionPresets = {
  linear: identity$2,
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
function createEasingFunction([p0, p1, p2, p3]) {
  const a2 = (a1, a22) => 1 - 3 * a22 + 3 * a1;
  const b2 = (a1, a22) => 3 * a22 - 6 * a1;
  const c = (a1) => 3 * a1;
  const calcBezier = (t, a1, a22) => ((a2(a1, a22) * t + b2(a1, a22)) * t + c(a1)) * t;
  const getSlope = (t, a1, a22) => 3 * a2(a1, a22) * t * t + 2 * b2(a1, a22) * t + c(a1);
  const getTforX = (x2) => {
    let aGuessT = x2;
    for (let i = 0; i < 4; ++i) {
      const currentSlope = getSlope(aGuessT, p0, p2);
      if (currentSlope === 0)
        return aGuessT;
      const currentX = calcBezier(aGuessT, p0, p2) - x2;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  return (x2) => p0 === p1 && p2 === p3 ? x2 : calcBezier(getTforX(x2), p1, p3);
}
function useTransition(source, options = {}) {
  const {
    delay = 0,
    disabled = false,
    duration = 1e3,
    onFinished = noop$3,
    onStarted = noop$3,
    transition: transition2 = identity$2
  } = options;
  const currentTransition = computed(() => {
    const t = unref(transition2);
    return isFunction$4(t) ? t : createEasingFunction(t);
  });
  const sourceValue = computed(() => {
    const s2 = unref(source);
    return isNumber$3(s2) ? s2 : s2.map(unref);
  });
  const sourceVector = computed(() => isNumber$3(sourceValue.value) ? [sourceValue.value] : sourceValue.value);
  const outputVector = ref(sourceVector.value.slice(0));
  let currentDuration;
  let diffVector;
  let endAt;
  let startAt;
  let startVector;
  const { resume, pause } = useRafFn(() => {
    const now2 = Date.now();
    const progress = clamp$1(1 - (endAt - now2) / currentDuration, 0, 1);
    outputVector.value = startVector.map((val, i) => {
      var _a2;
      return val + ((_a2 = diffVector[i]) != null ? _a2 : 0) * currentTransition.value(progress);
    });
    if (progress >= 1) {
      pause();
      onFinished();
    }
  }, { immediate: false });
  const start2 = () => {
    pause();
    currentDuration = unref(duration);
    diffVector = outputVector.value.map((n, i) => {
      var _a2, _b2;
      return ((_a2 = sourceVector.value[i]) != null ? _a2 : 0) - ((_b2 = outputVector.value[i]) != null ? _b2 : 0);
    });
    startVector = outputVector.value.slice(0);
    startAt = Date.now();
    endAt = startAt + currentDuration;
    resume();
    onStarted();
  };
  const timeout = useTimeoutFn$2(start2, delay, { immediate: false });
  watch$1(sourceVector, () => {
    if (unref(disabled)) {
      outputVector.value = sourceVector.value.slice(0);
    } else {
      if (unref(delay) <= 0)
        start2();
      else
        timeout.start();
    }
  }, { deep: true });
  return computed(() => {
    const targetVector = unref(disabled) ? sourceVector : outputVector;
    return isNumber$3(sourceValue.value) ? targetVector.value[0] : targetVector.value;
  });
}
const { toString: toString$1 } = Object.prototype;
function is$1(val, type) {
  return toString$1.call(val) === `[object ${type}]`;
}
function isObject$a(val) {
  return val !== null && is$1(val, "Object");
}
function isNumber$2(val) {
  return is$1(val, "Number");
}
function isFunction$3(val) {
  return typeof val === "function";
}
var index_vue_vue_type_style_index_0_scoped_true_lang$f = "";
var _export_sfc$2 = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props2) {
    target[key2] = val;
  }
  return target;
};
const props = {
  startVal: { type: Number, default: 0 },
  endVal: { type: Number, default: 2021 },
  duration: { type: Number, default: 1500 },
  autoplay: { type: Boolean, default: true },
  decimals: {
    type: Number,
    default: 0,
    validator(value) {
      return value >= 0;
    }
  },
  prefix: { type: String, default: "" },
  suffix: { type: String, default: "" },
  separator: { type: String, default: "," },
  decimal: { type: String, default: "." },
  color: { type: String },
  useEasing: { type: Boolean, default: true },
  transition: { type: String, default: "linear" }
};
const _sfc_main$5B = defineComponent({
  name: "CountTo",
  props,
  emits: ["onStarted", "onFinished"],
  setup(props2, { emit }) {
    const source = ref(props2.startVal);
    const disabled = ref(false);
    let outputValue = useTransition(source);
    const value = computed(() => formatNumber(unref(outputValue)));
    watchEffect(() => {
      source.value = props2.startVal;
    });
    watch$1([() => props2.startVal, () => props2.endVal], () => {
      if (props2.autoplay) {
        start2();
      }
    });
    onMounted(() => {
      props2.autoplay && start2();
    });
    function start2() {
      run();
      source.value = props2.endVal;
    }
    function reset() {
      source.value = props2.startVal;
      run();
    }
    function run() {
      outputValue = useTransition(source, __spreadValues({
        disabled,
        duration: props2.duration,
        onFinished: () => emit("onFinished"),
        onStarted: () => emit("onStarted")
      }, props2.useEasing ? { transition: TransitionPresets[props2.transition] } : {}));
    }
    function formatNumber(num) {
      if (!num && num !== 0) {
        return "";
      }
      const { decimals, decimal, separator, suffix, prefix } = props2;
      num = Number(num).toFixed(decimals);
      num += "";
      const x2 = num.split(".");
      let x1 = x2[0];
      const x22 = x2.length > 1 ? decimal + x2[1] : "";
      const rgx = /(\d+)(\d{3})/;
      if (separator && !isNumber$2(separator)) {
        while (rgx.test(x1)) {
          x1 = x1.replace(rgx, "$1" + separator + "$2");
        }
      }
      return prefix + x1 + x22 + suffix;
    }
    return { value, start: start2, reset };
  }
});
function _sfc_render$53(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    style: normalizeStyle$1({ color: _ctx.color })
  }, toDisplayString(_ctx.value), 5);
}
var CountTo = /* @__PURE__ */ _export_sfc$2(_sfc_main$5B, [["render", _sfc_render$53], ["__scopeId", "data-v-33b32b96"]]);
const CountToPlugin = {
  install(app) {
    app.component("d-count-to", CountTo);
  }
};
function useTimeoutFn$1(handle, wait, native = false) {
  if (!isFunction$3(handle)) {
    throw new Error("handle is not Function!");
  }
  const { readyRef, stop: stop2, start: start2 } = useTimeoutRef(wait);
  if (native) {
    handle();
  } else {
    watch$1(readyRef, (maturity) => {
      maturity && handle();
    }, { immediate: false });
  }
  return { readyRef, stop: stop2, start: start2 };
}
function useTimeoutRef(wait) {
  const readyRef = ref(false);
  let timer2;
  function stop2() {
    readyRef.value = false;
    timer2 && window.clearTimeout(timer2);
  }
  function start2() {
    stop2();
    timer2 = setTimeout(() => {
      readyRef.value = true;
    }, wait);
  }
  start2();
  tryOnUnmounted(stop2);
  return { readyRef, stop: stop2, start: start2 };
}
function useEventListener$1({
  el = window,
  name,
  listener,
  options,
  autoRemove = true,
  isDebounce = true,
  wait = 80
}) {
  let remove2 = () => {
  };
  const isAddRef = ref(false);
  if (el) {
    const element = ref(el);
    const handler = isDebounce ? useDebounceFn(listener, wait) : useThrottleFn(listener, wait);
    const realHandler = wait ? handler : listener;
    const removeEventListener2 = (e2) => {
      isAddRef.value = true;
      e2.removeEventListener(name, realHandler, options);
    };
    const addEventListener2 = (e2) => e2.addEventListener(name, realHandler, options);
    const removeWatch = watch$1(element, (v2, _ov, cleanUp) => {
      if (v2) {
        !unref(isAddRef) && addEventListener2(v2);
        cleanUp(() => {
          autoRemove && removeEventListener2(v2);
        });
      }
    }, { immediate: true });
    remove2 = () => {
      removeEventListener2(element.value);
      removeWatch();
    };
  }
  return { removeEvent: remove2 };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var Browser = function() {
  function Browser2() {
    this.firefox = false;
    this.ie = false;
    this.edge = false;
    this.newEdge = false;
    this.weChat = false;
  }
  return Browser2;
}();
var Env = function() {
  function Env2() {
    this.browser = new Browser();
    this.node = false;
    this.wxa = false;
    this.worker = false;
    this.svgSupported = false;
    this.touchEventsSupported = false;
    this.pointerEventsSupported = false;
    this.domSupported = false;
    this.transformSupported = false;
    this.transform3dSupported = false;
    this.hasGlobalWindow = typeof window !== "undefined";
  }
  return Env2;
}();
var env = new Env();
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
  env.wxa = true;
  env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env.worker = true;
} else if (typeof navigator === "undefined") {
  env.node = true;
  env.svgSupported = true;
} else {
  detect(navigator.userAgent, env);
}
function detect(ua, env2) {
  var browser2 = env2.browser;
  var firefox = ua.match(/Firefox\/([\d.]+)/);
  var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge?\/([\d.]+)/);
  var weChat = /micromessenger/i.test(ua);
  if (firefox) {
    browser2.firefox = true;
    browser2.version = firefox[1];
  }
  if (ie) {
    browser2.ie = true;
    browser2.version = ie[1];
  }
  if (edge) {
    browser2.edge = true;
    browser2.version = edge[1];
    browser2.newEdge = +edge[1].split(".")[0] > 18;
  }
  if (weChat) {
    browser2.weChat = true;
  }
  env2.svgSupported = typeof SVGRect !== "undefined";
  env2.touchEventsSupported = "ontouchstart" in window && !browser2.ie && !browser2.edge;
  env2.pointerEventsSupported = "onpointerdown" in window && (browser2.edge || browser2.ie && +browser2.version >= 11);
  env2.domSupported = typeof document !== "undefined";
  var style = document.documentElement.style;
  env2.transform3dSupported = (browser2.ie && "transition" in style || browser2.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
  env2.transformSupported = env2.transform3dSupported || browser2.ie && +browser2.version >= 9;
}
var env$1 = env;
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
  var map2 = {};
  if (typeof JSON === "undefined") {
    return map2;
  }
  for (var i = 0; i < mapStr.length; i++) {
    var char = String.fromCharCode(i + 32);
    var size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
    map2[char] = size;
  }
  return map2;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas: function() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    var _ctx;
    var _cachedFont;
    return function(text2, font) {
      if (!_ctx) {
        var canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text2);
      } else {
        text2 = text2 || "";
        font = font || DEFAULT_FONT;
        var res = /^([0-9]*?)px$/.exec(font);
        var fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE;
        var width = 0;
        if (font.indexOf("mono") >= 0) {
          width = fontSize * text2.length;
        } else {
          for (var i = 0; i < text2.length; i++) {
            var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text2[i]];
            width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return { width };
      }
    };
  }(),
  loadImage: function(src, onload, onerror) {
    var image = new Image();
    image.onload = onload;
    image.onerror = onerror;
    image.src = src;
    return image;
  }
};
function setPlatformAPI(newPlatformApis) {
  for (var key2 in platformApi) {
    if (newPlatformApis[key2]) {
      platformApi[key2] = newPlatformApis[key2];
    }
  }
}
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(obj, val) {
  obj["[object " + val + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(obj, val) {
  obj["[object " + val + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto$1 = Array.prototype;
var nativeForEach = arrayProto$1.forEach;
var nativeFilter = arrayProto$1.filter;
var nativeSlice = arrayProto$1.slice;
var nativeMap = arrayProto$1.map;
var ctorFunction = function() {
}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart = 2311;
function guid() {
  return idStart++;
}
function logError() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (typeof console !== "undefined") {
    console.error.apply(console, args);
  }
}
function clone$3(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  var result = source;
  var typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (var i = 0, len2 = source.length; i < len2; i++) {
        result[i] = clone$3(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;
      if (Ctor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (var i = 0, len2 = source.length; i < len2; i++) {
          result[i] = source[i];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (var key2 in source) {
      if (source.hasOwnProperty(key2) && key2 !== protoKey) {
        result[key2] = clone$3(source[key2]);
      }
    }
  }
  return result;
}
function merge(target, source, overwrite) {
  if (!isObject$9(source) || !isObject$9(target)) {
    return overwrite ? clone$3(source) : target;
  }
  for (var key2 in source) {
    if (source.hasOwnProperty(key2) && key2 !== protoKey) {
      var targetProp = target[key2];
      var sourceProp = source[key2];
      if (isObject$9(sourceProp) && isObject$9(targetProp) && !isArray$4(sourceProp) && !isArray$4(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key2 in target)) {
        target[key2] = clone$3(source[key2]);
      }
    }
  }
  return target;
}
function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];
  for (var i = 1, len2 = targetAndSources.length; i < len2; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }
  return result;
}
function extend$3(target, source) {
  if (Object.assign) {
    Object.assign(target, source);
  } else {
    for (var key2 in source) {
      if (source.hasOwnProperty(key2) && key2 !== protoKey) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
}
function defaults$1(target, source, overlay) {
  var keysArr = keys$1(source);
  for (var i = 0; i < keysArr.length; i++) {
    var key2 = keysArr[i];
    if (overlay ? source[key2] != null : target[key2] == null) {
      target[key2] = source[key2];
    }
  }
  return target;
}
var createCanvas = platformApi.createCanvas;
function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }
    for (var i = 0, len2 = array.length; i < len2; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }
  return -1;
}
function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;
  function F2() {
  }
  F2.prototype = baseClazz.prototype;
  clazz.prototype = new F2();
  for (var prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
function mixin(target, source, override) {
  target = "prototype" in target ? target.prototype : target;
  source = "prototype" in source ? source.prototype : source;
  if (Object.getOwnPropertyNames) {
    var keyList = Object.getOwnPropertyNames(source);
    for (var i = 0; i < keyList.length; i++) {
      var key2 = keyList[i];
      if (key2 !== "constructor") {
        if (override ? source[key2] != null : target[key2] == null) {
          target[key2] = source[key2];
        }
      }
    }
  } else {
    defaults$1(target, source, override);
  }
}
function isArrayLike$1(data) {
  if (!data) {
    return false;
  }
  if (typeof data === "string") {
    return false;
  }
  return typeof data.length === "number";
}
function each$e(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  if (arr.forEach && arr.forEach === nativeForEach) {
    arr.forEach(cb, context);
  } else if (arr.length === +arr.length) {
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      cb.call(context, arr[i], i, arr);
    }
  } else {
    for (var key2 in arr) {
      if (arr.hasOwnProperty(key2)) {
        cb.call(context, arr[key2], key2, arr);
      }
    }
  }
}
function map$1(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.map && arr.map === nativeMap) {
    return arr.map(cb, context);
  } else {
    var result = [];
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      result.push(cb.call(context, arr[i], i, arr));
    }
    return result;
  }
}
function reduce(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i = 0, len2 = arr.length; i < len2; i++) {
    memo = cb.call(context, memo, arr[i], i, arr);
  }
  return memo;
}
function filter$2(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.filter && arr.filter === nativeFilter) {
    return arr.filter(cb, context);
  } else {
    var result = [];
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        result.push(arr[i]);
      }
    }
    return result;
  }
}
function find$1(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i = 0, len2 = arr.length; i < len2; i++) {
    if (cb.call(context, arr[i], i, arr)) {
      return arr[i];
    }
  }
}
function keys$1(obj) {
  if (!obj) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keyList = [];
  for (var key2 in obj) {
    if (obj.hasOwnProperty(key2)) {
      keyList.push(key2);
    }
  }
  return keyList;
}
function bindPolyfill(func, context) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
var bind$1 = protoFunction && isFunction$2(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry$1(func) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray$4(value) {
  if (Array.isArray) {
    return Array.isArray(value);
  }
  return objToString.call(value) === "[object Array]";
}
function isFunction$2(value) {
  return typeof value === "function";
}
function isString$2(value) {
  return typeof value === "string";
}
function isStringSafe(value) {
  return objToString.call(value) === "[object String]";
}
function isNumber$1(value) {
  return typeof value === "number";
}
function isObject$9(value) {
  var type = typeof value;
  return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray$2(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function isGradientObject(value) {
  return value.colorStops != null;
}
function isImagePatternObject(value) {
  return value.image != null;
}
function isRegExp(value) {
  return objToString.call(value) === "[object RegExp]";
}
function eqNaN(value) {
  return value !== value;
}
function retrieve() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  for (var i = 0, len2 = args.length; i < len2; i++) {
    if (args[i] != null) {
      return args[i];
    }
  }
}
function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice(arr) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return nativeSlice.apply(arr, args);
}
function normalizeCssArray$1(val) {
  if (typeof val === "number") {
    return [val, val, val, val];
  }
  var len2 = val.length;
  if (len2 === 2) {
    return [val[0], val[1], val[0], val[1]];
  } else if (len2 === 3) {
    return [val[0], val[1], val[2], val[1]];
  }
  return val;
}
function assert(condition, message2) {
  if (!condition) {
    throw new Error(message2);
  }
}
function trim$1(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
var HashMap = function() {
  function HashMap2(obj) {
    this.data = {};
    var isArr = isArray$4(obj);
    this.data = {};
    var thisMap = this;
    obj instanceof HashMap2 ? obj.each(visit) : obj && each$e(obj, visit);
    function visit(value, key2) {
      isArr ? thisMap.set(value, key2) : thisMap.set(key2, value);
    }
  }
  HashMap2.prototype.get = function(key2) {
    return this.data.hasOwnProperty(key2) ? this.data[key2] : null;
  };
  HashMap2.prototype.set = function(key2, value) {
    return this.data[key2] = value;
  };
  HashMap2.prototype.each = function(cb, context) {
    for (var key2 in this.data) {
      if (this.data.hasOwnProperty(key2)) {
        cb.call(context, this.data[key2], key2);
      }
    }
  };
  HashMap2.prototype.keys = function() {
    return keys$1(this.data);
  };
  HashMap2.prototype.removeKey = function(key2) {
    delete this.data[key2];
  };
  return HashMap2;
}();
function createHashMap(obj) {
  return new HashMap(obj);
}
function concatArray(a2, b2) {
  var newArray = new a2.constructor(a2.length + b2.length);
  for (var i = 0; i < a2.length; i++) {
    newArray[i] = a2[i];
  }
  var offset2 = a2.length;
  for (var i = 0; i < b2.length; i++) {
    newArray[i + offset2] = b2[i];
  }
  return newArray;
}
function createObject(proto2, properties) {
  var obj;
  if (Object.create) {
    obj = Object.create(proto2);
  } else {
    var StyleCtor = function() {
    };
    StyleCtor.prototype = proto2;
    obj = new StyleCtor();
  }
  if (properties) {
    extend$3(obj, properties);
  }
  return obj;
}
function disableUserSelect(dom) {
  var domStyle = dom.style;
  domStyle.webkitUserSelect = "none";
  domStyle.userSelect = "none";
  domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
  domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn$1(own, prop) {
  return own.hasOwnProperty(prop);
}
function noop$2() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;
var util$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  guid,
  logError,
  clone: clone$3,
  merge,
  mergeAll,
  extend: extend$3,
  defaults: defaults$1,
  createCanvas,
  indexOf,
  inherits,
  mixin,
  isArrayLike: isArrayLike$1,
  each: each$e,
  map: map$1,
  reduce,
  filter: filter$2,
  find: find$1,
  keys: keys$1,
  bind: bind$1,
  curry: curry$1,
  isArray: isArray$4,
  isFunction: isFunction$2,
  isString: isString$2,
  isStringSafe,
  isNumber: isNumber$1,
  isObject: isObject$9,
  isBuiltInObject,
  isTypedArray: isTypedArray$2,
  isDom,
  isGradientObject,
  isImagePatternObject,
  isRegExp,
  eqNaN,
  retrieve,
  retrieve2,
  retrieve3,
  slice,
  normalizeCssArray: normalizeCssArray$1,
  assert,
  trim: trim$1,
  setAsPrimitive,
  isPrimitive,
  HashMap,
  createHashMap,
  concatArray,
  createObject,
  disableUserSelect,
  hasOwn: hasOwn$1,
  noop: noop$2,
  RADIAN_TO_DEGREE
}, Symbol.toStringTag, { value: "Module" }));
function create$1(x2, y) {
  if (x2 == null) {
    x2 = 0;
  }
  if (y == null) {
    y = 0;
  }
  return [x2, y];
}
function copy$1(out2, v2) {
  out2[0] = v2[0];
  out2[1] = v2[1];
  return out2;
}
function clone$2(v2) {
  return [v2[0], v2[1]];
}
function set$2(out2, a2, b2) {
  out2[0] = a2;
  out2[1] = b2;
  return out2;
}
function add(out2, v1, v2) {
  out2[0] = v1[0] + v2[0];
  out2[1] = v1[1] + v2[1];
  return out2;
}
function scaleAndAdd(out2, v1, v2, a2) {
  out2[0] = v1[0] + v2[0] * a2;
  out2[1] = v1[1] + v2[1] * a2;
  return out2;
}
function sub(out2, v1, v2) {
  out2[0] = v1[0] - v2[0];
  out2[1] = v1[1] - v2[1];
  return out2;
}
function len(v2) {
  return Math.sqrt(lenSquare(v2));
}
var length = len;
function lenSquare(v2) {
  return v2[0] * v2[0] + v2[1] * v2[1];
}
var lengthSquare = lenSquare;
function mul$1(out2, v1, v2) {
  out2[0] = v1[0] * v2[0];
  out2[1] = v1[1] * v2[1];
  return out2;
}
function div(out2, v1, v2) {
  out2[0] = v1[0] / v2[0];
  out2[1] = v1[1] / v2[1];
  return out2;
}
function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function scale$2(out2, v2, s2) {
  out2[0] = v2[0] * s2;
  out2[1] = v2[1] * s2;
  return out2;
}
function normalize$1(out2, v2) {
  var d2 = len(v2);
  if (d2 === 0) {
    out2[0] = 0;
    out2[1] = 0;
  } else {
    out2[0] = v2[0] / d2;
    out2[1] = v2[1] / d2;
  }
  return out2;
}
function distance(v1, v2) {
  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}
var dist$1 = distance;
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
var distSquare = distanceSquare;
function negate(out2, v2) {
  out2[0] = -v2[0];
  out2[1] = -v2[1];
  return out2;
}
function lerp$1(out2, v1, v2, t) {
  out2[0] = v1[0] + t * (v2[0] - v1[0]);
  out2[1] = v1[1] + t * (v2[1] - v1[1]);
  return out2;
}
function applyTransform$1(out2, v2, m2) {
  var x2 = v2[0];
  var y = v2[1];
  out2[0] = m2[0] * x2 + m2[2] * y + m2[4];
  out2[1] = m2[1] * x2 + m2[3] * y + m2[5];
  return out2;
}
function min$2(out2, v1, v2) {
  out2[0] = Math.min(v1[0], v2[0]);
  out2[1] = Math.min(v1[1], v2[1]);
  return out2;
}
function max$2(out2, v1, v2) {
  out2[0] = Math.max(v1[0], v2[0]);
  out2[1] = Math.max(v1[1], v2[1]);
  return out2;
}
var vector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: create$1,
  copy: copy$1,
  clone: clone$2,
  set: set$2,
  add,
  scaleAndAdd,
  sub,
  len,
  length,
  lenSquare,
  lengthSquare,
  mul: mul$1,
  div,
  dot,
  scale: scale$2,
  normalize: normalize$1,
  distance,
  dist: dist$1,
  distanceSquare,
  distSquare,
  negate,
  lerp: lerp$1,
  applyTransform: applyTransform$1,
  min: min$2,
  max: max$2
}, Symbol.toStringTag, { value: "Module" }));
var Param = function() {
  function Param2(target, e2) {
    this.target = target;
    this.topTarget = e2 && e2.topTarget;
  }
  return Param2;
}();
var Draggable = function() {
  function Draggable2(handler) {
    this.handler = handler;
    handler.on("mousedown", this._dragStart, this);
    handler.on("mousemove", this._drag, this);
    handler.on("mouseup", this._dragEnd, this);
  }
  Draggable2.prototype._dragStart = function(e2) {
    var draggingTarget = e2.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e2.offsetX;
      this._y = e2.offsetY;
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
    }
  };
  Draggable2.prototype._drag = function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      var x2 = e2.offsetX;
      var y = e2.offsetY;
      var dx = x2 - this._x;
      var dy = y - this._y;
      this._x = x2;
      this._y = y;
      draggingTarget.drift(dx, dy, e2);
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
      var dropTarget = this.handler.findHover(x2, y, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
        }
      }
    }
  };
  Draggable2.prototype._dragEnd = function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
    if (this._dropTarget) {
      this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  };
  return Draggable2;
}();
var Draggable$1 = Draggable;
var Eventful = function() {
  function Eventful2(eventProcessors) {
    if (eventProcessors) {
      this._$eventProcessor = eventProcessors;
    }
  }
  Eventful2.prototype.on = function(event, query, handler, context) {
    if (!this._$handlers) {
      this._$handlers = {};
    }
    var _h = this._$handlers;
    if (typeof query === "function") {
      context = handler;
      handler = query;
      query = null;
    }
    if (!handler || !event) {
      return this;
    }
    var eventProcessor = this._$eventProcessor;
    if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
      query = eventProcessor.normalizeQuery(query);
    }
    if (!_h[event]) {
      _h[event] = [];
    }
    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }
    var wrap = {
      h: handler,
      query,
      ctx: context || this,
      callAtLast: handler.zrEventfulCallAtLast
    };
    var lastIndex = _h[event].length - 1;
    var lastWrap = _h[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
    return this;
  };
  Eventful2.prototype.isSilent = function(eventName) {
    var _h = this._$handlers;
    return !_h || !_h[eventName] || !_h[eventName].length;
  };
  Eventful2.prototype.off = function(eventType, handler) {
    var _h = this._$handlers;
    if (!_h) {
      return this;
    }
    if (!eventType) {
      this._$handlers = {};
      return this;
    }
    if (handler) {
      if (_h[eventType]) {
        var newList = [];
        for (var i = 0, l2 = _h[eventType].length; i < l2; i++) {
          if (_h[eventType][i].h !== handler) {
            newList.push(_h[eventType][i]);
          }
        }
        _h[eventType] = newList;
      }
      if (_h[eventType] && _h[eventType].length === 0) {
        delete _h[eventType];
      }
    } else {
      delete _h[eventType];
    }
    return this;
  };
  Eventful2.prototype.trigger = function(eventType) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[eventType];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var len2 = _h.length;
      for (var i = 0; i < len2; i++) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(hItem.ctx);
            break;
          case 1:
            hItem.h.call(hItem.ctx, args[0]);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
    return this;
  };
  Eventful2.prototype.triggerWithContext = function(type) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var ctx = args[argLen - 1];
      var len2 = _h.length;
      for (var i = 0; i < len2; i++) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(ctx);
            break;
          case 1:
            hItem.h.call(ctx, args[0]);
            break;
          case 2:
            hItem.h.call(ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(ctx, args.slice(1, argLen - 1));
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  };
  return Eventful2;
}();
var Eventful$1 = Eventful;
var LN2 = Math.log(2);
function determinant(rows, rank2, rowStart, rowMask, colMask, detCache) {
  var cacheKey = rowMask + "-" + colMask;
  var fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank2 === 1) {
    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  var subRowMask = rowMask | 1 << rowStart;
  var subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  var sum = 0;
  for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
    var colTag = 1 << j;
    if (!(colTag & colMask)) {
      sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank2 - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum;
  return sum;
}
function buildTransformer(src, dest) {
  var mA = [
    [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
    [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
    [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
    [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
    [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
    [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
    [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
    [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
  ];
  var detCache = {};
  var det = determinant(mA, 8, 0, 0, 0, detCache);
  if (det === 0) {
    return;
  }
  var vh = [];
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      vh[j] == null && (vh[j] = 0);
      vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut$1 = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(out2, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env$1.domSupported && !isCanvasEl(el)) {
    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    var markers = prepareCoordMarkers(el, saved);
    var transformer = preparePointerTransformer(markers, saved, inverse);
    if (transformer) {
      transformer(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el, saved) {
  var markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  var propLR = ["left", "right"];
  var propTB = ["top", "bottom"];
  for (var i = 0; i < 4; i++) {
    var marker = document.createElement("div");
    var stl = marker.style;
    var idxLR = i % 2;
    var idxTB = (i >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el.appendChild(marker);
    markers.push(marker);
  }
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  var transformerName = inverse ? "invTrans" : "trans";
  var transformer = saved[transformerName];
  var oldSrcCoords = saved.srcCoords;
  var srcCoords = [];
  var destCoords = [];
  var oldCoordTheSame = true;
  for (var i = 0; i < 4; i++) {
    var rect = markers[i].getBoundingClientRect();
    var ii = 2 * i;
    var x2 = rect.left;
    var y = rect.top;
    srcCoords.push(x2, y);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x2 === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
  }
  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
  return el.nodeName.toUpperCase() === "CANVAS";
}
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
var firefoxNotSupportOffsetXY = env$1.browser.firefox && +env$1.browser.version.split(".")[0] < 39;
function clientToLocal(el, e2, out2, calculate) {
  out2 = out2 || {};
  if (calculate) {
    calculateZrXY(el, e2, out2);
  } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
    out2.zrX = e2.layerX;
    out2.zrY = e2.layerY;
  } else if (e2.offsetX != null) {
    out2.zrX = e2.offsetX;
    out2.zrY = e2.offsetY;
  } else {
    calculateZrXY(el, e2, out2);
  }
  return out2;
}
function calculateZrXY(el, e2, out2) {
  if (env$1.domSupported && el.getBoundingClientRect) {
    var ex = e2.clientX;
    var ey = e2.clientY;
    if (isCanvasEl(el)) {
      var box2 = el.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
        out2.zrX = _calcOut[0];
        out2.zrY = _calcOut[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent(e2) {
  return e2 || window.event;
}
function normalizeEvent(el, e2, calculate) {
  e2 = getNativeEvent(e2);
  if (e2.zrX != null) {
    return e2;
  }
  var eventType = e2.type;
  var isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el, e2, e2, calculate);
    var wheelDelta = getWheelDeltaMayPolyfill(e2);
    e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
  } else {
    var touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
    touch && clientToLocal(el, touch, e2, calculate);
  }
  var button = e2.button;
  if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
    e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e2;
}
function getWheelDeltaMayPolyfill(e2) {
  var rawWheelDelta = e2.wheelDelta;
  if (rawWheelDelta) {
    return rawWheelDelta;
  }
  var deltaX = e2.deltaX;
  var deltaY = e2.deltaY;
  if (deltaX == null || deltaY == null) {
    return rawWheelDelta;
  }
  var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
  var sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
  return 3 * delta * sign;
}
function addEventListener(el, name, handler, opt) {
  el.addEventListener(name, handler, opt);
}
function removeEventListener(el, name, handler, opt) {
  el.removeEventListener(name, handler, opt);
}
var stop = function(e2) {
  e2.preventDefault();
  e2.stopPropagation();
  e2.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e2) {
  return e2.which === 2 || e2.which === 3;
}
var GestureMgr = function() {
  function GestureMgr2() {
    this._track = [];
  }
  GestureMgr2.prototype.recognize = function(event, target, root2) {
    this._doTrack(event, target, root2);
    return this._recognize(event);
  };
  GestureMgr2.prototype.clear = function() {
    this._track.length = 0;
    return this;
  };
  GestureMgr2.prototype._doTrack = function(event, target, root2) {
    var touches = event.touches;
    if (!touches) {
      return;
    }
    var trackItem = {
      points: [],
      touches: [],
      target,
      event
    };
    for (var i = 0, len2 = touches.length; i < len2; i++) {
      var touch = touches[i];
      var pos = clientToLocal(root2, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  };
  GestureMgr2.prototype._recognize = function(event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  };
  return GestureMgr2;
}();
function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center(pointPair) {
  return [
    (pointPair[0][0] + pointPair[1][0]) / 2,
    (pointPair[0][1] + pointPair[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(tracks, event) {
    var trackLen = tracks.length;
    if (!trackLen) {
      return;
    }
    var pinchEnd = (tracks[trackLen - 1] || {}).points;
    var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: tracks[0].target,
        event
      };
    }
  }
};
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event,
    target: targetInfo.target,
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = function(_super) {
  __extends(EmptyProxy2, _super);
  function EmptyProxy2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.handler = null;
    return _this;
  }
  EmptyProxy2.prototype.dispose = function() {
  };
  EmptyProxy2.prototype.setCursor = function() {
  };
  return EmptyProxy2;
}(Eventful$1);
var HoveredResult = function() {
  function HoveredResult2(x2, y) {
    this.x = x2;
    this.y = y;
  }
  return HoveredResult2;
}();
var handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
];
var Handler = function(_super) {
  __extends(Handler2, _super);
  function Handler2(storage2, painter, proxy, painterRoot) {
    var _this = _super.call(this) || this;
    _this._hovered = new HoveredResult(0, 0);
    _this.storage = storage2;
    _this.painter = painter;
    _this.painterRoot = painterRoot;
    proxy = proxy || new EmptyProxy();
    _this.proxy = null;
    _this.setHandlerProxy(proxy);
    _this._draggingMgr = new Draggable$1(_this);
    return _this;
  }
  Handler2.prototype.setHandlerProxy = function(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      each$e(handlerNames, function(name) {
        proxy.on && proxy.on(name, this[name], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  };
  Handler2.prototype.mousemove = function(event) {
    var x2 = event.zrX;
    var y = event.zrY;
    var isOutside = isOutsideBoundary(this, x2, y);
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    var hovered = this._hovered = isOutside ? new HoveredResult(x2, y) : this.findHover(x2, y);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event);
    }
    this.dispatchToElement(hovered, "mousemove", event);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event);
    }
  };
  Handler2.prototype.mouseout = function(event) {
    var eventControl = event.zrEventControl;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event);
    }
    if (eventControl !== "no_globalout") {
      this.trigger("globalout", { type: "globalout", event });
    }
  };
  Handler2.prototype.resize = function() {
    this._hovered = new HoveredResult(0, 0);
  };
  Handler2.prototype.dispatch = function(eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  };
  Handler2.prototype.dispose = function() {
    this.proxy.dispose();
    this.storage = null;
    this.proxy = null;
    this.painter = null;
  };
  Handler2.prototype.setCursorStyle = function(cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  };
  Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;
    if (el && el.silent) {
      return;
    }
    var eventKey = "on" + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);
    while (el) {
      el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.__hostTarget ? el.__hostTarget : el.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      if (this.painter && this.painter.eachOtherLayer) {
        this.painter.eachOtherLayer(function(layer) {
          if (typeof layer[eventKey] === "function") {
            layer[eventKey].call(layer, eventPacket);
          }
          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    }
  };
  Handler2.prototype.findHover = function(x2, y, exclude) {
    var list2 = this.storage.getDisplayList();
    var out2 = new HoveredResult(x2, y);
    for (var i = list2.length - 1; i >= 0; i--) {
      var hoverCheckResult = void 0;
      if (list2[i] !== exclude && !list2[i].ignore && (hoverCheckResult = isHover(list2[i], x2, y))) {
        !out2.topTarget && (out2.topTarget = list2[i]);
        if (hoverCheckResult !== SILENT) {
          out2.target = list2[i];
          break;
        }
      }
    }
    return out2;
  };
  Handler2.prototype.processGesture = function(event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }
    var gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      var type = gestureInfo.type;
      event.gestureEvent = type;
      var res = new HoveredResult();
      res.target = gestureInfo.target;
      this.dispatchToElement(res, type, gestureInfo.event);
    }
  };
  return Handler2;
}(Eventful$1);
each$e(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
  Handler.prototype[name] = function(event) {
    var x2 = event.zrX;
    var y = event.zrY;
    var isOutside = isOutsideBoundary(this, x2, y);
    var hovered;
    var hoveredTarget;
    if (name !== "mouseup" || !isOutside) {
      hovered = this.findHover(x2, y);
      hoveredTarget = hovered.target;
    }
    if (name === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY];
      this._upEl = hoveredTarget;
    } else if (name === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name, event);
  };
});
function isHover(displayable, x2, y) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x2, y)) {
    var el = displayable;
    var isSilent = void 0;
    var ignoreClip = false;
    while (el) {
      if (el.ignoreClip) {
        ignoreClip = true;
      }
      if (!ignoreClip) {
        var clipPath = el.getClipPath();
        if (clipPath && !clipPath.contain(x2, y)) {
          return false;
        }
        if (el.silent) {
          isSilent = true;
        }
      }
      var hostEl = el.__hostTarget;
      el = hostEl ? hostEl : el.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function isOutsideBoundary(handlerInstance, x2, y) {
  var painter = handlerInstance.painter;
  return x2 < 0 || x2 > painter.getWidth() || y < 0 || y > painter.getHeight();
}
var Handler$1 = Handler;
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
  var r = 0;
  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }
  return n + r;
}
function makeAscendingRun(array, lo, hi, compare2) {
  var runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare2(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array, lo, hi) {
  hi--;
  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}
function binaryInsertionSort(array, lo, hi, start2, compare2) {
  if (start2 === lo) {
    start2++;
  }
  for (; start2 < hi; start2++) {
    var pivot = array[start2];
    var left2 = lo;
    var right2 = start2;
    var mid;
    while (left2 < right2) {
      mid = left2 + right2 >>> 1;
      if (compare2(pivot, array[mid]) < 0) {
        right2 = mid;
      } else {
        left2 = mid + 1;
      }
    }
    var n = start2 - left2;
    switch (n) {
      case 3:
        array[left2 + 3] = array[left2 + 2];
      case 2:
        array[left2 + 2] = array[left2 + 1];
      case 1:
        array[left2 + 1] = array[left2];
        break;
      default:
        while (n > 0) {
          array[left2 + n] = array[left2 + n - 1];
          n--;
        }
    }
    array[left2] = pivot;
  }
}
function gallopLeft(value, array, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset2 = 1;
  if (compare2(value, array[start2 + hint]) > 0) {
    maxOffset = length2 - hint;
    while (offset2 < maxOffset && compare2(value, array[start2 + hint + offset2]) > 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    lastOffset += hint;
    offset2 += hint;
  } else {
    maxOffset = hint + 1;
    while (offset2 < maxOffset && compare2(value, array[start2 + hint - offset2]) <= 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset2;
    offset2 = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset2) {
    var m2 = lastOffset + (offset2 - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) > 0) {
      lastOffset = m2 + 1;
    } else {
      offset2 = m2;
    }
  }
  return offset2;
}
function gallopRight(value, array, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset2 = 1;
  if (compare2(value, array[start2 + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset2 < maxOffset && compare2(value, array[start2 + hint - offset2]) < 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset2;
    offset2 = hint - tmp;
  } else {
    maxOffset = length2 - hint;
    while (offset2 < maxOffset && compare2(value, array[start2 + hint + offset2]) >= 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    lastOffset += hint;
    offset2 += hint;
  }
  lastOffset++;
  while (lastOffset < offset2) {
    var m2 = lastOffset + (offset2 - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) < 0) {
      offset2 = m2;
    } else {
      lastOffset = m2 + 1;
    }
  }
  return offset2;
}
function TimSort(array, compare2) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var runStart;
  var runLength;
  var stackSize = 0;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }
      mergeAt(n);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }
      mergeAt(n);
    }
  }
  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;
    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }
    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare2);
    start1 += k;
    length1 -= k;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare2);
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }
  function mergeLow(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];
    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
      return;
    }
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;
    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;
      do {
        if (compare2(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error();
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;
      do {
        if (compare2(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array[dest--] = tmp[cursor2--];
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare2);
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error();
    } else {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }
  return {
    mergeRuns,
    forceMergeRuns,
    pushRun
  };
}
function sort$1(array, compare2, lo, hi) {
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = array.length;
  }
  var remaining = hi - lo;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
    return;
  }
  var ts = TimSort(array, compare2);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
}
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;
var invalidZErrorLogged = false;
function logInvalidZError() {
  if (invalidZErrorLogged) {
    return;
  }
  invalidZErrorLogged = true;
  console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a2, b2) {
  if (a2.zlevel === b2.zlevel) {
    if (a2.z === b2.z) {
      return a2.z2 - b2.z2;
    }
    return a2.z - b2.z;
  }
  return a2.zlevel - b2.zlevel;
}
var Storage = function() {
  function Storage2() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    this.displayableSortFunc = shapeCompareFunc;
  }
  Storage2.prototype.traverse = function(cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  };
  Storage2.prototype.getDisplayList = function(update2, includeIgnore) {
    includeIgnore = includeIgnore || false;
    var displayList = this._displayList;
    if (update2 || !displayList.length) {
      this.updateDisplayList(includeIgnore);
    }
    return displayList;
  };
  Storage2.prototype.updateDisplayList = function(includeIgnore) {
    this._displayListLen = 0;
    var roots2 = this._roots;
    var displayList = this._displayList;
    for (var i = 0, len2 = roots2.length; i < len2; i++) {
      this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    sort$1(displayList, shapeCompareFunc);
  };
  Storage2.prototype._updateAndAddDisplayable = function(el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }
    el.beforeUpdate();
    el.update();
    el.afterUpdate();
    var userSetClipPath = el.getClipPath();
    if (el.ignoreClip) {
      clipPaths = null;
    } else if (userSetClipPath) {
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }
      var currentClipPath = userSetClipPath;
      var parentClipPath = el;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.getClipPath();
      }
    }
    if (el.childrenRef) {
      var children2 = el.childrenRef();
      for (var i = 0; i < children2.length; i++) {
        var child = children2[i];
        if (el.__dirty) {
          child.__dirty |= REDRAW_BIT;
        }
        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      }
      el.__dirty = 0;
    } else {
      var disp = el;
      if (clipPaths && clipPaths.length) {
        disp.__clipPaths = clipPaths;
      } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
        disp.__clipPaths = [];
      }
      if (isNaN(disp.z)) {
        logInvalidZError();
        disp.z = 0;
      }
      if (isNaN(disp.z2)) {
        logInvalidZError();
        disp.z2 = 0;
      }
      if (isNaN(disp.zlevel)) {
        logInvalidZError();
        disp.zlevel = 0;
      }
      this._displayList[this._displayListLen++] = disp;
    }
    var decalEl = el.getDecalElement && el.getDecalElement();
    if (decalEl) {
      this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
    }
    var textGuide = el.getTextGuideLine();
    if (textGuide) {
      this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
    }
    var textEl = el.getTextContent();
    if (textEl) {
      this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
    }
  };
  Storage2.prototype.addRoot = function(el) {
    if (el.__zr && el.__zr.storage === this) {
      return;
    }
    this._roots.push(el);
  };
  Storage2.prototype.delRoot = function(el) {
    if (el instanceof Array) {
      for (var i = 0, l2 = el.length; i < l2; i++) {
        this.delRoot(el[i]);
      }
      return;
    }
    var idx = indexOf(this._roots, el);
    if (idx >= 0) {
      this._roots.splice(idx, 1);
    }
  };
  Storage2.prototype.delAllRoots = function() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    return;
  };
  Storage2.prototype.getRoots = function() {
    return this._roots;
  };
  Storage2.prototype.dispose = function() {
    this._displayList = null;
    this._roots = null;
  };
  return Storage2;
}();
var Storage$1 = Storage;
var requestAnimationFrame$1;
requestAnimationFrame$1 = env$1.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  return setTimeout(func, 16);
};
var requestAnimationFrame$2 = requestAnimationFrame$1;
var easingFuncs = {
  linear: function(k) {
    return k;
  },
  quadraticIn: function(k) {
    return k * k;
  },
  quadraticOut: function(k) {
    return k * (2 - k);
  },
  quadraticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  },
  cubicIn: function(k) {
    return k * k * k;
  },
  cubicOut: function(k) {
    return --k * k * k + 1;
  },
  cubicInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k + 2);
  },
  quarticIn: function(k) {
    return k * k * k * k;
  },
  quarticOut: function(k) {
    return 1 - --k * k * k * k;
  },
  quarticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }
    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  quinticIn: function(k) {
    return k * k * k * k * k;
  },
  quinticOut: function(k) {
    return --k * k * k * k * k + 1;
  },
  quinticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  sinusoidalIn: function(k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },
  sinusoidalOut: function(k) {
    return Math.sin(k * Math.PI / 2);
  },
  sinusoidalInOut: function(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  exponentialIn: function(k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },
  exponentialOut: function(k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },
  exponentialInOut: function(k) {
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  circularIn: function(k) {
    return 1 - Math.sqrt(1 - k * k);
  },
  circularOut: function(k) {
    return Math.sqrt(1 - --k * k);
  },
  circularInOut: function(k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  elasticIn: function(k) {
    var s2;
    var a2 = 0.1;
    var p2 = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a2 || a2 < 1) {
      a2 = 1;
      s2 = p2 / 4;
    } else {
      s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
    }
    return -(a2 * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s2) * (2 * Math.PI) / p2));
  },
  elasticOut: function(k) {
    var s2;
    var a2 = 0.1;
    var p2 = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a2 || a2 < 1) {
      a2 = 1;
      s2 = p2 / 4;
    } else {
      s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
    }
    return a2 * Math.pow(2, -10 * k) * Math.sin((k - s2) * (2 * Math.PI) / p2) + 1;
  },
  elasticInOut: function(k) {
    var s2;
    var a2 = 0.1;
    var p2 = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a2 || a2 < 1) {
      a2 = 1;
      s2 = p2 / 4;
    } else {
      s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
    }
    if ((k *= 2) < 1) {
      return -0.5 * (a2 * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s2) * (2 * Math.PI) / p2));
    }
    return a2 * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s2) * (2 * Math.PI) / p2) * 0.5 + 1;
  },
  backIn: function(k) {
    var s2 = 1.70158;
    return k * k * ((s2 + 1) * k - s2);
  },
  backOut: function(k) {
    var s2 = 1.70158;
    return --k * k * ((s2 + 1) * k + s2) + 1;
  },
  backInOut: function(k) {
    var s2 = 1.70158 * 1.525;
    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s2 + 1) * k - s2));
    }
    return 0.5 * ((k -= 2) * k * ((s2 + 1) * k + s2) + 2);
  },
  bounceIn: function(k) {
    return 1 - easingFuncs.bounceOut(1 - k);
  },
  bounceOut: function(k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },
  bounceInOut: function(k) {
    if (k < 0.5) {
      return easingFuncs.bounceIn(k * 2) * 0.5;
    }
    return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var easingFuncs$1 = easingFuncs;
var mathPow$2 = Math.pow;
var mathSqrt$3 = Math.sqrt;
var EPSILON$4 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt$3(3);
var ONE_THIRD = 1 / 3;
var _v0 = create$1();
var _v1 = create$1();
var _v2 = create$1();
function isAroundZero$1(val) {
  return val > -EPSILON$4 && val < EPSILON$4;
}
function isNotAroundZero$1(val) {
  return val > EPSILON$4 || val < -EPSILON$4;
}
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function cubicDerivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  var a2 = p3 + 3 * (p1 - p2) - p0;
  var b2 = 3 * (p2 - p1 * 2 + p0);
  var c = 3 * (p1 - p0);
  var d2 = p0 - val;
  var A2 = b2 * b2 - 3 * a2 * c;
  var B = b2 * c - 9 * a2 * d2;
  var C = c * c - 3 * b2 * d2;
  var n = 0;
  if (isAroundZero$1(A2) && isAroundZero$1(B)) {
    if (isAroundZero$1(b2)) {
      roots2[0] = 0;
    } else {
      var t1 = -c / b2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = B * B - 4 * A2 * C;
    if (isAroundZero$1(disc)) {
      var K = B / A2;
      var t1 = -b2 / a2 + K;
      var t2 = -K / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var Y1 = A2 * b2 + 1.5 * a2 * (-B + discSqrt);
      var Y2 = A2 * b2 + 1.5 * a2 * (-B - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow$2(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow$2(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow$2(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow$2(Y2, ONE_THIRD);
      }
      var t1 = (-b2 - (Y1 + Y2)) / (3 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else {
      var T2 = (2 * A2 * b2 - 3 * a2 * B) / (2 * mathSqrt$3(A2 * A2 * A2));
      var theta = Math.acos(T2) / 3;
      var ASqrt = mathSqrt$3(A2);
      var tmp = Math.cos(theta);
      var t1 = (-b2 - 2 * ASqrt * tmp) / (3 * a2);
      var t2 = (-b2 + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a2);
      var t3 = (-b2 + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
      if (t3 >= 0 && t3 <= 1) {
        roots2[n++] = t3;
      }
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  var b2 = 6 * p2 - 12 * p1 + 6 * p0;
  var a2 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c = 3 * p1 - 3 * p0;
  var n = 0;
  if (isAroundZero$1(a2)) {
    if (isNotAroundZero$1(b2)) {
      var t1 = -c / b2;
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
    }
  } else {
    var disc = b2 * b2 - 4 * a2 * c;
    if (isAroundZero$1(disc)) {
      extrema2[0] = -b2 / (2 * a2);
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b2 + discSqrt) / (2 * a2);
      var t2 = (-b2 - discSqrt) / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        extrema2[n++] = t2;
      }
    }
  }
  return n;
}
function cubicSubdivide(p0, p1, p2, p3, t, out2) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p23 = (p3 - p2) * t + p2;
  var p012 = (p12 - p01) * t + p01;
  var p123 = (p23 - p12) * t + p12;
  var p0123 = (p123 - p012) * t + p012;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p0123;
  out2[4] = p0123;
  out2[5] = p123;
  out2[6] = p23;
  out2[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x4, y, out2) {
  var t;
  var interval = 5e-3;
  var d2 = Infinity;
  var prev2;
  var next2;
  var d1;
  var d22;
  _v0[0] = x4;
  _v0[1] = y;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = distSquare(_v0, _v1);
    if (d1 < d2) {
      t = _t;
      d2 = d1;
    }
  }
  d2 = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev2 = t - interval;
    next2 = t + interval;
    _v1[0] = cubicAt(x0, x1, x2, x3, prev2);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev2);
    d1 = distSquare(_v1, _v0);
    if (prev2 >= 0 && d1 < d2) {
      t = prev2;
      d2 = d1;
    } else {
      _v2[0] = cubicAt(x0, x1, x2, x3, next2);
      _v2[1] = cubicAt(y0, y1, y2, y3, next2);
      d22 = distSquare(_v2, _v0);
      if (next2 <= 1 && d22 < d2) {
        t = next2;
        d2 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = cubicAt(x0, x1, x2, x3, t);
    out2[1] = cubicAt(y0, y1, y2, y3, t);
  }
  return mathSqrt$3(d2);
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
  var px = x0;
  var py = y0;
  var d2 = 0;
  var step = 1 / iteration;
  for (var i = 1; i <= iteration; i++) {
    var t = i * step;
    var x4 = cubicAt(x0, x1, x2, x3, t);
    var y = cubicAt(y0, y1, y2, y3, t);
    var dx = x4 - px;
    var dy = y - py;
    d2 += Math.sqrt(dx * dx + dy * dy);
    px = x4;
    py = y;
  }
  return d2;
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  var a2 = p0 - 2 * p1 + p2;
  var b2 = 2 * (p1 - p0);
  var c = p0 - val;
  var n = 0;
  if (isAroundZero$1(a2)) {
    if (isNotAroundZero$1(b2)) {
      var t1 = -c / b2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = b2 * b2 - 4 * a2 * c;
    if (isAroundZero$1(disc)) {
      var t1 = -b2 / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b2 + discSqrt) / (2 * a2);
      var t2 = (-b2 - discSqrt) / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
function quadraticSubdivide(p0, p1, p2, t, out2) {
  var p01 = (p1 - p0) * t + p0;
  var p12 = (p2 - p1) * t + p1;
  var p012 = (p12 - p01) * t + p01;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p012;
  out2[4] = p12;
  out2[5] = p2;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x3, y, out2) {
  var t;
  var interval = 5e-3;
  var d2 = Infinity;
  _v0[0] = x3;
  _v0[1] = y;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t);
    _v1[1] = quadraticAt(y0, y1, y2, _t);
    var d1 = distSquare(_v0, _v1);
    if (d1 < d2) {
      t = _t;
      d2 = d1;
    }
  }
  d2 = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    var prev2 = t - interval;
    var next2 = t + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev2);
    _v1[1] = quadraticAt(y0, y1, y2, prev2);
    var d1 = distSquare(_v1, _v0);
    if (prev2 >= 0 && d1 < d2) {
      t = prev2;
      d2 = d1;
    } else {
      _v2[0] = quadraticAt(x0, x1, x2, next2);
      _v2[1] = quadraticAt(y0, y1, y2, next2);
      var d22 = distSquare(_v2, _v0);
      if (next2 <= 1 && d22 < d2) {
        t = next2;
        d2 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = quadraticAt(x0, x1, x2, t);
    out2[1] = quadraticAt(y0, y1, y2, t);
  }
  return mathSqrt$3(d2);
}
function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
  var px = x0;
  var py = y0;
  var d2 = 0;
  var step = 1 / iteration;
  for (var i = 1; i <= iteration; i++) {
    var t = i * step;
    var x3 = quadraticAt(x0, x1, x2, t);
    var y = quadraticAt(y0, y1, y2, t);
    var dx = x3 - px;
    var dy = y - py;
    d2 += Math.sqrt(dx * dx + dy * dy);
    px = x3;
    py = y;
  }
  return d2;
}
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
  var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
  if (cubic) {
    var points2 = cubic[1].split(",");
    var a_1 = +trim$1(points2[0]);
    var b_1 = +trim$1(points2[1]);
    var c_1 = +trim$1(points2[2]);
    var d_1 = +trim$1(points2[3]);
    if (isNaN(a_1 + b_1 + c_1 + d_1)) {
      return;
    }
    var roots_1 = [];
    return function(p2) {
      return p2 <= 0 ? 0 : p2 >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p2, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
    };
  }
}
var Clip = function() {
  function Clip2(opts) {
    this._inited = false;
    this._startTime = 0;
    this._pausedTime = 0;
    this._paused = false;
    this._life = opts.life || 1e3;
    this._delay = opts.delay || 0;
    this.loop = opts.loop || false;
    this.onframe = opts.onframe || noop$2;
    this.ondestroy = opts.ondestroy || noop$2;
    this.onrestart = opts.onrestart || noop$2;
    opts.easing && this.setEasing(opts.easing);
  }
  Clip2.prototype.step = function(globalTime, deltaTime) {
    if (!this._inited) {
      this._startTime = globalTime + this._delay;
      this._inited = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    var life = this._life;
    var elapsedTime = globalTime - this._startTime - this._pausedTime;
    var percent = elapsedTime / life;
    if (percent < 0) {
      percent = 0;
    }
    percent = Math.min(percent, 1);
    var easingFunc = this.easingFunc;
    var schedule = easingFunc ? easingFunc(percent) : percent;
    this.onframe(schedule);
    if (percent === 1) {
      if (this.loop) {
        var remainder = elapsedTime % life;
        this._startTime = globalTime - remainder;
        this._pausedTime = 0;
        this.onrestart();
      } else {
        return true;
      }
    }
    return false;
  };
  Clip2.prototype.pause = function() {
    this._paused = true;
  };
  Clip2.prototype.resume = function() {
    this._paused = false;
  };
  Clip2.prototype.setEasing = function(easing) {
    this.easing = easing;
    this.easingFunc = isFunction$2(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
  };
  return Clip2;
}();
var Clip$1 = Clip;
var Entry = function() {
  function Entry2(val) {
    this.value = val;
  }
  return Entry2;
}();
var LinkedList = function() {
  function LinkedList2() {
    this._len = 0;
  }
  LinkedList2.prototype.insert = function(val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  };
  LinkedList2.prototype.insertEntry = function(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }
    this._len++;
  };
  LinkedList2.prototype.remove = function(entry) {
    var prev2 = entry.prev;
    var next2 = entry.next;
    if (prev2) {
      prev2.next = next2;
    } else {
      this.head = next2;
    }
    if (next2) {
      next2.prev = prev2;
    } else {
      this.tail = prev2;
    }
    entry.next = entry.prev = null;
    this._len--;
  };
  LinkedList2.prototype.len = function() {
    return this._len;
  };
  LinkedList2.prototype.clear = function() {
    this.head = this.tail = null;
    this._len = 0;
  };
  return LinkedList2;
}();
var LRU = function() {
  function LRU2(maxSize) {
    this._list = new LinkedList();
    this._maxSize = 10;
    this._map = {};
    this._maxSize = maxSize;
  }
  LRU2.prototype.put = function(key2, value) {
    var list2 = this._list;
    var map2 = this._map;
    var removed = null;
    if (map2[key2] == null) {
      var len2 = list2.len();
      var entry = this._lastRemovedEntry;
      if (len2 >= this._maxSize && len2 > 0) {
        var leastUsedEntry = list2.head;
        list2.remove(leastUsedEntry);
        delete map2[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }
      if (entry) {
        entry.value = value;
      } else {
        entry = new Entry(value);
      }
      entry.key = key2;
      list2.insertEntry(entry);
      map2[key2] = entry;
    }
    return removed;
  };
  LRU2.prototype.get = function(key2) {
    var entry = this._map[key2];
    var list2 = this._list;
    if (entry != null) {
      if (entry !== list2.tail) {
        list2.remove(entry);
        list2.insertEntry(entry);
      }
      return entry.value;
    }
  };
  LRU2.prototype.clear = function() {
    this._list.clear();
    this._map = {};
  };
  LRU2.prototype.len = function() {
    return this._list.len();
  };
  return LRU2;
}();
var LRU$1 = LRU;
var kCSSColorTable = {
  "transparent": [0, 0, 0, 0],
  "aliceblue": [240, 248, 255, 1],
  "antiquewhite": [250, 235, 215, 1],
  "aqua": [0, 255, 255, 1],
  "aquamarine": [127, 255, 212, 1],
  "azure": [240, 255, 255, 1],
  "beige": [245, 245, 220, 1],
  "bisque": [255, 228, 196, 1],
  "black": [0, 0, 0, 1],
  "blanchedalmond": [255, 235, 205, 1],
  "blue": [0, 0, 255, 1],
  "blueviolet": [138, 43, 226, 1],
  "brown": [165, 42, 42, 1],
  "burlywood": [222, 184, 135, 1],
  "cadetblue": [95, 158, 160, 1],
  "chartreuse": [127, 255, 0, 1],
  "chocolate": [210, 105, 30, 1],
  "coral": [255, 127, 80, 1],
  "cornflowerblue": [100, 149, 237, 1],
  "cornsilk": [255, 248, 220, 1],
  "crimson": [220, 20, 60, 1],
  "cyan": [0, 255, 255, 1],
  "darkblue": [0, 0, 139, 1],
  "darkcyan": [0, 139, 139, 1],
  "darkgoldenrod": [184, 134, 11, 1],
  "darkgray": [169, 169, 169, 1],
  "darkgreen": [0, 100, 0, 1],
  "darkgrey": [169, 169, 169, 1],
  "darkkhaki": [189, 183, 107, 1],
  "darkmagenta": [139, 0, 139, 1],
  "darkolivegreen": [85, 107, 47, 1],
  "darkorange": [255, 140, 0, 1],
  "darkorchid": [153, 50, 204, 1],
  "darkred": [139, 0, 0, 1],
  "darksalmon": [233, 150, 122, 1],
  "darkseagreen": [143, 188, 143, 1],
  "darkslateblue": [72, 61, 139, 1],
  "darkslategray": [47, 79, 79, 1],
  "darkslategrey": [47, 79, 79, 1],
  "darkturquoise": [0, 206, 209, 1],
  "darkviolet": [148, 0, 211, 1],
  "deeppink": [255, 20, 147, 1],
  "deepskyblue": [0, 191, 255, 1],
  "dimgray": [105, 105, 105, 1],
  "dimgrey": [105, 105, 105, 1],
  "dodgerblue": [30, 144, 255, 1],
  "firebrick": [178, 34, 34, 1],
  "floralwhite": [255, 250, 240, 1],
  "forestgreen": [34, 139, 34, 1],
  "fuchsia": [255, 0, 255, 1],
  "gainsboro": [220, 220, 220, 1],
  "ghostwhite": [248, 248, 255, 1],
  "gold": [255, 215, 0, 1],
  "goldenrod": [218, 165, 32, 1],
  "gray": [128, 128, 128, 1],
  "green": [0, 128, 0, 1],
  "greenyellow": [173, 255, 47, 1],
  "grey": [128, 128, 128, 1],
  "honeydew": [240, 255, 240, 1],
  "hotpink": [255, 105, 180, 1],
  "indianred": [205, 92, 92, 1],
  "indigo": [75, 0, 130, 1],
  "ivory": [255, 255, 240, 1],
  "khaki": [240, 230, 140, 1],
  "lavender": [230, 230, 250, 1],
  "lavenderblush": [255, 240, 245, 1],
  "lawngreen": [124, 252, 0, 1],
  "lemonchiffon": [255, 250, 205, 1],
  "lightblue": [173, 216, 230, 1],
  "lightcoral": [240, 128, 128, 1],
  "lightcyan": [224, 255, 255, 1],
  "lightgoldenrodyellow": [250, 250, 210, 1],
  "lightgray": [211, 211, 211, 1],
  "lightgreen": [144, 238, 144, 1],
  "lightgrey": [211, 211, 211, 1],
  "lightpink": [255, 182, 193, 1],
  "lightsalmon": [255, 160, 122, 1],
  "lightseagreen": [32, 178, 170, 1],
  "lightskyblue": [135, 206, 250, 1],
  "lightslategray": [119, 136, 153, 1],
  "lightslategrey": [119, 136, 153, 1],
  "lightsteelblue": [176, 196, 222, 1],
  "lightyellow": [255, 255, 224, 1],
  "lime": [0, 255, 0, 1],
  "limegreen": [50, 205, 50, 1],
  "linen": [250, 240, 230, 1],
  "magenta": [255, 0, 255, 1],
  "maroon": [128, 0, 0, 1],
  "mediumaquamarine": [102, 205, 170, 1],
  "mediumblue": [0, 0, 205, 1],
  "mediumorchid": [186, 85, 211, 1],
  "mediumpurple": [147, 112, 219, 1],
  "mediumseagreen": [60, 179, 113, 1],
  "mediumslateblue": [123, 104, 238, 1],
  "mediumspringgreen": [0, 250, 154, 1],
  "mediumturquoise": [72, 209, 204, 1],
  "mediumvioletred": [199, 21, 133, 1],
  "midnightblue": [25, 25, 112, 1],
  "mintcream": [245, 255, 250, 1],
  "mistyrose": [255, 228, 225, 1],
  "moccasin": [255, 228, 181, 1],
  "navajowhite": [255, 222, 173, 1],
  "navy": [0, 0, 128, 1],
  "oldlace": [253, 245, 230, 1],
  "olive": [128, 128, 0, 1],
  "olivedrab": [107, 142, 35, 1],
  "orange": [255, 165, 0, 1],
  "orangered": [255, 69, 0, 1],
  "orchid": [218, 112, 214, 1],
  "palegoldenrod": [238, 232, 170, 1],
  "palegreen": [152, 251, 152, 1],
  "paleturquoise": [175, 238, 238, 1],
  "palevioletred": [219, 112, 147, 1],
  "papayawhip": [255, 239, 213, 1],
  "peachpuff": [255, 218, 185, 1],
  "peru": [205, 133, 63, 1],
  "pink": [255, 192, 203, 1],
  "plum": [221, 160, 221, 1],
  "powderblue": [176, 224, 230, 1],
  "purple": [128, 0, 128, 1],
  "red": [255, 0, 0, 1],
  "rosybrown": [188, 143, 143, 1],
  "royalblue": [65, 105, 225, 1],
  "saddlebrown": [139, 69, 19, 1],
  "salmon": [250, 128, 114, 1],
  "sandybrown": [244, 164, 96, 1],
  "seagreen": [46, 139, 87, 1],
  "seashell": [255, 245, 238, 1],
  "sienna": [160, 82, 45, 1],
  "silver": [192, 192, 192, 1],
  "skyblue": [135, 206, 235, 1],
  "slateblue": [106, 90, 205, 1],
  "slategray": [112, 128, 144, 1],
  "slategrey": [112, 128, 144, 1],
  "snow": [255, 250, 250, 1],
  "springgreen": [0, 255, 127, 1],
  "steelblue": [70, 130, 180, 1],
  "tan": [210, 180, 140, 1],
  "teal": [0, 128, 128, 1],
  "thistle": [216, 191, 216, 1],
  "tomato": [255, 99, 71, 1],
  "turquoise": [64, 224, 208, 1],
  "violet": [238, 130, 238, 1],
  "wheat": [245, 222, 179, 1],
  "white": [255, 255, 255, 1],
  "whitesmoke": [245, 245, 245, 1],
  "yellow": [255, 255, 0, 1],
  "yellowgreen": [154, 205, 50, 1]
};
function clampCssByte(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat(f) {
  return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h2) {
  if (h2 < 0) {
    h2 += 1;
  } else if (h2 > 1) {
    h2 -= 1;
  }
  if (h2 * 6 < 1) {
    return m1 + (m2 - m1) * h2 * 6;
  }
  if (h2 * 2 < 1) {
    return m2;
  }
  if (h2 * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h2) * 6;
  }
  return m1;
}
function lerpNumber(a2, b2, p2) {
  return a2 + (b2 - a2) * p2;
}
function setRgba(out2, r, g, b2, a2) {
  out2[0] = r;
  out2[1] = g;
  out2[2] = b2;
  out2[3] = a2;
  return out2;
}
function copyRgba(out2, a2) {
  out2[0] = a2[0];
  out2[1] = a2[1];
  out2[2] = a2[2];
  out2[3] = a2[3];
  return out2;
}
var colorCache = new LRU$1(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  var str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  var strLen = str.length;
  if (str.charAt(0) === "#") {
    if (strLen === 4 || strLen === 5) {
      var iv = parseInt(str.slice(1, 4), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (strLen === 7 || strLen === 9) {
      var iv = parseInt(str.slice(1, 7), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  var op = str.indexOf("(");
  var ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === strLen) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(",");
    var alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba(hsla, rgba) {
  var h2 = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  var s2 = parseCssFloat(hsla[1]);
  var l2 = parseCssFloat(hsla[2]);
  var m2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
  var m1 = l2 * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h2 + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h2) * 255), clampCssByte(cssHueToRgb(m1, m2, h2 - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  }
  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B);
  var vMax = Math.max(R, G, B);
  var delta = vMax - vMin;
  var L2 = (vMax + vMin) / 2;
  var H;
  var S2;
  if (delta === 0) {
    H = 0;
    S2 = 0;
  } else {
    if (L2 < 0.5) {
      S2 = delta / (vMax + vMin);
    } else {
      S2 = delta / (2 - vMax - vMin);
    }
    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }
    if (H < 0) {
      H += 1;
    }
    if (H > 1) {
      H -= 1;
    }
  }
  var hsla = [H * 360, S2, L2];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
function lift(color2, level) {
  var colorArr = parse(color2);
  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (colorArr[i] < 0) {
        colorArr[i] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function toHex(color2) {
  var colorArr = parse(color2);
  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
function fastLerp(normalizedValue, colors, out2) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out2;
}
var fastMapToColor = fastLerp;
function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color2 = stringify([
    clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
    clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
    clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
    clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color: color2,
    leftIndex,
    rightIndex,
    value
  } : color2;
}
var mapToColor = lerp;
function modifyHSL(color2, h2, s2, l2) {
  var colorArr = parse(color2);
  if (color2) {
    colorArr = rgba2hsla(colorArr);
    h2 != null && (colorArr[0] = clampCssAngle(h2));
    s2 != null && (colorArr[1] = parseCssFloat(s2));
    l2 != null && (colorArr[2] = parseCssFloat(l2));
    return stringify(hsla2rgba(colorArr), "rgba");
  }
}
function modifyAlpha(color2, alpha) {
  var colorArr = parse(color2);
  if (colorArr && alpha != null) {
    colorArr[3] = clampCssFloat(alpha);
    return stringify(colorArr, "rgba");
  }
}
function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
}
function lum(color2, backgroundLum) {
  var arr = parse(color2);
  return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
function random() {
  return stringify([
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255)
  ], "rgb");
}
var color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parse,
  lift,
  toHex,
  fastLerp,
  fastMapToColor,
  lerp,
  mapToColor,
  modifyHSL,
  modifyAlpha,
  stringify,
  lum,
  random
}, Symbol.toStringTag, { value: "Module" }));
var mathRound$1 = Math.round;
function normalizeColor(color2) {
  var opacity;
  if (!color2 || color2 === "transparent") {
    color2 = "none";
  } else if (typeof color2 === "string" && color2.indexOf("rgba") > -1) {
    var arr = parse(color2);
    if (arr) {
      color2 = "rgb(" + arr[0] + "," + arr[1] + "," + arr[2] + ")";
      opacity = arr[3];
    }
  }
  return {
    color: color2,
    opacity: opacity == null ? 1 : opacity
  };
}
var EPSILON$3 = 1e-4;
function isAroundZero(transform2) {
  return transform2 < EPSILON$3 && transform2 > -EPSILON$3;
}
function round3(transform2) {
  return mathRound$1(transform2 * 1e3) / 1e3;
}
function round4(transform2) {
  return mathRound$1(transform2 * 1e4) / 1e4;
}
function getMatrixStr(m2) {
  return "matrix(" + round3(m2[0]) + "," + round3(m2[1]) + "," + round3(m2[2]) + "," + round3(m2[3]) + "," + round4(m2[4]) + "," + round4(m2[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY$1(y, lineHeight, textBaseline) {
  if (textBaseline === "top") {
    y += lineHeight / 2;
  } else if (textBaseline === "bottom") {
    y -= lineHeight / 2;
  }
  return y;
}
function hasShadow(style) {
  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
}
function getShadowKey(displayable) {
  var style = displayable.style;
  var globalScale = displayable.getGlobalScale();
  return [
    style.shadowColor,
    (style.shadowBlur || 0).toFixed(2),
    (style.shadowOffsetX || 0).toFixed(2),
    (style.shadowOffsetY || 0).toFixed(2),
    globalScale[0],
    globalScale[1]
  ].join(",");
}
function isImagePattern(val) {
  return val && !!val.image;
}
function isSVGPattern(val) {
  return val && !!val.svgElement;
}
function isPattern(val) {
  return isImagePattern(val) || isSVGPattern(val);
}
function isLinearGradient(val) {
  return val.type === "linear";
}
function isRadialGradient(val) {
  return val.type === "radial";
}
function isGradient(val) {
  return val && (val.type === "linear" || val.type === "radial");
}
function getIdURL(id) {
  return "url(#" + id + ")";
}
function getPathPrecision(el) {
  var scale2 = el.getGlobalScale();
  var size = Math.max(scale2[0], scale2[1]);
  return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1);
}
function getSRTTransformString(transform2) {
  var x2 = transform2.x || 0;
  var y = transform2.y || 0;
  var rotation = (transform2.rotation || 0) * RADIAN_TO_DEGREE;
  var scaleX = retrieve2(transform2.scaleX, 1);
  var scaleY = retrieve2(transform2.scaleY, 1);
  var skewX = transform2.skewX || 0;
  var skewY = transform2.skewY || 0;
  var res = [];
  if (x2 || y) {
    res.push("translate(" + x2 + "px," + y + "px)");
  }
  if (rotation) {
    res.push("rotate(" + rotation + ")");
  }
  if (scaleX !== 1 || scaleY !== 1) {
    res.push("scale(" + scaleX + "," + scaleY + ")");
  }
  if (skewX || skewY) {
    res.push("skew(" + mathRound$1(skewX * RADIAN_TO_DEGREE) + "deg, " + mathRound$1(skewY * RADIAN_TO_DEGREE) + "deg)");
  }
  return res.join(" ");
}
var encodeBase64 = function() {
  if (env$1.hasGlobalWindow && isFunction$2(window.btoa)) {
    return function(str) {
      return window.btoa(unescape(str));
    };
  }
  if (typeof Buffer !== "undefined") {
    return function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
  return function(str) {
    return null;
  };
}();
var arraySlice = Array.prototype.slice;
function interpolateNumber$1(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out2, p0, p1, percent) {
  var len2 = p0.length;
  for (var i = 0; i < len2; i++) {
    out2[i] = interpolateNumber$1(p0[i], p1[i], percent);
  }
  return out2;
}
function interpolate2DArray(out2, p0, p1, percent) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (var j = 0; j < len22; j++) {
      out2[i][j] = interpolateNumber$1(p0[i][j], p1[i][j], percent);
    }
  }
  return out2;
}
function add1DArray(out2, p0, p1, sign) {
  var len2 = p0.length;
  for (var i = 0; i < len2; i++) {
    out2[i] = p0[i] + p1[i] * sign;
  }
  return out2;
}
function add2DArray(out2, p0, p1, sign) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (var j = 0; j < len22; j++) {
      out2[i][j] = p0[i][j] + p1[i][j] * sign;
    }
  }
  return out2;
}
function fillColorStops(val0, val1) {
  var len0 = val0.length;
  var len1 = val1.length;
  var shorterArr = len0 > len1 ? val1 : val0;
  var shorterLen = Math.min(len0, len1);
  var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
  for (var i = shorterLen; i < Math.max(len0, len1); i++) {
    shorterArr.push({
      offset: last.offset,
      color: last.color.slice()
    });
  }
}
function fillArray(val0, val1, arrDim) {
  var arr0 = val0;
  var arr1 = val1;
  if (!arr0.push || !arr1.push) {
    return;
  }
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    var isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  }
  var len2 = arr0[0] && arr0[0].length;
  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
function cloneValue(value) {
  if (isArrayLike$1(value)) {
    var len2 = value.length;
    if (isArrayLike$1(value[0])) {
      var ret = [];
      for (var i = 0; i < len2; i++) {
        ret.push(arraySlice.call(value[i]));
      }
      return ret;
    }
    return arraySlice.call(value);
  }
  return value;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]) || 0;
  rgba[1] = Math.floor(rgba[1]) || 0;
  rgba[2] = Math.floor(rgba[2]) || 0;
  rgba[3] = rgba[3] == null ? 1 : rgba[3];
  return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value) {
  return isArrayLike$1(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = function() {
  function Track2(propName) {
    this.keyframes = [];
    this.discrete = false;
    this._invalid = false;
    this._needsSort = false;
    this._lastFr = 0;
    this._lastFrP = 0;
    this.propName = propName;
  }
  Track2.prototype.isFinished = function() {
    return this._finished;
  };
  Track2.prototype.setFinished = function() {
    this._finished = true;
    if (this._additiveTrack) {
      this._additiveTrack.setFinished();
    }
  };
  Track2.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  };
  Track2.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  };
  Track2.prototype.addKeyframe = function(time2, rawValue, easing) {
    this._needsSort = true;
    var keyframes = this.keyframes;
    var len2 = keyframes.length;
    var discrete = false;
    var valType = VALUE_TYPE_UNKOWN;
    var value = rawValue;
    if (isArrayLike$1(rawValue)) {
      var arrayDim = guessArrayDim(rawValue);
      valType = arrayDim;
      if (arrayDim === 1 && !isNumber$1(rawValue[0]) || arrayDim === 2 && !isNumber$1(rawValue[0][0])) {
        discrete = true;
      }
    } else {
      if (isNumber$1(rawValue) && !eqNaN(rawValue)) {
        valType = VALUE_TYPE_NUMBER;
      } else if (isString$2(rawValue)) {
        if (!isNaN(+rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else {
          var colorArray = parse(rawValue);
          if (colorArray) {
            value = colorArray;
            valType = VALUE_TYPE_COLOR;
          }
        }
      } else if (isGradientObject(rawValue)) {
        var parsedGradient = extend$3({}, value);
        parsedGradient.colorStops = map$1(rawValue.colorStops, function(colorStop) {
          return {
            offset: colorStop.offset,
            color: parse(colorStop.color)
          };
        });
        if (isLinearGradient(rawValue)) {
          valType = VALUE_TYPE_LINEAR_GRADIENT;
        } else if (isRadialGradient(rawValue)) {
          valType = VALUE_TYPE_RADIAL_GRADIENT;
        }
        value = parsedGradient;
      }
    }
    if (len2 === 0) {
      this.valType = valType;
    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
      discrete = true;
    }
    this.discrete = this.discrete || discrete;
    var kf = {
      time: time2,
      value,
      rawValue,
      percent: 0
    };
    if (easing) {
      kf.easing = easing;
      kf.easingFunc = isFunction$2(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
    }
    keyframes.push(kf);
    return kf;
  };
  Track2.prototype.prepare = function(maxTime, additiveTrack) {
    var kfs = this.keyframes;
    if (this._needsSort) {
      kfs.sort(function(a2, b2) {
        return a2.time - b2.time;
      });
    }
    var valType = this.valType;
    var kfsLen = kfs.length;
    var lastKf = kfs[kfsLen - 1];
    var isDiscrete = this.discrete;
    var isArr = isArrayValueType(valType);
    var isGradient2 = isGradientValueType(valType);
    for (var i = 0; i < kfsLen; i++) {
      var kf = kfs[i];
      var value = kf.value;
      var lastValue = lastKf.value;
      kf.percent = kf.time / maxTime;
      if (!isDiscrete) {
        if (isArr && i !== kfsLen - 1) {
          fillArray(value, lastValue, valType);
        } else if (isGradient2) {
          fillColorStops(value.colorStops, lastValue.colorStops);
        }
      }
    }
    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
      this._additiveTrack = additiveTrack;
      var startValue = kfs[0].value;
      for (var i = 0; i < kfsLen; i++) {
        if (valType === VALUE_TYPE_NUMBER) {
          kfs[i].additiveValue = kfs[i].value - startValue;
        } else if (valType === VALUE_TYPE_COLOR) {
          kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
        } else if (isArrayValueType(valType)) {
          kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);
        }
      }
    }
  };
  Track2.prototype.step = function(target, percent) {
    if (this._finished) {
      return;
    }
    if (this._additiveTrack && this._additiveTrack._finished) {
      this._additiveTrack = null;
    }
    var isAdditive = this._additiveTrack != null;
    var valueKey = isAdditive ? "additiveValue" : "value";
    var valType = this.valType;
    var keyframes = this.keyframes;
    var kfsNum = keyframes.length;
    var propName = this.propName;
    var isValueColor = valType === VALUE_TYPE_COLOR;
    var frameIdx;
    var lastFrame = this._lastFr;
    var mathMin2 = Math.min;
    var frame;
    var nextFrame;
    if (kfsNum === 1) {
      frame = nextFrame = keyframes[0];
    } else {
      if (percent < 0) {
        frameIdx = 0;
      } else if (percent < this._lastFrP) {
        var start2 = mathMin2(lastFrame + 1, kfsNum - 1);
        for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
          if (keyframes[frameIdx].percent <= percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx, kfsNum - 2);
      } else {
        for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
          if (keyframes[frameIdx].percent > percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx - 1, kfsNum - 2);
      }
      nextFrame = keyframes[frameIdx + 1];
      frame = keyframes[frameIdx];
    }
    if (!(frame && nextFrame)) {
      return;
    }
    this._lastFr = frameIdx;
    this._lastFrP = percent;
    var interval = nextFrame.percent - frame.percent;
    var w2 = interval === 0 ? 1 : mathMin2((percent - frame.percent) / interval, 1);
    if (nextFrame.easingFunc) {
      w2 = nextFrame.easingFunc(w2);
    }
    var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
      targetArr = this._additiveValue = [];
    }
    if (this.discrete) {
      target[propName] = w2 < 1 ? frame.rawValue : nextFrame.rawValue;
    } else if (isArrayValueType(valType)) {
      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w2) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w2);
    } else if (isGradientValueType(valType)) {
      var val = frame[valueKey];
      var nextVal_1 = nextFrame[valueKey];
      var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
      target[propName] = {
        type: isLinearGradient_1 ? "linear" : "radial",
        x: interpolateNumber$1(val.x, nextVal_1.x, w2),
        y: interpolateNumber$1(val.y, nextVal_1.y, w2),
        colorStops: map$1(val.colorStops, function(colorStop, idx) {
          var nextColorStop = nextVal_1.colorStops[idx];
          return {
            offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w2),
            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w2))
          };
        }),
        global: nextVal_1.global
      };
      if (isLinearGradient_1) {
        target[propName].x2 = interpolateNumber$1(val.x2, nextVal_1.x2, w2);
        target[propName].y2 = interpolateNumber$1(val.y2, nextVal_1.y2, w2);
      } else {
        target[propName].r = interpolateNumber$1(val.r, nextVal_1.r, w2);
      }
    } else if (isValueColor) {
      interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w2);
      if (!isAdditive) {
        target[propName] = rgba2String(targetArr);
      }
    } else {
      var value = interpolateNumber$1(frame[valueKey], nextFrame[valueKey], w2);
      if (isAdditive) {
        this._additiveValue = value;
      } else {
        target[propName] = value;
      }
    }
    if (isAdditive) {
      this._addToTarget(target);
    }
  };
  Track2.prototype._addToTarget = function(target) {
    var valType = this.valType;
    var propName = this.propName;
    var additiveValue = this._additiveValue;
    if (valType === VALUE_TYPE_NUMBER) {
      target[propName] = target[propName] + additiveValue;
    } else if (valType === VALUE_TYPE_COLOR) {
      parse(target[propName], tmpRgba);
      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
      target[propName] = rgba2String(tmpRgba);
    } else if (valType === VALUE_TYPE_1D_ARRAY) {
      add1DArray(target[propName], target[propName], additiveValue, 1);
    } else if (valType === VALUE_TYPE_2D_ARRAY) {
      add2DArray(target[propName], target[propName], additiveValue, 1);
    }
  };
  return Track2;
}();
var Animator = function() {
  function Animator2(target, loop2, allowDiscreteAnimation, additiveTo) {
    this._tracks = {};
    this._trackKeys = [];
    this._maxTime = 0;
    this._started = 0;
    this._clip = null;
    this._target = target;
    this._loop = loop2;
    if (loop2 && additiveTo) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = additiveTo;
    this._allowDiscrete = allowDiscreteAnimation;
  }
  Animator2.prototype.getMaxTime = function() {
    return this._maxTime;
  };
  Animator2.prototype.getDelay = function() {
    return this._delay;
  };
  Animator2.prototype.getLoop = function() {
    return this._loop;
  };
  Animator2.prototype.getTarget = function() {
    return this._target;
  };
  Animator2.prototype.changeTarget = function(target) {
    this._target = target;
  };
  Animator2.prototype.when = function(time2, props2, easing) {
    return this.whenWithKeys(time2, props2, keys$1(props2), easing);
  };
  Animator2.prototype.whenWithKeys = function(time2, props2, propNames, easing) {
    var tracks = this._tracks;
    for (var i = 0; i < propNames.length; i++) {
      var propName = propNames[i];
      var track = tracks[propName];
      if (!track) {
        track = tracks[propName] = new Track(propName);
        var initialValue = void 0;
        var additiveTrack = this._getAdditiveTrack(propName);
        if (additiveTrack) {
          var addtiveTrackKfs = additiveTrack.keyframes;
          var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
          initialValue = lastFinalKf && lastFinalKf.value;
          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
            initialValue = rgba2String(initialValue);
          }
        } else {
          initialValue = this._target[propName];
        }
        if (initialValue == null) {
          continue;
        }
        if (time2 > 0) {
          track.addKeyframe(0, cloneValue(initialValue), easing);
        }
        this._trackKeys.push(propName);
      }
      track.addKeyframe(time2, cloneValue(props2[propName]), easing);
    }
    this._maxTime = Math.max(this._maxTime, time2);
    return this;
  };
  Animator2.prototype.pause = function() {
    this._clip.pause();
    this._paused = true;
  };
  Animator2.prototype.resume = function() {
    this._clip.resume();
    this._paused = false;
  };
  Animator2.prototype.isPaused = function() {
    return !!this._paused;
  };
  Animator2.prototype.duration = function(duration) {
    this._maxTime = duration;
    this._force = true;
    return this;
  };
  Animator2.prototype._doneCallback = function() {
    this._setTracksFinished();
    this._clip = null;
    var doneList = this._doneCbs;
    if (doneList) {
      var len2 = doneList.length;
      for (var i = 0; i < len2; i++) {
        doneList[i].call(this);
      }
    }
  };
  Animator2.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var animation = this.animation;
    var abortedList = this._abortedCbs;
    if (animation) {
      animation.removeClip(this._clip);
    }
    this._clip = null;
    if (abortedList) {
      for (var i = 0; i < abortedList.length; i++) {
        abortedList[i].call(this);
      }
    }
  };
  Animator2.prototype._setTracksFinished = function() {
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i = 0; i < tracksKeys.length; i++) {
      tracks[tracksKeys[i]].setFinished();
    }
  };
  Animator2.prototype._getAdditiveTrack = function(trackName) {
    var additiveTrack;
    var additiveAnimators = this._additiveAnimators;
    if (additiveAnimators) {
      for (var i = 0; i < additiveAnimators.length; i++) {
        var track = additiveAnimators[i].getTrack(trackName);
        if (track) {
          additiveTrack = track;
        }
      }
    }
    return additiveTrack;
  };
  Animator2.prototype.start = function(easing) {
    if (this._started > 0) {
      return;
    }
    this._started = 1;
    var self2 = this;
    var tracks = [];
    var maxTime = this._maxTime || 0;
    for (var i = 0; i < this._trackKeys.length; i++) {
      var propName = this._trackKeys[i];
      var track = this._tracks[propName];
      var additiveTrack = this._getAdditiveTrack(propName);
      var kfs = track.keyframes;
      var kfsNum = kfs.length;
      track.prepare(maxTime, additiveTrack);
      if (track.needsAnimate()) {
        if (!this._allowDiscrete && track.discrete) {
          var lastKf = kfs[kfsNum - 1];
          if (lastKf) {
            self2._target[track.propName] = lastKf.rawValue;
          }
          track.setFinished();
        } else {
          tracks.push(track);
        }
      }
    }
    if (tracks.length || this._force) {
      var clip2 = new Clip$1({
        life: maxTime,
        loop: this._loop,
        delay: this._delay || 0,
        onframe: function(percent) {
          self2._started = 2;
          var additiveAnimators = self2._additiveAnimators;
          if (additiveAnimators) {
            var stillHasAdditiveAnimator = false;
            for (var i2 = 0; i2 < additiveAnimators.length; i2++) {
              if (additiveAnimators[i2]._clip) {
                stillHasAdditiveAnimator = true;
                break;
              }
            }
            if (!stillHasAdditiveAnimator) {
              self2._additiveAnimators = null;
            }
          }
          for (var i2 = 0; i2 < tracks.length; i2++) {
            tracks[i2].step(self2._target, percent);
          }
          var onframeList = self2._onframeCbs;
          if (onframeList) {
            for (var i2 = 0; i2 < onframeList.length; i2++) {
              onframeList[i2](self2._target, percent);
            }
          }
        },
        ondestroy: function() {
          self2._doneCallback();
        }
      });
      this._clip = clip2;
      if (this.animation) {
        this.animation.addClip(clip2);
      }
      if (easing) {
        clip2.setEasing(easing);
      }
    } else {
      this._doneCallback();
    }
    return this;
  };
  Animator2.prototype.stop = function(forwardToLast) {
    if (!this._clip) {
      return;
    }
    var clip2 = this._clip;
    if (forwardToLast) {
      clip2.onframe(1);
    }
    this._abortedCallback();
  };
  Animator2.prototype.delay = function(time2) {
    this._delay = time2;
    return this;
  };
  Animator2.prototype.during = function(cb) {
    if (cb) {
      if (!this._onframeCbs) {
        this._onframeCbs = [];
      }
      this._onframeCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.done = function(cb) {
    if (cb) {
      if (!this._doneCbs) {
        this._doneCbs = [];
      }
      this._doneCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.aborted = function(cb) {
    if (cb) {
      if (!this._abortedCbs) {
        this._abortedCbs = [];
      }
      this._abortedCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.getClip = function() {
    return this._clip;
  };
  Animator2.prototype.getTrack = function(propName) {
    return this._tracks[propName];
  };
  Animator2.prototype.getTracks = function() {
    var _this = this;
    return map$1(this._trackKeys, function(key2) {
      return _this._tracks[key2];
    });
  };
  Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
    if (!propNames.length || !this._clip) {
      return true;
    }
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i = 0; i < propNames.length; i++) {
      var track = tracks[propNames[i]];
      if (track && !track.isFinished()) {
        if (forwardToLast) {
          track.step(this._target, 1);
        } else if (this._started === 1) {
          track.step(this._target, 0);
        }
        track.setFinished();
      }
    }
    var allAborted = true;
    for (var i = 0; i < tracksKeys.length; i++) {
      if (!tracks[tracksKeys[i]].isFinished()) {
        allAborted = false;
        break;
      }
    }
    if (allAborted) {
      this._abortedCallback();
    }
    return allAborted;
  };
  Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
    if (!target) {
      return;
    }
    trackKeys = trackKeys || this._trackKeys;
    for (var i = 0; i < trackKeys.length; i++) {
      var propName = trackKeys[i];
      var track = this._tracks[propName];
      if (!track || track.isFinished()) {
        continue;
      }
      var kfs = track.keyframes;
      var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
      if (kf) {
        target[propName] = cloneValue(kf.rawValue);
      }
    }
  };
  Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
    trackKeys = trackKeys || keys$1(finalProps);
    for (var i = 0; i < trackKeys.length; i++) {
      var propName = trackKeys[i];
      var track = this._tracks[propName];
      if (!track) {
        continue;
      }
      var kfs = track.keyframes;
      if (kfs.length > 1) {
        var lastKf = kfs.pop();
        track.addKeyframe(lastKf.time, finalProps[propName]);
        track.prepare(this._maxTime, track.getAdditiveTrack());
      }
    }
  };
  return Animator2;
}();
var Animator$1 = Animator;
function getTime() {
  return new Date().getTime();
}
var Animation = function(_super) {
  __extends(Animation2, _super);
  function Animation2(opts) {
    var _this = _super.call(this) || this;
    _this._running = false;
    _this._time = 0;
    _this._pausedTime = 0;
    _this._pauseStart = 0;
    _this._paused = false;
    opts = opts || {};
    _this.stage = opts.stage || {};
    return _this;
  }
  Animation2.prototype.addClip = function(clip2) {
    if (clip2.animation) {
      this.removeClip(clip2);
    }
    if (!this._head) {
      this._head = this._tail = clip2;
    } else {
      this._tail.next = clip2;
      clip2.prev = this._tail;
      clip2.next = null;
      this._tail = clip2;
    }
    clip2.animation = this;
  };
  Animation2.prototype.addAnimator = function(animator) {
    animator.animation = this;
    var clip2 = animator.getClip();
    if (clip2) {
      this.addClip(clip2);
    }
  };
  Animation2.prototype.removeClip = function(clip2) {
    if (!clip2.animation) {
      return;
    }
    var prev2 = clip2.prev;
    var next2 = clip2.next;
    if (prev2) {
      prev2.next = next2;
    } else {
      this._head = next2;
    }
    if (next2) {
      next2.prev = prev2;
    } else {
      this._tail = prev2;
    }
    clip2.next = clip2.prev = clip2.animation = null;
  };
  Animation2.prototype.removeAnimator = function(animator) {
    var clip2 = animator.getClip();
    if (clip2) {
      this.removeClip(clip2);
    }
    animator.animation = null;
  };
  Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
    var time2 = getTime() - this._pausedTime;
    var delta = time2 - this._time;
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      var finished2 = clip2.step(time2, delta);
      if (finished2) {
        clip2.ondestroy();
        this.removeClip(clip2);
        clip2 = nextClip;
      } else {
        clip2 = nextClip;
      }
    }
    this._time = time2;
    if (!notTriggerFrameAndStageUpdate) {
      this.trigger("frame", delta);
      this.stage.update && this.stage.update();
    }
  };
  Animation2.prototype._startLoop = function() {
    var self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame$2(step);
        !self2._paused && self2.update();
      }
    }
    requestAnimationFrame$2(step);
  };
  Animation2.prototype.start = function() {
    if (this._running) {
      return;
    }
    this._time = getTime();
    this._pausedTime = 0;
    this._startLoop();
  };
  Animation2.prototype.stop = function() {
    this._running = false;
  };
  Animation2.prototype.pause = function() {
    if (!this._paused) {
      this._pauseStart = getTime();
      this._paused = true;
    }
  };
  Animation2.prototype.resume = function() {
    if (this._paused) {
      this._pausedTime += getTime() - this._pauseStart;
      this._paused = false;
    }
  };
  Animation2.prototype.clear = function() {
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      clip2.prev = clip2.next = clip2.animation = null;
      clip2 = nextClip;
    }
    this._head = this._tail = null;
  };
  Animation2.prototype.isFinished = function() {
    return this._head == null;
  };
  Animation2.prototype.animate = function(target, options) {
    options = options || {};
    this.start();
    var animator = new Animator$1(target, options.loop);
    this.addAnimator(animator);
    return animator;
  };
  return Animation2;
}(Eventful$1);
var Animation$1 = Animation;
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env$1.domSupported;
var localNativeListenerNames = function() {
  var mouseHandlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var touchHandlerNames = [
    "touchstart",
    "touchend",
    "touchmove"
  ];
  var pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  var pointerHandlerNames = map$1(mouseHandlerNames, function(name) {
    var nm = name.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event) {
  event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event) {
  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
function isLocalEl(instance, el) {
  var elTmp = el;
  var isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
var FakeGlobalEvent = function() {
  function FakeGlobalEvent2(instance, event) {
    this.stopPropagation = noop$2;
    this.stopImmediatePropagation = noop$2;
    this.preventDefault = noop$2;
    this.type = event.type;
    this.target = this.currentTarget = instance.dom;
    this.pointerType = event.pointerType;
    this.clientX = event.clientX;
    this.clientY = event.clientY;
  }
  return FakeGlobalEvent2;
}();
var localDOMHandlers = {
  mousedown: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__mayPointerCapture = [event.zrX, event.zrY];
    this.trigger("mousedown", event);
  },
  mousemove: function(event) {
    event = normalizeEvent(this.dom, event);
    var downPoint = this.__mayPointerCapture;
    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      this.__togglePointerCapture(true);
    }
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
  },
  mouseout: function(event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;
    if (!isLocalEl(this, element)) {
      if (this.__pointerCapturing) {
        event.zrEventControl = "no_globalout";
      }
      this.trigger("mouseout", event);
    }
  },
  wheel: function(event) {
    wheelEventSupported = true;
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  mousewheel: function(event) {
    if (wheelEventSupported) {
      return;
    }
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  touchstart: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.__lastTouchMoment = new Date();
    this.handler.processGesture(event, "start");
    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "change");
    localDOMHandlers.mousemove.call(this, event);
  },
  touchend: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "end");
    localDOMHandlers.mouseup.call(this, event);
    if (+new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown: function(event) {
    localDOMHandlers.mousedown.call(this, event);
  },
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
each$e(["click", "dblclick", "contextmenu"], function(name) {
  localDOMHandlers[name] = function(event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
var globalDOMHandlers = {
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function(event) {
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    var pointerCaptureReleasing = this.__pointerCapturing;
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
    if (pointerCaptureReleasing) {
      event.zrEventControl = "only_globalout";
      this.trigger("mouseout", event);
    }
  }
};
function mountLocalDOMEventListeners(instance, scope) {
  var domHandlers = scope.domHandlers;
  if (env$1.pointerEventsSupported) {
    each$e(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        domHandlers[nativeEventName].call(instance, event);
      });
    });
  } else {
    if (env$1.touchEventsSupported) {
      each$e(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
          setTouchTimer(scope);
        });
      });
    }
    each$e(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        event = getNativeEvent(event);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance, event);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance, scope) {
  if (env$1.pointerEventsSupported) {
    each$e(globalNativeListenerNames.pointer, mount);
  } else if (!env$1.touchEventsSupported) {
    each$e(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event);
      if (!isLocalEl(instance, event.target)) {
        event = normalizeGlobalEvent(instance, event);
        scope.domHandlers[nativeEventName].call(instance, event);
      }
    }
    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
  var mounted = scope.mounted;
  for (var nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
var DOMHandlerScope = function() {
  function DOMHandlerScope2(domTarget, domHandlers) {
    this.mounted = {};
    this.listenerOpts = {};
    this.touching = false;
    this.domTarget = domTarget;
    this.domHandlers = domHandlers;
  }
  return DOMHandlerScope2;
}();
var HandlerDomProxy = function(_super) {
  __extends(HandlerDomProxy2, _super);
  function HandlerDomProxy2(dom, painterRoot) {
    var _this = _super.call(this) || this;
    _this.__pointerCapturing = false;
    _this.dom = dom;
    _this.painterRoot = painterRoot;
    _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
    if (globalEventSupported) {
      _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    mountLocalDOMEventListeners(_this, _this._localHandlerScope);
    return _this;
  }
  HandlerDomProxy2.prototype.dispose = function() {
    unmountDOMEventListeners(this._localHandlerScope);
    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  };
  HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
  };
  HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
    this.__mayPointerCapture = null;
    if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
      this.__pointerCapturing = isPointerCapturing;
      var globalHandlerScope = this._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  };
  return HandlerDomProxy2;
}(Eventful$1);
var HandlerProxy = HandlerDomProxy;
var dpr = 1;
if (env$1.hasGlobalWindow) {
  dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function identity$1(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
}
function copy(out2, m2) {
  out2[0] = m2[0];
  out2[1] = m2[1];
  out2[2] = m2[2];
  out2[3] = m2[3];
  out2[4] = m2[4];
  out2[5] = m2[5];
  return out2;
}
function mul(out2, m1, m2) {
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out22 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out2[0] = out0;
  out2[1] = out1;
  out2[2] = out22;
  out2[3] = out3;
  out2[4] = out4;
  out2[5] = out5;
  return out2;
}
function translate$2(out2, a2, v2) {
  out2[0] = a2[0];
  out2[1] = a2[1];
  out2[2] = a2[2];
  out2[3] = a2[3];
  out2[4] = a2[4] + v2[0];
  out2[5] = a2[5] + v2[1];
  return out2;
}
function rotate(out2, a2, rad) {
  var aa = a2[0];
  var ac = a2[2];
  var atx = a2[4];
  var ab = a2[1];
  var ad = a2[3];
  var aty = a2[5];
  var st = Math.sin(rad);
  var ct = Math.cos(rad);
  out2[0] = aa * ct + ab * st;
  out2[1] = -aa * st + ab * ct;
  out2[2] = ac * ct + ad * st;
  out2[3] = -ac * st + ct * ad;
  out2[4] = ct * atx + st * aty;
  out2[5] = ct * aty - st * atx;
  return out2;
}
function scale$1(out2, a2, v2) {
  var vx = v2[0];
  var vy = v2[1];
  out2[0] = a2[0] * vx;
  out2[1] = a2[1] * vy;
  out2[2] = a2[2] * vx;
  out2[3] = a2[3] * vy;
  out2[4] = a2[4] * vx;
  out2[5] = a2[5] * vy;
  return out2;
}
function invert(out2, a2) {
  var aa = a2[0];
  var ac = a2[2];
  var atx = a2[4];
  var ab = a2[1];
  var ad = a2[3];
  var aty = a2[5];
  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = ad * det;
  out2[1] = -ab * det;
  out2[2] = -ac * det;
  out2[3] = aa * det;
  out2[4] = (ac * aty - ad * atx) * det;
  out2[5] = (ab * atx - aa * aty) * det;
  return out2;
}
function clone$1(a2) {
  var b2 = create();
  copy(b2, a2);
  return b2;
}
var matrix = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create,
  identity: identity$1,
  copy,
  mul,
  translate: translate$2,
  rotate,
  scale: scale$1,
  invert,
  clone: clone$1
}, Symbol.toStringTag, { value: "Module" }));
var mIdentity = identity$1;
var EPSILON$2 = 5e-5;
function isNotAroundZero(val) {
  return val > EPSILON$2 || val < -EPSILON$2;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create();
var abs = Math.abs;
var Transformable = function() {
  function Transformable2() {
  }
  Transformable2.prototype.getLocalTransform = function(m2) {
    return Transformable2.getLocalTransform(this, m2);
  };
  Transformable2.prototype.setPosition = function(arr) {
    this.x = arr[0];
    this.y = arr[1];
  };
  Transformable2.prototype.setScale = function(arr) {
    this.scaleX = arr[0];
    this.scaleY = arr[1];
  };
  Transformable2.prototype.setSkew = function(arr) {
    this.skewX = arr[0];
    this.skewY = arr[1];
  };
  Transformable2.prototype.setOrigin = function(arr) {
    this.originX = arr[0];
    this.originY = arr[1];
  };
  Transformable2.prototype.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
  };
  Transformable2.prototype.updateTransform = function() {
    var parentTransform = this.parent && this.parent.transform;
    var needLocalTransform = this.needLocalTransform();
    var m2 = this.transform;
    if (!(needLocalTransform || parentTransform)) {
      m2 && mIdentity(m2);
      return;
    }
    m2 = m2 || create();
    if (needLocalTransform) {
      this.getLocalTransform(m2);
    } else {
      mIdentity(m2);
    }
    if (parentTransform) {
      if (needLocalTransform) {
        mul(m2, parentTransform, m2);
      } else {
        copy(m2, parentTransform);
      }
    }
    this.transform = m2;
    this._resolveGlobalScaleRatio(m2);
  };
  Transformable2.prototype._resolveGlobalScaleRatio = function(m2) {
    var globalScaleRatio = this.globalScaleRatio;
    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      var relX = scaleTmp[0] < 0 ? -1 : 1;
      var relY = scaleTmp[1] < 0 ? -1 : 1;
      var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m2[0] *= sx;
      m2[1] *= sx;
      m2[2] *= sy;
      m2[3] *= sy;
    }
    this.invTransform = this.invTransform || create();
    invert(this.invTransform, m2);
  };
  Transformable2.prototype.getComputedTransform = function() {
    var transformNode = this;
    var ancestors = [];
    while (transformNode) {
      ancestors.push(transformNode);
      transformNode = transformNode.parent;
    }
    while (transformNode = ancestors.pop()) {
      transformNode.updateTransform();
    }
    return this.transform;
  };
  Transformable2.prototype.setLocalTransform = function(m2) {
    if (!m2) {
      return;
    }
    var sx = m2[0] * m2[0] + m2[1] * m2[1];
    var sy = m2[2] * m2[2] + m2[3] * m2[3];
    var rotation = Math.atan2(m2[1], m2[0]);
    var shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
    sy = Math.sqrt(sy) * Math.cos(shearX);
    sx = Math.sqrt(sx);
    this.skewX = shearX;
    this.skewY = 0;
    this.rotation = -rotation;
    this.x = +m2[4];
    this.y = +m2[5];
    this.scaleX = sx;
    this.scaleY = sy;
    this.originX = 0;
    this.originY = 0;
  };
  Transformable2.prototype.decomposeTransform = function() {
    if (!this.transform) {
      return;
    }
    var parent2 = this.parent;
    var m2 = this.transform;
    if (parent2 && parent2.transform) {
      mul(tmpTransform, parent2.invTransform, m2);
      m2 = tmpTransform;
    }
    var ox = this.originX;
    var oy = this.originY;
    if (ox || oy) {
      originTransform[4] = ox;
      originTransform[5] = oy;
      mul(tmpTransform, m2, originTransform);
      tmpTransform[4] -= ox;
      tmpTransform[5] -= oy;
      m2 = tmpTransform;
    }
    this.setLocalTransform(m2);
  };
  Transformable2.prototype.getGlobalScale = function(out2) {
    var m2 = this.transform;
    out2 = out2 || [];
    if (!m2) {
      out2[0] = 1;
      out2[1] = 1;
      return out2;
    }
    out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
    out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
    if (m2[0] < 0) {
      out2[0] = -out2[0];
    }
    if (m2[3] < 0) {
      out2[1] = -out2[1];
    }
    return out2;
  };
  Transformable2.prototype.transformCoordToLocal = function(x2, y) {
    var v2 = [x2, y];
    var invTransform = this.invTransform;
    if (invTransform) {
      applyTransform$1(v2, v2, invTransform);
    }
    return v2;
  };
  Transformable2.prototype.transformCoordToGlobal = function(x2, y) {
    var v2 = [x2, y];
    var transform2 = this.transform;
    if (transform2) {
      applyTransform$1(v2, v2, transform2);
    }
    return v2;
  };
  Transformable2.prototype.getLineScale = function() {
    var m2 = this.transform;
    return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
  };
  Transformable2.prototype.copyTransform = function(source) {
    copyTransform(this, source);
  };
  Transformable2.getLocalTransform = function(target, m2) {
    m2 = m2 || [];
    var ox = target.originX || 0;
    var oy = target.originY || 0;
    var sx = target.scaleX;
    var sy = target.scaleY;
    var ax = target.anchorX;
    var ay = target.anchorY;
    var rotation = target.rotation || 0;
    var x2 = target.x;
    var y = target.y;
    var skewX = target.skewX ? Math.tan(target.skewX) : 0;
    var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
    if (ox || oy || ax || ay) {
      var dx = ox + ax;
      var dy = oy + ay;
      m2[4] = -dx * sx - skewX * dy * sy;
      m2[5] = -dy * sy - skewY * dx * sx;
    } else {
      m2[4] = m2[5] = 0;
    }
    m2[0] = sx;
    m2[3] = sy;
    m2[1] = skewY * sx;
    m2[2] = skewX * sy;
    rotation && rotate(m2, m2, rotation);
    m2[4] += ox + x2;
    m2[5] += oy + y;
    return m2;
  };
  Transformable2.initDefaultProps = function() {
    var proto2 = Transformable2.prototype;
    proto2.scaleX = proto2.scaleY = proto2.globalScaleRatio = 1;
    proto2.x = proto2.y = proto2.originX = proto2.originY = proto2.skewX = proto2.skewY = proto2.rotation = proto2.anchorX = proto2.anchorY = 0;
  }();
  return Transformable2;
}();
var TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(target, source) {
  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    var propName = TRANSFORMABLE_PROPS[i];
    target[propName] = source[propName];
  }
}
var Transformable$1 = Transformable;
var Point = function() {
  function Point2(x2, y) {
    this.x = x2 || 0;
    this.y = y || 0;
  }
  Point2.prototype.copy = function(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  };
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.set = function(x2, y) {
    this.x = x2;
    this.y = y;
    return this;
  };
  Point2.prototype.equal = function(other) {
    return other.x === this.x && other.y === this.y;
  };
  Point2.prototype.add = function(other) {
    this.x += other.x;
    this.y += other.y;
    return this;
  };
  Point2.prototype.scale = function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  };
  Point2.prototype.scaleAndAdd = function(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
  };
  Point2.prototype.sub = function(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this;
  };
  Point2.prototype.dot = function(other) {
    return this.x * other.x + this.y * other.y;
  };
  Point2.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Point2.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  };
  Point2.prototype.normalize = function() {
    var len2 = this.len();
    this.x /= len2;
    this.y /= len2;
    return this;
  };
  Point2.prototype.distance = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point2.prototype.distanceSquare = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return dx * dx + dy * dy;
  };
  Point2.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  };
  Point2.prototype.transform = function(m2) {
    if (!m2) {
      return;
    }
    var x2 = this.x;
    var y = this.y;
    this.x = m2[0] * x2 + m2[2] * y + m2[4];
    this.y = m2[1] * x2 + m2[3] * y + m2[5];
    return this;
  };
  Point2.prototype.toArray = function(out2) {
    out2[0] = this.x;
    out2[1] = this.y;
    return out2;
  };
  Point2.prototype.fromArray = function(input) {
    this.x = input[0];
    this.y = input[1];
  };
  Point2.set = function(p2, x2, y) {
    p2.x = x2;
    p2.y = y;
  };
  Point2.copy = function(p2, p22) {
    p2.x = p22.x;
    p2.y = p22.y;
  };
  Point2.len = function(p2) {
    return Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  };
  Point2.lenSquare = function(p2) {
    return p2.x * p2.x + p2.y * p2.y;
  };
  Point2.dot = function(p0, p1) {
    return p0.x * p1.x + p0.y * p1.y;
  };
  Point2.add = function(out2, p0, p1) {
    out2.x = p0.x + p1.x;
    out2.y = p0.y + p1.y;
  };
  Point2.sub = function(out2, p0, p1) {
    out2.x = p0.x - p1.x;
    out2.y = p0.y - p1.y;
  };
  Point2.scale = function(out2, p0, scalar) {
    out2.x = p0.x * scalar;
    out2.y = p0.y * scalar;
  };
  Point2.scaleAndAdd = function(out2, p0, p1, scalar) {
    out2.x = p0.x + p1.x * scalar;
    out2.y = p0.y + p1.y * scalar;
  };
  Point2.lerp = function(out2, p0, p1, t) {
    var onet = 1 - t;
    out2.x = onet * p0.x + t * p1.x;
    out2.y = onet * p0.y + t * p1.y;
  };
  return Point2;
}();
var Point$1 = Point;
var mathMin$9 = Math.min;
var mathMax$9 = Math.max;
var lt = new Point$1();
var rb = new Point$1();
var lb = new Point$1();
var rt = new Point$1();
var minTv$1 = new Point$1();
var maxTv$1 = new Point$1();
var BoundingRect = function() {
  function BoundingRect2(x2, y, width, height) {
    if (width < 0) {
      x2 = x2 + width;
      width = -width;
    }
    if (height < 0) {
      y = y + height;
      height = -height;
    }
    this.x = x2;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  BoundingRect2.prototype.union = function(other) {
    var x2 = mathMin$9(other.x, this.x);
    var y = mathMin$9(other.y, this.y);
    if (isFinite(this.x) && isFinite(this.width)) {
      this.width = mathMax$9(other.x + other.width, this.x + this.width) - x2;
    } else {
      this.width = other.width;
    }
    if (isFinite(this.y) && isFinite(this.height)) {
      this.height = mathMax$9(other.y + other.height, this.y + this.height) - y;
    } else {
      this.height = other.height;
    }
    this.x = x2;
    this.y = y;
  };
  BoundingRect2.prototype.applyTransform = function(m2) {
    BoundingRect2.applyTransform(this, this, m2);
  };
  BoundingRect2.prototype.calculateTransform = function(b2) {
    var a2 = this;
    var sx = b2.width / a2.width;
    var sy = b2.height / a2.height;
    var m2 = create();
    translate$2(m2, m2, [-a2.x, -a2.y]);
    scale$1(m2, m2, [sx, sy]);
    translate$2(m2, m2, [b2.x, b2.y]);
    return m2;
  };
  BoundingRect2.prototype.intersect = function(b2, mtv) {
    if (!b2) {
      return false;
    }
    if (!(b2 instanceof BoundingRect2)) {
      b2 = BoundingRect2.create(b2);
    }
    var a2 = this;
    var ax0 = a2.x;
    var ax1 = a2.x + a2.width;
    var ay0 = a2.y;
    var ay1 = a2.y + a2.height;
    var bx0 = b2.x;
    var bx1 = b2.x + b2.width;
    var by0 = b2.y;
    var by1 = b2.y + b2.height;
    var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    if (mtv) {
      var dMin = Infinity;
      var dMax = 0;
      var d0 = Math.abs(ax1 - bx0);
      var d1 = Math.abs(bx1 - ax0);
      var d2 = Math.abs(ay1 - by0);
      var d3 = Math.abs(by1 - ay0);
      var dx = Math.min(d0, d1);
      var dy = Math.min(d2, d3);
      if (ax1 < bx0 || bx1 < ax0) {
        if (dx > dMax) {
          dMax = dx;
          if (d0 < d1) {
            Point$1.set(maxTv$1, -d0, 0);
          } else {
            Point$1.set(maxTv$1, d1, 0);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d0 < d1) {
            Point$1.set(minTv$1, d0, 0);
          } else {
            Point$1.set(minTv$1, -d1, 0);
          }
        }
      }
      if (ay1 < by0 || by1 < ay0) {
        if (dy > dMax) {
          dMax = dy;
          if (d2 < d3) {
            Point$1.set(maxTv$1, 0, -d2);
          } else {
            Point$1.set(maxTv$1, 0, d3);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d2 < d3) {
            Point$1.set(minTv$1, 0, d2);
          } else {
            Point$1.set(minTv$1, 0, -d3);
          }
        }
      }
    }
    if (mtv) {
      Point$1.copy(mtv, overlap ? minTv$1 : maxTv$1);
    }
    return overlap;
  };
  BoundingRect2.prototype.contain = function(x2, y) {
    var rect = this;
    return x2 >= rect.x && x2 <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  };
  BoundingRect2.prototype.clone = function() {
    return new BoundingRect2(this.x, this.y, this.width, this.height);
  };
  BoundingRect2.prototype.copy = function(other) {
    BoundingRect2.copy(this, other);
  };
  BoundingRect2.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  };
  BoundingRect2.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  };
  BoundingRect2.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  };
  BoundingRect2.create = function(rect) {
    return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
  };
  BoundingRect2.copy = function(target, source) {
    target.x = source.x;
    target.y = source.y;
    target.width = source.width;
    target.height = source.height;
  };
  BoundingRect2.applyTransform = function(target, source, m2) {
    if (!m2) {
      if (target !== source) {
        BoundingRect2.copy(target, source);
      }
      return;
    }
    if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
      var sx = m2[0];
      var sy = m2[3];
      var tx = m2[4];
      var ty = m2[5];
      target.x = source.x * sx + tx;
      target.y = source.y * sy + ty;
      target.width = source.width * sx;
      target.height = source.height * sy;
      if (target.width < 0) {
        target.x += target.width;
        target.width = -target.width;
      }
      if (target.height < 0) {
        target.y += target.height;
        target.height = -target.height;
      }
      return;
    }
    lt.x = lb.x = source.x;
    lt.y = rt.y = source.y;
    rb.x = rt.x = source.x + source.width;
    rb.y = lb.y = source.y + source.height;
    lt.transform(m2);
    rt.transform(m2);
    rb.transform(m2);
    lb.transform(m2);
    target.x = mathMin$9(lt.x, rb.x, lb.x, rt.x);
    target.y = mathMin$9(lt.y, rb.y, lb.y, rt.y);
    var maxX = mathMax$9(lt.x, rb.x, lb.x, rt.x);
    var maxY = mathMax$9(lt.y, rb.y, lb.y, rt.y);
    target.width = maxX - target.x;
    target.height = maxY - target.y;
  };
  return BoundingRect2;
}();
var BoundingRect$1 = BoundingRect;
var textWidthCache = {};
function getWidth(text2, font) {
  font = font || DEFAULT_FONT;
  var cacheOfFont = textWidthCache[font];
  if (!cacheOfFont) {
    cacheOfFont = textWidthCache[font] = new LRU$1(500);
  }
  var width = cacheOfFont.get(text2);
  if (width == null) {
    width = platformApi.measureText(text2, font).width;
    cacheOfFont.put(text2, width);
  }
  return width;
}
function innerGetBoundingRect(text2, font, textAlign, textBaseline) {
  var width = getWidth(text2, font);
  var height = getLineHeight(font);
  var x2 = adjustTextX(0, width, textAlign);
  var y = adjustTextY(0, height, textBaseline);
  var rect = new BoundingRect$1(x2, y, width, height);
  return rect;
}
function getBoundingRect(text2, font, textAlign, textBaseline) {
  var textLines = ((text2 || "") + "").split("\n");
  var len2 = textLines.length;
  if (len2 === 1) {
    return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
  } else {
    var uniondRect = new BoundingRect$1(0, 0, 0, 0);
    for (var i = 0; i < textLines.length; i++) {
      var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
      i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
    }
    return uniondRect;
  }
}
function adjustTextX(x2, width, textAlign) {
  if (textAlign === "right") {
    x2 -= width;
  } else if (textAlign === "center") {
    x2 -= width / 2;
  }
  return x2;
}
function adjustTextY(y, height, verticalAlign) {
  if (verticalAlign === "middle") {
    y -= height / 2;
  } else if (verticalAlign === "bottom") {
    y -= height;
  }
  return y;
}
function getLineHeight(font) {
  return getWidth("\u56FD", font);
}
function parsePercent$1(value, maxValue) {
  if (typeof value === "string") {
    if (value.lastIndexOf("%") >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }
    return parseFloat(value);
  }
  return value;
}
function calculateTextPosition(out2, opts, rect) {
  var textPosition = opts.position || "inside";
  var distance2 = opts.distance != null ? opts.distance : 5;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var x2 = rect.x;
  var y = rect.y;
  var textAlign = "left";
  var textVerticalAlign = "top";
  if (textPosition instanceof Array) {
    x2 += parsePercent$1(textPosition[0], rect.width);
    y += parsePercent$1(textPosition[1], rect.height);
    textAlign = null;
    textVerticalAlign = null;
  } else {
    switch (textPosition) {
      case "left":
        x2 -= distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "right":
        x2 += distance2 + width;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "top":
        x2 += width / 2;
        y -= distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "bottom":
        x2 += width / 2;
        y += height + distance2;
        textAlign = "center";
        break;
      case "inside":
        x2 += width / 2;
        y += halfHeight;
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "insideLeft":
        x2 += distance2;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "insideRight":
        x2 += width - distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideTop":
        x2 += width / 2;
        y += distance2;
        textAlign = "center";
        break;
      case "insideBottom":
        x2 += width / 2;
        y += height - distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideTopLeft":
        x2 += distance2;
        y += distance2;
        break;
      case "insideTopRight":
        x2 += width - distance2;
        y += distance2;
        textAlign = "right";
        break;
      case "insideBottomLeft":
        x2 += distance2;
        y += height - distance2;
        textVerticalAlign = "bottom";
        break;
      case "insideBottomRight":
        x2 += width - distance2;
        y += height - distance2;
        textAlign = "right";
        textVerticalAlign = "bottom";
        break;
    }
  }
  out2 = out2 || {};
  out2.x = x2;
  out2.y = y;
  out2.align = textAlign;
  out2.verticalAlign = textVerticalAlign;
  return out2;
}
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key2) {
  obj[key2] = true;
  return obj;
}, { ignore: false });
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect$1(0, 0, 0, 0);
var Element$1 = function() {
  function Element2(props2) {
    this.id = guid();
    this.animators = [];
    this.currentStates = [];
    this.states = {};
    this._init(props2);
  }
  Element2.prototype._init = function(props2) {
    this.attr(props2);
  };
  Element2.prototype.drift = function(dx, dy, e2) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    var m2 = this.transform;
    if (!m2) {
      m2 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m2[4] += dx;
    m2[5] += dy;
    this.decomposeTransform();
    this.markRedraw();
  };
  Element2.prototype.beforeUpdate = function() {
  };
  Element2.prototype.afterUpdate = function() {
  };
  Element2.prototype.update = function() {
    this.updateTransform();
    if (this.__dirty) {
      this.updateInnerText();
    }
  };
  Element2.prototype.updateInnerText = function(forceUpdate) {
    var textEl = this._textContent;
    if (textEl && (!textEl.ignore || forceUpdate)) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      var textConfig = this.textConfig;
      var isLocal = textConfig.local;
      var innerTransformable = textEl.innerTransformable;
      var textAlign = void 0;
      var textVerticalAlign = void 0;
      var textStyleChanged = false;
      innerTransformable.parent = isLocal ? this : null;
      var innerOrigin = false;
      innerTransformable.copyTransform(textEl);
      if (textConfig.position != null) {
        var layoutRect = tmpBoundingRect;
        if (textConfig.layoutRect) {
          layoutRect.copy(textConfig.layoutRect);
        } else {
          layoutRect.copy(this.getBoundingRect());
        }
        if (!isLocal) {
          layoutRect.applyTransform(this.transform);
        }
        if (this.calculateTextPosition) {
          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        } else {
          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        }
        innerTransformable.x = tmpTextPosCalcRes.x;
        innerTransformable.y = tmpTextPosCalcRes.y;
        textAlign = tmpTextPosCalcRes.align;
        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
        var textOrigin = textConfig.origin;
        if (textOrigin && textConfig.rotation != null) {
          var relOriginX = void 0;
          var relOriginY = void 0;
          if (textOrigin === "center") {
            relOriginX = layoutRect.width * 0.5;
            relOriginY = layoutRect.height * 0.5;
          } else {
            relOriginX = parsePercent$1(textOrigin[0], layoutRect.width);
            relOriginY = parsePercent$1(textOrigin[1], layoutRect.height);
          }
          innerOrigin = true;
          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
        }
      }
      if (textConfig.rotation != null) {
        innerTransformable.rotation = textConfig.rotation;
      }
      var textOffset = textConfig.offset;
      if (textOffset) {
        innerTransformable.x += textOffset[0];
        innerTransformable.y += textOffset[1];
        if (!innerOrigin) {
          innerTransformable.originX = -textOffset[0];
          innerTransformable.originY = -textOffset[1];
        }
      }
      var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
      var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      var textFill = void 0;
      var textStroke = void 0;
      var autoStroke = void 0;
      if (isInside && this.canBeInsideText()) {
        textFill = textConfig.insideFill;
        textStroke = textConfig.insideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getInsideTextFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getInsideTextStroke(textFill);
          autoStroke = true;
        }
      } else {
        textFill = textConfig.outsideFill;
        textStroke = textConfig.outsideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getOutsideFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getOutsideStroke(textFill);
          autoStroke = true;
        }
      }
      textFill = textFill || "#000";
      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
        textStyleChanged = true;
        innerTextDefaultStyle.fill = textFill;
        innerTextDefaultStyle.stroke = textStroke;
        innerTextDefaultStyle.autoStroke = autoStroke;
        innerTextDefaultStyle.align = textAlign;
        innerTextDefaultStyle.verticalAlign = textVerticalAlign;
        textEl.setDefaultTextStyle(innerTextDefaultStyle);
      }
      textEl.__dirty |= REDRAW_BIT;
      if (textStyleChanged) {
        textEl.dirtyStyle(true);
      }
    }
  };
  Element2.prototype.canBeInsideText = function() {
    return true;
  };
  Element2.prototype.getInsideTextFill = function() {
    return "#fff";
  };
  Element2.prototype.getInsideTextStroke = function(textFill) {
    return "#000";
  };
  Element2.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  };
  Element2.prototype.getOutsideStroke = function(textFill) {
    var backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
    var colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
    if (!colorArr) {
      colorArr = [255, 255, 255, 1];
    }
    var alpha = colorArr[3];
    var isDark = this.__zr.isDarkMode();
    for (var i = 0; i < 3; i++) {
      colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
    }
    colorArr[3] = 1;
    return stringify(colorArr, "rgba");
  };
  Element2.prototype.traverse = function(cb, context) {
  };
  Element2.prototype.attrKV = function(key2, value) {
    if (key2 === "textConfig") {
      this.setTextConfig(value);
    } else if (key2 === "textContent") {
      this.setTextContent(value);
    } else if (key2 === "clipPath") {
      this.setClipPath(value);
    } else if (key2 === "extra") {
      this.extra = this.extra || {};
      extend$3(this.extra, value);
    } else {
      this[key2] = value;
    }
  };
  Element2.prototype.hide = function() {
    this.ignore = true;
    this.markRedraw();
  };
  Element2.prototype.show = function() {
    this.ignore = false;
    this.markRedraw();
  };
  Element2.prototype.attr = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.attrKV(keyOrObj, value);
    } else if (isObject$9(keyOrObj)) {
      var obj = keyOrObj;
      var keysArr = keys$1(obj);
      for (var i = 0; i < keysArr.length; i++) {
        var key2 = keysArr[i];
        this.attrKV(key2, keyOrObj[key2]);
      }
    }
    this.markRedraw();
    return this;
  };
  Element2.prototype.saveCurrentToNormalState = function(toState) {
    this._innerSaveToNormal(toState);
    var normalState = this._normalState;
    for (var i = 0; i < this.animators.length; i++) {
      var animator = this.animators[i];
      var fromStateTransition = animator.__fromStateTransition;
      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
        continue;
      }
      var targetName = animator.targetName;
      var target = targetName ? normalState[targetName] : normalState;
      animator.saveTo(target);
    }
  };
  Element2.prototype._innerSaveToNormal = function(toState) {
    var normalState = this._normalState;
    if (!normalState) {
      normalState = this._normalState = {};
    }
    if (toState.textConfig && !normalState.textConfig) {
      normalState.textConfig = this.textConfig;
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
  };
  Element2.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
    for (var i = 0; i < primaryKeys.length; i++) {
      var key2 = primaryKeys[i];
      if (toState[key2] != null && !(key2 in normalState)) {
        normalState[key2] = this[key2];
      }
    }
  };
  Element2.prototype.hasState = function() {
    return this.currentStates.length > 0;
  };
  Element2.prototype.getState = function(name) {
    return this.states[name];
  };
  Element2.prototype.ensureState = function(name) {
    var states = this.states;
    if (!states[name]) {
      states[name] = {};
    }
    return states[name];
  };
  Element2.prototype.clearStates = function(noAnimation) {
    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
  };
  Element2.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
    var toNormalState = stateName === PRESERVED_NORMAL_STATE;
    var hasStates = this.hasState();
    if (!hasStates && toNormalState) {
      return;
    }
    var currentStates = this.currentStates;
    var animationCfg = this.stateTransition;
    if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
      return;
    }
    var state;
    if (this.stateProxy && !toNormalState) {
      state = this.stateProxy(stateName);
    }
    if (!state) {
      state = this.states && this.states[stateName];
    }
    if (!state && !toNormalState) {
      logError("State " + stateName + " not exists.");
      return;
    }
    if (!toNormalState) {
      this.saveCurrentToNormalState(state);
    }
    var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
    if (useHoverLayer) {
      this._toggleHoverLayerFlag(true);
    }
    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (textGuide) {
      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (toNormalState) {
      this.currentStates = [];
      this._normalState = {};
    } else {
      if (!keepCurrentStates) {
        this.currentStates = [stateName];
      } else {
        this.currentStates.push(stateName);
      }
    }
    this._updateAnimationTargets();
    this.markRedraw();
    if (!useHoverLayer && this.__inHover) {
      this._toggleHoverLayerFlag(false);
      this.__dirty &= ~REDRAW_BIT;
    }
    return state;
  };
  Element2.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
    if (!states.length) {
      this.clearStates();
    } else {
      var stateObjects = [];
      var currentStates = this.currentStates;
      var len2 = states.length;
      var notChange = len2 === currentStates.length;
      if (notChange) {
        for (var i = 0; i < len2; i++) {
          if (states[i] !== currentStates[i]) {
            notChange = false;
            break;
          }
        }
      }
      if (notChange) {
        return;
      }
      for (var i = 0; i < len2; i++) {
        var stateName = states[i];
        var stateObj = void 0;
        if (this.stateProxy) {
          stateObj = this.stateProxy(stateName, states);
        }
        if (!stateObj) {
          stateObj = this.states[stateName];
        }
        if (stateObj) {
          stateObjects.push(stateObj);
        }
      }
      var lastStateObj = stateObjects[len2 - 1];
      var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      var mergedState = this._mergeStates(stateObjects);
      var animationCfg = this.stateTransition;
      this.saveCurrentToNormalState(mergedState);
      this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useStates(states, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useStates(states, noAnimation, useHoverLayer);
      }
      this._updateAnimationTargets();
      this.currentStates = states.slice();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
    }
  };
  Element2.prototype._updateAnimationTargets = function() {
    for (var i = 0; i < this.animators.length; i++) {
      var animator = this.animators[i];
      if (animator.targetName) {
        animator.changeTarget(this[animator.targetName]);
      }
    }
  };
  Element2.prototype.removeState = function(state) {
    var idx = indexOf(this.currentStates, state);
    if (idx >= 0) {
      var currentStates = this.currentStates.slice();
      currentStates.splice(idx, 1);
      this.useStates(currentStates);
    }
  };
  Element2.prototype.replaceState = function(oldState, newState, forceAdd) {
    var currentStates = this.currentStates.slice();
    var idx = indexOf(currentStates, oldState);
    var newStateExists = indexOf(currentStates, newState) >= 0;
    if (idx >= 0) {
      if (!newStateExists) {
        currentStates[idx] = newState;
      } else {
        currentStates.splice(idx, 1);
      }
    } else if (forceAdd && !newStateExists) {
      currentStates.push(newState);
    }
    this.useStates(currentStates);
  };
  Element2.prototype.toggleState = function(state, enable) {
    if (enable) {
      this.useState(state, true);
    } else {
      this.removeState(state);
    }
  };
  Element2.prototype._mergeStates = function(states) {
    var mergedState = {};
    var mergedTextConfig;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      extend$3(mergedState, state);
      if (state.textConfig) {
        mergedTextConfig = mergedTextConfig || {};
        extend$3(mergedTextConfig, state.textConfig);
      }
    }
    if (mergedTextConfig) {
      mergedState.textConfig = mergedTextConfig;
    }
    return mergedState;
  };
  Element2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition2, animationCfg) {
    var needsRestoreToNormal = !(state && keepCurrentStates);
    if (state && state.textConfig) {
      this.textConfig = extend$3({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
      extend$3(this.textConfig, state.textConfig);
    } else if (needsRestoreToNormal) {
      if (normalState.textConfig) {
        this.textConfig = normalState.textConfig;
      }
    }
    var transitionTarget = {};
    var hasTransition = false;
    for (var i = 0; i < PRIMARY_STATES_KEYS$1.length; i++) {
      var key2 = PRIMARY_STATES_KEYS$1[i];
      var propNeedsTransition = transition2 && DEFAULT_ANIMATABLE_MAP[key2];
      if (state && state[key2] != null) {
        if (propNeedsTransition) {
          hasTransition = true;
          transitionTarget[key2] = state[key2];
        } else {
          this[key2] = state[key2];
        }
      } else if (needsRestoreToNormal) {
        if (normalState[key2] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key2] = normalState[key2];
          } else {
            this[key2] = normalState[key2];
          }
        }
      }
    }
    if (!transition2) {
      for (var i = 0; i < this.animators.length; i++) {
        var animator = this.animators[i];
        var targetName = animator.targetName;
        if (!animator.getLoop()) {
          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
        }
      }
    }
    if (hasTransition) {
      this._transitionState(stateName, transitionTarget, animationCfg);
    }
  };
  Element2.prototype._attachComponent = function(componentEl) {
    if (componentEl.__zr && !componentEl.__hostTarget) {
      return;
    }
    if (componentEl === this) {
      return;
    }
    var zr = this.__zr;
    if (zr) {
      componentEl.addSelfToZr(zr);
    }
    componentEl.__zr = zr;
    componentEl.__hostTarget = this;
  };
  Element2.prototype._detachComponent = function(componentEl) {
    if (componentEl.__zr) {
      componentEl.removeSelfFromZr(componentEl.__zr);
    }
    componentEl.__zr = null;
    componentEl.__hostTarget = null;
  };
  Element2.prototype.getClipPath = function() {
    return this._clipPath;
  };
  Element2.prototype.setClipPath = function(clipPath) {
    if (this._clipPath && this._clipPath !== clipPath) {
      this.removeClipPath();
    }
    this._attachComponent(clipPath);
    this._clipPath = clipPath;
    this.markRedraw();
  };
  Element2.prototype.removeClipPath = function() {
    var clipPath = this._clipPath;
    if (clipPath) {
      this._detachComponent(clipPath);
      this._clipPath = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextContent = function() {
    return this._textContent;
  };
  Element2.prototype.setTextContent = function(textEl) {
    var previousTextContent = this._textContent;
    if (previousTextContent === textEl) {
      return;
    }
    if (previousTextContent && previousTextContent !== textEl) {
      this.removeTextContent();
    }
    textEl.innerTransformable = new Transformable$1();
    this._attachComponent(textEl);
    this._textContent = textEl;
    this.markRedraw();
  };
  Element2.prototype.setTextConfig = function(cfg) {
    if (!this.textConfig) {
      this.textConfig = {};
    }
    extend$3(this.textConfig, cfg);
    this.markRedraw();
  };
  Element2.prototype.removeTextConfig = function() {
    this.textConfig = null;
    this.markRedraw();
  };
  Element2.prototype.removeTextContent = function() {
    var textEl = this._textContent;
    if (textEl) {
      textEl.innerTransformable = null;
      this._detachComponent(textEl);
      this._textContent = null;
      this._innerTextDefaultStyle = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextGuideLine = function() {
    return this._textGuide;
  };
  Element2.prototype.setTextGuideLine = function(guideLine) {
    if (this._textGuide && this._textGuide !== guideLine) {
      this.removeTextGuideLine();
    }
    this._attachComponent(guideLine);
    this._textGuide = guideLine;
    this.markRedraw();
  };
  Element2.prototype.removeTextGuideLine = function() {
    var textGuide = this._textGuide;
    if (textGuide) {
      this._detachComponent(textGuide);
      this._textGuide = null;
      this.markRedraw();
    }
  };
  Element2.prototype.markRedraw = function() {
    this.__dirty |= REDRAW_BIT;
    var zr = this.__zr;
    if (zr) {
      if (this.__inHover) {
        zr.refreshHover();
      } else {
        zr.refresh();
      }
    }
    if (this.__hostTarget) {
      this.__hostTarget.markRedraw();
    }
  };
  Element2.prototype.dirty = function() {
    this.markRedraw();
  };
  Element2.prototype._toggleHoverLayerFlag = function(inHover) {
    this.__inHover = inHover;
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.__inHover = inHover;
    }
    if (textGuide) {
      textGuide.__inHover = inHover;
    }
  };
  Element2.prototype.addSelfToZr = function(zr) {
    if (this.__zr === zr) {
      return;
    }
    this.__zr = zr;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.addSelfToZr(zr);
    }
    if (this._textContent) {
      this._textContent.addSelfToZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.addSelfToZr(zr);
    }
  };
  Element2.prototype.removeSelfFromZr = function(zr) {
    if (!this.__zr) {
      return;
    }
    this.__zr = null;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.removeSelfFromZr(zr);
    }
    if (this._textContent) {
      this._textContent.removeSelfFromZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.removeSelfFromZr(zr);
    }
  };
  Element2.prototype.animate = function(key2, loop2, allowDiscreteAnimation) {
    var target = key2 ? this[key2] : this;
    var animator = new Animator$1(target, loop2, allowDiscreteAnimation);
    key2 && (animator.targetName = key2);
    this.addAnimator(animator, key2);
    return animator;
  };
  Element2.prototype.addAnimator = function(animator, key2) {
    var zr = this.__zr;
    var el = this;
    animator.during(function() {
      el.updateDuringAnimation(key2);
    }).done(function() {
      var animators = el.animators;
      var idx = indexOf(animators, animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    this.animators.push(animator);
    if (zr) {
      zr.animation.addAnimator(animator);
    }
    zr && zr.wakeUp();
  };
  Element2.prototype.updateDuringAnimation = function(key2) {
    this.markRedraw();
  };
  Element2.prototype.stopAnimation = function(scope, forwardToLast) {
    var animators = this.animators;
    var len2 = animators.length;
    var leftAnimators = [];
    for (var i = 0; i < len2; i++) {
      var animator = animators[i];
      if (!scope || scope === animator.scope) {
        animator.stop(forwardToLast);
      } else {
        leftAnimators.push(animator);
      }
    }
    this.animators = leftAnimators;
    return this;
  };
  Element2.prototype.animateTo = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps);
  };
  Element2.prototype.animateFrom = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps, true);
  };
  Element2.prototype._transitionState = function(stateName, target, cfg, animationProps) {
    var animators = animateTo(this, target, cfg, animationProps);
    for (var i = 0; i < animators.length; i++) {
      animators[i].__fromStateTransition = stateName;
    }
  };
  Element2.prototype.getBoundingRect = function() {
    return null;
  };
  Element2.prototype.getPaintRect = function() {
    return null;
  };
  Element2.initDefaultProps = function() {
    var elProto = Element2.prototype;
    elProto.type = "element";
    elProto.name = "";
    elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
    elProto.__dirty = REDRAW_BIT;
    function createLegacyProperty(key2, privateKey, xKey, yKey) {
      Object.defineProperty(elProto, key2, {
        get: function() {
          if (!this[privateKey]) {
            var pos = this[privateKey] = [];
            enhanceArray(this, pos);
          }
          return this[privateKey];
        },
        set: function(pos) {
          this[xKey] = pos[0];
          this[yKey] = pos[1];
          this[privateKey] = pos;
          enhanceArray(this, pos);
        }
      });
      function enhanceArray(self2, pos) {
        Object.defineProperty(pos, 0, {
          get: function() {
            return self2[xKey];
          },
          set: function(val) {
            self2[xKey] = val;
          }
        });
        Object.defineProperty(pos, 1, {
          get: function() {
            return self2[yKey];
          },
          set: function(val) {
            self2[yKey] = val;
          }
        });
      }
    }
    if (Object.defineProperty) {
      createLegacyProperty("position", "_legacyPos", "x", "y");
      createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
      createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
    }
  }();
  return Element2;
}();
mixin(Element$1, Eventful$1);
mixin(Element$1, Transformable$1);
function animateTo(animatable, target, cfg, animationProps, reverse) {
  cfg = cfg || {};
  var animators = [];
  animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse);
  var finishCount = animators.length;
  var doneHappened = false;
  var cfgDone = cfg.done;
  var cfgAborted = cfg.aborted;
  var doneCb = function() {
    doneHappened = true;
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  var abortedCb = function() {
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  if (!finishCount) {
    cfgDone && cfgDone();
  }
  if (animators.length > 0 && cfg.during) {
    animators[0].during(function(target2, percent) {
      cfg.during(percent);
    });
  }
  for (var i = 0; i < animators.length; i++) {
    var animator = animators[i];
    if (doneCb) {
      animator.done(doneCb);
    }
    if (abortedCb) {
      animator.aborted(abortedCb);
    }
    if (cfg.force) {
      animator.duration(cfg.duration);
    }
    animator.start(cfg.easing);
  }
  return animators;
}
function copyArrShallow(source, target, len2) {
  for (var i = 0; i < len2; i++) {
    source[i] = target[i];
  }
}
function is2DArray(value) {
  return isArrayLike$1(value[0]);
}
function copyValue(target, source, key2) {
  if (isArrayLike$1(source[key2])) {
    if (!isArrayLike$1(target[key2])) {
      target[key2] = [];
    }
    if (isTypedArray$2(source[key2])) {
      var len2 = source[key2].length;
      if (target[key2].length !== len2) {
        target[key2] = new source[key2].constructor(len2);
        copyArrShallow(target[key2], source[key2], len2);
      }
    } else {
      var sourceArr = source[key2];
      var targetArr = target[key2];
      var len0 = sourceArr.length;
      if (is2DArray(sourceArr)) {
        var len1 = sourceArr[0].length;
        for (var i = 0; i < len0; i++) {
          if (!targetArr[i]) {
            targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
          } else {
            copyArrShallow(targetArr[i], sourceArr[i], len1);
          }
        }
      } else {
        copyArrShallow(targetArr, sourceArr, len0);
      }
      targetArr.length = sourceArr.length;
    }
  } else {
    target[key2] = source[key2];
  }
}
function isValueSame(val1, val2) {
  return val1 === val2 || isArrayLike$1(val1) && isArrayLike$1(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
  var len2 = arr0.length;
  if (len2 !== arr1.length) {
    return false;
  }
  for (var i = 0; i < len2; i++) {
    if (arr0[i] !== arr1[i]) {
      return false;
    }
  }
  return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse) {
  var targetKeys = keys$1(target);
  var duration = cfg.duration;
  var delay = cfg.delay;
  var additive = cfg.additive;
  var setToFinal = cfg.setToFinal;
  var animateAll = !isObject$9(animationProps);
  var existsAnimators = animatable.animators;
  var animationKeys = [];
  for (var k = 0; k < targetKeys.length; k++) {
    var innerKey = targetKeys[k];
    var targetVal = target[innerKey];
    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
      if (isObject$9(targetVal) && !isArrayLike$1(targetVal) && !isGradientObject(targetVal)) {
        if (topKey) {
          if (!reverse) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
          }
          continue;
        }
        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse);
      } else {
        animationKeys.push(innerKey);
      }
    } else if (!reverse) {
      animateObj[innerKey] = targetVal;
      animatable.updateDuringAnimation(topKey);
      animationKeys.push(innerKey);
    }
  }
  var keyLen = animationKeys.length;
  if (!additive && keyLen) {
    for (var i = 0; i < existsAnimators.length; i++) {
      var animator = existsAnimators[i];
      if (animator.targetName === topKey) {
        var allAborted = animator.stopTracks(animationKeys);
        if (allAborted) {
          var idx = indexOf(existsAnimators, animator);
          existsAnimators.splice(idx, 1);
        }
      }
    }
  }
  if (!cfg.force) {
    animationKeys = filter$2(animationKeys, function(key2) {
      return !isValueSame(target[key2], animateObj[key2]);
    });
    keyLen = animationKeys.length;
  }
  if (keyLen > 0 || cfg.force && !animators.length) {
    var revertedSource = void 0;
    var reversedTarget = void 0;
    var sourceClone = void 0;
    if (reverse) {
      reversedTarget = {};
      if (setToFinal) {
        revertedSource = {};
      }
      for (var i = 0; i < keyLen; i++) {
        var innerKey = animationKeys[i];
        reversedTarget[innerKey] = animateObj[innerKey];
        if (setToFinal) {
          revertedSource[innerKey] = target[innerKey];
        } else {
          animateObj[innerKey] = target[innerKey];
        }
      }
    } else if (setToFinal) {
      sourceClone = {};
      for (var i = 0; i < keyLen; i++) {
        var innerKey = animationKeys[i];
        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
        copyValue(animateObj, target, innerKey);
      }
    }
    var animator = new Animator$1(animateObj, false, false, additive ? filter$2(existsAnimators, function(animator2) {
      return animator2.targetName === topKey;
    }) : null);
    animator.targetName = topKey;
    if (cfg.scope) {
      animator.scope = cfg.scope;
    }
    if (setToFinal && revertedSource) {
      animator.whenWithKeys(0, revertedSource, animationKeys);
    }
    if (sourceClone) {
      animator.whenWithKeys(0, sourceClone, animationKeys);
    }
    animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animationKeys).delay(delay || 0);
    animatable.addAnimator(animator, topKey);
    animators.push(animator);
  }
}
var Element$2 = Element$1;
var Group$2 = function(_super) {
  __extends(Group2, _super);
  function Group2(opts) {
    var _this = _super.call(this) || this;
    _this.isGroup = true;
    _this._children = [];
    _this.attr(opts);
    return _this;
  }
  Group2.prototype.childrenRef = function() {
    return this._children;
  };
  Group2.prototype.children = function() {
    return this._children.slice();
  };
  Group2.prototype.childAt = function(idx) {
    return this._children[idx];
  };
  Group2.prototype.childOfName = function(name) {
    var children2 = this._children;
    for (var i = 0; i < children2.length; i++) {
      if (children2[i].name === name) {
        return children2[i];
      }
    }
  };
  Group2.prototype.childCount = function() {
    return this._children.length;
  };
  Group2.prototype.add = function(child) {
    if (child) {
      if (child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.addBefore = function(child, nextSibling2) {
    if (child && child !== this && child.parent !== this && nextSibling2 && nextSibling2.parent === this) {
      var children2 = this._children;
      var idx = children2.indexOf(nextSibling2);
      if (idx >= 0) {
        children2.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.replace = function(oldChild, newChild) {
    var idx = indexOf(this._children, oldChild);
    if (idx >= 0) {
      this.replaceAt(newChild, idx);
    }
    return this;
  };
  Group2.prototype.replaceAt = function(child, index2) {
    var children2 = this._children;
    var old = children2[index2];
    if (child && child !== this && child.parent !== this && child !== old) {
      children2[index2] = child;
      old.parent = null;
      var zr = this.__zr;
      if (zr) {
        old.removeSelfFromZr(zr);
      }
      this._doAdd(child);
    }
    return this;
  };
  Group2.prototype._doAdd = function(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    var zr = this.__zr;
    if (zr && zr !== child.__zr) {
      child.addSelfToZr(zr);
    }
    zr && zr.refresh();
  };
  Group2.prototype.remove = function(child) {
    var zr = this.__zr;
    var children2 = this._children;
    var idx = indexOf(children2, child);
    if (idx < 0) {
      return this;
    }
    children2.splice(idx, 1);
    child.parent = null;
    if (zr) {
      child.removeSelfFromZr(zr);
    }
    zr && zr.refresh();
    return this;
  };
  Group2.prototype.removeAll = function() {
    var children2 = this._children;
    var zr = this.__zr;
    for (var i = 0; i < children2.length; i++) {
      var child = children2[i];
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      child.parent = null;
    }
    children2.length = 0;
    return this;
  };
  Group2.prototype.eachChild = function(cb, context) {
    var children2 = this._children;
    for (var i = 0; i < children2.length; i++) {
      var child = children2[i];
      cb.call(context, child, i);
    }
    return this;
  };
  Group2.prototype.traverse = function(cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      var stopped = cb.call(context, child);
      if (child.isGroup && !stopped) {
        child.traverse(cb, context);
      }
    }
    return this;
  };
  Group2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.addSelfToZr(zr);
    }
  };
  Group2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.removeSelfFromZr(zr);
    }
  };
  Group2.prototype.getBoundingRect = function(includeChildren) {
    var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
    var children2 = includeChildren || this._children;
    var tmpMat = [];
    var rect = null;
    for (var i = 0; i < children2.length; i++) {
      var child = children2[i];
      if (child.ignore || child.invisible) {
        continue;
      }
      var childRect = child.getBoundingRect();
      var transform2 = child.getLocalTransform(tmpMat);
      if (transform2) {
        BoundingRect$1.applyTransform(tmpRect2, childRect, transform2);
        rect = rect || tmpRect2.clone();
        rect.union(tmpRect2);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect2;
  };
  return Group2;
}(Element$2);
Group$2.prototype.type = "group";
var Group$3 = Group$2;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances$1 = {};
function delInstance(id) {
  delete instances$1[id];
}
function isDarkMode(backgroundColor2) {
  if (!backgroundColor2) {
    return false;
  }
  if (typeof backgroundColor2 === "string") {
    return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
  } else if (backgroundColor2.colorStops) {
    var colorStops = backgroundColor2.colorStops;
    var totalLum = 0;
    var len2 = colorStops.length;
    for (var i = 0; i < len2; i++) {
      totalLum += lum(colorStops[i].color, 1);
    }
    totalLum /= len2;
    return totalLum < DARK_MODE_THRESHOLD;
  }
  return false;
}
var ZRender = function() {
  function ZRender2(id, dom, opts) {
    var _this = this;
    this._sleepAfterStill = 10;
    this._stillFrameAccum = 0;
    this._needsRefresh = true;
    this._needsRefreshHover = true;
    this._darkMode = false;
    opts = opts || {};
    this.dom = dom;
    this.id = id;
    var storage2 = new Storage$1();
    var rendererType = opts.renderer || "canvas";
    if (!painterCtors[rendererType]) {
      rendererType = keys$1(painterCtors)[0];
    }
    opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
    var painter = new painterCtors[rendererType](dom, storage2, opts, id);
    var ssrMode = opts.ssr || painter.ssrOnly;
    this.storage = storage2;
    this.painter = painter;
    var handerProxy = !env$1.node && !env$1.worker && !ssrMode ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
    this.handler = new Handler$1(storage2, painter, handerProxy, painter.root);
    this.animation = new Animation$1({
      stage: {
        update: ssrMode ? null : function() {
          return _this._flush(true);
        }
      }
    });
    if (!ssrMode) {
      this.animation.start();
    }
  }
  ZRender2.prototype.add = function(el) {
    if (!el) {
      return;
    }
    this.storage.addRoot(el);
    el.addSelfToZr(this);
    this.refresh();
  };
  ZRender2.prototype.remove = function(el) {
    if (!el) {
      return;
    }
    this.storage.delRoot(el);
    el.removeSelfFromZr(this);
    this.refresh();
  };
  ZRender2.prototype.configLayer = function(zLevel, config) {
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }
    this.refresh();
  };
  ZRender2.prototype.setBackgroundColor = function(backgroundColor2) {
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor2);
    }
    this.refresh();
    this._backgroundColor = backgroundColor2;
    this._darkMode = isDarkMode(backgroundColor2);
  };
  ZRender2.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  };
  ZRender2.prototype.setDarkMode = function(darkMode) {
    this._darkMode = darkMode;
  };
  ZRender2.prototype.isDarkMode = function() {
    return this._darkMode;
  };
  ZRender2.prototype.refreshImmediately = function(fromInside) {
    if (!fromInside) {
      this.animation.update(true);
    }
    this._needsRefresh = false;
    this.painter.refresh();
    this._needsRefresh = false;
  };
  ZRender2.prototype.refresh = function() {
    this._needsRefresh = true;
    this.animation.start();
  };
  ZRender2.prototype.flush = function() {
    this._flush(false);
  };
  ZRender2.prototype._flush = function(fromInside) {
    var triggerRendered;
    var start2 = getTime();
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately(fromInside);
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    var end2 = getTime();
    if (triggerRendered) {
      this._stillFrameAccum = 0;
      this.trigger("rendered", {
        elapsedTime: end2 - start2
      });
    } else if (this._sleepAfterStill > 0) {
      this._stillFrameAccum++;
      if (this._stillFrameAccum > this._sleepAfterStill) {
        this.animation.stop();
      }
    }
  };
  ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
    this._sleepAfterStill = stillFramesCount;
  };
  ZRender2.prototype.wakeUp = function() {
    this.animation.start();
    this._stillFrameAccum = 0;
  };
  ZRender2.prototype.refreshHover = function() {
    this._needsRefreshHover = true;
  };
  ZRender2.prototype.refreshHoverImmediately = function() {
    this._needsRefreshHover = false;
    if (this.painter.refreshHover && this.painter.getType() === "canvas") {
      this.painter.refreshHover();
    }
  };
  ZRender2.prototype.resize = function(opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  };
  ZRender2.prototype.clearAnimation = function() {
    this.animation.clear();
  };
  ZRender2.prototype.getWidth = function() {
    return this.painter.getWidth();
  };
  ZRender2.prototype.getHeight = function() {
    return this.painter.getHeight();
  };
  ZRender2.prototype.setCursorStyle = function(cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  };
  ZRender2.prototype.findHover = function(x2, y) {
    return this.handler.findHover(x2, y);
  };
  ZRender2.prototype.on = function(eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
    return this;
  };
  ZRender2.prototype.off = function(eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  };
  ZRender2.prototype.trigger = function(eventName, event) {
    this.handler.trigger(eventName, event);
  };
  ZRender2.prototype.clear = function() {
    var roots2 = this.storage.getRoots();
    for (var i = 0; i < roots2.length; i++) {
      if (roots2[i] instanceof Group$3) {
        roots2[i].removeSelfFromZr(this);
      }
    }
    this.storage.delAllRoots();
    this.painter.clear();
  };
  ZRender2.prototype.dispose = function() {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  };
  return ZRender2;
}();
function init$1(dom, opts) {
  var zr = new ZRender(guid(), dom, opts);
  instances$1[zr.id] = zr;
  return zr;
}
function dispose$1(zr) {
  zr.dispose();
}
function disposeAll() {
  for (var key2 in instances$1) {
    if (instances$1.hasOwnProperty(key2)) {
      instances$1[key2].dispose();
    }
  }
  instances$1 = {};
}
function getInstance(id) {
  return instances$1[id];
}
function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}
var version$1 = "5.3.0";
var zrender = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  init: init$1,
  dispose: dispose$1,
  disposeAll,
  getInstance,
  registerPainter,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
function linearMap$2(val, domain, range, clamp2) {
  var d0 = domain[0];
  var d1 = domain[1];
  var r0 = range[0];
  var r1 = range[1];
  var subDomain = d1 - d0;
  var subRange = r1 - r0;
  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  }
  if (clamp2) {
    if (subDomain > 0) {
      if (val <= d0) {
        return r0;
      } else if (val >= d1) {
        return r1;
      }
    } else {
      if (val >= d0) {
        return r0;
      } else if (val <= d1) {
        return r1;
      }
    }
  } else {
    if (val === d0) {
      return r0;
    }
    if (val === d1) {
      return r1;
    }
  }
  return (val - d0) / subDomain * subRange + r0;
}
function parsePercent(percent, all) {
  switch (percent) {
    case "center":
    case "middle":
      percent = "50%";
      break;
    case "left":
    case "top":
      percent = "0%";
      break;
    case "right":
    case "bottom":
      percent = "100%";
      break;
  }
  if (isString$2(percent)) {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }
    return parseFloat(percent);
  }
  return percent == null ? NaN : +percent;
}
function round$4(x2, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  }
  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
  x2 = (+x2).toFixed(precision);
  return returnStr ? x2 : +x2;
}
function asc$2(arr) {
  arr.sort(function(a2, b2) {
    return a2 - b2;
  });
  return arr;
}
function getPrecision(val) {
  val = +val;
  if (isNaN(val)) {
    return 0;
  }
  if (val > 1e-14) {
    var e2 = 1;
    for (var i = 0; i < 15; i++, e2 *= 10) {
      if (Math.round(val * e2) / e2 === val) {
        return i;
      }
    }
  }
  return getPrecisionSafe(val);
}
function getPrecisionSafe(val) {
  var str = val.toString().toLowerCase();
  var eIndex = str.indexOf("e");
  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  var significandPartLen = eIndex > 0 ? eIndex : str.length;
  var dotIndex = str.indexOf(".");
  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }
  var sum = reduce(valueList, function(acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);
  if (sum === 0) {
    return 0;
  }
  var digits = Math.pow(10, precision);
  var votesPerQuota = map$1(valueList, function(val) {
    return (isNaN(val) ? 0 : val) / sum * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = map$1(votesPerQuota, function(votes) {
    return Math.floor(votes);
  });
  var currentSum = reduce(seats, function(acc, val) {
    return acc + val;
  }, 0);
  var remainder = map$1(votesPerQuota, function(votes, idx2) {
    return votes - seats[idx2];
  });
  while (currentSum < targetSeats) {
    var max3 = Number.NEGATIVE_INFINITY;
    var maxId = null;
    for (var i = 0, len2 = remainder.length; i < len2; ++i) {
      if (remainder[i] > max3) {
        max3 = remainder[i];
        maxId = i;
      }
    }
    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }
  return seats[idx] / digits;
}
function addSafe(val0, val1) {
  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
  var sum = val0 + val1;
  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round$4(sum, maxPrecision);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (isString$2(value)) {
    var match = TIME_REG.exec(value);
    if (!match) {
      return new Date(NaN);
    }
    if (!match[8]) {
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } else {
      var hour = +match[4] || 0;
      if (match[8].toUpperCase() !== "Z") {
        hour -= +match[8].slice(0, 3);
      }
      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
  } else if (value == null) {
    return new Date(NaN);
  }
  return new Date(Math.round(value));
}
function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}
function quantityExponent(val) {
  if (val === 0) {
    return 0;
  }
  var exp = Math.floor(Math.log(val) / Math.LN10);
  if (val / Math.pow(10, exp) >= 10) {
    exp++;
  }
  return exp;
}
function nice(val, round2) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f = val / exp10;
  var nf;
  if (round2) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }
  val = nf * exp10;
  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
function quantile(ascArr, p2) {
  var H = (ascArr.length - 1) * p2 + 1;
  var h2 = Math.floor(H);
  var v2 = +ascArr[h2 - 1];
  var e2 = H - h2;
  return e2 ? v2 + e2 * (ascArr[h2] - v2) : v2;
}
function reformIntervals(list2) {
  list2.sort(function(a2, b2) {
    return littleThan2(a2, b2, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;
  for (var i = 0; i < list2.length; ) {
    var interval = list2[i].interval;
    var close_1 = list2[i].close;
    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close_1[lg] = !lg ? 1 - currClose : 1;
      }
      curr = interval[lg];
      currClose = close_1[lg];
    }
    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
      list2.splice(i, 1);
    } else {
      i++;
    }
  }
  return list2;
  function littleThan2(a2, b2, lg2) {
    return a2.interval[lg2] < b2.interval[lg2] || a2.interval[lg2] === b2.interval[lg2] && (a2.close[lg2] - b2.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan2(a2, b2, 1));
  }
}
function numericToNumber(val) {
  var valFloat = parseFloat(val);
  return valFloat == val && (valFloat !== 0 || !isString$2(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
function isNumeric(val) {
  return !isNaN(numericToNumber(val));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(a2, b2) {
  if (b2 === 0) {
    return a2;
  }
  return getGreatestCommonDividor(b2, a2 % b2);
}
function getLeastCommonMultiple(a2, b2) {
  if (a2 == null) {
    return b2;
  }
  if (b2 == null) {
    return a2;
  }
  return a2 * b2 / getGreatestCommonDividor(a2, b2);
}
var ECHARTS_PREFIX = "[ECharts] ";
var storedLogs = {};
var hasConsole = typeof console !== "undefined" && console.warn && console.log;
function outputLog(type, str, onlyOnce) {
  if (hasConsole) {
    if (onlyOnce) {
      if (storedLogs[str]) {
        return;
      }
      storedLogs[str] = true;
    }
    console[type](ECHARTS_PREFIX + str);
  }
}
function warn(str, onlyOnce) {
  outputLog("warn", str, onlyOnce);
}
function throwError$1(msg) {
  throw new Error(msg);
}
function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
function defaultEmphasis(opt, key2, subOpts) {
  if (opt) {
    opt[key2] = opt[key2] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key2] = opt.emphasis[key2] || {};
    for (var i = 0, len2 = subOpts.length; i < len2; i++) {
      var subOptName = subOpts[i];
      if (!opt.emphasis[key2].hasOwnProperty(subOptName) && opt[key2].hasOwnProperty(subOptName)) {
        opt.emphasis[key2][subOptName] = opt[key2][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue(dataItem) {
  return isObject$9(dataItem) && !isArray$4(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption(dataItem) {
  return isObject$9(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(existings, newCmptOptions, mode) {
  var isNormalMergeMode = mode === "normalMerge";
  var isReplaceMergeMode = mode === "replaceMerge";
  var isReplaceAllMode = mode === "replaceAll";
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  var existingIdIdxMap = createHashMap();
  each$e(newCmptOptions, function(cmptOption, index2) {
    if (!isObject$9(cmptOption)) {
      newCmptOptions[index2] = null;
      return;
    }
  });
  var result = prepareResult(existings, existingIdIdxMap, mode);
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }
  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }
  makeIdAndName(result);
  return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
  var result = [];
  if (mode === "replaceAll") {
    return result;
  }
  for (var index2 = 0; index2 < existings.length; index2++) {
    var existing = existings[index2];
    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index2);
    }
    result.push({
      existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  each$e(newCmptOptions, function(cmptOption, index2) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }
    var optionId = makeComparableKey(cmptOption.id);
    var existingIdx = existingIdIdxMap.get(optionId);
    if (existingIdx != null) {
      var resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption;
      resultItem.existing = existings[existingIdx];
      newCmptOptions[index2] = null;
    }
  });
}
function mappingByName(result, newCmptOptions) {
  each$e(newCmptOptions, function(cmptOption, index2) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }
    for (var i = 0; i < result.length; i++) {
      var existing = result[i].existing;
      if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
        result[i].newOption = cmptOption;
        newCmptOptions[index2] = null;
        return;
      }
    }
  });
}
function mappingByIndex(result, newCmptOptions, brandNew) {
  each$e(newCmptOptions, function(cmptOption) {
    if (!cmptOption) {
      return;
    }
    var resultItem;
    var nextIdx = 0;
    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
      nextIdx++;
    }
    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew,
        existing: null,
        keyInfo: null
      });
    }
    nextIdx++;
  });
}
function mappingInReplaceAllMode(result, newCmptOptions) {
  each$e(newCmptOptions, function(cmptOption) {
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(mapResult) {
  var idMap = createHashMap();
  each$e(mapResult, function(item) {
    var existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each$e(mapResult, function(item) {
    var opt = item.newOption;
    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each$e(mapResult, function(item, index2) {
    var existing = item.existing;
    var opt = item.newOption;
    var keyInfo = item.keyInfo;
    if (!isObject$9(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index2;
    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      var idNum = 0;
      do {
        keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function keyExistAndEqual(attr2, obj1, obj2) {
  var key1 = convertOptionIdName(obj1[attr2], null);
  var key2 = convertOptionIdName(obj2[attr2], null);
  return key1 != null && key2 != null && key1 === key2;
}
function makeComparableKey(val) {
  return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }
  return isString$2(idOrName) ? idOrName : isNumber$1(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function isNameSpecified(componentModel) {
  var name = componentModel.name;
  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(idSuffix) {
  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  each$e(mappingResult, function(item) {
    var newOption = item.newOption;
    if (isObject$9(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
  return subType;
}
function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray2(mapA), mapToArray2(mapB)];
  function makeMap(sourceBatch, map2, otherMap) {
    for (var i = 0, len2 = sourceBatch.length; i < len2; i++) {
      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
      if (seriesId == null) {
        return;
      }
      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];
      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];
        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map2[seriesId] || (map2[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }
  function mapToArray2(map2, isData) {
    var result = [];
    for (var i in map2) {
      if (map2.hasOwnProperty(i) && map2[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray2(map2[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }
    return result;
  }
}
function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray$4(payload.dataIndex) ? map$1(payload.dataIndex, function(value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray$4(payload.name) ? map$1(payload.name, function(value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
function makeInner() {
  var key2 = "__ec_inner_" + innerUniqueIndex++;
  return function(hostObj) {
    return hostObj[key2] || (hostObj[key2] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder$1(ecModel, finderInput, opt) {
  var _a2 = preParseFinder(finderInput, opt), mainTypeSpecified = _a2.mainTypeSpecified, queryOptionMap = _a2.queryOptionMap, others = _a2.others;
  var result = others;
  var defaultMainType = opt ? opt.defaultMainType : null;
  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }
  queryOptionMap.each(function(queryOption, mainType) {
    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + "Models"] = queryResult.models;
    result[mainType + "Model"] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  var finder;
  if (isString$2(finderInput)) {
    var obj = {};
    obj[finderInput + "Index"] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }
  var queryOptionMap = createHashMap();
  var others = {};
  var mainTypeSpecified = false;
  each$e(finder, function(value, key2) {
    if (key2 === "dataIndex" || key2 === "dataIndexInside") {
      others[key2] = value;
      return;
    }
    var parsedKey = key2.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    mainTypeSpecified = mainTypeSpecified || !!mainType;
    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value;
  });
  return {
    mainTypeSpecified,
    queryOptionMap,
    others
  };
}
var SINGLE_REFERRING = {
  useDefault: true,
  enableAll: false,
  enableNone: false
};
var MULTIPLE_REFERRING = {
  useDefault: false,
  enableAll: true,
  enableNone: true
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  var indexOption = userOption.index;
  var idOption = userOption.id;
  var nameOption = userOption.name;
  var result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };
  if (!result.specified) {
    var firstCmpt = void 0;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }
  if (indexOption === "none" || indexOption === false) {
    assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
    result.models = [];
    return result;
  }
  if (indexOption === "all") {
    assert(opt.enableAll, '`"all"` is not a valid value on index option.');
    indexOption = idOption = nameOption = null;
  }
  result.models = ecModel.queryComponents({
    mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key2, value) {
  dom.setAttribute ? dom.setAttribute(key2, value) : dom[key2] = value;
}
function getAttribute(dom, key2) {
  return dom.getAttribute ? dom.getAttribute(key2) : dom[key2];
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === "auto") {
    return env$1.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
  var isAutoPrecision = precision == null || precision === "auto";
  if (targetValue == null) {
    return targetValue;
  }
  if (isNumber$1(targetValue)) {
    var value = interpolateNumber(sourceValue || 0, targetValue, percent);
    return round$4(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString$2(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    var interpolated = [];
    var leftArr = sourceValue;
    var rightArr = targetValue;
    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
    for (var i = 0; i < length_1; ++i) {
      var info = data.getDimensionInfo(i);
      if (info && info.type === "ordinal") {
        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
      } else {
        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
        var rightVal = rightArr[i];
        var value = interpolateNumber(leftVal, rightVal, percent);
        interpolated[i] = round$4(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }
    return interpolated;
  }
}
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(componentType) {
  var ret = {
    main: "",
    sub: ""
  };
  if (componentType) {
    var typeArr = componentType.split(TYPE_DELIMITER);
    ret.main = typeArr[0] || "";
    ret.sub = typeArr[1] || "";
  }
  return ret;
}
function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz;
  rootClz.extend = function(proto2) {
    var superClass = this;
    var ExtendedClass;
    if (isESClass(superClass)) {
      ExtendedClass = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          return _super.apply(this, arguments) || this;
        }
        return class_1;
      }(superClass);
    } else {
      ExtendedClass = function() {
        (proto2.$constructor || superClass).apply(this, arguments);
      };
      inherits(ExtendedClass, this);
    }
    extend$3(ExtendedClass.prototype, proto2);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
function isESClass(fn2) {
  return isFunction$2(fn2) && /^class\s/.test(Function.prototype.toString.call(fn2));
}
function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(target) {
  var classAttr = ["__\0is_clz", classBase++].join("_");
  target.prototype[classAttr] = true;
  target.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement(target) {
  var storage2 = {};
  target.registerClass = function(clz) {
    var componentFullType = clz.type || clz.prototype.type;
    if (componentFullType) {
      checkClassType(componentFullType);
      clz.prototype.type = componentFullType;
      var componentTypeInfo = parseClassType(componentFullType);
      if (!componentTypeInfo.sub) {
        storage2[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        var container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }
    return clz;
  };
  target.getClass = function(mainType, subType, throwWhenNotFound) {
    var clz = storage2[mainType];
    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }
    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
    }
    return clz;
  };
  target.getClassesByMainType = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var result = [];
    var obj = storage2[componentTypeInfo.main];
    if (obj && obj[IS_CONTAINER]) {
      each$e(obj, function(o2, type) {
        type !== IS_CONTAINER && result.push(o2);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  target.hasClass = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    return !!storage2[componentTypeInfo.main];
  };
  target.getAllClassMainTypes = function() {
    var types = [];
    each$e(storage2, function(obj, type) {
      types.push(type);
    });
    return types;
  };
  target.hasSubTypes = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var obj = storage2[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };
  function makeContainer(componentTypeInfo) {
    var container = storage2[componentTypeInfo.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage2[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
}
function makeStyleMapper(properties, ignoreParent) {
  for (var i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }
  ignoreParent = ignoreParent || false;
  return function(model, excludes, includes) {
    var style = {};
    for (var i2 = 0; i2 < properties.length; i2++) {
      var propName = properties[i2][1];
      if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
        continue;
      }
      var val = model.getShallow(propName, ignoreParent);
      if (val != null) {
        style[properties[i2][0]] = val;
      }
    }
    return style;
  };
}
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = function() {
  function AreaStyleMixin2() {
  }
  AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  };
  return AreaStyleMixin2;
}();
var globalImageCache = new LRU$1(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === "string") {
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    }
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = { hostEl, cb: onload, cbPayload };
    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      var image_1 = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
      image_1.__zrImageSrc = newImageOrSrc;
      globalImageCache.put(newImageOrSrc, image_1.__cachedImgObj = {
        image: image_1,
        pending: [pendingWrap]
      });
    }
    return image;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
  return image && image.width && image.height;
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text2, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return "";
  }
  var textLines = (text2 + "").split("\n");
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  for (var i = 0, len2 = textLines.length; i < len2; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }
  return textLines.join("\n");
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = options || {};
  var preparedOpts = extend$3({}, options);
  preparedOpts.font = font;
  ellipsis = retrieve2(ellipsis, "...");
  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
  preparedOpts.cnCharWidth = getWidth("\u56FD", font);
  var ascCharWidth = preparedOpts.ascCharWidth = getWidth("a", font);
  preparedOpts.placeholder = retrieve2(options.placeholder, "");
  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }
  var ellipsisWidth = getWidth(ellipsis, font);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  preparedOpts.ellipsis = ellipsis;
  preparedOpts.ellipsisWidth = ellipsisWidth;
  preparedOpts.contentWidth = contentWidth;
  preparedOpts.containerWidth = containerWidth;
  return preparedOpts;
}
function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;
  if (!containerWidth) {
    return "";
  }
  var lineWidth = getWidth(textLine, font);
  if (lineWidth <= containerWidth) {
    return textLine;
  }
  for (var j = 0; ; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  return textLine;
}
function estimateLength(text2, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;
  for (var len2 = text2.length; i < len2 && width < contentWidth; i++) {
    var charCode = text2.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }
  return i;
}
function parsePlainText(text2, style) {
  text2 != null && (text2 += "");
  var overflow = style.overflow;
  var padding = style.padding;
  var font = style.font;
  var truncate = overflow === "truncate";
  var calculatedLineHeight = getLineHeight(font);
  var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
  var bgColorDrawn = !!style.backgroundColor;
  var truncateLineOverflow = style.lineOverflow === "truncate";
  var width = style.width;
  var lines;
  if (width != null && (overflow === "break" || overflow === "breakAll")) {
    lines = text2 ? wrapText(text2, style.font, width, overflow === "breakAll", 0).lines : [];
  } else {
    lines = text2 ? text2.split("\n") : [];
  }
  var contentHeight = lines.length * lineHeight;
  var height = retrieve2(style.height, contentHeight);
  if (contentHeight > height && truncateLineOverflow) {
    var lineCount = Math.floor(height / lineHeight);
    lines = lines.slice(0, lineCount);
  }
  if (text2 && truncate && width != null) {
    var options = prepareTruncateOptions(width, font, style.ellipsis, {
      minChar: style.truncateMinChar,
      placeholder: style.placeholder
    });
    for (var i = 0; i < lines.length; i++) {
      lines[i] = truncateSingleLine(lines[i], options);
    }
  }
  var outerHeight2 = height;
  var contentWidth = 0;
  for (var i = 0; i < lines.length; i++) {
    contentWidth = Math.max(getWidth(lines[i], font), contentWidth);
  }
  if (width == null) {
    width = contentWidth;
  }
  var outerWidth2 = contentWidth;
  if (padding) {
    outerHeight2 += padding[0] + padding[2];
    outerWidth2 += padding[1] + padding[3];
    width += padding[1] + padding[3];
  }
  if (bgColorDrawn) {
    outerWidth2 = width;
  }
  return {
    lines,
    height,
    outerWidth: outerWidth2,
    outerHeight: outerHeight2,
    lineHeight,
    calculatedLineHeight,
    contentWidth,
    contentHeight,
    width
  };
}
var RichTextToken = function() {
  function RichTextToken2() {
  }
  return RichTextToken2;
}();
var RichTextLine = function() {
  function RichTextLine2(tokens) {
    this.tokens = [];
    if (tokens) {
      this.tokens = tokens;
    }
  }
  return RichTextLine2;
}();
var RichTextContentBlock = function() {
  function RichTextContentBlock2() {
    this.width = 0;
    this.height = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.outerWidth = 0;
    this.outerHeight = 0;
    this.lines = [];
  }
  return RichTextContentBlock2;
}();
function parseRichText(text2, style) {
  var contentBlock = new RichTextContentBlock();
  text2 != null && (text2 += "");
  if (!text2) {
    return contentBlock;
  }
  var topWidth = style.width;
  var topHeight = style.height;
  var overflow = style.overflow;
  var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;
  while ((result = STYLE_REG.exec(text2)) != null) {
    var matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text2.substring(lastIndex, matchedIndex), style, wrapInfo);
    }
    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text2.length) {
    pushTokens(contentBlock, text2.substring(lastIndex, text2.length), style, wrapInfo);
  }
  var pendingList = [];
  var calculatedHeight = 0;
  var calculatedWidth = 0;
  var stlPadding = style.padding;
  var truncate = overflow === "truncate";
  var truncateLine = style.lineOverflow === "truncate";
  function finishLine(line2, lineWidth2, lineHeight2) {
    line2.width = lineWidth2;
    line2.lineHeight = lineHeight2;
    calculatedHeight += lineHeight2;
    calculatedWidth = Math.max(calculatedWidth, lineWidth2);
  }
  outer:
    for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var lineHeight = 0;
      var lineWidth = 0;
      for (var j = 0; j < line.tokens.length; j++) {
        var token = line.tokens[j];
        var tokenStyle = token.styleName && style.rich[token.styleName] || {};
        var textPadding = token.textPadding = tokenStyle.padding;
        var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        var font = token.font = tokenStyle.font || style.font;
        token.contentHeight = getLineHeight(font);
        var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
        token.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token.align = tokenStyle && tokenStyle.align || style.align;
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          if (j > 0) {
            line.tokens = line.tokens.slice(0, j);
            finishLine(line, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i);
          }
          break outer;
        }
        var styleTokenWidth = tokenStyle.width;
        var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token.percentWidth = styleTokenWidth;
          pendingList.push(token);
          token.contentWidth = getWidth(token.text, font);
        } else {
          if (tokenWidthNotSpecified) {
            var textBackgroundColor = tokenStyle.backgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = "";
              token.width = token.contentWidth = 0;
            } else {
              token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
              token.width = token.contentWidth = getWidth(token.text, font);
            }
          } else {
            token.contentWidth = getWidth(token.text, font);
          }
        }
        token.width += paddingH;
        lineWidth += token.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }
      finishLine(line, lineWidth, lineHeight);
    }
  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
  contentBlock.contentHeight = calculatedHeight;
  contentBlock.contentWidth = calculatedWidth;
  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }
  for (var i = 0; i < pendingList.length; i++) {
    var token = pendingList[i];
    var percentWidth = token.percentWidth;
    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
  }
  return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
  var isEmptyStr = str === "";
  var tokenStyle = styleName && style.rich[styleName] || {};
  var lines = block.lines;
  var font = tokenStyle.font || style.font;
  var newLine = false;
  var strLines;
  var linesWidths;
  if (wrapInfo) {
    var tokenPadding = tokenStyle.padding;
    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
    if (tokenStyle.width != null && tokenStyle.width !== "auto") {
      var outerWidth_1 = parsePercent$1(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
      if (lines.length > 0) {
        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
          strLines = str.split("\n");
          newLine = true;
        }
      }
      wrapInfo.accumWidth = outerWidth_1;
    } else {
      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
      linesWidths = res.linesWidths;
      strLines = res.lines;
    }
  } else {
    strLines = str.split("\n");
  }
  for (var i = 0; i < strLines.length; i++) {
    var text2 = strLines[i];
    var token = new RichTextToken();
    token.styleName = styleName;
    token.text = text2;
    token.isLineHolder = !text2 && !isEmptyStr;
    if (typeof tokenStyle.width === "number") {
      token.width = tokenStyle.width;
    } else {
      token.width = linesWidths ? linesWidths[i] : getWidth(text2, font);
    }
    if (!i && !newLine) {
      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text2 || !tokensLen || isEmptyStr) && tokens.push(token);
    } else {
      lines.push(new RichTextLine([token]));
    }
  }
}
function isLatin(ch) {
  var code = ch.charCodeAt(0);
  return code >= 33 && code <= 383;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
  obj[ch] = true;
  return obj;
}, {});
function isWordBreakChar(ch) {
  if (isLatin(ch)) {
    if (breakCharMap[ch]) {
      return true;
    }
    return false;
  }
  return true;
}
function wrapText(text2, font, lineWidth, isBreakAll, lastAccumWidth) {
  var lines = [];
  var linesWidths = [];
  var line = "";
  var currentWord = "";
  var currentWordWidth = 0;
  var accumWidth = 0;
  for (var i = 0; i < text2.length; i++) {
    var ch = text2.charAt(i);
    if (ch === "\n") {
      if (currentWord) {
        line += currentWord;
        accumWidth += currentWordWidth;
      }
      lines.push(line);
      linesWidths.push(accumWidth);
      line = "";
      currentWord = "";
      currentWordWidth = 0;
      accumWidth = 0;
      continue;
    }
    var chWidth = getWidth(ch, font);
    var inWord = isBreakAll ? false : !isWordBreakChar(ch);
    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
      if (!accumWidth) {
        if (inWord) {
          lines.push(currentWord);
          linesWidths.push(currentWordWidth);
          currentWord = ch;
          currentWordWidth = chWidth;
        } else {
          lines.push(ch);
          linesWidths.push(chWidth);
        }
      } else if (line || currentWord) {
        if (inWord) {
          if (!line) {
            line = currentWord;
            currentWord = "";
            currentWordWidth = 0;
            accumWidth = currentWordWidth;
          }
          lines.push(line);
          linesWidths.push(accumWidth - currentWordWidth);
          currentWord += ch;
          currentWordWidth += chWidth;
          line = "";
          accumWidth = currentWordWidth;
        } else {
          if (currentWord) {
            line += currentWord;
            currentWord = "";
            currentWordWidth = 0;
          }
          lines.push(line);
          linesWidths.push(accumWidth);
          line = ch;
          accumWidth = chWidth;
        }
      }
      continue;
    }
    accumWidth += chWidth;
    if (inWord) {
      currentWord += ch;
      currentWordWidth += chWidth;
    } else {
      if (currentWord) {
        line += currentWord;
        currentWord = "";
        currentWordWidth = 0;
      }
      line += ch;
    }
  }
  if (!lines.length && !line) {
    line = text2;
    currentWord = "";
    currentWordWidth = 0;
  }
  if (currentWord) {
    line += currentWord;
  }
  if (line) {
    lines.push(line);
    linesWidths.push(accumWidth);
  }
  if (lines.length === 1) {
    accumWidth += lastAccumWidth;
  }
  return {
    accumWidth,
    lines,
    linesWidths
  };
}
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: true,
    shadowOffsetX: true,
    shadowOffsetY: true,
    shadowColor: true,
    opacity: true
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable = function(_super) {
  __extends(Displayable2, _super);
  function Displayable2(props2) {
    return _super.call(this, props2) || this;
  }
  Displayable2.prototype._init = function(props2) {
    var keysArr = keys$1(props2);
    for (var i = 0; i < keysArr.length; i++) {
      var key2 = keysArr[i];
      if (key2 === "style") {
        this.useStyle(props2[key2]);
      } else {
        _super.prototype.attrKV.call(this, key2, props2[key2]);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Displayable2.prototype.beforeBrush = function() {
  };
  Displayable2.prototype.afterBrush = function() {
  };
  Displayable2.prototype.innerBeforeBrush = function() {
  };
  Displayable2.prototype.innerAfterBrush = function() {
  };
  Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
    var m2 = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
      return false;
    }
    if (considerClipPath && this.__clipPaths) {
      for (var i = 0; i < this.__clipPaths.length; ++i) {
        if (this.__clipPaths[i].isZeroArea()) {
          return false;
        }
      }
    }
    if (considerAncestors && this.parent) {
      var parent_1 = this.parent;
      while (parent_1) {
        if (parent_1.ignore) {
          return false;
        }
        parent_1 = parent_1.parent;
      }
    }
    return true;
  };
  Displayable2.prototype.contain = function(x2, y) {
    return this.rectContain(x2, y);
  };
  Displayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  Displayable2.prototype.rectContain = function(x2, y) {
    var coord = this.transformCoordToLocal(x2, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  };
  Displayable2.prototype.getPaintRect = function() {
    var rect = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var transform2 = this.transform;
      var elRect = this.getBoundingRect();
      var style = this.style;
      var shadowSize = style.shadowBlur || 0;
      var shadowOffsetX = style.shadowOffsetX || 0;
      var shadowOffsetY = style.shadowOffsetY || 0;
      rect = this._paintRect || (this._paintRect = new BoundingRect$1(0, 0, 0, 0));
      if (transform2) {
        BoundingRect$1.applyTransform(rect, elRect, transform2);
      } else {
        rect.copy(elRect);
      }
      if (shadowSize || shadowOffsetX || shadowOffsetY) {
        rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
        rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
        rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
        rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
      }
      var tolerance = this.dirtyRectTolerance;
      if (!rect.isZero()) {
        rect.x = Math.floor(rect.x - tolerance);
        rect.y = Math.floor(rect.y - tolerance);
        rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
        rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
      }
    }
    return rect;
  };
  Displayable2.prototype.setPrevPaintRect = function(paintRect) {
    if (paintRect) {
      this._prevPaintRect = this._prevPaintRect || new BoundingRect$1(0, 0, 0, 0);
      this._prevPaintRect.copy(paintRect);
    } else {
      this._prevPaintRect = null;
    }
  };
  Displayable2.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  };
  Displayable2.prototype.animateStyle = function(loop2) {
    return this.animate("style", loop2);
  };
  Displayable2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else {
      this.markRedraw();
    }
  };
  Displayable2.prototype.attrKV = function(key2, value) {
    if (key2 !== "style") {
      _super.prototype.attrKV.call(this, key2, value);
    } else {
      if (!this.style) {
        this.useStyle(value);
      } else {
        this.setStyle(value);
      }
    }
  };
  Displayable2.prototype.setStyle = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.style[keyOrObj] = value;
    } else {
      extend$3(this.style, keyOrObj);
    }
    this.dirtyStyle();
    return this;
  };
  Displayable2.prototype.dirtyStyle = function(notRedraw) {
    if (!notRedraw) {
      this.markRedraw();
    }
    this.__dirty |= STYLE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
  };
  Displayable2.prototype.dirty = function() {
    this.dirtyStyle();
  };
  Displayable2.prototype.styleChanged = function() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  };
  Displayable2.prototype.styleUpdated = function() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  };
  Displayable2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_COMMON_STYLE, obj);
  };
  Displayable2.prototype.useStyle = function(obj) {
    if (!obj[STYLE_MAGIC_KEY]) {
      obj = this.createStyle(obj);
    }
    if (this.__inHover) {
      this.__hoverStyle = obj;
    } else {
      this.style = obj;
    }
    this.dirtyStyle();
  };
  Displayable2.prototype.isStyleObject = function(obj) {
    return obj[STYLE_MAGIC_KEY];
  };
  Displayable2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.style && !normalState.style) {
      normalState.style = this._mergeStyle(this.createStyle(), this.style);
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
  };
  Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition2, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition2, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetStyle;
    if (state && state.style) {
      if (transition2) {
        if (keepCurrentStates) {
          targetStyle = state.style;
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else {
        targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
        this._mergeStyle(targetStyle, state.style);
      }
    } else if (needsRestoreToNormal) {
      targetStyle = normalState.style;
    }
    if (targetStyle) {
      if (transition2) {
        var sourceStyle = this.style;
        this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
        if (needsRestoreToNormal) {
          var changedKeys = keys$1(sourceStyle);
          for (var i = 0; i < changedKeys.length; i++) {
            var key2 = changedKeys[i];
            if (key2 in targetStyle) {
              targetStyle[key2] = targetStyle[key2];
              this.style[key2] = sourceStyle[key2];
            }
          }
        }
        var targetKeys = keys$1(targetStyle);
        for (var i = 0; i < targetKeys.length; i++) {
          var key2 = targetKeys[i];
          this.style[key2] = this.style[key2];
        }
        this._transitionState(stateName, {
          style: targetStyle
        }, animationCfg, this.getAnimationStyleProps());
      } else {
        this.useStyle(targetStyle);
      }
    }
    var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
    for (var i = 0; i < statesKeys.length; i++) {
      var key2 = statesKeys[i];
      if (state && state[key2] != null) {
        this[key2] = state[key2];
      } else if (needsRestoreToNormal) {
        if (normalState[key2] != null) {
          this[key2] = normalState[key2];
        }
      }
    }
  };
  Displayable2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedStyle;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      if (state.style) {
        mergedStyle = mergedStyle || {};
        this._mergeStyle(mergedStyle, state.style);
      }
    }
    if (mergedStyle) {
      mergedState.style = mergedStyle;
    }
    return mergedState;
  };
  Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    extend$3(targetStyle, sourceStyle);
    return targetStyle;
  };
  Displayable2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  };
  Displayable2.initDefaultProps = function() {
    var dispProto = Displayable2.prototype;
    dispProto.type = "displayable";
    dispProto.invisible = false;
    dispProto.z = 0;
    dispProto.z2 = 0;
    dispProto.zlevel = 0;
    dispProto.culling = false;
    dispProto.cursor = "pointer";
    dispProto.rectHover = false;
    dispProto.incremental = false;
    dispProto._rect = null;
    dispProto.dirtyRectTolerance = 0;
    dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
  }();
  return Displayable2;
}(Element$2);
var tmpRect = new BoundingRect$1(0, 0, 0, 0);
var viewRect = new BoundingRect$1(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());
  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }
  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}
var Displayable$1 = Displayable;
var mathMin$8 = Math.min;
var mathMax$8 = Math.max;
var mathSin$4 = Math.sin;
var mathCos$4 = Math.cos;
var PI2$7 = Math.PI * 2;
var start$1 = create$1();
var end$1 = create$1();
var extremity = create$1();
function fromLine(x0, y0, x1, y1, min3, max3) {
  min3[0] = mathMin$8(x0, x1);
  min3[1] = mathMin$8(y0, y1);
  max3[0] = mathMax$8(x0, x1);
  max3[1] = mathMax$8(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
  var cubicExtrema$1 = cubicExtrema;
  var cubicAt$1 = cubicAt;
  var n = cubicExtrema$1(x0, x1, x2, x3, xDim);
  min3[0] = Infinity;
  min3[1] = Infinity;
  max3[0] = -Infinity;
  max3[1] = -Infinity;
  for (var i = 0; i < n; i++) {
    var x4 = cubicAt$1(x0, x1, x2, x3, xDim[i]);
    min3[0] = mathMin$8(x4, min3[0]);
    max3[0] = mathMax$8(x4, max3[0]);
  }
  n = cubicExtrema$1(y0, y1, y2, y3, yDim);
  for (var i = 0; i < n; i++) {
    var y = cubicAt$1(y0, y1, y2, y3, yDim[i]);
    min3[1] = mathMin$8(y, min3[1]);
    max3[1] = mathMax$8(y, max3[1]);
  }
  min3[0] = mathMin$8(x0, min3[0]);
  max3[0] = mathMax$8(x0, max3[0]);
  min3[0] = mathMin$8(x3, min3[0]);
  max3[0] = mathMax$8(x3, max3[0]);
  min3[1] = mathMin$8(y0, min3[1]);
  max3[1] = mathMax$8(y0, max3[1]);
  min3[1] = mathMin$8(y3, min3[1]);
  max3[1] = mathMax$8(y3, max3[1]);
}
function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
  var quadraticExtremum$1 = quadraticExtremum;
  var quadraticAt$1 = quadraticAt;
  var tx = mathMax$8(mathMin$8(quadraticExtremum$1(x0, x1, x2), 1), 0);
  var ty = mathMax$8(mathMin$8(quadraticExtremum$1(y0, y1, y2), 1), 0);
  var x3 = quadraticAt$1(x0, x1, x2, tx);
  var y = quadraticAt$1(y0, y1, y2, ty);
  min3[0] = mathMin$8(x0, x2, x3);
  min3[1] = mathMin$8(y0, y2, y);
  max3[0] = mathMax$8(x0, x2, x3);
  max3[1] = mathMax$8(y0, y2, y);
}
function fromArc(x2, y, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
  var vec2Min = min$2;
  var vec2Max = max$2;
  var diff = Math.abs(startAngle - endAngle);
  if (diff % PI2$7 < 1e-4 && diff > 1e-4) {
    min3[0] = x2 - rx;
    min3[1] = y - ry;
    max3[0] = x2 + rx;
    max3[1] = y + ry;
    return;
  }
  start$1[0] = mathCos$4(startAngle) * rx + x2;
  start$1[1] = mathSin$4(startAngle) * ry + y;
  end$1[0] = mathCos$4(endAngle) * rx + x2;
  end$1[1] = mathSin$4(endAngle) * ry + y;
  vec2Min(min3, start$1, end$1);
  vec2Max(max3, start$1, end$1);
  startAngle = startAngle % PI2$7;
  if (startAngle < 0) {
    startAngle = startAngle + PI2$7;
  }
  endAngle = endAngle % PI2$7;
  if (endAngle < 0) {
    endAngle = endAngle + PI2$7;
  }
  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2$7;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2$7;
  }
  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  }
  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos$4(angle) * rx + x2;
      extremity[1] = mathSin$4(angle) * ry + y;
      vec2Min(min3, extremity, min3);
      vec2Max(max3, extremity, max3);
    }
  }
}
var CMD$2 = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min$1 = [];
var max$1 = [];
var min2 = [];
var max2 = [];
var mathMin$7 = Math.min;
var mathMax$7 = Math.max;
var mathCos$3 = Math.cos;
var mathSin$3 = Math.sin;
var mathAbs$1 = Math.abs;
var PI$7 = Math.PI;
var PI2$6 = PI$7 * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
  var n = Math.round(radian / PI$7 * 1e8) / 1e8;
  return n % 2 * PI$7;
}
function normalizeArcAngles(angles, anticlockwise) {
  var newStartAngle = modPI2(angles[0]);
  if (newStartAngle < 0) {
    newStartAngle += PI2$6;
  }
  var delta = newStartAngle - angles[0];
  var newEndAngle = angles[1];
  newEndAngle += delta;
  if (!anticlockwise && newEndAngle - newStartAngle >= PI2$6) {
    newEndAngle = newStartAngle + PI2$6;
  } else if (anticlockwise && newStartAngle - newEndAngle >= PI2$6) {
    newEndAngle = newStartAngle - PI2$6;
  } else if (!anticlockwise && newStartAngle > newEndAngle) {
    newEndAngle = newStartAngle + (PI2$6 - modPI2(newStartAngle - newEndAngle));
  } else if (anticlockwise && newStartAngle < newEndAngle) {
    newEndAngle = newStartAngle - (PI2$6 - modPI2(newEndAngle - newStartAngle));
  }
  angles[0] = newStartAngle;
  angles[1] = newEndAngle;
}
var PathProxy = function() {
  function PathProxy2(notSaveData) {
    this.dpr = 1;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._len = 0;
    if (notSaveData) {
      this._saveData = false;
    }
    if (this._saveData) {
      this.data = [];
    }
  }
  PathProxy2.prototype.increaseVersion = function() {
    this._version++;
  };
  PathProxy2.prototype.getVersion = function() {
    return this._version;
  };
  PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    if (segmentIgnoreThreshold > 0) {
      this._ux = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
      this._uy = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
    }
  };
  PathProxy2.prototype.setDPR = function(dpr2) {
    this.dpr = dpr2;
  };
  PathProxy2.prototype.setContext = function(ctx) {
    this._ctx = ctx;
  };
  PathProxy2.prototype.getContext = function() {
    return this._ctx;
  };
  PathProxy2.prototype.beginPath = function() {
    this._ctx && this._ctx.beginPath();
    this.reset();
    return this;
  };
  PathProxy2.prototype.reset = function() {
    if (this._saveData) {
      this._len = 0;
    }
    if (this._pathSegLen) {
      this._pathSegLen = null;
      this._pathLen = 0;
    }
    this._version++;
  };
  PathProxy2.prototype.moveTo = function(x2, y) {
    this._drawPendingPt();
    this.addData(CMD$2.M, x2, y);
    this._ctx && this._ctx.moveTo(x2, y);
    this._x0 = x2;
    this._y0 = y;
    this._xi = x2;
    this._yi = y;
    return this;
  };
  PathProxy2.prototype.lineTo = function(x2, y) {
    var dx = mathAbs$1(x2 - this._xi);
    var dy = mathAbs$1(y - this._yi);
    var exceedUnit = dx > this._ux || dy > this._uy;
    this.addData(CMD$2.L, x2, y);
    if (this._ctx && exceedUnit) {
      this._ctx.lineTo(x2, y);
    }
    if (exceedUnit) {
      this._xi = x2;
      this._yi = y;
      this._pendingPtDist = 0;
    } else {
      var d2 = dx * dx + dy * dy;
      if (d2 > this._pendingPtDist) {
        this._pendingPtX = x2;
        this._pendingPtY = y;
        this._pendingPtDist = d2;
      }
    }
    return this;
  };
  PathProxy2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
    this._drawPendingPt();
    this.addData(CMD$2.C, x1, y1, x2, y2, x3, y3);
    if (this._ctx) {
      this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  };
  PathProxy2.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
    this._drawPendingPt();
    this.addData(CMD$2.Q, x1, y1, x2, y2);
    if (this._ctx) {
      this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }
    this._xi = x2;
    this._yi = y2;
    return this;
  };
  PathProxy2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this._drawPendingPt();
    tmpAngles[0] = startAngle;
    tmpAngles[1] = endAngle;
    normalizeArcAngles(tmpAngles, anticlockwise);
    startAngle = tmpAngles[0];
    endAngle = tmpAngles[1];
    var delta = endAngle - startAngle;
    this.addData(CMD$2.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos$3(endAngle) * r + cx;
    this._yi = mathSin$3(endAngle) * r + cy;
    return this;
  };
  PathProxy2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
    this._drawPendingPt();
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }
    return this;
  };
  PathProxy2.prototype.rect = function(x2, y, w2, h2) {
    this._drawPendingPt();
    this._ctx && this._ctx.rect(x2, y, w2, h2);
    this.addData(CMD$2.R, x2, y, w2, h2);
    return this;
  };
  PathProxy2.prototype.closePath = function() {
    this._drawPendingPt();
    this.addData(CMD$2.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;
    if (ctx) {
      ctx.closePath();
    }
    this._xi = x0;
    this._yi = y0;
    return this;
  };
  PathProxy2.prototype.fill = function(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  };
  PathProxy2.prototype.stroke = function(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  };
  PathProxy2.prototype.len = function() {
    return this._len;
  };
  PathProxy2.prototype.setData = function(data) {
    var len2 = data.length;
    if (!(this.data && this.data.length === len2) && hasTypedArray) {
      this.data = new Float32Array(len2);
    }
    for (var i = 0; i < len2; i++) {
      this.data[i] = data[i];
    }
    this._len = len2;
  };
  PathProxy2.prototype.appendPath = function(path) {
    if (!(path instanceof Array)) {
      path = [path];
    }
    var len2 = path.length;
    var appendSize = 0;
    var offset2 = this._len;
    for (var i = 0; i < len2; i++) {
      appendSize += path[i].len();
    }
    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset2 + appendSize);
    }
    for (var i = 0; i < len2; i++) {
      var appendPathData = path[i].data;
      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset2++] = appendPathData[k];
      }
    }
    this._len = offset2;
  };
  PathProxy2.prototype.addData = function(cmd, a2, b2, c, d2, e2, f, g, h2) {
    if (!this._saveData) {
      return;
    }
    var data = this.data;
    if (this._len + arguments.length > data.length) {
      this._expandData();
      data = this.data;
    }
    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }
  };
  PathProxy2.prototype._drawPendingPt = function() {
    if (this._pendingPtDist > 0) {
      this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
      this._pendingPtDist = 0;
    }
  };
  PathProxy2.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      var newData = [];
      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }
  };
  PathProxy2.prototype.toStatic = function() {
    if (!this._saveData) {
      return;
    }
    this._drawPendingPt();
    var data = this.data;
    if (data instanceof Array) {
      data.length = this._len;
      if (hasTypedArray && this._len > 11) {
        this.data = new Float32Array(data);
      }
    }
  };
  PathProxy2.prototype.getBoundingRect = function() {
    min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var i;
    for (i = 0; i < this._len; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD$2.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;
        case CMD$2.L:
          fromLine(xi, yi, data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$2.C:
          fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$2.Q:
          fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$2.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle;
          i += 1;
          var anticlockwise = !data[i++];
          if (isFirst) {
            x0 = mathCos$3(startAngle) * rx + cx;
            y0 = mathSin$3(startAngle) * ry + cy;
          }
          fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi = mathCos$3(endAngle) * rx + cx;
          yi = mathSin$3(endAngle) * ry + cy;
          break;
        case CMD$2.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
          break;
        case CMD$2.Z:
          xi = x0;
          yi = y0;
          break;
      }
      min$2(min$1, min$1, min2);
      max$2(max$1, max$1, max2);
    }
    if (i === 0) {
      min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;
    }
    return new BoundingRect$1(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);
  };
  PathProxy2.prototype._calculateLength = function() {
    var data = this.data;
    var len2 = this._len;
    var ux = this._ux;
    var uy = this._uy;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    if (!this._pathSegLen) {
      this._pathSegLen = [];
    }
    var pathSegLen = this._pathSegLen;
    var pathTotalLen = 0;
    var segCount = 0;
    for (var i = 0; i < len2; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      var l2 = -1;
      switch (cmd) {
        case CMD$2.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          break;
        case CMD$2.L: {
          var x2 = data[i++];
          var y2 = data[i++];
          var dx = x2 - xi;
          var dy = y2 - yi;
          if (mathAbs$1(dx) > ux || mathAbs$1(dy) > uy || i === len2 - 1) {
            l2 = Math.sqrt(dx * dx + dy * dy);
            xi = x2;
            yi = y2;
          }
          break;
        }
        case CMD$2.C: {
          var x1 = data[i++];
          var y1 = data[i++];
          var x2 = data[i++];
          var y2 = data[i++];
          var x3 = data[i++];
          var y3 = data[i++];
          l2 = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
          xi = x3;
          yi = y3;
          break;
        }
        case CMD$2.Q: {
          var x1 = data[i++];
          var y1 = data[i++];
          var x2 = data[i++];
          var y2 = data[i++];
          l2 = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
          xi = x2;
          yi = y2;
          break;
        }
        case CMD$2.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var delta = data[i++];
          var endAngle = delta + startAngle;
          i += 1;
          !data[i++];
          if (isFirst) {
            x0 = mathCos$3(startAngle) * rx + cx;
            y0 = mathSin$3(startAngle) * ry + cy;
          }
          l2 = mathMax$7(rx, ry) * mathMin$7(PI2$6, Math.abs(delta));
          xi = mathCos$3(endAngle) * rx + cx;
          yi = mathSin$3(endAngle) * ry + cy;
          break;
        case CMD$2.R: {
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          l2 = width * 2 + height * 2;
          break;
        }
        case CMD$2.Z: {
          var dx = x0 - xi;
          var dy = y0 - yi;
          l2 = Math.sqrt(dx * dx + dy * dy);
          xi = x0;
          yi = y0;
          break;
        }
      }
      if (l2 >= 0) {
        pathSegLen[segCount++] = l2;
        pathTotalLen += l2;
      }
    }
    this._pathLen = pathTotalLen;
    return pathTotalLen;
  };
  PathProxy2.prototype.rebuildPath = function(ctx, percent) {
    var d2 = this.data;
    var ux = this._ux;
    var uy = this._uy;
    var len2 = this._len;
    var x0;
    var y0;
    var xi;
    var yi;
    var x2;
    var y;
    var drawPart = percent < 1;
    var pathSegLen;
    var pathTotalLen;
    var accumLength = 0;
    var segCount = 0;
    var displayedLength;
    var pendingPtDist = 0;
    var pendingPtX;
    var pendingPtY;
    if (drawPart) {
      if (!this._pathSegLen) {
        this._calculateLength();
      }
      pathSegLen = this._pathSegLen;
      pathTotalLen = this._pathLen;
      displayedLength = percent * pathTotalLen;
      if (!displayedLength) {
        return;
      }
    }
    lo:
      for (var i = 0; i < len2; ) {
        var cmd = d2[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = d2[i];
          yi = d2[i + 1];
          x0 = xi;
          y0 = yi;
        }
        if (cmd !== CMD$2.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD$2.M:
            x0 = xi = d2[i++];
            y0 = yi = d2[i++];
            ctx.moveTo(xi, yi);
            break;
          case CMD$2.L: {
            x2 = d2[i++];
            y = d2[i++];
            var dx = mathAbs$1(x2 - xi);
            var dy = mathAbs$1(y - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l2 = pathSegLen[segCount++];
                if (accumLength + l2 > displayedLength) {
                  var t = (displayedLength - accumLength) / l2;
                  ctx.lineTo(xi * (1 - t) + x2 * t, yi * (1 - t) + y * t);
                  break lo;
                }
                accumLength += l2;
              }
              ctx.lineTo(x2, y);
              xi = x2;
              yi = y;
              pendingPtDist = 0;
            } else {
              var d22 = dx * dx + dy * dy;
              if (d22 > pendingPtDist) {
                pendingPtX = x2;
                pendingPtY = y;
                pendingPtDist = d22;
              }
            }
            break;
          }
          case CMD$2.C: {
            var x1 = d2[i++];
            var y1 = d2[i++];
            var x22 = d2[i++];
            var y2 = d2[i++];
            var x3 = d2[i++];
            var y3 = d2[i++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t = (displayedLength - accumLength) / l2;
                cubicSubdivide(xi, x1, x22, x3, t, tmpOutX);
                cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l2;
            }
            ctx.bezierCurveTo(x1, y1, x22, y2, x3, y3);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD$2.Q: {
            var x1 = d2[i++];
            var y1 = d2[i++];
            var x22 = d2[i++];
            var y2 = d2[i++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t = (displayedLength - accumLength) / l2;
                quadraticSubdivide(xi, x1, x22, t, tmpOutX);
                quadraticSubdivide(yi, y1, y2, t, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l2;
            }
            ctx.quadraticCurveTo(x1, y1, x22, y2);
            xi = x22;
            yi = y2;
            break;
          }
          case CMD$2.A:
            var cx = d2[i++];
            var cy = d2[i++];
            var rx = d2[i++];
            var ry = d2[i++];
            var startAngle = d2[i++];
            var delta = d2[i++];
            var psi = d2[i++];
            var anticlockwise = !d2[i++];
            var r = rx > ry ? rx : ry;
            var isEllipse = mathAbs$1(rx - ry) > 1e-3;
            var endAngle = startAngle + delta;
            var breakBuild = false;
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l2;
                breakBuild = true;
              }
              accumLength += l2;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos$3(startAngle) * rx + cx;
              y0 = mathSin$3(startAngle) * ry + cy;
            }
            xi = mathCos$3(endAngle) * rx + cx;
            yi = mathSin$3(endAngle) * ry + cy;
            break;
          case CMD$2.R:
            x0 = xi = d2[i];
            y0 = yi = d2[i + 1];
            x2 = d2[i++];
            y = d2[i++];
            var width = d2[i++];
            var height = d2[i++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var d_1 = displayedLength - accumLength;
                ctx.moveTo(x2, y);
                ctx.lineTo(x2 + mathMin$7(d_1, width), y);
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + width, y + mathMin$7(d_1, height));
                }
                d_1 -= height;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + mathMax$7(width - d_1, 0), y + height);
                }
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x2, y + mathMax$7(height - d_1, 0));
                }
                break lo;
              }
              accumLength += l2;
            }
            ctx.rect(x2, y, width, height);
            break;
          case CMD$2.Z:
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t = (displayedLength - accumLength) / l2;
                ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
                break lo;
              }
              accumLength += l2;
            }
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
  };
  PathProxy2.prototype.clone = function() {
    var newProxy = new PathProxy2();
    var data = this.data;
    newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
    newProxy._len = this._len;
    return newProxy;
  };
  PathProxy2.CMD = CMD$2;
  PathProxy2.initDefaultProps = function() {
    var proto2 = PathProxy2.prototype;
    proto2._saveData = true;
    proto2._ux = 0;
    proto2._uy = 0;
    proto2._pendingPtDist = 0;
    proto2._version = 0;
  }();
  return PathProxy2;
}();
var PathProxy$1 = PathProxy;
function containStroke$4(x0, y0, x1, y1, lineWidth, x2, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  var _a2 = 0;
  var _b2 = x0;
  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x2 > x0 + _l && x2 > x1 + _l || x2 < x0 - _l && x2 < x1 - _l) {
    return false;
  }
  if (x0 !== x1) {
    _a2 = (y0 - y1) / (x0 - x1);
    _b2 = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x2 - x0) <= _l / 2;
  }
  var tmp = _a2 * x2 - y + _b2;
  var _s = tmp * tmp / (_a2 * _a2 + 1);
  return _s <= _l / 2 * _l / 2;
}
function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x4, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x4 > x0 + _l && x4 > x1 + _l && x4 > x2 + _l && x4 > x3 + _l || x4 < x0 - _l && x4 < x1 - _l && x4 < x2 - _l && x4 < x3 - _l) {
    return false;
  }
  var d2 = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x4, y, null);
  return d2 <= _l / 2;
}
function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x3, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x3 > x0 + _l && x3 > x1 + _l && x3 > x2 + _l || x3 < x0 - _l && x3 < x1 - _l && x3 < x2 - _l) {
    return false;
  }
  var d2 = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x3, y, null);
  return d2 <= _l / 2;
}
var PI2$5 = Math.PI * 2;
function normalizeRadian(angle) {
  angle %= PI2$5;
  if (angle < 0) {
    angle += PI2$5;
  }
  return angle;
}
var PI2$4 = Math.PI * 2;
function containStroke$1(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x2, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  x2 -= cx;
  y -= cy;
  var d2 = Math.sqrt(x2 * x2 + y * y);
  if (d2 - _l > r || d2 + _l < r) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI2$4 < 1e-4) {
    return true;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$4;
  }
  var angle = Math.atan2(y, x2);
  if (angle < 0) {
    angle += PI2$4;
  }
  return angle >= startAngle && angle <= endAngle || angle + PI2$4 >= startAngle && angle + PI2$4 <= endAngle;
}
function windingLine(x0, y0, x1, y1, x2, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  }
  if (y1 === y0) {
    return 0;
  }
  var t = (y - y0) / (y1 - y0);
  var dir3 = y1 < y0 ? 1 : -1;
  if (t === 1 || t === 0) {
    dir3 = y1 < y0 ? 0.5 : -0.5;
  }
  var x_ = t * (x1 - x0) + x0;
  return x_ === x2 ? Infinity : x_ > x2 ? dir3 : 0;
}
var CMD$1 = PathProxy$1.CMD;
var PI2$3 = Math.PI * 2;
var EPSILON$1 = 1e-4;
function isAroundEqual$1(a2, b2) {
  return Math.abs(a2 - b2) < EPSILON$1;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x4, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }
  var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var w2 = 0;
    var nExtrema = -1;
    var y0_ = void 0;
    var y1_ = void 0;
    for (var i = 0; i < nRoots; i++) {
      var t = roots[i];
      var unit = t === 0 || t === 1 ? 0.5 : 1;
      var x_ = cubicAt(x0, x1, x2, x3, t);
      if (x_ < x4) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t < extrema[0]) {
          w2 += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w2 += y1_ < y0_ ? unit : -unit;
        } else {
          w2 += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t < extrema[0]) {
          w2 += y0_ < y0 ? unit : -unit;
        } else {
          w2 += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w2;
  }
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x3, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }
  var nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var t = quadraticExtremum(y0, y1, y2);
    if (t >= 0 && t <= 1) {
      var w2 = 0;
      var y_ = quadraticAt(y0, y1, y2, t);
      for (var i = 0; i < nRoots; i++) {
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = quadraticAt(x0, x1, x2, roots[i]);
        if (x_ < x3) {
          continue;
        }
        if (roots[i] < t) {
          w2 += y_ < y0 ? unit : -unit;
        } else {
          w2 += y2 < y_ ? unit : -unit;
        }
      }
      return w2;
    } else {
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = quadraticAt(x0, x1, x2, roots[0]);
      if (x_ < x3) {
        return 0;
      }
      return y2 < y0 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x2, y) {
  y -= cy;
  if (y > r || y < -r) {
    return 0;
  }
  var tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  var dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) {
    return 0;
  }
  if (dTheta >= PI2$3 - 1e-4) {
    startAngle = 0;
    endAngle = PI2$3;
    var dir3 = anticlockwise ? 1 : -1;
    if (x2 >= roots[0] + cx && x2 <= roots[1] + cx) {
      return dir3;
    } else {
      return 0;
    }
  }
  if (startAngle > endAngle) {
    var tmp_1 = startAngle;
    startAngle = endAngle;
    endAngle = tmp_1;
  }
  if (startAngle < 0) {
    startAngle += PI2$3;
    endAngle += PI2$3;
  }
  var w2 = 0;
  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];
    if (x_ + cx > x2) {
      var angle = Math.atan2(y, x_);
      var dir3 = anticlockwise ? 1 : -1;
      if (angle < 0) {
        angle = PI2$3 + angle;
      }
      if (angle >= startAngle && angle <= endAngle || angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir3 = -dir3;
        }
        w2 += dir3;
      }
    }
  }
  return w2;
}
function containPath(path, lineWidth, isStroke, x2, y) {
  var data = path.data;
  var len2 = path.len();
  var w2 = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;
  var x1;
  var y1;
  for (var i = 0; i < len2; ) {
    var cmd = data[i++];
    var isFirst = i === 1;
    if (cmd === CMD$1.M && i > 1) {
      if (!isStroke) {
        w2 += windingLine(xi, yi, x0, y0, x2, y);
      }
    }
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    switch (cmd) {
      case CMD$1.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD$1.L:
        if (isStroke) {
          if (containStroke$4(xi, yi, data[i], data[i + 1], lineWidth, x2, y)) {
            return true;
          }
        } else {
          w2 += windingLine(xi, yi, data[i], data[i + 1], x2, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.C:
        if (isStroke) {
          if (containStroke$3(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x2, y)) {
            return true;
          }
        } else {
          w2 += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x2, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.Q:
        if (isStroke) {
          if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x2, y)) {
            return true;
          }
        } else {
          w2 += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x2, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++];
        i += 1;
        var anticlockwise = !!(1 - data[i++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (!isFirst) {
          w2 += windingLine(xi, yi, x1, y1, x2, y);
        } else {
          x0 = x1;
          y0 = y1;
        }
        var _x = (x2 - cx) * ry / rx + cx;
        if (isStroke) {
          if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w2 += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$1.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        x1 = x0 + width;
        y1 = y0 + height;
        if (isStroke) {
          if (containStroke$4(x0, y0, x1, y0, lineWidth, x2, y) || containStroke$4(x1, y0, x1, y1, lineWidth, x2, y) || containStroke$4(x1, y1, x0, y1, lineWidth, x2, y) || containStroke$4(x0, y1, x0, y0, lineWidth, x2, y)) {
            return true;
          }
        } else {
          w2 += windingLine(x1, y0, x1, y1, x2, y);
          w2 += windingLine(x0, y1, x0, y0, x2, y);
        }
        break;
      case CMD$1.Z:
        if (isStroke) {
          if (containStroke$4(xi, yi, x0, y0, lineWidth, x2, y)) {
            return true;
          }
        } else {
          w2 += windingLine(xi, yi, x0, y0, x2, y);
        }
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (!isStroke && !isAroundEqual$1(yi, y0)) {
    w2 += windingLine(xi, yi, x0, y0, x2, y) || 0;
  }
  return w2 !== 0;
}
function contain$2(pathProxy, x2, y) {
  return containPath(pathProxy, 0, false, x2, y);
}
function containStroke(pathProxy, lineWidth, x2, y) {
  return containPath(pathProxy, lineWidth, true, x2, y);
}
var DEFAULT_PATH_STYLE = defaults$1({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: false,
  strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults$1({
    fill: true,
    stroke: true,
    strokePercent: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineDashOffset: true,
    lineWidth: true,
    miterLimit: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]);
var Path = function(_super) {
  __extends(Path2, _super);
  function Path2(opts) {
    return _super.call(this, opts) || this;
  }
  Path2.prototype.update = function() {
    var _this = this;
    _super.prototype.update.call(this);
    var style = this.style;
    if (style.decal) {
      var decalEl = this._decalEl = this._decalEl || new Path2();
      if (decalEl.buildPath === Path2.prototype.buildPath) {
        decalEl.buildPath = function(ctx) {
          _this.buildPath(ctx, _this.shape);
        };
      }
      decalEl.silent = true;
      var decalElStyle = decalEl.style;
      for (var key2 in style) {
        if (decalElStyle[key2] !== style[key2]) {
          decalElStyle[key2] = style[key2];
        }
      }
      decalElStyle.fill = style.fill ? style.decal : null;
      decalElStyle.decal = null;
      decalElStyle.shadowColor = null;
      style.strokeFirst && (decalElStyle.stroke = null);
      for (var i = 0; i < pathCopyParams.length; ++i) {
        decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
      }
      decalEl.__dirty |= REDRAW_BIT;
    } else if (this._decalEl) {
      this._decalEl = null;
    }
  };
  Path2.prototype.getDecalElement = function() {
    return this._decalEl;
  };
  Path2.prototype._init = function(props2) {
    var keysArr = keys$1(props2);
    this.shape = this.getDefaultShape();
    var defaultStyle = this.getDefaultStyle();
    if (defaultStyle) {
      this.useStyle(defaultStyle);
    }
    for (var i = 0; i < keysArr.length; i++) {
      var key2 = keysArr[i];
      var value = props2[key2];
      if (key2 === "style") {
        if (!this.style) {
          this.useStyle(value);
        } else {
          extend$3(this.style, value);
        }
      } else if (key2 === "shape") {
        extend$3(this.shape, value);
      } else {
        _super.prototype.attrKV.call(this, key2, value);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Path2.prototype.getDefaultStyle = function() {
    return null;
  };
  Path2.prototype.getDefaultShape = function() {
    return {};
  };
  Path2.prototype.canBeInsideText = function() {
    return this.hasFill();
  };
  Path2.prototype.getInsideTextFill = function() {
    var pathFill = this.style.fill;
    if (pathFill !== "none") {
      if (isString$2(pathFill)) {
        var fillLum = lum(pathFill, 0);
        if (fillLum > 0.5) {
          return DARK_LABEL_COLOR;
        } else if (fillLum > 0.2) {
          return LIGHTER_LABEL_COLOR;
        }
        return LIGHT_LABEL_COLOR;
      } else if (pathFill) {
        return LIGHT_LABEL_COLOR;
      }
    }
    return DARK_LABEL_COLOR;
  };
  Path2.prototype.getInsideTextStroke = function(textFill) {
    var pathFill = this.style.fill;
    if (isString$2(pathFill)) {
      var zr = this.__zr;
      var isDarkMode2 = !!(zr && zr.isDarkMode());
      var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
      if (isDarkMode2 === isDarkLabel) {
        return pathFill;
      }
    }
  };
  Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {
  };
  Path2.prototype.pathUpdated = function() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  };
  Path2.prototype.getUpdatedPathProxy = function(inBatch) {
    !this.path && this.createPathProxy();
    this.path.beginPath();
    this.buildPath(this.path, this.shape, inBatch);
    return this.path;
  };
  Path2.prototype.createPathProxy = function() {
    this.path = new PathProxy$1(false);
  };
  Path2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  };
  Path2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  Path2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;
    if (needsUpdateRect) {
      var firstInvoke = false;
      if (!this.path) {
        firstInvoke = true;
        this.createPathProxy();
      }
      var path = this.path;
      if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
        this.pathUpdated();
      }
      rect = path.getBoundingRect();
    }
    this._rect = rect;
    if (this.hasStroke() && this.path && this.path.len() > 0) {
      var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectStroke.copy(rect);
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        var w2 = style.lineWidth;
        if (!this.hasFill()) {
          var strokeContainThreshold = this.strokeContainThreshold;
          w2 = Math.max(w2, strokeContainThreshold == null ? 4 : strokeContainThreshold);
        }
        if (lineScale > 1e-10) {
          rectStroke.width += w2 / lineScale;
          rectStroke.height += w2 / lineScale;
          rectStroke.x -= w2 / lineScale / 2;
          rectStroke.y -= w2 / lineScale / 2;
        }
      }
      return rectStroke;
    }
    return rect;
  };
  Path2.prototype.contain = function(x2, y) {
    var localPos = this.transformCoordToLocal(x2, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x2 = localPos[0];
    y = localPos[1];
    if (rect.contain(x2, y)) {
      var pathProxy = this.path;
      if (this.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 1e-10) {
          if (!this.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (containStroke(pathProxy, lineWidth / lineScale, x2, y)) {
            return true;
          }
        }
      }
      if (this.hasFill()) {
        return contain$2(pathProxy, x2, y);
      }
    }
    return false;
  };
  Path2.prototype.dirtyShape = function() {
    this.__dirty |= SHAPE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
    if (this._decalEl) {
      this._decalEl.dirtyShape();
    }
    this.markRedraw();
  };
  Path2.prototype.dirty = function() {
    this.dirtyStyle();
    this.dirtyShape();
  };
  Path2.prototype.animateShape = function(loop2) {
    return this.animate("shape", loop2);
  };
  Path2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else if (targetKey === "shape") {
      this.dirtyShape();
    } else {
      this.markRedraw();
    }
  };
  Path2.prototype.attrKV = function(key2, value) {
    if (key2 === "shape") {
      this.setShape(value);
    } else {
      _super.prototype.attrKV.call(this, key2, value);
    }
  };
  Path2.prototype.setShape = function(keyOrObj, value) {
    var shape = this.shape;
    if (!shape) {
      shape = this.shape = {};
    }
    if (typeof keyOrObj === "string") {
      shape[keyOrObj] = value;
    } else {
      extend$3(shape, keyOrObj);
    }
    this.dirtyShape();
    return this;
  };
  Path2.prototype.shapeChanged = function() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  };
  Path2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_PATH_STYLE, obj);
  };
  Path2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.shape && !normalState.shape) {
      normalState.shape = extend$3({}, this.shape);
    }
  };
  Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition2, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition2, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetShape;
    if (state && state.shape) {
      if (transition2) {
        if (keepCurrentStates) {
          targetShape = state.shape;
        } else {
          targetShape = extend$3({}, normalState.shape);
          extend$3(targetShape, state.shape);
        }
      } else {
        targetShape = extend$3({}, keepCurrentStates ? this.shape : normalState.shape);
        extend$3(targetShape, state.shape);
      }
    } else if (needsRestoreToNormal) {
      targetShape = normalState.shape;
    }
    if (targetShape) {
      if (transition2) {
        this.shape = extend$3({}, this.shape);
        var targetShapePrimaryProps = {};
        var shapeKeys = keys$1(targetShape);
        for (var i = 0; i < shapeKeys.length; i++) {
          var key2 = shapeKeys[i];
          if (typeof targetShape[key2] === "object") {
            this.shape[key2] = targetShape[key2];
          } else {
            targetShapePrimaryProps[key2] = targetShape[key2];
          }
        }
        this._transitionState(stateName, {
          shape: targetShapePrimaryProps
        }, animationCfg);
      } else {
        this.shape = targetShape;
        this.dirtyShape();
      }
    }
  };
  Path2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedShape;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      if (state.shape) {
        mergedShape = mergedShape || {};
        this._mergeStyle(mergedShape, state.shape);
      }
    }
    if (mergedShape) {
      mergedState.shape = mergedShape;
    }
    return mergedState;
  };
  Path2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  };
  Path2.prototype.isZeroArea = function() {
    return false;
  };
  Path2.extend = function(defaultProps2) {
    var Sub = function(_super2) {
      __extends(Sub2, _super2);
      function Sub2(opts) {
        var _this = _super2.call(this, opts) || this;
        defaultProps2.init && defaultProps2.init.call(_this, opts);
        return _this;
      }
      Sub2.prototype.getDefaultStyle = function() {
        return clone$3(defaultProps2.style);
      };
      Sub2.prototype.getDefaultShape = function() {
        return clone$3(defaultProps2.shape);
      };
      return Sub2;
    }(Path2);
    for (var key2 in defaultProps2) {
      if (typeof defaultProps2[key2] === "function") {
        Sub.prototype[key2] = defaultProps2[key2];
      }
    }
    return Sub;
  };
  Path2.initDefaultProps = function() {
    var pathProto = Path2.prototype;
    pathProto.type = "path";
    pathProto.strokeContainThreshold = 5;
    pathProto.segmentIgnoreThreshold = 0;
    pathProto.subPixelOptimize = false;
    pathProto.autoBatch = false;
    pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
  }();
  return Path2;
}(Displayable$1);
var Path$1 = Path;
var DEFAULT_TSPAN_STYLE = defaults$1({
  strokeFirst: true,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan = function(_super) {
  __extends(TSpan2, _super);
  function TSpan2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TSpan2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  };
  TSpan2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  TSpan2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_TSPAN_STYLE, obj);
  };
  TSpan2.prototype.setBoundingRect = function(rect) {
    this._rect = rect;
  };
  TSpan2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      var text2 = style.text;
      text2 != null ? text2 += "" : text2 = "";
      var rect = getBoundingRect(text2, style.font, style.textAlign, style.textBaseline);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (this.hasStroke()) {
        var w2 = style.lineWidth;
        rect.x -= w2 / 2;
        rect.y -= w2 / 2;
        rect.width += w2;
        rect.height += w2;
      }
      this._rect = rect;
    }
    return this._rect;
  };
  TSpan2.initDefaultProps = function() {
    var tspanProto = TSpan2.prototype;
    tspanProto.dirtyRectTolerance = 10;
  }();
  return TSpan2;
}(Displayable$1);
TSpan.prototype.type = "tspan";
var TSpan$1 = TSpan;
var DEFAULT_IMAGE_STYLE = defaults$1({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults$1({
    x: true,
    y: true,
    width: true,
    height: true,
    sx: true,
    sy: true,
    sWidth: true,
    sHeight: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike$1(source) {
  return !!(source && typeof source !== "string" && source.width && source.height);
}
var ZRImage = function(_super) {
  __extends(ZRImage2, _super);
  function ZRImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ZRImage2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_IMAGE_STYLE, obj);
  };
  ZRImage2.prototype._getSize = function(dim) {
    var style = this.style;
    var size = style[dim];
    if (size != null) {
      return size;
    }
    var imageSource = isImageLike$1(style.image) ? style.image : this.__image;
    if (!imageSource) {
      return 0;
    }
    var otherDim = dim === "width" ? "height" : "width";
    var otherDimSize = style[otherDim];
    if (otherDimSize == null) {
      return imageSource[dim];
    } else {
      return imageSource[dim] / imageSource[otherDim] * otherDimSize;
    }
  };
  ZRImage2.prototype.getWidth = function() {
    return this._getSize("width");
  };
  ZRImage2.prototype.getHeight = function() {
    return this._getSize("height");
  };
  ZRImage2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  };
  ZRImage2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect$1(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
    }
    return this._rect;
  };
  return ZRImage2;
}(Displayable$1);
ZRImage.prototype.type = "image";
var ZRImage$1 = ZRImage;
function buildPath$2(ctx, shape) {
  var x2 = shape.x;
  var y = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4;
  if (width < 0) {
    x2 = x2 + width;
    width = -width;
  }
  if (height < 0) {
    y = y + height;
    height = -height;
  }
  if (typeof r === "number") {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }
  var total;
  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }
  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }
  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }
  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }
  ctx.moveTo(x2 + r1, y);
  ctx.lineTo(x2 + width - r2, y);
  r2 !== 0 && ctx.arc(x2 + width - r2, y + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x2 + width, y + height - r3);
  r3 !== 0 && ctx.arc(x2 + width - r3, y + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x2 + r4, y + height);
  r4 !== 0 && ctx.arc(x2 + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x2, y + r1);
  r1 !== 0 && ctx.arc(x2 + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}
var round$3 = Math.round;
function subPixelOptimizeLine$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var x1 = inputShape.x1;
  var x2 = inputShape.x2;
  var y1 = inputShape.y1;
  var y2 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x2;
  outputShape.y1 = y1;
  outputShape.y2 = y2;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  if (round$3(x1 * 2) === round$3(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x1, lineWidth, true);
  }
  if (round$3(y1 * 2) === round$3(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y1, lineWidth, true);
  }
  return outputShape;
}
function subPixelOptimizeRect$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var originX = inputShape.x;
  var originY = inputShape.y;
  var originWidth = inputShape.width;
  var originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
  outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  return outputShape;
}
function subPixelOptimize$1(position2, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position2;
  }
  var doubledPosition = round$3(position2 * 2);
  return (doubledPosition + round$3(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}
var RectShape = function() {
  function RectShape2() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
  return RectShape2;
}();
var subPixelOptimizeOutputShape$1 = {};
var Rect$1 = function(_super) {
  __extends(Rect2, _super);
  function Rect2(opts) {
    return _super.call(this, opts) || this;
  }
  Rect2.prototype.getDefaultShape = function() {
    return new RectShape();
  };
  Rect2.prototype.buildPath = function(ctx, shape) {
    var x2;
    var y;
    var width;
    var height;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
      x2 = optimizedShape.x;
      y = optimizedShape.y;
      width = optimizedShape.width;
      height = optimizedShape.height;
      optimizedShape.r = shape.r;
      shape = optimizedShape;
    } else {
      x2 = shape.x;
      y = shape.y;
      width = shape.width;
      height = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x2, y, width, height);
    } else {
      buildPath$2(ctx, shape);
    }
  };
  Rect2.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  };
  return Rect2;
}(Path$1);
Rect$1.prototype.type = "rect";
var Rect$2 = Rect$1;
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults$1({
    fill: true,
    stroke: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineWidth: true,
    fontSize: true,
    lineHeight: true,
    width: true,
    height: true,
    textShadowColor: true,
    textShadowBlur: true,
    textShadowOffsetX: true,
    textShadowOffsetY: true,
    backgroundColor: true,
    padding: true,
    borderColor: true,
    borderWidth: true,
    borderRadius: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = function(_super) {
  __extends(ZRText2, _super);
  function ZRText2(opts) {
    var _this = _super.call(this) || this;
    _this.type = "text";
    _this._children = [];
    _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
    _this.attr(opts);
    return _this;
  }
  ZRText2.prototype.childrenRef = function() {
    return this._children;
  };
  ZRText2.prototype.update = function() {
    _super.prototype.update.call(this);
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.zlevel = this.zlevel;
      child.z = this.z;
      child.z2 = this.z2;
      child.culling = this.culling;
      child.cursor = this.cursor;
      child.invisible = this.invisible;
    }
  };
  ZRText2.prototype.updateTransform = function() {
    var innerTransformable = this.innerTransformable;
    if (innerTransformable) {
      innerTransformable.updateTransform();
      if (innerTransformable.transform) {
        this.transform = innerTransformable.transform;
      }
    } else {
      _super.prototype.updateTransform.call(this);
    }
  };
  ZRText2.prototype.getLocalTransform = function(m2) {
    var innerTransformable = this.innerTransformable;
    return innerTransformable ? innerTransformable.getLocalTransform(m2) : _super.prototype.getLocalTransform.call(this, m2);
  };
  ZRText2.prototype.getComputedTransform = function() {
    if (this.__hostTarget) {
      this.__hostTarget.getComputedTransform();
      this.__hostTarget.updateInnerText(true);
    }
    return _super.prototype.getComputedTransform.call(this);
  };
  ZRText2.prototype._updateSubTexts = function() {
    this._childCursor = 0;
    normalizeTextStyle(this.style);
    this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
    this._children.length = this._childCursor;
    this.styleUpdated();
  };
  ZRText2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      this._children[i].__zr = zr;
    }
  };
  ZRText2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      this._children[i].__zr = null;
    }
  };
  ZRText2.prototype.getBoundingRect = function() {
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    if (!this._rect) {
      var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
      var children2 = this._children;
      var tmpMat = [];
      var rect = null;
      for (var i = 0; i < children2.length; i++) {
        var child = children2[i];
        var childRect = child.getBoundingRect();
        var transform2 = child.getLocalTransform(tmpMat);
        if (transform2) {
          tmpRect2.copy(childRect);
          tmpRect2.applyTransform(transform2);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      this._rect = rect || tmpRect2;
    }
    return this._rect;
  };
  ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
    this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
  };
  ZRText2.prototype.setTextContent = function(textContent) {
  };
  ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    if (!sourceStyle) {
      return targetStyle;
    }
    var sourceRich = sourceStyle.rich;
    var targetRich = targetStyle.rich || sourceRich && {};
    extend$3(targetStyle, sourceStyle);
    if (sourceRich && targetRich) {
      this._mergeRich(targetRich, sourceRich);
      targetStyle.rich = targetRich;
    } else if (targetRich) {
      targetStyle.rich = targetRich;
    }
    return targetStyle;
  };
  ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
    var richNames = keys$1(sourceRich);
    for (var i = 0; i < richNames.length; i++) {
      var richName = richNames[i];
      targetRich[richName] = targetRich[richName] || {};
      extend$3(targetRich[richName], sourceRich[richName]);
    }
  };
  ZRText2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  };
  ZRText2.prototype._getOrCreateChild = function(Ctor) {
    var child = this._children[this._childCursor];
    if (!child || !(child instanceof Ctor)) {
      child = new Ctor();
    }
    this._children[this._childCursor++] = child;
    child.__zr = this.__zr;
    child.parent = this;
    return child;
  };
  ZRText2.prototype._updatePlainTexts = function() {
    var style = this.style;
    var textFont = style.font || DEFAULT_FONT;
    var textPadding = style.padding;
    var text2 = getStyleText(style);
    var contentBlock = parsePlainText(text2, style);
    var needDrawBg = needDrawBackground(style);
    var bgColorDrawn = !!style.backgroundColor;
    var outerHeight2 = contentBlock.outerHeight;
    var outerWidth2 = contentBlock.outerWidth;
    var contentWidth = contentBlock.contentWidth;
    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;
    var defaultStyle = this._defaultStyle;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.align || defaultStyle.align || "left";
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
    var textX = baseX;
    var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
    if (needDrawBg || textPadding) {
      var boxX = adjustTextX(baseX, outerWidth2, textAlign);
      var boxY = adjustTextY(baseY, outerHeight2, verticalAlign);
      needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth2, outerHeight2);
    }
    textY += lineHeight / 2;
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      if (verticalAlign === "top") {
        textY += textPadding[0];
      } else if (verticalAlign === "bottom") {
        textY -= textPadding[2];
      }
    }
    var defaultLineWidth = 0;
    var useDefaultFill = false;
    var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow2 = style.textShadowBlur > 0;
    var fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
    var calculatedLineHeight = contentBlock.calculatedLineHeight;
    for (var i = 0; i < textLines.length; i++) {
      var el = this._getOrCreateChild(TSpan$1);
      var subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      subElStyle.text = textLines[i];
      subElStyle.x = textX;
      subElStyle.y = textY;
      if (textAlign) {
        subElStyle.textAlign = textAlign;
      }
      subElStyle.textBaseline = "middle";
      subElStyle.opacity = style.opacity;
      subElStyle.strokeFirst = true;
      if (hasShadow2) {
        subElStyle.shadowBlur = style.textShadowBlur || 0;
        subElStyle.shadowColor = style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
      }
      subElStyle.stroke = textStroke;
      subElStyle.fill = textFill;
      if (textStroke) {
        subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
        subElStyle.lineDash = style.lineDash;
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
      }
      subElStyle.font = textFont;
      setSeparateFont(subElStyle, style);
      textY += lineHeight;
      if (fixedBoundingRect) {
        el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
      }
    }
  };
  ZRText2.prototype._updateRichTexts = function() {
    var style = this.style;
    var text2 = getStyleText(style);
    var contentBlock = parseRichText(text2, style);
    var contentWidth = contentBlock.width;
    var outerWidth2 = contentBlock.outerWidth;
    var outerHeight2 = contentBlock.outerHeight;
    var textPadding = style.padding;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var defaultStyle = this._defaultStyle;
    var textAlign = style.align || defaultStyle.align;
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
    var boxX = adjustTextX(baseX, outerWidth2, textAlign);
    var boxY = adjustTextY(baseY, outerHeight2, verticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;
    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }
    var xRight = xLeft + contentWidth;
    if (needDrawBackground(style)) {
      this._renderBackground(style, style, boxX, boxY, outerWidth2, outerHeight2);
    }
    var bgColorDrawn = !!style.backgroundColor;
    for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var tokens = line.tokens;
      var tokenCount = tokens.length;
      var lineHeight = line.lineHeight;
      var remainedWidth = line.width;
      var leftIndex = 0;
      var lineXLeft = xLeft;
      var lineXRight = xRight;
      var rightIndex = tokenCount - 1;
      var token = void 0;
      while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.align || token.align === "left")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
        remainedWidth -= token.width;
        lineXLeft += token.width;
        leftIndex++;
      }
      while (rightIndex >= 0 && (token = tokens[rightIndex], token.align === "right")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
        remainedWidth -= token.width;
        lineXRight -= token.width;
        rightIndex--;
      }
      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
      while (leftIndex <= rightIndex) {
        token = tokens[leftIndex];
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
        lineXLeft += token.width;
        leftIndex++;
      }
      lineTop += lineHeight;
    }
  };
  ZRText2.prototype._placeToken = function(token, style, lineHeight, lineTop, x2, textAlign, parentBgColorDrawn) {
    var tokenStyle = style.rich[token.styleName] || {};
    tokenStyle.text = token.text;
    var verticalAlign = token.verticalAlign;
    var y = lineTop + lineHeight / 2;
    if (verticalAlign === "top") {
      y = lineTop + token.height / 2;
    } else if (verticalAlign === "bottom") {
      y = lineTop + lineHeight - token.height / 2;
    }
    var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
    needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x2 - token.width : textAlign === "center" ? x2 - token.width / 2 : x2, y - token.height / 2, token.width, token.height);
    var bgColorDrawn = !!tokenStyle.backgroundColor;
    var textPadding = token.textPadding;
    if (textPadding) {
      x2 = getTextXForPadding(x2, textAlign, textPadding);
      y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
    }
    var el = this._getOrCreateChild(TSpan$1);
    var subElStyle = el.createStyle();
    el.useStyle(subElStyle);
    var defaultStyle = this._defaultStyle;
    var useDefaultFill = false;
    var defaultLineWidth = 0;
    var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow2 = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
    subElStyle.text = token.text;
    subElStyle.x = x2;
    subElStyle.y = y;
    if (hasShadow2) {
      subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
      subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
      subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
      subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
    }
    subElStyle.textAlign = textAlign;
    subElStyle.textBaseline = "middle";
    subElStyle.font = token.font || DEFAULT_FONT;
    subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
    setSeparateFont(subElStyle, tokenStyle);
    if (textStroke) {
      subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
      subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
      subElStyle.lineDashOffset = style.lineDashOffset || 0;
      subElStyle.stroke = textStroke;
    }
    if (textFill) {
      subElStyle.fill = textFill;
    }
    var textWidth = token.contentWidth;
    var textHeight = token.contentHeight;
    el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
  };
  ZRText2.prototype._renderBackground = function(style, topStyle, x2, y, width, height) {
    var textBackgroundColor = style.backgroundColor;
    var textBorderWidth = style.borderWidth;
    var textBorderColor = style.borderColor;
    var isImageBg = textBackgroundColor && textBackgroundColor.image;
    var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
    var textBorderRadius = style.borderRadius;
    var self2 = this;
    var rectEl;
    var imgEl;
    if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
      rectEl = this._getOrCreateChild(Rect$2);
      rectEl.useStyle(rectEl.createStyle());
      rectEl.style.fill = null;
      var rectShape = rectEl.shape;
      rectShape.x = x2;
      rectShape.y = y;
      rectShape.width = width;
      rectShape.height = height;
      rectShape.r = textBorderRadius;
      rectEl.dirtyShape();
    }
    if (isPlainOrGradientBg) {
      var rectStyle = rectEl.style;
      rectStyle.fill = textBackgroundColor || null;
      rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
    } else if (isImageBg) {
      imgEl = this._getOrCreateChild(ZRImage$1);
      imgEl.onload = function() {
        self2.dirtyStyle();
      };
      var imgStyle = imgEl.style;
      imgStyle.image = textBackgroundColor.image;
      imgStyle.x = x2;
      imgStyle.y = y;
      imgStyle.width = width;
      imgStyle.height = height;
    }
    if (textBorderWidth && textBorderColor) {
      var rectStyle = rectEl.style;
      rectStyle.lineWidth = textBorderWidth;
      rectStyle.stroke = textBorderColor;
      rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
      rectStyle.lineDash = style.borderDash;
      rectStyle.lineDashOffset = style.borderDashOffset || 0;
      rectEl.strokeContainThreshold = 0;
      if (rectEl.hasFill() && rectEl.hasStroke()) {
        rectStyle.strokeFirst = true;
        rectStyle.lineWidth *= 2;
      }
    }
    var commonStyle = (rectEl || imgEl).style;
    commonStyle.shadowBlur = style.shadowBlur || 0;
    commonStyle.shadowColor = style.shadowColor || "transparent";
    commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
    commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
    commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
  };
  ZRText2.makeFont = function(style) {
    var font = "";
    if (hasSeparateFont(style)) {
      font = [
        style.fontStyle,
        style.fontWeight,
        parseFontSize(style.fontSize),
        style.fontFamily || "sans-serif"
      ].join(" ");
    }
    return font && trim$1(font) || style.textFont || style.font;
  };
  return ZRText2;
}(Displayable$1);
var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(fontSize) {
  if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
    return fontSize;
  } else if (!isNaN(+fontSize)) {
    return fontSize + "px";
  } else {
    return DEFAULT_FONT_SIZE + "px";
  }
}
function setSeparateFont(targetStyle, sourceStyle) {
  for (var i = 0; i < FONT_PARTS.length; i++) {
    var fontProp = FONT_PARTS[i];
    var val = sourceStyle[fontProp];
    if (val != null) {
      targetStyle[fontProp] = val;
    }
  }
}
function hasSeparateFont(style) {
  return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each$e(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = ZRText.makeFont(style);
    var textAlign = style.align;
    textAlign === "middle" && (textAlign = "center");
    style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    var verticalAlign = style.verticalAlign;
    verticalAlign === "center" && (verticalAlign = "middle");
    style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
    var textPadding = style.padding;
    if (textPadding) {
      style.padding = normalizeCssArray$1(style.padding);
    }
  }
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x2, textAlign, textPadding) {
  return textAlign === "right" ? x2 - textPadding[1] : textAlign === "center" ? x2 + textPadding[3] / 2 - textPadding[1] / 2 : x2 + textPadding[3];
}
function getStyleText(style) {
  var text2 = style.text;
  text2 != null && (text2 += "");
  return text2;
}
function needDrawBackground(style) {
  return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var ZRText$1 = ZRText;
var getECData = makeInner();
var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
  if (el) {
    var ecData = getECData(el);
    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex;
    if (el.type === "group") {
      el.traverse(function(child) {
        var childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
      });
    }
  }
};
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ["emphasis", "blur", "select"];
var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
var liftedColorCache = new LRU$1(100);
function liftColor(color$1) {
  if (isString$2(color$1)) {
    var liftedColor = liftedColorCache.get(color$1);
    if (!liftedColor) {
      liftedColor = lift(color$1, -0.1);
      liftedColorCache.put(color$1, liftedColor);
    }
    return liftedColor;
  } else if (isGradientObject(color$1)) {
    var ret = extend$3({}, color$1);
    ret.colorStops = map$1(color$1.colorStops, function(stop2) {
      return {
        offset: stop2.offset,
        color: lift(stop2.color, -0.1)
      };
    });
    return ret;
  }
  return color$1;
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
    el.onHoverStateChange(stateName);
  }
  el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
  doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
  if (el.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterBlur(el) {
  doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
  if (el.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterSelect(el) {
  el.selected = true;
}
function singleLeaveSelect(el) {
  el.selected = false;
}
function updateElementState(el, updater, commonParam) {
  updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
  updateElementState(el, updater, commonParam);
  el.isGroup && el.traverse(function(child) {
    updateElementState(child, updater, commonParam);
  });
}
function setStatesFlag(el, stateName) {
  switch (stateName) {
    case "emphasis":
      el.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      el.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      el.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      el.selected = true;
  }
}
function getFromStateStyle(el, props2, toStateName, defaultValue) {
  var style = el.style;
  var fromState = {};
  for (var i = 0; i < props2.length; i++) {
    var propName = props2[i];
    var val = style[propName];
    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
  }
  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];
    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
      animator.saveTo(fromState, props2);
    }
  }
  return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
  var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
  var cloned = false;
  if (el instanceof Path$1) {
    var store = getSavedStates(el);
    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      var emphasisStyle = state.style || {};
      if (emphasisStyle.fill === "inherit") {
        cloned = true;
        state = extend$3({}, state);
        emphasisStyle = extend$3({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
        cloned = true;
        state = extend$3({}, state);
        emphasisStyle = extend$3({}, emphasisStyle);
        emphasisStyle.fill = liftColor(fromFill);
      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
        if (!cloned) {
          state = extend$3({}, state);
          emphasisStyle = extend$3({}, emphasisStyle);
        }
        emphasisStyle.stroke = liftColor(fromStroke);
      }
      state.style = emphasisStyle;
    }
  }
  if (state) {
    if (state.z2 == null) {
      if (!cloned) {
        state = extend$3({}, state);
      }
      var z2EmphasisLift = el.z2EmphasisLift;
      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }
  return state;
}
function createSelectDefaultState(el, stateName, state) {
  if (state) {
    if (state.z2 == null) {
      state = extend$3({}, state);
      var z2SelectLift = el.z2SelectLift;
      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }
  return state;
}
function createBlurDefaultState(el, stateName, state) {
  var hasBlur = indexOf(el.currentStates, stateName) >= 0;
  var currentOpacity = el.style.opacity;
  var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  var blurStyle = state.style || {};
  if (blurStyle.opacity == null) {
    state = extend$3({}, state);
    blurStyle = extend$3({
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }
  return state;
}
function elementStateProxy(stateName, targetStates) {
  var state = this.states[stateName];
  if (this.style) {
    if (stateName === "emphasis") {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === "blur") {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === "select") {
      return createSelectDefaultState(this, stateName, state);
    }
  }
  return state;
}
function setDefaultStateProxy(el) {
  el.stateProxy = elementStateProxy;
  var textContent = el.getTextContent();
  var textGuide = el.getTextGuideLine();
  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }
  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
  el.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
  traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
  traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
  traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
  traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e2) {
  return el.__highDownSilentOnTouch && e2.zrByTouch;
}
function allLeaveBlur(api) {
  var model = api.getModel();
  var leaveBlurredSeries = [];
  var allComponentViews = [];
  model.eachComponent(function(componentType, componentModel) {
    var componentStates = getComponentStates(componentModel);
    var isSeries2 = componentType === "series";
    var view2 = isSeries2 ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
    !isSeries2 && allComponentViews.push(view2);
    if (componentStates.isBlured) {
      view2.group.traverse(function(child) {
        singleLeaveBlur(child);
      });
      isSeries2 && leaveBlurredSeries.push(componentModel);
    }
    componentStates.isBlured = false;
  });
  each$e(allComponentViews, function(view2) {
    if (view2 && view2.toggleBlurSeries) {
      view2.toggleBlurSeries(leaveBlurredSeries, false, model);
    }
  });
}
function blurSeries(targetSeriesIndex, focus, blurScope, api) {
  var ecModel = api.getModel();
  blurScope = blurScope || "coordinateSystem";
  function leaveBlurOfIndices(data, dataIndices) {
    for (var i = 0; i < dataIndices.length; i++) {
      var itemEl = data.getItemGraphicEl(dataIndices[i]);
      itemEl && leaveBlur(itemEl);
    }
  }
  if (targetSeriesIndex == null) {
    return;
  }
  if (!focus || focus === "none") {
    return;
  }
  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  var targetCoordSys = targetSeriesModel.coordinateSystem;
  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }
  var blurredSeries = [];
  ecModel.eachSeries(function(seriesModel) {
    var sameSeries = targetSeriesModel === seriesModel;
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }
    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
    if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
      var view2 = api.getViewOfSeriesModel(seriesModel);
      view2.group.traverse(function(child) {
        singleEnterBlur(child);
      });
      if (isArrayLike$1(focus)) {
        leaveBlurOfIndices(seriesModel.getData(), focus);
      } else if (isObject$9(focus)) {
        var dataTypes = keys$1(focus);
        for (var d2 = 0; d2 < dataTypes.length; d2++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d2]), focus[dataTypes[d2]]);
        }
      }
      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType === "series") {
      return;
    }
    var view2 = api.getViewOfComponentModel(componentModel);
    if (view2 && view2.toggleBlurSeries) {
      view2.toggleBlurSeries(blurredSeries, true, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return;
  }
  getComponentStates(componentModel).isBlured = true;
  var view2 = api.getViewOfComponentModel(componentModel);
  if (!view2 || !view2.focusBlurEnabled) {
    return;
  }
  view2.group.traverse(function(child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
  var seriesIndex = seriesModel.seriesIndex;
  var data = seriesModel.getData(payload.dataType);
  if (!data) {
    return;
  }
  var dataIndex = queryDataIndex(data, payload);
  dataIndex = (isArray$4(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  var el = data.getItemGraphicEl(dataIndex);
  if (!el) {
    var count2 = data.count();
    var current = 0;
    while (!el && current < count2) {
      el = data.getItemGraphicEl(current++);
    }
  }
  if (el) {
    var ecData = getECData(el);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
  } else {
    var focus_1 = seriesModel.get(["emphasis", "focus"]);
    var blurScope = seriesModel.get(["emphasis", "blurScope"]);
    if (focus_1 != null) {
      blurSeries(seriesIndex, focus_1, blurScope, api);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
  var ret = {
    focusSelf: false,
    dispatchers: null
  };
  if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
    return ret;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return ret;
  }
  var view2 = api.getViewOfComponentModel(componentModel);
  if (!view2 || !view2.findHighDownDispatchers) {
    return ret;
  }
  var dispatchers = view2.findHighDownDispatchers(name);
  var focusSelf;
  for (var i = 0; i < dispatchers.length; i++) {
    if (getECData(dispatchers[i]).focus === "self") {
      focusSelf = true;
      break;
    }
  }
  return {
    focusSelf,
    dispatchers
  };
}
function handleGlobalMouseOverForHighDown(dispatcher, e2, api) {
  var ecData = getECData(dispatcher);
  var _a2 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a2.dispatchers, focusSelf = _a2.focusSelf;
  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    each$e(dispatchers, function(dispatcher2) {
      return enterEmphasisWhenMouseOver(dispatcher2, e2);
    });
  } else {
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
    if (ecData.focus === "self") {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    enterEmphasisWhenMouseOver(dispatcher, e2);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e2, api) {
  allLeaveBlur(api);
  var ecData = getECData(dispatcher);
  var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
  if (dispatchers) {
    each$e(dispatchers, function(dispatcher2) {
      return leaveEmphasisWhenMouseOut(dispatcher2, e2);
    });
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e2);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
  if (!isSelectChangePayload(payload)) {
    return;
  }
  var dataType = payload.dataType;
  var data = seriesModel.getData(dataType);
  var dataIndex = queryDataIndex(data, payload);
  if (!isArray$4(dataIndex)) {
    dataIndex = [dataIndex];
  }
  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  var allData = seriesModel.getAllData();
  each$e(allData, function(_a2) {
    var data = _a2.data, type = _a2.type;
    data.eachItemGraphicEl(function(el, idx) {
      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  var ret = [];
  ecModel.eachSeries(function(seriesModel) {
    var allData = seriesModel.getAllData();
    each$e(allData, function(_a2) {
      _a2.data;
      var type = _a2.type;
      var dataIndices = seriesModel.getSelectedDataIndices();
      if (dataIndices.length > 0) {
        var item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };
        if (type != null) {
          item.dataType = type;
        }
        ret.push(item);
      }
    });
  });
  return ret;
}
function enableHoverEmphasis(el, focus, blurScope) {
  setAsHighDownDispatcher(el, true);
  traverseUpdateState(el, setDefaultStateProxy);
  enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
  setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
  var ecData = getECData(el);
  if (focus != null) {
    ecData.focus = focus;
    ecData.blurScope = blurScope;
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ["emphasis", "blur", "select"];
var defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
  styleType = styleType || "itemStyle";
  for (var i = 0; i < OTHER_STATES.length; i++) {
    var stateName = OTHER_STATES[i];
    var model = itemModel.getModel([stateName, styleType]);
    var state = el.ensureState(stateName);
    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
function setAsHighDownDispatcher(el, asDispatcher) {
  var disable = asDispatcher === false;
  var extendedEl = el;
  if (el.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  }
  if (!disable || extendedEl.__highDownDispatcher) {
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
  var ecData = getECData(el);
  ecData.componentMainType = componentModel.mainType;
  ecData.componentIndex = componentModel.componentIndex;
  ecData.componentHighDownName = componentHighDownName;
}
function getHighlightDigit(highlightKey) {
  var highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function isSelectChangePayload(payload) {
  var payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  var payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
  var store = getSavedStates(el);
  store.normalFill = el.style.fill;
  store.normalStroke = el.style.stroke;
  var selectState = el.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}
var CMD = PathProxy$1.CMD;
var points$2 = [[], [], []];
var mathSqrt$2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m2) {
  if (!m2) {
    return;
  }
  var data = path.data;
  var len2 = path.len();
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p2;
  var M2 = CMD.M;
  var C = CMD.C;
  var L2 = CMD.L;
  var R = CMD.R;
  var A2 = CMD.A;
  var Q = CMD.Q;
  for (i = 0, j = 0; i < len2; ) {
    cmd = data[i++];
    j = i;
    nPoint = 0;
    switch (cmd) {
      case M2:
        nPoint = 1;
        break;
      case L2:
        nPoint = 1;
        break;
      case C:
        nPoint = 3;
        break;
      case Q:
        nPoint = 2;
        break;
      case A2:
        var x2 = m2[4];
        var y = m2[5];
        var sx = mathSqrt$2(m2[0] * m2[0] + m2[1] * m2[1]);
        var sy = mathSqrt$2(m2[2] * m2[2] + m2[3] * m2[3]);
        var angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
        data[i] *= sx;
        data[i++] += x2;
        data[i] *= sy;
        data[i++] += y;
        data[i++] *= sx;
        data[i++] *= sy;
        data[i++] += angle;
        data[i++] += angle;
        i += 2;
        j = i;
        break;
      case R:
        p2[0] = data[i++];
        p2[1] = data[i++];
        applyTransform$1(p2, p2, m2);
        data[j++] = p2[0];
        data[j++] = p2[1];
        p2[0] += data[i++];
        p2[1] += data[i++];
        applyTransform$1(p2, p2, m2);
        data[j++] = p2[0];
        data[j++] = p2[1];
    }
    for (k = 0; k < nPoint; k++) {
      var p_1 = points$2[k];
      p_1[0] = data[i++];
      p_1[1] = data[i++];
      applyTransform$1(p_1, p_1, m2);
      data[j++] = p_1[0];
      data[j++] = p_1[1];
    }
  }
  path.increaseVersion();
}
var mathSqrt$1 = Math.sqrt;
var mathSin$2 = Math.sin;
var mathCos$2 = Math.cos;
var PI$6 = Math.PI;
function vMag(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio(u2, v2) {
  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
}
function vAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
}
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI$6 / 180);
  var xp = mathCos$2(psi) * (x1 - x2) / 2 + mathSin$2(psi) * (y1 - y2) / 2;
  var yp = -1 * mathSin$2(psi) * (x1 - x2) / 2 + mathCos$2(psi) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt$1(lambda);
    ry *= mathSqrt$1(lambda);
  }
  var f = (fa === fs ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x1 + x2) / 2 + mathCos$2(psi) * cxp - mathSin$2(psi) * cyp;
  var cy = (y1 + y2) / 2 + mathSin$2(psi) * cxp + mathCos$2(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u2, v2);
  if (vRatio(u2, v2) <= -1) {
    dTheta = PI$6;
  }
  if (vRatio(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (dTheta < 0) {
    var n = Math.round(dTheta / PI$6 * 1e6) / 1e6;
    dTheta = PI$6 * 2 + n % 2 * PI$6;
  }
  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
  var path = new PathProxy$1();
  if (!data) {
    return path;
  }
  var cpx = 0;
  var cpy = 0;
  var subpathX = cpx;
  var subpathY = cpy;
  var prevCmd;
  var CMD2 = PathProxy$1.CMD;
  var cmdList = data.match(commandReg);
  if (!cmdList) {
    return path;
  }
  for (var l2 = 0; l2 < cmdList.length; l2++) {
    var cmdText = cmdList[l2];
    var cmdStr = cmdText.charAt(0);
    var cmd = void 0;
    var p2 = cmdText.match(numberReg$1) || [];
    var pLen = p2.length;
    for (var i = 0; i < pLen; i++) {
      p2[i] = parseFloat(p2[i]);
    }
    var off2 = 0;
    while (off2 < pLen) {
      var ctlPtx = void 0;
      var ctlPty = void 0;
      var rx = void 0;
      var ry = void 0;
      var psi = void 0;
      var fa = void 0;
      var fs = void 0;
      var x1 = cpx;
      var y1 = cpy;
      var len2 = void 0;
      var pathData = void 0;
      switch (cmdStr) {
        case "l":
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD2.C;
          path.addData(cmd, p2[off2++], p2[off2++], p2[off2++], p2[off2++], p2[off2++], p2[off2++]);
          cpx = p2[off2 - 2];
          cpy = p2[off2 - 1];
          break;
        case "c":
          cmd = CMD2.C;
          path.addData(cmd, p2[off2++] + cpx, p2[off2++] + cpy, p2[off2++] + cpx, p2[off2++] + cpy, p2[off2++] + cpx, p2[off2++] + cpy);
          cpx += p2[off2 - 2];
          cpy += p2[off2 - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x1 = p2[off2++];
          y1 = p2[off2++];
          cpx = p2[off2++];
          cpy = p2[off2++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x1 = cpx + p2[off2++];
          y1 = cpy + p2[off2++];
          cpx += p2[off2++];
          cpy += p2[off2++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "Q":
          x1 = p2[off2++];
          y1 = p2[off2++];
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "q":
          x1 = p2[off2++] + cpx;
          y1 = p2[off2++] + cpy;
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p2[off2++];
          ry = p2[off2++];
          psi = p2[off2++];
          fa = p2[off2++];
          fs = p2[off2++];
          x1 = cpx, y1 = cpy;
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
        case "a":
          rx = p2[off2++];
          ry = p2[off2++];
          psi = p2[off2++];
          fa = p2[off2++];
          fs = p2[off2++];
          x1 = cpx, y1 = cpy;
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD2.Z;
      path.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path.toStatic();
  return path;
}
var SVGPath = function(_super) {
  __extends(SVGPath2, _super);
  function SVGPath2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SVGPath2.prototype.applyTransform = function(m2) {
  };
  return SVGPath2;
}(Path$1);
function isPathProxy(path) {
  return path.setData != null;
}
function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  var innerOpts = extend$3({}, opts);
  innerOpts.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.setData(pathProxy.data);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx, 1);
    }
  };
  innerOpts.applyTransform = function(m2) {
    transformPath(pathProxy, m2);
    this.dirtyShape();
  };
  return innerOpts;
}
function createFromString(str, opts) {
  return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
  var innerOpts = createPathOptions(str, defaultOpts);
  var Sub = function(_super) {
    __extends(Sub2, _super);
    function Sub2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.applyTransform = innerOpts.applyTransform;
      _this.buildPath = innerOpts.buildPath;
      return _this;
    }
    return Sub2;
  }(SVGPath);
  return Sub;
}
function mergePath$1(pathEls, opts) {
  var pathList = [];
  var len2 = pathEls.length;
  for (var i = 0; i < len2; i++) {
    var pathEl = pathEls[i];
    pathList.push(pathEl.getUpdatedPathProxy(true));
  }
  var pathBundle = new Path$1(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.appendPath(pathList);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    }
  };
  return pathBundle;
}
var CircleShape = function() {
  function CircleShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
  }
  return CircleShape2;
}();
var Circle = function(_super) {
  __extends(Circle2, _super);
  function Circle2(opts) {
    return _super.call(this, opts) || this;
  }
  Circle2.prototype.getDefaultShape = function() {
    return new CircleShape();
  };
  Circle2.prototype.buildPath = function(ctx, shape) {
    ctx.moveTo(shape.cx + shape.r, shape.cy);
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
  };
  return Circle2;
}(Path$1);
Circle.prototype.type = "circle";
var Circle$1 = Circle;
var EllipseShape = function() {
  function EllipseShape2() {
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;
  }
  return EllipseShape2;
}();
var Ellipse = function(_super) {
  __extends(Ellipse2, _super);
  function Ellipse2(opts) {
    return _super.call(this, opts) || this;
  }
  Ellipse2.prototype.getDefaultShape = function() {
    return new EllipseShape();
  };
  Ellipse2.prototype.buildPath = function(ctx, shape) {
    var k = 0.5522848;
    var x2 = shape.cx;
    var y = shape.cy;
    var a2 = shape.rx;
    var b2 = shape.ry;
    var ox = a2 * k;
    var oy = b2 * k;
    ctx.moveTo(x2 - a2, y);
    ctx.bezierCurveTo(x2 - a2, y - oy, x2 - ox, y - b2, x2, y - b2);
    ctx.bezierCurveTo(x2 + ox, y - b2, x2 + a2, y - oy, x2 + a2, y);
    ctx.bezierCurveTo(x2 + a2, y + oy, x2 + ox, y + b2, x2, y + b2);
    ctx.bezierCurveTo(x2 - ox, y + b2, x2 - a2, y + oy, x2 - a2, y);
    ctx.closePath();
  };
  return Ellipse2;
}(Path$1);
Ellipse.prototype.type = "ellipse";
var Ellipse$1 = Ellipse;
var PI$5 = Math.PI;
var PI2$2 = PI$5 * 2;
var mathSin$1 = Math.sin;
var mathCos$1 = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax$6 = Math.max;
var mathMin$6 = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e) {
    return;
  }
  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
  return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d2 = dx * dx + dy * dy;
  var r = radius - cr;
  var s2 = x11 * y10 - x10 * y11;
  var d3 = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$6(0, r * r * d2 - s2 * s2));
  var cx0 = (s2 * dy - dx * d3) / d2;
  var cy0 = (-s2 * dx - dy * d3) / d2;
  var cx1 = (s2 * dy + dx * d3) / d2;
  var cy1 = (-s2 * dx + dy * d3) / d2;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function normalizeCornerRadius(cr) {
  var arr;
  if (isArray$4(cr)) {
    var len2 = cr.length;
    if (!len2) {
      return cr;
    }
    if (len2 === 1) {
      arr = [cr[0], cr[0], 0, 0];
    } else if (len2 === 2) {
      arr = [cr[0], cr[0], cr[1], cr[1]];
    } else if (len2 === 3) {
      arr = cr.concat(cr[2]);
    } else {
      arr = cr;
    }
  } else {
    arr = [cr, cr, cr, cr];
  }
  return arr;
}
function buildPath$1(ctx, shape) {
  var _a2;
  var radius = mathMax$6(shape.r, 0);
  var innerRadius = mathMax$6(shape.r0 || 0, 0);
  var hasRadius = radius > 0;
  var hasInnerRadius = innerRadius > 0;
  if (!hasRadius && !hasInnerRadius) {
    return;
  }
  if (!hasRadius) {
    radius = innerRadius;
    innerRadius = 0;
  }
  if (innerRadius > radius) {
    var tmp = radius;
    radius = innerRadius;
    innerRadius = tmp;
  }
  var startAngle = shape.startAngle, endAngle = shape.endAngle;
  if (isNaN(startAngle) || isNaN(endAngle)) {
    return;
  }
  var cx = shape.cx, cy = shape.cy;
  var clockwise = !!shape.clockwise;
  var arc = mathAbs(endAngle - startAngle);
  var mod = arc > PI2$2 && arc % PI2$2;
  mod > e && (arc = mod);
  if (!(radius > e)) {
    ctx.moveTo(cx, cy);
  } else if (arc > PI2$2 - e) {
    ctx.moveTo(cx + radius * mathCos$1(startAngle), cy + radius * mathSin$1(startAngle));
    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    if (innerRadius > e) {
      ctx.moveTo(cx + innerRadius * mathCos$1(endAngle), cy + innerRadius * mathSin$1(endAngle));
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  } else {
    var icrStart = void 0;
    var icrEnd = void 0;
    var ocrStart = void 0;
    var ocrEnd = void 0;
    var ocrs = void 0;
    var ocre = void 0;
    var icrs = void 0;
    var icre = void 0;
    var ocrMax = void 0;
    var icrMax = void 0;
    var limitedOcrMax = void 0;
    var limitedIcrMax = void 0;
    var xre = void 0;
    var yre = void 0;
    var xirs = void 0;
    var yirs = void 0;
    var xrs = radius * mathCos$1(startAngle);
    var yrs = radius * mathSin$1(startAngle);
    var xire = innerRadius * mathCos$1(endAngle);
    var yire = innerRadius * mathSin$1(endAngle);
    var hasArc = arc > e;
    if (hasArc) {
      var cornerRadius = shape.cornerRadius;
      if (cornerRadius) {
        _a2 = normalizeCornerRadius(cornerRadius), icrStart = _a2[0], icrEnd = _a2[1], ocrStart = _a2[2], ocrEnd = _a2[3];
      }
      var halfRd = mathAbs(radius - innerRadius) / 2;
      ocrs = mathMin$6(halfRd, ocrStart);
      ocre = mathMin$6(halfRd, ocrEnd);
      icrs = mathMin$6(halfRd, icrStart);
      icre = mathMin$6(halfRd, icrEnd);
      limitedOcrMax = ocrMax = mathMax$6(ocrs, ocre);
      limitedIcrMax = icrMax = mathMax$6(icrs, icre);
      if (ocrMax > e || icrMax > e) {
        xre = radius * mathCos$1(endAngle);
        yre = radius * mathSin$1(endAngle);
        xirs = innerRadius * mathCos$1(startAngle);
        yirs = innerRadius * mathSin$1(startAngle);
        if (arc < PI$5) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x0 = xrs - it_1[0];
            var y0 = yrs - it_1[1];
            var x1 = xre - it_1[0];
            var y1 = yre - it_1[1];
            var a2 = 1 / mathSin$1(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
            var b2 = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOcrMax = mathMin$6(ocrMax, (radius - b2) / (a2 + 1));
            limitedIcrMax = mathMin$6(icrMax, (innerRadius - b2) / (a2 - 1));
          }
        }
      }
    }
    if (!hasArc) {
      ctx.moveTo(cx + xrs, cy + yrs);
    } else if (limitedOcrMax > e) {
      var crStart = mathMin$6(ocrStart, limitedOcrMax);
      var crEnd = mathMin$6(ocrEnd, limitedOcrMax);
      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
      var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedOcrMax < ocrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.moveTo(cx + xrs, cy + yrs);
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    }
    if (!(innerRadius > e) || !hasArc) {
      ctx.lineTo(cx + xire, cy + yire);
    } else if (limitedIcrMax > e) {
      var crStart = mathMin$6(icrStart, limitedIcrMax);
      var crEnd = mathMin$6(icrEnd, limitedIcrMax);
      var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
      var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedIcrMax < icrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.lineTo(cx + xire, cy + yire);
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  }
  ctx.closePath();
}
var SectorShape = function() {
  function SectorShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
    this.cornerRadius = 0;
  }
  return SectorShape2;
}();
var Sector = function(_super) {
  __extends(Sector2, _super);
  function Sector2(opts) {
    return _super.call(this, opts) || this;
  }
  Sector2.prototype.getDefaultShape = function() {
    return new SectorShape();
  };
  Sector2.prototype.buildPath = function(ctx, shape) {
    buildPath$1(ctx, shape);
  };
  Sector2.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  };
  return Sector2;
}(Path$1);
Sector.prototype.type = "sector";
var Sector$1 = Sector;
var RingShape = function() {
  function RingShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.r0 = 0;
  }
  return RingShape2;
}();
var Ring = function(_super) {
  __extends(Ring2, _super);
  function Ring2(opts) {
    return _super.call(this, opts) || this;
  }
  Ring2.prototype.getDefaultShape = function() {
    return new RingShape();
  };
  Ring2.prototype.buildPath = function(ctx, shape) {
    var x2 = shape.cx;
    var y = shape.cy;
    var PI22 = Math.PI * 2;
    ctx.moveTo(x2 + shape.r, y);
    ctx.arc(x2, y, shape.r, 0, PI22, false);
    ctx.moveTo(x2 + shape.r0, y);
    ctx.arc(x2, y, shape.r0, 0, PI22, true);
  };
  return Ring2;
}(Path$1);
Ring.prototype.type = "ring";
var Ring$1 = Ring;
function smoothBezier(points2, smooth, isLoop, constraint) {
  var cps = [];
  var v2 = [];
  var v1 = [];
  var v22 = [];
  var prevPoint;
  var nextPoint;
  var min3;
  var max3;
  if (constraint) {
    min3 = [Infinity, Infinity];
    max3 = [-Infinity, -Infinity];
    for (var i = 0, len2 = points2.length; i < len2; i++) {
      min$2(min3, min3, points2[i]);
      max$2(max3, max3, points2[i]);
    }
    min$2(min3, min3, constraint[0]);
    max$2(max3, max3, constraint[1]);
  }
  for (var i = 0, len2 = points2.length; i < len2; i++) {
    var point = points2[i];
    if (isLoop) {
      prevPoint = points2[i ? i - 1 : len2 - 1];
      nextPoint = points2[(i + 1) % len2];
    } else {
      if (i === 0 || i === len2 - 1) {
        cps.push(clone$2(points2[i]));
        continue;
      } else {
        prevPoint = points2[i - 1];
        nextPoint = points2[i + 1];
      }
    }
    sub(v2, nextPoint, prevPoint);
    scale$2(v2, v2, smooth);
    var d0 = distance(point, prevPoint);
    var d1 = distance(point, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    scale$2(v1, v2, -d0);
    scale$2(v22, v2, d1);
    var cp0 = add([], point, v1);
    var cp1 = add([], point, v22);
    if (constraint) {
      max$2(cp0, cp0, min3);
      min$2(cp0, cp0, max3);
      max$2(cp1, cp1, min3);
      min$2(cp1, cp1, max3);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function buildPath(ctx, shape, closePath) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (points2 && points2.length >= 2) {
    if (smooth) {
      var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points2[0][0], points2[0][1]);
      var len2 = points2.length;
      for (var i = 0; i < (closePath ? len2 : len2 - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p2 = points2[(i + 1) % len2];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]);
      }
    } else {
      ctx.moveTo(points2[0][0], points2[0][1]);
      for (var i = 1, l2 = points2.length; i < l2; i++) {
        ctx.lineTo(points2[i][0], points2[i][1]);
      }
    }
    closePath && ctx.closePath();
  }
}
var PolygonShape = function() {
  function PolygonShape2() {
    this.points = null;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolygonShape2;
}();
var Polygon = function(_super) {
  __extends(Polygon2, _super);
  function Polygon2(opts) {
    return _super.call(this, opts) || this;
  }
  Polygon2.prototype.getDefaultShape = function() {
    return new PolygonShape();
  };
  Polygon2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, true);
  };
  return Polygon2;
}(Path$1);
Polygon.prototype.type = "polygon";
var Polygon$1 = Polygon;
var PolylineShape = function() {
  function PolylineShape2() {
    this.points = null;
    this.percent = 1;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolylineShape2;
}();
var Polyline = function(_super) {
  __extends(Polyline2, _super);
  function Polyline2(opts) {
    return _super.call(this, opts) || this;
  }
  Polyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Polyline2.prototype.getDefaultShape = function() {
    return new PolylineShape();
  };
  Polyline2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, false);
  };
  return Polyline2;
}(Path$1);
Polyline.prototype.type = "polyline";
var Polyline$1 = Polyline;
var subPixelOptimizeOutputShape = {};
var LineShape = function() {
  function LineShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
  return LineShape2;
}();
var Line = function(_super) {
  __extends(Line2, _super);
  function Line2(opts) {
    return _super.call(this, opts) || this;
  }
  Line2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Line2.prototype.getDefaultShape = function() {
    return new LineShape();
  };
  Line2.prototype.buildPath = function(ctx, shape) {
    var x1;
    var y1;
    var x2;
    var y2;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
      x1 = optimizedShape.x1;
      y1 = optimizedShape.y1;
      x2 = optimizedShape.x2;
      y2 = optimizedShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }
    ctx.lineTo(x2, y2);
  };
  Line2.prototype.pointAt = function(p2) {
    var shape = this.shape;
    return [
      shape.x1 * (1 - p2) + shape.x2 * p2,
      shape.y1 * (1 - p2) + shape.y2 * p2
    ];
  };
  return Line2;
}(Path$1);
Line.prototype.type = "line";
var Line$1 = Line;
var out = [];
var BezierCurveShape = function() {
  function BezierCurveShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.percent = 1;
  }
  return BezierCurveShape2;
}();
function someVectorAt(shape, t, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;
  if (cpx2 != null || cpy2 != null) {
    return [
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
    ];
  } else {
    return [
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
    ];
  }
}
var BezierCurve = function(_super) {
  __extends(BezierCurve2, _super);
  function BezierCurve2(opts) {
    return _super.call(this, opts) || this;
  }
  BezierCurve2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  BezierCurve2.prototype.getDefaultShape = function() {
    return new BezierCurveShape();
  };
  BezierCurve2.prototype.buildPath = function(ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  };
  BezierCurve2.prototype.pointAt = function(t) {
    return someVectorAt(this.shape, t, false);
  };
  BezierCurve2.prototype.tangentAt = function(t) {
    var p2 = someVectorAt(this.shape, t, true);
    return normalize$1(p2, p2);
  };
  return BezierCurve2;
}(Path$1);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve$1 = BezierCurve;
var ArcShape = function() {
  function ArcShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return ArcShape2;
}();
var Arc = function(_super) {
  __extends(Arc2, _super);
  function Arc2(opts) {
    return _super.call(this, opts) || this;
  }
  Arc2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Arc2.prototype.getDefaultShape = function() {
    return new ArcShape();
  };
  Arc2.prototype.buildPath = function(ctx, shape) {
    var x2 = shape.cx;
    var y = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x2, unitY * r + y);
    ctx.arc(x2, y, r, startAngle, endAngle, !clockwise);
  };
  return Arc2;
}(Path$1);
Arc.prototype.type = "arc";
var Arc$1 = Arc;
var CompoundPath = function(_super) {
  __extends(CompoundPath2, _super);
  function CompoundPath2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "compound";
    return _this;
  }
  CompoundPath2.prototype._updatePathDirty = function() {
    var paths = this.shape.paths;
    var dirtyPath = this.shapeChanged();
    for (var i = 0; i < paths.length; i++) {
      dirtyPath = dirtyPath || paths[i].shapeChanged();
    }
    if (dirtyPath) {
      this.dirtyShape();
    }
  };
  CompoundPath2.prototype.beforeBrush = function() {
    this._updatePathDirty();
    var paths = this.shape.paths || [];
    var scale2 = this.getGlobalScale();
    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }
      paths[i].path.setScale(scale2[0], scale2[1], paths[i].segmentIgnoreThreshold);
    }
  };
  CompoundPath2.prototype.buildPath = function(ctx, shape) {
    var paths = shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  };
  CompoundPath2.prototype.afterBrush = function() {
    var paths = this.shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].pathUpdated();
    }
  };
  CompoundPath2.prototype.getBoundingRect = function() {
    this._updatePathDirty.call(this);
    return Path$1.prototype.getBoundingRect.call(this);
  };
  return CompoundPath2;
}(Path$1);
var CompoundPath$1 = CompoundPath;
var Gradient = function() {
  function Gradient2(colorStops) {
    this.colorStops = colorStops || [];
  }
  Gradient2.prototype.addColorStop = function(offset2, color2) {
    this.colorStops.push({
      offset: offset2,
      color: color2
    });
  };
  return Gradient2;
}();
var Gradient$1 = Gradient;
var LinearGradient = function(_super) {
  __extends(LinearGradient2, _super);
  function LinearGradient2(x2, y, x22, y2, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x2 == null ? 0 : x2;
    _this.y = y == null ? 0 : y;
    _this.x2 = x22 == null ? 1 : x22;
    _this.y2 = y2 == null ? 0 : y2;
    _this.type = "linear";
    _this.global = globalCoord || false;
    return _this;
  }
  return LinearGradient2;
}(Gradient$1);
var LinearGradient$1 = LinearGradient;
var RadialGradient = function(_super) {
  __extends(RadialGradient2, _super);
  function RadialGradient2(x2, y, r, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x2 == null ? 0.5 : x2;
    _this.y = y == null ? 0.5 : y;
    _this.r = r == null ? 0.5 : r;
    _this.type = "radial";
    _this.global = globalCoord || false;
    return _this;
  }
  return RadialGradient2;
}(Gradient$1);
var RadialGradient$1 = RadialGradient;
var extent = [0, 0];
var extent2 = [0, 0];
var minTv = new Point$1();
var maxTv = new Point$1();
var OrientedBoundingRect = function() {
  function OrientedBoundingRect2(rect, transform2) {
    this._corners = [];
    this._axes = [];
    this._origin = [0, 0];
    for (var i = 0; i < 4; i++) {
      this._corners[i] = new Point$1();
    }
    for (var i = 0; i < 2; i++) {
      this._axes[i] = new Point$1();
    }
    if (rect) {
      this.fromBoundingRect(rect, transform2);
    }
  }
  OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform2) {
    var corners = this._corners;
    var axes = this._axes;
    var x2 = rect.x;
    var y = rect.y;
    var x22 = x2 + rect.width;
    var y2 = y + rect.height;
    corners[0].set(x2, y);
    corners[1].set(x22, y);
    corners[2].set(x22, y2);
    corners[3].set(x2, y2);
    if (transform2) {
      for (var i = 0; i < 4; i++) {
        corners[i].transform(transform2);
      }
    }
    Point$1.sub(axes[0], corners[1], corners[0]);
    Point$1.sub(axes[1], corners[3], corners[0]);
    axes[0].normalize();
    axes[1].normalize();
    for (var i = 0; i < 2; i++) {
      this._origin[i] = axes[i].dot(corners[0]);
    }
  };
  OrientedBoundingRect2.prototype.intersect = function(other, mtv) {
    var overlapped = true;
    var noMtv = !mtv;
    minTv.set(Infinity, Infinity);
    maxTv.set(0, 0);
    if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!noMtv) {
      Point$1.copy(mtv, overlapped ? minTv : maxTv);
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, minTv2, maxTv2, noMtv, inverse) {
    var overlapped = true;
    for (var i = 0; i < 2; i++) {
      var axis = this._axes[i];
      this._getProjMinMaxOnAxis(i, self2._corners, extent);
      this._getProjMinMaxOnAxis(i, other._corners, extent2);
      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) > maxTv2.len()) {
          if (dist0 < dist1) {
            Point$1.scale(maxTv2, axis, -dist0 * inverse);
          } else {
            Point$1.scale(maxTv2, axis, dist1 * inverse);
          }
        }
      } else if (minTv2) {
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) < minTv2.len()) {
          if (dist0 < dist1) {
            Point$1.scale(minTv2, axis, dist0 * inverse);
          } else {
            Point$1.scale(minTv2, axis, -dist1 * inverse);
          }
        }
      }
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
    var axis = this._axes[dim];
    var origin = this._origin;
    var proj = corners[0].dot(axis) + origin[dim];
    var min3 = proj;
    var max3 = proj;
    for (var i = 1; i < corners.length; i++) {
      var proj_1 = corners[i].dot(axis) + origin[dim];
      min3 = Math.min(proj_1, min3);
      max3 = Math.max(proj_1, max3);
    }
    out2[0] = min3;
    out2[1] = max3;
  };
  return OrientedBoundingRect2;
}();
var OrientedBoundingRect$1 = OrientedBoundingRect;
var m$1 = [];
var IncrementalDisplayable = function(_super) {
  __extends(IncrementalDisplayable2, _super);
  function IncrementalDisplayable2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.notClear = true;
    _this.incremental = true;
    _this._displayables = [];
    _this._temporaryDisplayables = [];
    _this._cursor = 0;
    return _this;
  }
  IncrementalDisplayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  IncrementalDisplayable2.prototype.useStyle = function() {
    this.style = {};
  };
  IncrementalDisplayable2.prototype.getCursor = function() {
    return this._cursor;
  };
  IncrementalDisplayable2.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  };
  IncrementalDisplayable2.prototype.clearDisplaybles = function() {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.markRedraw();
    this.notClear = false;
  };
  IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  };
  IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }
    this.markRedraw();
  };
  IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
    notPersistent = notPersistent || false;
    for (var i = 0; i < displayables.length; i++) {
      this.addDisplayable(displayables[i], notPersistent);
    }
  };
  IncrementalDisplayable2.prototype.getDisplayables = function() {
    return this._displayables;
  };
  IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  };
  IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
    for (var i = this._cursor; i < this._displayables.length; i++) {
      cb && cb(this._displayables[i]);
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      cb && cb(this._temporaryDisplayables[i]);
    }
  };
  IncrementalDisplayable2.prototype.update = function() {
    this.updateTransform();
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var displayable = this._temporaryDisplayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  };
  IncrementalDisplayable2.prototype.getBoundingRect = function() {
    if (!this._rect) {
      var rect = new BoundingRect$1(Infinity, Infinity, -Infinity, -Infinity);
      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        var childRect = displayable.getBoundingRect().clone();
        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m$1));
        }
        rect.union(childRect);
      }
      this._rect = rect;
    }
    return this._rect;
  };
  IncrementalDisplayable2.prototype.contain = function(x2, y) {
    var localPos = this.transformCoordToLocal(x2, y);
    var rect = this.getBoundingRect();
    if (rect.contain(localPos[0], localPos[1])) {
      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        if (displayable.contain(x2, y)) {
          return true;
        }
      }
    }
    return false;
  };
  return IncrementalDisplayable2;
}(Displayable$1);
var IncrementalDisplayable$1 = IncrementalDisplayable;
var transitionStore = makeInner();
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
  var animationPayload;
  if (animatableModel && animatableModel.ecModel) {
    var updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }
  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  var isUpdate = animationType === "update";
  if (animationEnabled) {
    var duration = void 0;
    var easing = void 0;
    var delay = void 0;
    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, "cubicOut");
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
      easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
      delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
    }
    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }
    if (isFunction$2(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }
    if (isFunction$2(duration)) {
      duration = duration(dataIndex);
    }
    var config = {
      duration: duration || 0,
      delay,
      easing
    };
    return config;
  } else {
    return null;
  }
}
function animateOrSetProps(animationType, el, props2, animatableModel, dataIndex, cb, during) {
  var isFrom = false;
  var removeOpt;
  if (isFunction$2(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject$9(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }
  var isRemove = animationType === "leave";
  if (!isRemove) {
    el.stopAnimation("leave");
  }
  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
  if (animationConfig && animationConfig.duration > 0) {
    var duration = animationConfig.duration;
    var animationDelay = animationConfig.delay;
    var animationEasing = animationConfig.easing;
    var animateConfig = {
      duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      setToFinal: !isRemove,
      scope: animationType,
      during
    };
    isFrom ? el.animateFrom(props2, animateConfig) : el.animateTo(props2, animateConfig);
  } else {
    el.stopAnimation();
    !isFrom && el.attr(props2);
    during && during(1);
    cb && cb();
  }
}
function updateProps$1(el, props2, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("update", el, props2, animatableModel, dataIndex, cb, during);
}
function initProps(el, props2, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("enter", el, props2, animatableModel, dataIndex, cb, during);
}
function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }
  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];
    if (animator.scope === "leave") {
      return true;
    }
  }
  return false;
}
function removeElement(el, props2, animatableModel, dataIndex, cb, during) {
  if (isElementRemoved(el)) {
    return;
  }
  animateOrSetProps("leave", el, props2, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  }
  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function(disp) {
      if (!disp.isGroup) {
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}
var mathMax$5 = Math.max;
var mathMin$5 = Math.min;
var _customShapeMap = {};
function extendShape(opts) {
  return Path$1.extend(opts);
}
var extendPathFromString = extendFromString;
function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
function registerShape(name, ShapeClass) {
  _customShapeMap[name] = ShapeClass;
}
function getShapeClass(name) {
  if (_customShapeMap.hasOwnProperty(name)) {
    return _customShapeMap[name];
  }
}
function makePath(pathData, opts, rect, layout2) {
  var path = createFromString(pathData, opts);
  if (rect) {
    if (layout2 === "center") {
      rect = centerGraphic(rect, path.getBoundingRect());
    }
    resizePath(path, rect);
  }
  return path;
}
function makeImage(imageUrl, rect, layout2) {
  var zrImg = new ZRImage$1({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function(img) {
      if (layout2 === "center") {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
function centerGraphic(rect, boundingRect) {
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;
  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }
  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width,
    height
  };
}
var mergePath = mergePath$1;
function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }
  var pathRect = path.getBoundingRect();
  var m2 = pathRect.calculateTransform(rect);
  path.applyTransform(m2);
}
function subPixelOptimizeLine(param) {
  subPixelOptimizeLine$1(param.shape, param.shape, param.style);
  return param;
}
function subPixelOptimizeRect(param) {
  subPixelOptimizeRect$1(param.shape, param.shape, param.style);
  return param;
}
var subPixelOptimize = subPixelOptimize$1;
function getTransform$1(target, ancestor) {
  var mat = identity$1([]);
  while (target && target !== ancestor) {
    mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform(target, transform2, invert$1) {
  if (transform2 && !isArrayLike$1(transform2)) {
    transform2 = Transformable$1.getLocalTransform(transform2);
  }
  if (invert$1) {
    transform2 = invert([], transform2);
  }
  return applyTransform$1([], target, transform2);
}
function transformDirection(direction, transform2, invert2) {
  var hBase = transform2[4] === 0 || transform2[5] === 0 || transform2[0] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[0]);
  var vBase = transform2[4] === 0 || transform2[5] === 0 || transform2[2] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[2]);
  var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
  vertex = applyTransform(vertex, transform2, invert2);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
  return !el.isGroup;
}
function isPath(el) {
  return el.shape != null;
}
function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g) {
    var elMap = {};
    g.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el) {
    var obj = {
      x: el.x,
      y: el.y,
      rotation: el.rotation
    };
    if (isPath(el)) {
      obj.shape = extend$3({}, el.shape);
    }
    return obj;
  }
  var elMap1 = getElMap(g1);
  g2.traverse(function(el) {
    if (isNotGroup(el) && el.anid) {
      var oldEl = elMap1[el.anid];
      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps$1(el, newProp, animatableModel, getECData(el).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points2, rect) {
  return map$1(points2, function(point) {
    var x2 = point[0];
    x2 = mathMax$5(x2, rect.x);
    x2 = mathMin$5(x2, rect.x + rect.width);
    var y = point[1];
    y = mathMax$5(y, rect.y);
    y = mathMin$5(y, rect.y + rect.height);
    return [x2, y];
  });
}
function clipRectByRect(targetRect, rect) {
  var x2 = mathMax$5(targetRect.x, rect.x);
  var x22 = mathMin$5(targetRect.x + targetRect.width, rect.x + rect.width);
  var y = mathMax$5(targetRect.y, rect.y);
  var y2 = mathMin$5(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x22 >= x2 && y2 >= y) {
    return {
      x: x2,
      y,
      width: x22 - x2,
      height: y2 - y
    };
  }
}
function createIcon(iconStr, opt, rect) {
  var innerOpts = extend$3({
    rectHover: true
  }, opt);
  var style = innerOpts.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults$1(style, rect), new ZRImage$1(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
  for (var i = 0, p2 = points2[points2.length - 1]; i < points2.length; i++) {
    var p3 = points2[i];
    if (lineLineIntersect(a1x, a1y, a2x, a2y, p3[0], p3[1], p2[0], p2[1])) {
      return true;
    }
    p2 = p3;
  }
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
  if (q < 0 || q > 1) {
    return false;
  }
  var p2 = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p2 < 0 || p2 > 1) {
    return false;
  }
  return true;
}
function crossProduct2d(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function nearZero(val) {
  return val <= 1e-6 && val >= -1e-6;
}
function setTooltipConfig(opt) {
  var itemTooltipOption = opt.itemTooltipOption;
  var componentModel = opt.componentModel;
  var itemName = opt.itemName;
  var itemTooltipOptionObj = isString$2(itemTooltipOption) ? {
    formatter: itemTooltipOption
  } : itemTooltipOption;
  var mainType = componentModel.mainType;
  var componentIndex = componentModel.componentIndex;
  var formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ["name"]
  };
  formatterParams[mainType + "Index"] = componentIndex;
  var formatterParamsExtra = opt.formatterParamsExtra;
  if (formatterParamsExtra) {
    each$e(keys$1(formatterParamsExtra), function(key2) {
      if (!hasOwn$1(formatterParams, key2)) {
        formatterParams[key2] = formatterParamsExtra[key2];
        formatterParams.$vars.push(key2);
      }
    });
  }
  var ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults$1({
      content: itemName,
      formatterParams
    }, itemTooltipOptionObj)
  };
}
function traverseElement(el, cb) {
  var stopped;
  if (el.isGroup) {
    stopped = cb(el);
  }
  if (!stopped) {
    el.traverse(cb);
  }
}
function traverseElements(els, cb) {
  if (els) {
    if (isArray$4(els)) {
      for (var i = 0; i < els.length; i++) {
        traverseElement(els[i], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
}
registerShape("circle", Circle$1);
registerShape("ellipse", Ellipse$1);
registerShape("sector", Sector$1);
registerShape("ring", Ring$1);
registerShape("polygon", Polygon$1);
registerShape("polyline", Polyline$1);
registerShape("rect", Rect$2);
registerShape("line", Line$1);
registerShape("bezierCurve", BezierCurve$1);
registerShape("arc", Arc$1);
var graphic$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  updateProps: updateProps$1,
  initProps,
  removeElement,
  removeElementWithFadeOut,
  isElementRemoved,
  extendShape,
  extendPath,
  registerShape,
  getShapeClass,
  makePath,
  makeImage,
  mergePath,
  resizePath,
  subPixelOptimizeLine,
  subPixelOptimizeRect,
  subPixelOptimize,
  getTransform: getTransform$1,
  applyTransform,
  transformDirection,
  groupTransition,
  clipPointsByRect,
  clipRectByRect,
  createIcon,
  linePolygonIntersect,
  lineLineIntersect,
  setTooltipConfig,
  traverseElements,
  Group: Group$3,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$1,
  Rect: Rect$2,
  Line: Line$1,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1,
  OrientedBoundingRect: OrientedBoundingRect$1,
  Point: Point$1,
  Path: Path$1
}, Symbol.toStringTag, { value: "Module" }));
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var text2 = labelTexts[stateName];
    var state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text2;
  }
  var oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({
    text: labelTexts.normal
  });
  label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex;
  var normalModel = stateModels.normal;
  var baseText;
  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
      interpolatedValue
    } : null);
  }
  if (baseText == null) {
    baseText = isFunction$2(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }
  var statesText = {
    normal: baseText
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
  }
  return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
  opt = opt || EMPTY_OBJ;
  var isSetOnText = targetEl instanceof ZRText$1;
  var needsCreateText = false;
  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateModel = labelStatesModels[DISPLAY_STATES[i]];
    if (stateModel && stateModel.getShallow("show")) {
      needsCreateText = true;
      break;
    }
  }
  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
  if (needsCreateText) {
    if (!isSetOnText) {
      if (!textContent) {
        textContent = new ZRText$1();
        targetEl.setTextContent(textContent);
      }
      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }
    var labelStatesTexts = getLabelText(opt, labelStatesModels);
    var normalModel = labelStatesModels.normal;
    var showNormal = !!normalModel.getShallow("show");
    var normalStyle = createTextStyle$1(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;
    if (!isSetOnText) {
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var stateModel = labelStatesModels[stateName];
      if (stateModel) {
        var stateObj = textContent.ensureState(stateName);
        var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }
        stateObj.style = createTextStyle$1(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];
        if (!isSetOnText) {
          var targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    }
    textContent.silent = !!normalModel.getShallow("silent");
    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }
    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }
    textContent.ignore = !showNormal;
    textContent.useStyle(normalStyle);
    textContent.dirty();
    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function(interpolatedValue) {
        var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts2);
      };
    }
  } else if (textContent) {
    textContent.ignore = true;
  }
  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || "label";
  var statesModels = {
    normal: itemModel.getModel(labelName)
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }
  return statesModels;
}
function createTextStyle$1(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
  var textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend$3(textStyle, specifiedTextStyle);
  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  var textConfig = {};
  var labelPosition;
  var labelRotate = textStyleModel.getShallow("rotate");
  var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
  var labelOffset = textStyleModel.getShallow("offset");
  labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
  labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }
  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }
  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }
  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  }
  textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
  return textConfig;
}
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  opt = opt || EMPTY_OBJ;
  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle;
  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;
  if (richItemNames) {
    richResult = {};
    for (var name_1 in richItemNames) {
      if (richItemNames.hasOwnProperty(name_1)) {
        var richTextStyle = textStyleModel.getModel(["rich", name_1]);
        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
      }
    }
  }
  if (richResult) {
    textStyle.rich = richResult;
  }
  var overflow = textStyleModel.get("overflow");
  if (overflow) {
    textStyle.overflow = overflow;
  }
  var margin = textStyleModel.get("minMargin");
  if (margin != null) {
    textStyle.margin = margin;
  }
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
  var richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      var richKeys = keys$1(rich);
      for (var i = 0; i < richKeys.length; i++) {
        var richKey = richKeys[i];
        richItemNameMap[richKey] = 1;
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign"];
var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  var inheritColor = opt && opt.inheritColor;
  var fillColor = textStyleModel.getShallow("color");
  var strokeColor = textStyleModel.getShallow("textBorderColor");
  var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
  if (fillColor === "inherit" || fillColor === "auto") {
    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }
  if (strokeColor === "inherit" || strokeColor === "auto") {
    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }
  if (!isAttached) {
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }
  if (fillColor != null) {
    textStyle.fill = fillColor;
  }
  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }
  var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }
  var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }
  var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }
  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }
  if (opacity != null) {
    textStyle.opacity = opacity;
  }
  if (!isNotNormal && !isAttached) {
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  }
  for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
    var key2 = TEXT_PROPS_WITH_GLOBAL[i];
    var val = retrieve2(textStyleModel.getShallow(key2), globalTextStyle[key2]);
    if (val != null) {
      textStyle[key2] = val;
    }
  }
  for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
    var key2 = TEXT_PROPS_SELF[i];
    var val = textStyleModel.getShallow(key2);
    if (val != null) {
      textStyle[key2] = val;
    }
  }
  if (textStyle.verticalAlign == null) {
    var baseline = textStyleModel.getShallow("baseline");
    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }
  if (!isBlock || !opt.disableBox) {
    for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
      var key2 = TEXT_PROPS_BOX[i];
      var val = textStyleModel.getShallow(key2);
      if (val != null) {
        textStyle[key2] = val;
      }
    }
    var borderType = textStyleModel.getShallow("borderType");
    if (borderType != null) {
      textStyle.borderDash = borderType;
    }
    if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
      textStyle.backgroundColor = inheritColor;
    }
    if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
      textStyle.borderColor = inheritColor;
    }
  }
}
function getFont(opt, ecModel) {
  var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return trim$1([
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
  if (!label) {
    return;
  }
  var obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value;
  var normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get("valueAnimation");
  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get("precision");
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
var tmpText = new ZRText$1();
var TextStyleMixin = function() {
  function TextStyleMixin2() {
  }
  TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  };
  TextStyleMixin2.prototype.getFont = function() {
    return getFont({
      fontStyle: this.getShallow("fontStyle"),
      fontWeight: this.getShallow("fontWeight"),
      fontSize: this.getShallow("fontSize"),
      fontFamily: this.getShallow("fontFamily")
    }, this.ecModel);
  };
  TextStyleMixin2.prototype.getTextRect = function(text2) {
    var style = {
      text: text2,
      verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
    };
    for (var i = 0; i < textStyleParams.length; i++) {
      style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
    }
    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  };
  return TextStyleMixin2;
}();
var TextStyleMixin$1 = TextStyleMixin;
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = function() {
  function LineStyleMixin2() {
  }
  LineStyleMixin2.prototype.getLineStyle = function(excludes) {
    return getLineStyle(this, excludes);
  };
  return LineStyleMixin2;
}();
var ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = function() {
  function ItemStyleMixin2() {
  }
  ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes) {
    return getItemStyle(this, excludes, includes);
  };
  return ItemStyleMixin2;
}();
var Model = function() {
  function Model2(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  Model2.prototype.init = function(option, parentModel, ecModel) {
    var rest = [];
    for (var _i = 3; _i < arguments.length; _i++) {
      rest[_i - 3] = arguments[_i];
    }
  };
  Model2.prototype.mergeOption = function(option, ecModel) {
    merge(this.option, option, true);
  };
  Model2.prototype.get = function(path, ignoreParent) {
    if (path == null) {
      return this.option;
    }
    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  };
  Model2.prototype.getShallow = function(key2, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key2];
    if (val == null && !ignoreParent) {
      var parentModel = this.parentModel;
      if (parentModel) {
        val = parentModel.getShallow(key2);
      }
    }
    return val;
  };
  Model2.prototype.getModel = function(path, parentModel) {
    var hasPath2 = path != null;
    var pathFinal = hasPath2 ? this.parsePath(path) : null;
    var obj = hasPath2 ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model2(obj, parentModel, this.ecModel);
  };
  Model2.prototype.isEmpty = function() {
    return this.option == null;
  };
  Model2.prototype.restoreData = function() {
  };
  Model2.prototype.clone = function() {
    var Ctor = this.constructor;
    return new Ctor(clone$3(this.option));
  };
  Model2.prototype.parsePath = function(path) {
    if (typeof path === "string") {
      return path.split(".");
    }
    return path;
  };
  Model2.prototype.resolveParentPath = function(path) {
    return path;
  };
  Model2.prototype.isAnimationEnabled = function() {
    if (!env$1.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  };
  Model2.prototype._doGet = function(pathArr, parentModel) {
    var obj = this.option;
    if (!pathArr) {
      return obj;
    }
    for (var i = 0; i < pathArr.length; i++) {
      if (!pathArr[i]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }
    return obj;
  };
  return Model2;
}();
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, TextStyleMixin$1);
var Model$1 = Model;
var base = Math.round(Math.random() * 10);
function getUID(type) {
  return [type || "", base++].join("_");
}
function enableSubTypeDefaulter(target) {
  var subTypeDefaulters = {};
  target.registerSubTypeDefaulter = function(componentType, defaulter) {
    var componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };
  target.determineSubType = function(componentType, option) {
    var type = option.type;
    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;
      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type;
  };
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var noEntryList = result.noEntryList;
    var targetNameSet = {};
    each$e(targetNameList, function(name) {
      targetNameSet[name] = true;
    });
    while (noEntryList.length) {
      var currComponentType = noEntryList.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      each$e(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    each$e(targetNameSet, function() {
      var errMsg = "";
      throw new Error(errMsg);
    });
    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;
      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    each$e(fullNameList, function(name) {
      var thisItem = createDependencyGraphItem(graph, name);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }
      each$e(availableDeps, function(dependentName) {
        if (indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        var thatItem = createDependencyGraphItem(graph, dependentName);
        if (indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {
      graph,
      noEntryList
    };
  }
  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {
        predecessor: [],
        successor: []
      };
    }
    return graph[name];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    each$e(originalDeps, function(dep) {
      indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  return merge(merge({}, superOption, true), subOption, true);
}
var langEN = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
};
var langZH = {
  time: {
    month: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
    monthAbbr: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"],
    dayOfWeek: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"],
    dayOfWeekAbbr: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]
  },
  legend: {
    selector: {
      all: "\u5168\u9009",
      inverse: "\u53CD\u9009"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "\u77E9\u5F62\u9009\u62E9",
        polygon: "\u5708\u9009",
        lineX: "\u6A2A\u5411\u9009\u62E9",
        lineY: "\u7EB5\u5411\u9009\u62E9",
        keep: "\u4FDD\u6301\u9009\u62E9",
        clear: "\u6E05\u9664\u9009\u62E9"
      }
    },
    dataView: {
      title: "\u6570\u636E\u89C6\u56FE",
      lang: ["\u6570\u636E\u89C6\u56FE", "\u5173\u95ED", "\u5237\u65B0"]
    },
    dataZoom: {
      title: {
        zoom: "\u533A\u57DF\u7F29\u653E",
        back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
      }
    },
    magicType: {
      title: {
        line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
        bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
        stack: "\u5207\u6362\u4E3A\u5806\u53E0",
        tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
      }
    },
    restore: {
      title: "\u8FD8\u539F"
    },
    saveAsImage: {
      title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
      lang: ["\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"]
    }
  },
  series: {
    typeNames: {
      pie: "\u997C\u56FE",
      bar: "\u67F1\u72B6\u56FE",
      line: "\u6298\u7EBF\u56FE",
      scatter: "\u6563\u70B9\u56FE",
      effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
      radar: "\u96F7\u8FBE\u56FE",
      tree: "\u6811\u56FE",
      treemap: "\u77E9\u5F62\u6811\u56FE",
      boxplot: "\u7BB1\u578B\u56FE",
      candlestick: "K\u7EBF\u56FE",
      k: "K\u7EBF\u56FE",
      heatmap: "\u70ED\u529B\u56FE",
      map: "\u5730\u56FE",
      parallel: "\u5E73\u884C\u5750\u6807\u56FE",
      lines: "\u7EBF\u56FE",
      graph: "\u5173\u7CFB\u56FE",
      sankey: "\u6851\u57FA\u56FE",
      funnel: "\u6F0F\u6597\u56FE",
      gauge: "\u4EEA\u8868\u76D8\u56FE",
      pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
      themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
      sunburst: "\u65ED\u65E5\u56FE"
    }
  },
  aria: {
    general: {
      withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
      withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
    },
    series: {
      single: {
        prefix: "",
        withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
        withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
      },
      multiple: {
        prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
        withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
        withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
        separator: {
          middle: "\uFF1B",
          end: "\u3002"
        }
      }
    },
    data: {
      allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
      partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
      withName: "{name}\u7684\u6570\u636E\u662F{value}",
      withoutName: "{value}",
      separator: {
        middle: "\uFF0C",
        end: ""
      }
    }
  }
};
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env$1.domSupported ? DEFAULT_LOCALE : function() {
  var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
  locale = locale.toUpperCase();
  localeModels[locale] = new Model$1(localeObj);
  localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
  if (isString$2(locale)) {
    var localeObj = localeStorage[locale.toUpperCase()] || {};
    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
      return clone$3(localeObj);
    } else {
      return merge(clone$3(localeObj), clone$3(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge(clone$3(locale), clone$3(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN);
registerLocale(LOCALE_ZH, langZH);
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
};
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
};
var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function pad(str, len2) {
  str += "";
  return "0000".substr(0, len2 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format$1(time2, template, isUTC, lang) {
  var date = parseDate(time2);
  var y = date[fullYearGetterName(isUTC)]();
  var M2 = date[monthGetterName(isUTC)]() + 1;
  var q = Math.floor((M2 - 1) / 4) + 1;
  var d2 = date[dateGetterName(isUTC)]();
  var e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
  var H = date[hoursGetterName(isUTC)]();
  var h2 = (H - 1) % 12 + 1;
  var m2 = date[minutesGetterName(isUTC)]();
  var s2 = date[secondsGetterName(isUTC)]();
  var S2 = date[millisecondsGetterName(isUTC)]();
  var localeModel = lang instanceof Model$1 ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  var timeModel = localeModel.getModel("time");
  var month = timeModel.get("month");
  var monthAbbr = timeModel.get("monthAbbr");
  var dayOfWeek = timeModel.get("dayOfWeek");
  var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
  return (template || "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, y % 100 + "").replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M2 - 1]).replace(/{MMM}/g, monthAbbr[M2 - 1]).replace(/{MM}/g, pad(M2, 2)).replace(/{M}/g, M2 + "").replace(/{dd}/g, pad(d2, 2)).replace(/{d}/g, d2 + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h2 + "", 2)).replace(/{h}/g, h2 + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s2, 2)).replace(/{s}/g, s2 + "").replace(/{SSS}/g, pad(S2, 3)).replace(/{S}/g, S2 + "");
}
function leveledFormat(tick, idx, formatter2, lang, isUTC) {
  var template = null;
  if (isString$2(formatter2)) {
    template = formatter2;
  } else if (isFunction$2(formatter2)) {
    template = formatter2(tick.value, idx, {
      level: tick.level
    });
  } else {
    var defaults2 = extend$3({}, defaultLeveledFormatter);
    if (tick.level > 0) {
      for (var i = 0; i < primaryTimeUnits.length; ++i) {
        defaults2[primaryTimeUnits[i]] = "{primary|" + defaults2[primaryTimeUnits[i]] + "}";
      }
    }
    var mergedFormatter = formatter2 ? formatter2.inherit === false ? formatter2 : defaults$1(formatter2, defaults2) : defaults2;
    var unit = getUnitFromValue(tick.value, isUTC);
    if (mergedFormatter[unit]) {
      template = mergedFormatter[unit];
    } else if (mergedFormatter.inherit) {
      var targetId = timeUnits.indexOf(unit);
      for (var i = targetId - 1; i >= 0; --i) {
        if (mergedFormatter[unit]) {
          template = mergedFormatter[unit];
          break;
        }
      }
      template = template || defaults2.none;
    }
    if (isArray$4(template)) {
      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
      levelId = Math.min(levelId, template.length - 1);
      template = template[levelId];
    }
  }
  return format$1(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
  var date = parseDate(value);
  var M2 = date[monthGetterName(isUTC)]() + 1;
  var d2 = date[dateGetterName(isUTC)]();
  var h2 = date[hoursGetterName(isUTC)]();
  var m2 = date[minutesGetterName(isUTC)]();
  var s2 = date[secondsGetterName(isUTC)]();
  var S2 = date[millisecondsGetterName(isUTC)]();
  var isSecond = S2 === 0;
  var isMinute = isSecond && s2 === 0;
  var isHour = isMinute && m2 === 0;
  var isDay = isHour && h2 === 0;
  var isMonth = isDay && d2 === 1;
  var isYear = isMonth && M2 === 1;
  if (isYear) {
    return "year";
  } else if (isMonth) {
    return "month";
  } else if (isDay) {
    return "day";
  } else if (isHour) {
    return "hour";
  } else if (isMinute) {
    return "minute";
  } else if (isSecond) {
    return "second";
  } else {
    return "millisecond";
  }
}
function getUnitValue(value, unit, isUTC) {
  var date = isNumber$1(value) ? parseDate(value) : value;
  unit = unit || getUnitFromValue(value, isUTC);
  switch (unit) {
    case "year":
      return date[fullYearGetterName(isUTC)]();
    case "half-year":
      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
    case "month":
      return date[monthGetterName(isUTC)]();
    case "day":
      return date[dateGetterName(isUTC)]();
    case "half-day":
      return date[hoursGetterName(isUTC)]() / 24;
    case "hour":
      return date[hoursGetterName(isUTC)]();
    case "minute":
      return date[minutesGetterName(isUTC)]();
    case "second":
      return date[secondsGetterName(isUTC)]();
    case "millisecond":
      return date[millisecondsGetterName(isUTC)]();
  }
}
function fullYearGetterName(isUTC) {
  return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
  return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
  return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
  return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
  return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
  return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
  return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
  return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
  return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
  return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
  return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
  return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
  return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
  return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}
function getTextRect(text2, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
  var textEl = new ZRText$1({
    style: {
      text: text2,
      font,
      align,
      verticalAlign,
      padding,
      rich,
      overflow: truncate ? "truncate" : null,
      lineHeight
    }
  });
  return textEl.getBoundingRect();
}
function addCommas(x2) {
  if (!isNumeric(x2)) {
    return isString$2(x2) ? x2 : "-";
  }
  var parts = (x2 + "").split(".");
  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
  str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
var normalizeCssArray = normalizeCssArray$1;
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(source) {
  return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
    return replaceMap[c];
  });
}
function makeValueReadable(value, valueType, useUTC) {
  var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function stringToUserReadable(str) {
    return str && trim$1(str) ? str : "-";
  }
  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }
  var isTypeTime = valueType === "time";
  var isValueDate = value instanceof Date;
  if (isTypeTime || isValueDate) {
    var date = isTypeTime ? parseDate(value) : value;
    if (!isNaN(+date)) {
      return format$1(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return "-";
    }
  }
  if (valueType === "ordinal") {
    return isStringSafe(value) ? stringToUserReadable(value) : isNumber$1(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
  }
  var numericResult = numericToNumber(value);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
var wrapVar = function(varName, seriesIdx) {
  return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
function formatTpl(tpl, paramsList2, encode) {
  if (!isArray$4(paramsList2)) {
    paramsList2 = [paramsList2];
  }
  var seriesLen = paramsList2.length;
  if (!seriesLen) {
    return "";
  }
  var $vars = paramsList2[0].$vars || [];
  for (var i = 0; i < $vars.length; i++) {
    var alias = TPL_VAR_ALIAS[i];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }
  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k = 0; k < $vars.length; k++) {
      var val = paramsList2[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }
  return tpl;
}
function formatTplSimple(tpl, param, encode) {
  each$e(param, function(value, key2) {
    tpl = tpl.replace("{" + key2 + "}", encode ? encodeHTML(value) : value);
  });
  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  var opt = isString$2(inOpt) ? {
    color: inOpt,
    extraCssText
  } : inOpt || {};
  var color2 = opt.color;
  var type = opt.type;
  extraCssText = opt.extraCssText;
  var renderMode = opt.renderMode || "html";
  if (!color2) {
    return "";
  }
  if (renderMode === "html") {
    return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>';
  } else {
    var markerId = opt.markerId || "markerX";
    return {
      renderMode,
      content: "{" + markerId + "|}  ",
      style: type === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color2
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color2
      }
    };
  }
}
function formatTime(tpl, value, isUTC) {
  if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
    tpl = "MM-dd\nyyyy";
  }
  var date = parseDate(value);
  var getUTC = isUTC ? "getUTC" : "get";
  var y = date[getUTC + "FullYear"]();
  var M2 = date[getUTC + "Month"]() + 1;
  var d2 = date[getUTC + "Date"]();
  var h2 = date[getUTC + "Hours"]();
  var m2 = date[getUTC + "Minutes"]();
  var s2 = date[getUTC + "Seconds"]();
  var S2 = date[getUTC + "Milliseconds"]();
  tpl = tpl.replace("MM", pad(M2, 2)).replace("M", M2).replace("yyyy", y).replace("yy", y % 100 + "").replace("dd", pad(d2, 2)).replace("d", d2).replace("hh", pad(h2, 2)).replace("h", h2).replace("mm", pad(m2, 2)).replace("m", m2).replace("ss", pad(s2, 2)).replace("s", s2).replace("SSS", pad(S2, 3));
  return tpl;
}
function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}
function convertToColorString(color2, defaultColor) {
  defaultColor = defaultColor || "transparent";
  return isString$2(color2) ? color2 : isObject$9(color2) ? color2.colorStops && (color2.colorStops[0] || {}).color || defaultColor : defaultColor;
}
function windowOpen(link2, target) {
  if (target === "_blank" || target === "blank") {
    var blank = window.open();
    blank.opener = null;
    blank.location.href = link2;
  } else {
    window.open(link2, target);
  }
}
var each$d = each$e;
var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x2 = 0;
  var y = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  var currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;
    if (orient === "horizontal") {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x2 + moveX;
      if (nextX > maxWidth || child.newline) {
        x2 = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY;
      if (nextY > maxHeight || child.newline) {
        x2 += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    child.x = x2;
    child.y = y;
    child.markRedraw();
    orient === "horizontal" ? x2 = nextX + gap : y = nextY + gap;
  });
}
var box$1 = boxLayout;
curry$1(boxLayout, "vertical");
curry$1(boxLayout, "horizontal");
function getLayoutRect$1(positionInfo, containerRect, margin) {
  margin = normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left2 = parsePercent(positionInfo.left, containerWidth);
  var top2 = parsePercent(positionInfo.top, containerHeight);
  var right2 = parsePercent(positionInfo.right, containerWidth);
  var bottom2 = parsePercent(positionInfo.bottom, containerHeight);
  var width = parsePercent(positionInfo.width, containerWidth);
  var height = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect;
  if (isNaN(width)) {
    width = containerWidth - right2 - horizontalMargin - left2;
  }
  if (isNaN(height)) {
    height = containerHeight - bottom2 - verticalMargin - top2;
  }
  if (aspect != null) {
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (isNaN(width)) {
      width = aspect * height;
    }
    if (isNaN(height)) {
      height = width / aspect;
    }
  }
  if (isNaN(left2)) {
    left2 = containerWidth - right2 - width - horizontalMargin;
  }
  if (isNaN(top2)) {
    top2 = containerHeight - bottom2 - height - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left2 = containerWidth / 2 - width / 2 - margin[3];
      break;
    case "right":
      left2 = containerWidth - width - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top2 = containerHeight / 2 - height / 2 - margin[0];
      break;
    case "bottom":
      top2 = containerHeight - height - verticalMargin;
      break;
  }
  left2 = left2 || 0;
  top2 = top2 || 0;
  if (isNaN(width)) {
    width = containerWidth - horizontalMargin - left2 - (right2 || 0);
  }
  if (isNaN(height)) {
    height = containerHeight - verticalMargin - top2 - (bottom2 || 0);
  }
  var rect = new BoundingRect$1(left2 + margin[3], top2 + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
function positionElement(el, positionInfo, containerRect, margin, opt, out2) {
  var h2 = !opt || !opt.hv || opt.hv[0];
  var v2 = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || "all";
  out2 = out2 || el;
  out2.x = el.x;
  out2.y = el.y;
  if (!h2 && !v2) {
    return false;
  }
  var rect;
  if (boundingMode === "raw") {
    rect = el.type === "group" ? new BoundingRect$1(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();
    if (el.needLocalTransform()) {
      var transform2 = el.getLocalTransform();
      rect = rect.clone();
      rect.applyTransform(transform2);
    }
  }
  var layoutRect = getLayoutRect$1(defaults$1({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin);
  var dx = h2 ? layoutRect.x - rect.x : 0;
  var dy = v2 ? layoutRect.y - rect.y : 0;
  if (boundingMode === "raw") {
    out2.x = dx;
    out2.y = dy;
  } else {
    out2.x += dx;
    out2.y += dy;
  }
  if (out2 === el) {
    el.markRedraw();
  }
  return true;
}
function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function fetchLayoutMode(ins) {
  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject$9(layoutMode) ? layoutMode : layoutMode ? {
    type: layoutMode
  } : null;
}
function mergeLayoutParam(targetOption, newOption, opt) {
  var ignoreSize = opt && opt.ignoreSize;
  !isArray$4(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge2(HV_NAMES[0], 0);
  var vResult = merge2(HV_NAMES[1], 1);
  copy2(HV_NAMES[0], targetOption, hResult);
  copy2(HV_NAMES[1], targetOption, vResult);
  function merge2(names2, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each$d(names2, function(name) {
      merged[name] = targetOption[name];
    });
    each$d(names2, function(name) {
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names2[1])) {
        merged[names2[2]] = null;
      } else if (hasValue(newOption, names2[2])) {
        merged[names2[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (var i = 0; i < names2.length; i++) {
        var name_1 = names2[i];
        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
          newParams[name_1] = targetOption[name_1];
          break;
        }
      }
      return newParams;
    }
  }
  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }
  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== "auto";
  }
  function copy2(names2, target, source) {
    each$d(names2, function(name) {
      target[name] = source[name];
    });
  }
}
function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
function copyLayoutParams(target, source) {
  source && target && each$d(LOCATION_PARAMS, function(name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}
var inner$e = makeInner();
var ComponentModel = function(_super) {
  __extends(ComponentModel2, _super);
  function ComponentModel2(option, parentModel, ecModel) {
    var _this = _super.call(this, option, parentModel, ecModel) || this;
    _this.uid = getUID("ec_cpt_model");
    return _this;
  }
  ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    merge(option, themeModel.get(this.mainType));
    merge(option, this.getDefaultOption());
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  ComponentModel2.prototype.mergeOption = function(option, ecModel) {
    merge(this.option, option, true);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  };
  ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {
  };
  ComponentModel2.prototype.getDefaultOption = function() {
    var ctor = this.constructor;
    if (!isExtendedClass(ctor)) {
      return ctor.defaultOption;
    }
    var fields = inner$e(this);
    if (!fields.defaultOption) {
      var optList = [];
      var clz = ctor;
      while (clz) {
        var opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }
      var defaultOption2 = {};
      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption2 = merge(defaultOption2, optList[i], true);
      }
      fields.defaultOption = defaultOption2;
    }
    return fields.defaultOption;
  };
  ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
    var indexKey = mainType + "Index";
    var idKey = mainType + "Id";
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  };
  ComponentModel2.prototype.getBoxLayoutParams = function() {
    var boxLayoutModel = this;
    return {
      left: boxLayoutModel.get("left"),
      top: boxLayoutModel.get("top"),
      right: boxLayoutModel.get("right"),
      bottom: boxLayoutModel.get("bottom"),
      width: boxLayoutModel.get("width"),
      height: boxLayoutModel.get("height")
    };
  };
  ComponentModel2.prototype.getZLevelKey = function() {
    return "";
  };
  ComponentModel2.prototype.setZLevel = function(zlevel) {
    this.option.zlevel = zlevel;
  };
  ComponentModel2.protoInitialize = function() {
    var proto2 = ComponentModel2.prototype;
    proto2.type = "component";
    proto2.id = "";
    proto2.name = "";
    proto2.mainType = "";
    proto2.subType = "";
    proto2.componentIndex = 0;
  }();
  return ComponentModel2;
}(Model$1);
mountExtend(ComponentModel, Model$1);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
  var deps = [];
  each$e(ComponentModel.getClassesByMainType(componentType), function(clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  });
  deps = map$1(deps, function(type) {
    return parseClassType(type).main;
  });
  if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
var ComponentModel$1 = ComponentModel;
var platform$1 = "";
if (typeof navigator !== "undefined") {
  platform$1 = navigator.platform || "";
}
var decalColor = "rgba(0, 0, 0, 0.2)";
var globalDefault = {
  darkMode: "auto",
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  textStyle: {
    fontFamily: platform$1.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  progressiveThreshold: 3e3,
  progressive: 400,
  hoverLayerThreshold: 3e3,
  useUTC: false
};
var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";
var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
};
var innerGlobalModel = makeInner();
function resetSourceDefaulter(ecModel) {
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel || !coordDimensions) {
    return encode;
  }
  var encodeItemName = [];
  var encodeSeriesName = [];
  var ecModel = seriesModel.ecModel;
  var datasetMap = innerGlobalModel(ecModel).datasetMap;
  var key2 = datasetModel.uid + "_" + source.seriesLayoutBy;
  var baseCategoryDimIndex;
  var categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each$e(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
    var coordDimInfo = isObject$9(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
      name: coordDimInfoLoose
    };
    if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }
    encode[coordDimInfo.name] = [];
  });
  var datasetRecord = datasetMap.get(key2) || datasetMap.set(key2, {
    categoryWayDim: categoryWayValueDimStart,
    valueWayDim: 0
  });
  each$e(coordDimensions, function(coordDimInfo, coordDimIdx) {
    var coordDimName = coordDimInfo.name;
    var count2 = getDataDimCountOnCoordDim(coordDimInfo);
    if (baseCategoryDimIndex == null) {
      var start2 = datasetRecord.valueWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.valueWayDim += count2;
    } else if (baseCategoryDimIndex === coordDimIdx) {
      pushDim(encode[coordDimName], 0, count2);
      pushDim(encodeItemName, 0, count2);
    } else {
      var start2 = datasetRecord.categoryWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.categoryWayDim += count2;
    }
  });
  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (var i = 0; i < idxCount; i++) {
      dimIdxArr.push(idxFrom + i);
    }
  }
  function getDataDimCountOnCoordDim(coordDimInfo) {
    var dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }
  encodeItemName.length && (encode.itemName = encodeItemName);
  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
  return encode;
}
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel) {
    return encode;
  }
  var sourceFormat = source.sourceFormat;
  var dimensionsDefine = source.dimensionsDefine;
  var potentialNameDimIndex;
  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each$e(dimensionsDefine, function(dim, idx) {
      if ((isObject$9(dim) ? dim.name : dim) === "name") {
        potentialNameDimIndex = idx;
      }
    });
  }
  var idxResult = function() {
    var idxRes0 = {};
    var idxRes1 = {};
    var guessRecords = [];
    for (var i = 0, len2 = Math.min(5, dimCount); i < len2; i++) {
      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
      guessRecords.push(guessResult);
      var isPureNumber = guessResult === BE_ORDINAL.Not;
      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
        idxRes0.v = i;
      }
      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i;
      }
      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      }
      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
          idxRes1.v = i;
        }
        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i;
        }
      }
    }
    function fulfilled(idxResult2) {
      return idxResult2.v != null && idxResult2.n != null;
    }
    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();
  if (idxResult) {
    encode.value = [idxResult.v];
    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
    encode.itemName = [nameDimIndex];
    encode.seriesName = [nameDimIndex];
  }
  return encode;
}
function querySeriesUpstreamDatasetModel(seriesModel) {
  var thisData = seriesModel.get("data", true);
  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, "dataset", {
      index: seriesModel.get("datasetIndex", true),
      id: seriesModel.get("datasetId", true)
    }, SINGLE_REFERRING).models[0];
  }
}
function queryDatasetUpstreamDatasetModels(datasetModel) {
  if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
    return [];
  }
  return queryReferringComponents(datasetModel.ecModel, "dataset", {
    index: datasetModel.get("fromDatasetIndex", true),
    id: datasetModel.get("fromDatasetId", true)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  var result;
  var maxLoop = 5;
  if (isTypedArray$2(data)) {
    return BE_ORDINAL.Not;
  }
  var dimName;
  var dimType;
  if (dimensionsDefine) {
    var dimDefItem = dimensionsDefine[dimIndex];
    if (isObject$9(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString$2(dimDefItem)) {
      dimName = dimDefItem;
    }
  }
  if (dimType != null) {
    return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      var sample = dataArrayRows[dimIndex];
      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
        if ((result = detectValue(sample[startIndex + i])) != null) {
          return result;
        }
      }
    } else {
      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
        var row = dataArrayRows[startIndex + i];
        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var dataObjectRows = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
      var item = dataObjectRows[i];
      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    var dataKeyedColumns = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    var sample = dataKeyedColumns[dimName];
    if (!sample || isTypedArray$2(sample)) {
      return BE_ORDINAL.Not;
    }
    for (var i = 0; i < sample.length && i < maxLoop; i++) {
      if ((result = detectValue(sample[i])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var dataOriginal = data;
    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
      var item = dataOriginal[i];
      var val = getDataItemValue(item);
      if (!isArray$4(val)) {
        return BE_ORDINAL.Not;
      }
      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }
  function detectValue(val2) {
    var beStr = isString$2(val2);
    if (val2 != null && isFinite(val2) && val2 !== "") {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val2 !== "-") {
      return BE_ORDINAL.Must;
    }
  }
  return BE_ORDINAL.Not;
}
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(mainType, creator) {
  assert(internalOptionCreatorMap.get(mainType) == null && creator);
  internalOptionCreatorMap.set(mainType, creator);
}
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  var internalOptionCreator = internalOptionCreatorMap.get(mainType);
  if (!internalOptionCreator) {
    return newCmptOptionList;
  }
  var internalOptions = internalOptionCreator(ecModel);
  if (!internalOptions) {
    return newCmptOptionList;
  }
  return newCmptOptionList.concat(internalOptions);
}
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = function() {
  function PaletteMixin2() {
  }
  PaletteMixin2.prototype.getColorFromPalette = function(name, scope, requestNum) {
    var defaultPalette = normalizeToArray(this.get("color", true));
    var layeredPalette = this.get("colorLayer", true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
  };
  PaletteMixin2.prototype.clearColorPalette = function() {
    clearPalette(this, innerColor);
  };
  return PaletteMixin2;
}();
function getDecalFromPalette(ecModel, name, scope, requestNum) {
  var defaultDecals = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);
}
function getNearestPalette(palettes, requestColorNum) {
  var paletteNum = palettes.length;
  for (var i = 0; i < paletteNum; i++) {
    if (palettes[i].length > requestColorNum) {
      return palettes[i];
    }
  }
  return palettes[paletteNum - 1];
}
function getFromPalette(that, inner2, defaultPalette, layeredPalette, name, scope, requestNum) {
  scope = scope || that;
  var scopeFields = inner2(scope);
  var paletteIdx = scopeFields.paletteIdx || 0;
  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
  if (paletteNameMap.hasOwnProperty(name)) {
    return paletteNameMap[name];
  }
  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
  palette = palette || defaultPalette;
  if (!palette || !palette.length) {
    return;
  }
  var pickedPaletteItem = palette[paletteIdx];
  if (name) {
    paletteNameMap[name] = pickedPaletteItem;
  }
  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}
function clearPalette(that, inner2) {
  inner2(that).paletteIdx = 0;
  inner2(that).paletteNameMap = {};
}
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var GlobalModel = function(_super) {
  __extends(GlobalModel2, _super);
  function GlobalModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme2, locale, optionManager) {
    theme2 = theme2 || {};
    this.option = null;
    this._theme = new Model$1(theme2);
    this._locale = new Model$1(locale);
    this._optionManager = optionManager;
  };
  GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs2) {
    var innerOpt = normalizeSetOptionInput(opts);
    this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
    this._resetOption(null, innerOpt);
  };
  GlobalModel2.prototype.resetOption = function(type, opt) {
    return this._resetOption(type, normalizeSetOptionInput(opt));
  };
  GlobalModel2.prototype._resetOption = function(type, opt) {
    var optionChanged = false;
    var optionManager = this._optionManager;
    if (!type || type === "recreate") {
      var baseOption = optionManager.mountOption(type === "recreate");
      if (!this.option || type === "recreate") {
        initBase(this, baseOption);
      } else {
        this.restoreData();
        this._mergeOption(baseOption, opt);
      }
      optionChanged = true;
    }
    if (type === "timeline" || type === "media") {
      this.restoreData();
    }
    if (!type || type === "recreate" || type === "timeline") {
      var timelineOption = optionManager.getTimelineOption(this);
      if (timelineOption) {
        optionChanged = true;
        this._mergeOption(timelineOption, opt);
      }
    }
    if (!type || type === "recreate" || type === "media") {
      var mediaOptions = optionManager.getMediaOption(this);
      if (mediaOptions.length) {
        each$e(mediaOptions, function(mediaOption) {
          optionChanged = true;
          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }
    return optionChanged;
  };
  GlobalModel2.prototype.mergeOption = function(option) {
    this._mergeOption(option, null);
  };
  GlobalModel2.prototype._mergeOption = function(newOption, opt) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var componentsCount = this._componentsCount;
    var newCmptTypes = [];
    var newCmptTypeMap = createHashMap();
    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this);
    each$e(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!ComponentModel$1.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone$3(componentOption) : merge(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });
    if (replaceMergeMainTypeMap) {
      replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
        if (ComponentModel$1.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }
    ComponentModel$1.topologicalTravel(newCmptTypes, ComponentModel$1.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType) {
      var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      var oldCmptList = componentsMap.get(mainType);
      var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
      var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
      setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel$1);
      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      var optionsByMainType = [];
      var cmptsByMainType = [];
      var cmptsCountByMainType = 0;
      var tooltipExists;
      each$e(mappingResult, function(resultItem, index2) {
        var componentModel = resultItem.existing;
        var newCmptOption = resultItem.newOption;
        if (!newCmptOption) {
          if (componentModel) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          }
        } else {
          var isSeriesType = mainType === "series";
          var ComponentModelClass = ComponentModel$1.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
          if (!ComponentModelClass) {
            return;
          }
          if (mainType === "tooltip") {
            if (tooltipExists) {
              return;
            }
            tooltipExists = true;
          }
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            var extraOpt = extend$3({
              componentIndex: index2
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
            extend$3(componentModel, extraOpt);
            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }
            componentModel.init(newCmptOption, this, this);
            componentModel.optionUpdated(null, true);
          }
        }
        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          optionsByMainType.push(void 0);
          cmptsByMainType.push(void 0);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType);
      if (mainType === "series") {
        reCreateSeriesIndices(this);
      }
    }
    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  };
  GlobalModel2.prototype.getOption = function() {
    var option = clone$3(this.option);
    each$e(option, function(optInMainType, mainType) {
      if (ComponentModel$1.hasClass(mainType)) {
        var opts = normalizeToArray(optInMainType);
        var realLen = opts.length;
        var metNonInner = false;
        for (var i = realLen - 1; i >= 0; i--) {
          if (opts[i] && !isComponentIdInternal(opts[i])) {
            metNonInner = true;
          } else {
            opts[i] = null;
            !metNonInner && realLen--;
          }
        }
        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  };
  GlobalModel2.prototype.getTheme = function() {
    return this._theme;
  };
  GlobalModel2.prototype.getLocaleModel = function() {
    return this._locale;
  };
  GlobalModel2.prototype.setUpdatePayload = function(payload) {
    this._payload = payload;
  };
  GlobalModel2.prototype.getUpdatePayload = function() {
    return this._payload;
  };
  GlobalModel2.prototype.getComponent = function(mainType, idx) {
    var list2 = this._componentsMap.get(mainType);
    if (list2) {
      var cmpt = list2[idx || 0];
      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (var i = 0; i < list2.length; i++) {
          if (list2[i]) {
            return list2[i];
          }
        }
      }
    }
  };
  GlobalModel2.prototype.queryComponents = function(condition) {
    var mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    var index2 = condition.index;
    var id = condition.id;
    var name = condition.name;
    var cmpts = this._componentsMap.get(mainType);
    if (!cmpts || !cmpts.length) {
      return [];
    }
    var result;
    if (index2 != null) {
      result = [];
      each$e(normalizeToArray(index2), function(idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id != null) {
      result = queryByIdOrName("id", id, cmpts);
    } else if (name != null) {
      result = queryByIdOrName("name", name, cmpts);
    } else {
      result = filter$2(cmpts, function(cmpt) {
        return !!cmpt;
      });
    }
    return filterBySubType(result, condition);
  };
  GlobalModel2.prototype.findComponents = function(condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : filter$2(this._componentsMap.get(mainType), function(cmpt) {
      return !!cmpt;
    });
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q) {
      var indexAttr = mainType + "Index";
      var idAttr = mainType + "Id";
      var nameAttr = mainType + "Name";
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType,
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter$2(res, condition.filter) : res;
    }
  };
  GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
    var componentsMap = this._componentsMap;
    if (isFunction$2(mainType)) {
      var ctxForAll_1 = cb;
      var cbForAll_1 = mainType;
      componentsMap.each(function(cmpts2, componentType) {
        for (var i2 = 0; cmpts2 && i2 < cmpts2.length; i2++) {
          var cmpt2 = cmpts2[i2];
          cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
        }
      });
    } else {
      var cmpts = isString$2(mainType) ? componentsMap.get(mainType) : isObject$9(mainType) ? this.findComponents(mainType) : null;
      for (var i = 0; cmpts && i < cmpts.length; i++) {
        var cmpt = cmpts[i];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  };
  GlobalModel2.prototype.getSeriesByName = function(name) {
    var nameStr = convertOptionIdName(name, null);
    return filter$2(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
    });
  };
  GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  };
  GlobalModel2.prototype.getSeriesByType = function(subType) {
    return filter$2(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && oneSeries.subType === subType;
    });
  };
  GlobalModel2.prototype.getSeries = function() {
    return filter$2(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries;
    });
  };
  GlobalModel2.prototype.getSeriesCount = function() {
    return this._componentsCount.get("series");
  };
  GlobalModel2.prototype.eachSeries = function(cb, context) {
    assertSeriesInitialized(this);
    each$e(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  };
  GlobalModel2.prototype.eachRawSeries = function(cb, context) {
    each$e(this._componentsMap.get("series"), function(series) {
      series && cb.call(context, series, series.componentIndex);
    });
  };
  GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
    assertSeriesInitialized(this);
    each$e(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  };
  GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
    return each$e(this.getSeriesByType(subType), cb, context);
  };
  GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  };
  GlobalModel2.prototype.getCurrentSeriesIndices = function() {
    return (this._seriesIndices || []).slice();
  };
  GlobalModel2.prototype.filterSeries = function(cb, context) {
    assertSeriesInitialized(this);
    var newSeriesIndices = [];
    each$e(this._seriesIndices, function(seriesRawIdx) {
      var series = this._componentsMap.get("series")[seriesRawIdx];
      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  };
  GlobalModel2.prototype.restoreData = function(payload) {
    reCreateSeriesIndices(this);
    var componentsMap = this._componentsMap;
    var componentTypes = [];
    componentsMap.each(function(components, componentType) {
      if (ComponentModel$1.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    ComponentModel$1.topologicalTravel(componentTypes, ComponentModel$1.getAllClassMainTypes(), function(componentType) {
      each$e(componentsMap.get(componentType), function(component) {
        if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  };
  GlobalModel2.internalField = function() {
    reCreateSeriesIndices = function(ecModel) {
      var seriesIndices = ecModel._seriesIndices = [];
      each$e(ecModel._componentsMap.get("series"), function(series) {
        series && seriesIndices.push(series.componentIndex);
      });
      ecModel._seriesIndicesMap = createHashMap(seriesIndices);
    };
    assertSeriesInitialized = function(ecModel) {
    };
    initBase = function(ecModel, baseOption) {
      ecModel.option = {};
      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
      ecModel._componentsMap = createHashMap({
        series: []
      });
      ecModel._componentsCount = createHashMap();
      var airaOption = baseOption.aria;
      if (isObject$9(airaOption) && airaOption.enabled == null) {
        airaOption.enabled = true;
      }
      mergeTheme(baseOption, ecModel._theme.option);
      merge(baseOption, globalDefault, false);
      ecModel._mergeOption(baseOption, null);
    };
  }();
  return GlobalModel2;
}(Model$1);
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index2 = payload.seriesIndex;
    var id = payload.seriesId;
    var name_1 = payload.seriesName;
    return index2 != null && seriesModel.componentIndex !== index2 || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
  }
}
function mergeTheme(option, theme2) {
  var notMergeColorLayer = option.color && !option.colorLayer;
  each$e(theme2, function(themeItem, name) {
    if (name === "colorLayer" && notMergeColorLayer) {
      return;
    }
    if (!ComponentModel$1.hasClass(name)) {
      if (typeof themeItem === "object") {
        option[name] = !option[name] ? clone$3(themeItem) : merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}
function queryByIdOrName(attr2, idOrName, cmpts) {
  if (isArray$4(idOrName)) {
    var keyMap_1 = createHashMap();
    each$e(idOrName, function(idOrNameItem) {
      if (idOrNameItem != null) {
        var idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap_1.set(idOrNameItem, true);
      }
    });
    return filter$2(cmpts, function(cmpt) {
      return cmpt && keyMap_1.get(cmpt[attr2]);
    });
  } else {
    var idName_1 = convertOptionIdName(idOrName, null);
    return filter$2(cmpts, function(cmpt) {
      return cmpt && idName_1 != null && cmpt[attr2] === idName_1;
    });
  }
}
function filterBySubType(components, condition) {
  return condition.hasOwnProperty("subType") ? filter$2(components, function(cmpt) {
    return cmpt && cmpt.subType === condition.subType;
  }) : components;
}
function normalizeSetOptionInput(opts) {
  var replaceMergeMainTypeMap = createHashMap();
  opts && each$e(normalizeToArray(opts.replaceMerge), function(mainType) {
    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap
  };
}
mixin(GlobalModel, PaletteMixin);
var GlobalModel$1 = GlobalModel;
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  "getOption",
  "getId",
  "updateLabelLayout"
];
var ExtensionAPI = function() {
  function ExtensionAPI2(ecInstance) {
    each$e(availableMethods, function(methodName) {
      this[methodName] = bind$1(ecInstance[methodName], ecInstance);
    }, this);
  }
  return ExtensionAPI2;
}();
var ExtensionAPI$1 = ExtensionAPI;
var coordinateSystemCreators = {};
var CoordinateSystemManager = function() {
  function CoordinateSystemManager2() {
    this._coordinateSystems = [];
  }
  CoordinateSystemManager2.prototype.create = function(ecModel, api) {
    var coordinateSystems = [];
    each$e(coordinateSystemCreators, function(creater, type) {
      var list2 = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list2 || []);
    });
    this._coordinateSystems = coordinateSystems;
  };
  CoordinateSystemManager2.prototype.update = function(ecModel, api) {
    each$e(this._coordinateSystems, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  };
  CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
    return this._coordinateSystems.slice();
  };
  CoordinateSystemManager2.register = function(type, creator) {
    coordinateSystemCreators[type] = creator;
  };
  CoordinateSystemManager2.get = function(type) {
    return coordinateSystemCreators[type];
  };
  return CoordinateSystemManager2;
}();
var CoordinateSystem = CoordinateSystemManager;
var QUERY_REG = /^(min|max)?(.+)$/;
var OptionManager = function() {
  function OptionManager2(api) {
    this._timelineOptions = [];
    this._mediaList = [];
    this._currentMediaIndices = [];
    this._api = api;
  }
  OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs2, opt) {
    if (rawOption) {
      each$e(normalizeToArray(rawOption.series), function(series) {
        series && series.data && isTypedArray$2(series.data) && setAsPrimitive(series.data);
      });
      each$e(normalizeToArray(rawOption.dataset), function(dataset) {
        dataset && dataset.source && isTypedArray$2(dataset.source) && setAsPrimitive(dataset.source);
      });
    }
    rawOption = clone$3(rawOption);
    var optionBackup = this._optionBackup;
    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (optionBackup) {
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  };
  OptionManager2.prototype.mountOption = function(isRecreate) {
    var optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone$3(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  };
  OptionManager2.prototype.getTimelineOption = function(ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone$3(timelineOptions[timelineModel.getCurrentIndex()]);
      }
    }
    return option;
  };
  OptionManager2.prototype.getMediaOption = function(ecModel) {
    var ecWidth = this._api.getWidth();
    var ecHeight = this._api.getHeight();
    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (var i = 0, len2 = mediaList.length; i < len2; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map$1(indices, function(index2) {
        return clone$3(index2 === -1 ? mediaDefault.option : mediaList[index2].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  };
  return OptionManager2;
}();
function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
  var mediaList = [];
  var mediaDefault;
  var baseOption;
  var declaredBaseOption = rawOption.baseOption;
  var timelineOnRoot = rawOption.timeline;
  var timelineOptionsOnRoot = rawOption.options;
  var mediaOnRoot = rawOption.media;
  var hasMedia = !!rawOption.media;
  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
  if (declaredBaseOption) {
    baseOption = declaredBaseOption;
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } else {
    if (hasTimeline || hasMedia) {
      rawOption.options = rawOption.media = null;
    }
    baseOption = rawOption;
  }
  if (hasMedia) {
    if (isArray$4(mediaOnRoot)) {
      each$e(mediaOnRoot, function(singleMedia) {
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    }
  }
  doPreprocess(baseOption);
  each$e(timelineOptionsOnRoot, function(option) {
    return doPreprocess(option);
  });
  each$e(mediaList, function(media) {
    return doPreprocess(media.option);
  });
  function doPreprocess(option) {
    each$e(optionPreprocessorFuncs2, function(preProcess) {
      preProcess(option, isNew);
    });
  }
  return {
    baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
  };
  var applicatable = true;
  each$e(query, function(value, attr2) {
    var matched = attr2.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();
    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}
function compare(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
var OptionManager$1 = OptionManager;
var each$c = each$e;
var isObject$8 = isObject$9;
var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (var i = 0, len2 = POSSIBLE_STYLES.length; i < len2; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults$1(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }
      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, "itemStyle");
  convertNormalEmphasis(opt, "lineStyle");
  convertNormalEmphasis(opt, "areaStyle");
  convertNormalEmphasis(opt, "label");
  convertNormalEmphasis(opt, "labelLine");
  convertNormalEmphasis(opt, "upperLabel");
  convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject$8(opt) && opt[propName];
  var textStyle = isObject$8(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle) {
    for (var i = 0, len2 = TEXT_STYLE_OPTIONS.length; i < len2; i++) {
      var textPropName = TEXT_STYLE_OPTIONS[i];
      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject$8(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  var markPoint = seriesOpt.markPoint;
  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }
  var markLine = seriesOpt.markLine;
  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }
  var markArea = seriesOpt.markArea;
  if (markArea) {
    compatEC3CommonStyles(markArea);
  }
  var data = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data = data || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !isTypedArray$2(edgeData)) {
      for (var i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }
    each$e(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data && !isTypedArray$2(data)) {
    for (var i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  }
  markPoint = seriesOpt.markPoint;
  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;
    for (var i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  }
  markLine = seriesOpt.markLine;
  if (markLine && markLine.data) {
    var mlData = markLine.data;
    for (var i = 0; i < mlData.length; i++) {
      if (isArray$4(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
    each$e(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o2) {
  return isArray$4(o2) ? o2 : o2 ? [o2] : [];
}
function toObj(o2) {
  return (isArray$4(o2) ? o2[0] : o2) || {};
}
function globalCompatStyle(option, isTheme) {
  each$c(toArr(option.series), function(seriesOpt) {
    isObject$8(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each$c(axes, function(axisName) {
    each$c(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each$c(toArr(option.parallel), function(parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each$c(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each$c(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;
    }
    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;
    }
  });
  each$c(toArr(option.geo), function(geoOpt) {
    if (isObject$8(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each$c(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each$c(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, "label");
    convertNormalEmphasis(timelineOpt, "itemStyle");
    convertNormalEmphasis(timelineOpt, "controlStyle", true);
    var data = timelineOpt.data;
    isArray$4(data) && each$e(data, function(item) {
      if (isObject$9(item)) {
        convertNormalEmphasis(item, "label");
        convertNormalEmphasis(item, "itemStyle");
      }
    });
  });
  each$c(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, "iconStyle");
    each$c(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}
function get$1(opt, path) {
  var pathArr = path.split(",");
  var obj = opt;
  for (var i = 0; i < pathArr.length; i++) {
    obj = obj && obj[pathArr[i]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set$1(opt, path, val, overwrite) {
  var pathArr = path.split(",");
  var obj = opt;
  var key2;
  var i = 0;
  for (; i < pathArr.length - 1; i++) {
    key2 = pathArr[i];
    if (obj[key2] == null) {
      obj[key2] = {};
    }
    obj = obj[key2];
  }
  if (overwrite || obj[pathArr[i]] == null) {
    obj[pathArr[i]] = val;
  }
}
function compatLayoutProperties(option) {
  option && each$e(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function compatBarItemStyle(option) {
  var itemStyle = option && option.itemStyle;
  if (itemStyle) {
    for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
      var oldName = BAR_ITEM_STYLE_MAP[i][1];
      var newName = BAR_ITEM_STYLE_MAP[i][0];
      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];
      }
    }
  }
}
function compatPieLabel(option) {
  if (!option) {
    return;
  }
  if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
    option.edgeDistance = option.margin;
  }
}
function compatSunburstState(option) {
  if (!option) {
    return;
  }
  if (option.downplay && !option.blur) {
    option.blur = option.downplay;
  }
}
function compatGraphFocus(option) {
  if (!option) {
    return;
  }
  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};
    if (option.emphasis.focus == null) {
      option.emphasis.focus = "adjacency";
    }
  }
}
function traverseTree(data, cb) {
  if (data) {
    for (var i = 0; i < data.length; i++) {
      cb(data[i]);
      data[i] && traverseTree(data[i].children, cb);
    }
  }
}
function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme);
  option.series = normalizeToArray(option.series);
  each$e(option.series, function(seriesOpt) {
    if (!isObject$9(seriesOpt)) {
      return;
    }
    var seriesType2 = seriesOpt.type;
    if (seriesType2 === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
      }
    } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
      }
      compatPieLabel(seriesOpt.label);
      var data = seriesOpt.data;
      if (data && !isTypedArray$2(data)) {
        for (var i = 0; i < data.length; i++) {
          compatPieLabel(data[i]);
        }
      }
      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis.scaleSize = null) {
          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType2 === "gauge") {
      var pointerColor = get$1(seriesOpt, "pointer.color");
      pointerColor != null && set$1(seriesOpt, "itemStyle.color", pointerColor);
    } else if (seriesType2 === "bar") {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      var data = seriesOpt.data;
      if (data && !isTypedArray$2(data)) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i] === "object") {
            compatBarItemStyle(data[i]);
            compatBarItemStyle(data[i] && data[i].emphasis);
          }
        }
      }
    } else if (seriesType2 === "sunburst") {
      var highlightPolicy = seriesOpt.highlightPolicy;
      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;
        }
      }
      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
      compatGraphFocus(seriesOpt);
    } else if (seriesType2 === "map") {
      if (seriesOpt.mapType && !seriesOpt.map) {
        seriesOpt.map = seriesOpt.mapType;
      }
      if (seriesOpt.mapLocation) {
        defaults$1(seriesOpt, seriesOpt.mapLocation);
      }
    }
    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};
      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each$e(COMPATITABLE_COMPONENTS, function(componentName2) {
    var options = option[componentName2];
    if (options) {
      if (!isArray$4(options)) {
        options = [options];
      }
      each$e(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}
function dataStack$1(ecModel) {
  var stackInfoMap = createHashMap();
  ecModel.eachSeries(function(seriesModel) {
    var stack = seriesModel.get("stack");
    if (stack) {
      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      var data = seriesModel.getData();
      var stackInfo = {
        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data.getCalculationInfo("stackedDimension"),
        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
        data,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}
function calculateStack(stackInfoList) {
  each$e(stackInfoList, function(targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex;
    targetData.modify(dims, function(v0, v1, dataIndex) {
      var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum)) {
        return resultNaN;
      }
      var byValue;
      var stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      var stackedOver = NaN;
      for (var j = idxInStack - 1; j >= 0; j--) {
        var stackInfo = stackInfoList[j];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (sum >= 0 && val > 0 || sum <= 0 && val < 0) {
            sum = addSafe(sum, val);
            stackedOver = val;
            break;
          }
        }
      }
      resultVal[0] = sum;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}
var SourceImpl = function() {
  function SourceImpl2(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
    if (dimensionsDefine) {
      for (var i = 0; i < dimensionsDefine.length; i++) {
        var dim = dimensionsDefine[i];
        if (dim.type == null) {
          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
            dim.type = "ordinal";
          }
        }
      }
    }
  }
  return SourceImpl2;
}();
function isSourceInstance(val) {
  return val instanceof SourceImpl;
}
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  var source = new SourceImpl({
    data: sourceData,
    sourceFormat,
    seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone$3(thisMetaRawOption)
  });
  return source;
}
function createSourceFromSeriesDataOption(data) {
  return new SourceImpl({
    data,
    sourceFormat: isTypedArray$2(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(source) {
  return new SourceImpl({
    data: source.data,
    sourceFormat: source.sourceFormat,
    seriesLayoutBy: source.seriesLayoutBy,
    dimensionsDefine: clone$3(source.dimensionsDefine),
    startIndex: source.startIndex,
    dimensionsDetectedCount: source.dimensionsDetectedCount
  });
}
function detectSourceFormat(data) {
  var sourceFormat = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray$2(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray$4(data)) {
    if (data.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }
    for (var i = 0, len2 = data.length; i < len2; i++) {
      var item = data[i];
      if (item == null) {
        continue;
      } else if (isArray$4(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject$9(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject$9(data)) {
    for (var key2 in data) {
      if (hasOwn$1(data, key2) && isArrayLike$1(data[key2])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }
  return sourceFormat;
}
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  var dimensionsDetectedCount;
  var startIndex;
  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex,
      dimensionsDetectedCount
    };
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (sourceHeader === "auto" || sourceHeader == null) {
      arrayRowsTravelFirst(function(val) {
        if (val != null && val !== "-") {
          if (isString$2(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        }
      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber$1(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }
    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function(val, index2) {
        dimensionsDefine[index2] = val != null ? val + "" : "";
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }
    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each$e(data, function(colArr, key2) {
        dimensionsDefine.push(key2);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var value0 = getDataItemValue(data[0]);
    dimensionsDetectedCount = isArray$4(value0) && value0.length || 1;
  } else
    ;
  return {
    startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount
  };
}
function objectRowsCollectDimensions(data) {
  var firstIndex = 0;
  var obj;
  while (firstIndex < data.length && !(obj = data[firstIndex++])) {
  }
  if (obj) {
    var dimensions_1 = [];
    each$e(obj, function(value, key2) {
      dimensions_1.push(key2);
    });
    return dimensions_1;
  }
}
function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    return;
  }
  var nameMap = createHashMap();
  return map$1(dimensionsDefine, function(rawItem, index2) {
    rawItem = isObject$9(rawItem) ? rawItem : {
      name: rawItem
    };
    var item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    };
    if (item.name == null) {
      return item;
    }
    item.name += "";
    if (item.displayName == null) {
      item.displayName = item.name;
    }
    var exist = nameMap.get(item.name);
    if (!exist) {
      nameMap.set(item.name, {
        count: 1
      });
    } else {
      item.name += "-" + exist.count++;
    }
    return item;
  });
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (var i = 0; i < data.length && i < maxLoop; i++) {
      cb(data[i] ? data[i][0] : null, i);
    }
  } else {
    var value0 = data[0] || [];
    for (var i = 0; i < value0.length && i < maxLoop; i++) {
      cb(value0[i], i);
    }
  }
}
function shouldRetrieveDataByName(source) {
  var sourceFormat = source.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}
var _a$1, _b$1, _c;
var providerMethods;
var mountMethods;
var DefaultDataProvider = function() {
  function DefaultDataProvider2(sourceParam, dimSize) {
    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
    this._source = source;
    var data = this._data = source.data;
    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }
    mountMethods(this, data, source);
  }
  DefaultDataProvider2.prototype.getSource = function() {
    return this._source;
  };
  DefaultDataProvider2.prototype.count = function() {
    return 0;
  };
  DefaultDataProvider2.prototype.getItem = function(idx, out2) {
    return;
  };
  DefaultDataProvider2.prototype.appendData = function(newData) {
  };
  DefaultDataProvider2.prototype.clean = function() {
  };
  DefaultDataProvider2.protoInitialize = function() {
    var proto2 = DefaultDataProvider2.prototype;
    proto2.pure = false;
    proto2.persistent = true;
  }();
  DefaultDataProvider2.internalField = function() {
    var _a2;
    mountMethods = function(provider, data, source) {
      var sourceFormat = source.sourceFormat;
      var seriesLayoutBy = source.seriesLayoutBy;
      var startIndex = source.startIndex;
      var dimsDef = source.dimensionsDefine;
      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
      extend$3(provider, methods);
      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        provider.getItem = getItemForTypedArray;
        provider.count = countForTypedArray;
        provider.fillStorage = fillStorageForTypedArray;
      } else {
        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
        provider.getItem = bind$1(rawItemGetter, null, data, startIndex, dimsDef);
        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
        provider.count = bind$1(rawCounter, null, data, startIndex, dimsDef);
      }
    };
    var getItemForTypedArray = function(idx, out2) {
      idx = idx - this._offset;
      out2 = out2 || [];
      var data = this._data;
      var dimSize = this._dimSize;
      var offset2 = dimSize * idx;
      for (var i = 0; i < dimSize; i++) {
        out2[i] = data[offset2 + i];
      }
      return out2;
    };
    var fillStorageForTypedArray = function(start2, end2, storage2, extent3) {
      var data = this._data;
      var dimSize = this._dimSize;
      for (var dim = 0; dim < dimSize; dim++) {
        var dimExtent = extent3[dim];
        var min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
        var max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
        var count2 = end2 - start2;
        var arr = storage2[dim];
        for (var i = 0; i < count2; i++) {
          var val = data[i * dimSize + dim];
          arr[start2 + i] = val;
          val < min3 && (min3 = val);
          val > max3 && (max3 = val);
        }
        dimExtent[0] = min3;
        dimExtent[1] = max3;
      }
    };
    var countForTypedArray = function() {
      return this._data ? this._data.length / this._dimSize : 0;
    };
    providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
      pure: true,
      appendData: function() {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
      pure: true,
      appendData: function(newData) {
        var data = this._data;
        each$e(newData, function(newCol, key2) {
          var oldCol = data[key2] || (data[key2] = []);
          for (var i = 0; i < (newCol || []).length; i++) {
            oldCol.push(newCol[i]);
          }
        });
      }
    }, _a2[SOURCE_FORMAT_ORIGINAL] = {
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
      persistent: false,
      pure: true,
      appendData: function(newData) {
        this._data = newData;
      },
      clean: function() {
        this._offset += this.count();
        this._data = null;
      }
    }, _a2);
    function appendDataSimply(newData) {
      for (var i = 0; i < newData.length; i++) {
        this._data.push(newData[i]);
      }
    }
  }();
  return DefaultDataProvider2;
}();
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};
var rawSourceItemGetterMap = (_a$1 = {}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx + startIndex];
}, _a$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
  idx += startIndex;
  var item = out2 || [];
  var data = rawData;
  for (var i = 0; i < data.length; i++) {
    var row = data[i];
    item[i] = row ? row[idx] : null;
  }
  return item;
}, _a$1[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a$1[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
  var item = out2 || [];
  for (var i = 0; i < dimsDef.length; i++) {
    var dimName = dimsDef[i].name;
    var col = rawData[dimName];
    item[i] = col ? col[idx] : null;
  }
  return item;
}, _a$1[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a$1);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
  return rawData.length;
};
var rawSourceDataCounterMap = (_b$1 = {}, _b$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
  return Math.max(0, rawData.length - startIndex);
}, _b$1[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
  var row = rawData[0];
  return row ? Math.max(0, row.length - startIndex) : 0;
}, _b$1[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b$1[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
  var dimName = dimsDef[0].name;
  var col = rawData[dimName];
  return col ? col.length : 0;
}, _b$1[SOURCE_FORMAT_ORIGINAL] = countSimply, _b$1);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property2) {
  return dataItem[dimIndex];
};
var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property2) {
  return dataItem[property2];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property2) {
  var value = getDataItemValue(dataItem);
  return !(value instanceof Array) ? value : value[dimIndex];
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(sourceFormat) {
  var method = rawSourceValueGetterMap[sourceFormat];
  return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
  if (!data) {
    return;
  }
  var dataItem = data.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  var store = data.getStore();
  var sourceFormat = store.getSource().sourceFormat;
  if (dim != null) {
    var dimIndex = data.getDimensionIndex(dim);
    var property2 = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property2);
  } else {
    var result = dataItem;
    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }
    return result;
  }
}
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = function() {
  function DataFormatMixin2() {
  }
  DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name = data.getName(dataIndex);
    var itemOpt = data.getRawDataItem(dataIndex);
    var style = data.getItemVisual(dataIndex, "style");
    var color2 = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
    var borderColor = style && style.stroke;
    var mainType = this.mainType;
    var isSeries2 = mainType === "series";
    var userOutput = data.userOutput && data.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries2 ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries2 ? this.id : null,
      seriesName: isSeries2 ? this.name : null,
      name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color: color2,
      borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      $vars: ["seriesName", "name", "value"]
    };
  };
  DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter2, extendParams) {
    status = status || "normal";
    var data = this.getData(dataType);
    var params = this.getDataParams(dataIndex, dataType);
    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }
    if (labelDimIndex != null && isArray$4(params.value)) {
      params.value = params.value[labelDimIndex];
    }
    if (!formatter2) {
      var itemModel = data.getItemModel(dataIndex);
      formatter2 = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
    }
    if (isFunction$2(formatter2)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter2(params);
    } else if (isString$2(formatter2)) {
      var str = formatTpl(formatter2, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
        var len2 = dimStr.length;
        var dimLoose = dimStr;
        if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
          dimLoose = +dimLoose.slice(1, len2 - 1);
        }
        var val = retrieveRawValue(data, dataIndex, dimLoose);
        if (extendParams && isArray$4(extendParams.interpolatedValue)) {
          var dimIndex = data.getDimensionIndex(dimLoose);
          if (dimIndex >= 0) {
            val = extendParams.interpolatedValue[dimIndex];
          }
        }
        return val != null ? val + "" : "";
      });
    }
  };
  DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  };
  DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return;
  };
  return DataFormatMixin2;
}();
function normalizeTooltipFormatResult(result) {
  var markupText;
  var markupFragment;
  if (isObject$9(result)) {
    if (result.type) {
      markupFragment = result;
    }
  } else {
    markupText = result;
  }
  return {
    text: markupText,
    frag: markupFragment
  };
}
function createTask(define) {
  return new Task(define);
}
var Task = function() {
  function Task2(define) {
    define = define || {};
    this._reset = define.reset;
    this._plan = define.plan;
    this._count = define.count;
    this._onDirty = define.onDirty;
    this._dirty = true;
  }
  Task2.prototype.perform = function(performArgs) {
    var upTask = this._upstream;
    var skip = performArgs && performArgs.skip;
    if (this._dirty && upTask) {
      var context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }
    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }
    var planResult;
    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    }
    var lastModBy = normalizeModBy(this._modBy);
    var lastModDataCount = this._modDataCount || 0;
    var modBy = normalizeModBy(performArgs && performArgs.modBy);
    var modDataCount = performArgs && performArgs.modDataCount || 0;
    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = "reset";
    }
    function normalizeModBy(val) {
      !(val >= 1) && (val = 1);
      return val;
    }
    var forceFirstProgress;
    if (this._dirty || planResult === "reset") {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }
    this._modBy = modBy;
    this._modDataCount = modDataCount;
    var step = performArgs && performArgs.step;
    if (upTask) {
      this._dueEnd = upTask._outputDueEnd;
    } else {
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    }
    if (this._progress) {
      var start2 = this._dueIndex;
      var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
      if (!skip && (forceFirstProgress || start2 < end2)) {
        var progress = this._progress;
        if (isArray$4(progress)) {
          for (var i = 0; i < progress.length; i++) {
            this._doProgress(progress[i], start2, end2, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start2, end2, modBy, modDataCount);
        }
      }
      this._dueIndex = end2;
      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
      this._outputDueEnd = outputDueEnd;
    } else {
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }
    return this.unfinished();
  };
  Task2.prototype.dirty = function() {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  };
  Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
    iterator.reset(start2, end2, modBy, modDataCount);
    this._callingProgress = progress;
    this._callingProgress({
      start: start2,
      end: end2,
      count: end2 - start2,
      next: iterator.next
    }, this.context);
  };
  Task2.prototype._doReset = function(skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    var progress;
    var forceFirstProgress;
    if (!skip && this._reset) {
      progress = this._reset(this.context);
      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      }
      if (isArray$4(progress) && !progress.length) {
        progress = null;
      }
    }
    this._progress = progress;
    this._modBy = this._modDataCount = null;
    var downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  };
  Task2.prototype.unfinished = function() {
    return this._progress && this._dueIndex < this._dueEnd;
  };
  Task2.prototype.pipe = function(downTask) {
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  };
  Task2.prototype.dispose = function() {
    if (this._disposed) {
      return;
    }
    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  };
  Task2.prototype.getUpstream = function() {
    return this._upstream;
  };
  Task2.prototype.getDownstream = function() {
    return this._downstream;
  };
  Task2.prototype.setOutputEnd = function(end2) {
    this._outputDueEnd = this._settedOutputEnd = end2;
  };
  return Task2;
}();
var iterator = function() {
  var end2;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it = {
    reset: function(s2, e2, sStep, sCount) {
      current = s2;
      end2 = e2;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;
  function sequentialNext() {
    return current < end2 ? current++ : null;
  }
  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();
function parseDataValue(value, opt) {
  var dimType = opt && opt.type;
  if (dimType === "ordinal") {
    return value;
  }
  if (dimType === "time" && !isNumber$1(value) && value != null && value !== "-") {
    value = +parseDate(value);
  }
  return value == null || value === "" ? NaN : +value;
}
createHashMap({
  "number": function(val) {
    return parseFloat(val);
  },
  "time": function(val) {
    return +parseDate(val);
  },
  "trim": function(val) {
    return isString$2(val) ? trim$1(val) : val;
  }
});
var SortOrderComparator = function() {
  function SortOrderComparator2(order2, incomparable) {
    var isDesc = order2 === "desc";
    this._resultLT = isDesc ? 1 : -1;
    if (incomparable == null) {
      incomparable = isDesc ? "min" : "max";
    }
    this._incomparable = incomparable === "min" ? -Infinity : Infinity;
  }
  SortOrderComparator2.prototype.evaluate = function(lval, rval) {
    var lvalFloat = isNumber$1(lval) ? lval : numericToNumber(lval);
    var rvalFloat = isNumber$1(rval) ? rval : numericToNumber(rval);
    var lvalNotNumeric = isNaN(lvalFloat);
    var rvalNotNumeric = isNaN(rvalFloat);
    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }
    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }
    if (lvalNotNumeric && rvalNotNumeric) {
      var lvalIsStr = isString$2(lval);
      var rvalIsStr = isString$2(rval);
      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }
      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }
    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  };
  return SortOrderComparator2;
}();
var ExternalSource = function() {
  function ExternalSource2() {
  }
  ExternalSource2.prototype.getRawData = function() {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.cloneRawData = function() {
    return;
  };
  ExternalSource2.prototype.getDimensionInfo = function(dim) {
    return;
  };
  ExternalSource2.prototype.cloneAllDimensionInfo = function() {
    return;
  };
  ExternalSource2.prototype.count = function() {
    return;
  };
  ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
    return;
  };
  ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
    return;
  };
  ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  };
  return ExternalSource2;
}();
function createExternalSource(internalSource, externalTransform) {
  var extSource = new ExternalSource();
  var data = internalSource.data;
  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  var sourceHeaderCount = internalSource.startIndex;
  var errMsg = "";
  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    throwError$1(errMsg);
  }
  var dimensions = [];
  var dimsByName = {};
  var dimsDef = internalSource.dimensionsDefine;
  if (dimsDef) {
    each$e(dimsDef, function(dimDef, idx) {
      var name = dimDef.name;
      var dimDefExt = {
        index: idx,
        name,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt);
      if (name != null) {
        var errMsg_1 = "";
        if (hasOwn$1(dimsByName, name)) {
          throwError$1(errMsg_1);
        }
        dimsByName[name] = dimDefExt;
      }
    });
  } else {
    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
      dimensions.push({
        index: i
      });
    }
  }
  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function(dataIndex) {
      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    };
    extSource.getRawData = bind$1(getRawData, null, internalSource);
  }
  extSource.cloneRawData = bind$1(cloneRawData, null, internalSource);
  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind$1(rawCounter, null, data, sourceHeaderCount, dimensions);
  var rawValueGetter = getRawSourceValueGetter(sourceFormat);
  extSource.retrieveValue = function(dataIndex, dimIndex) {
    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };
  var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }
    var dimDef = dimensions[dimIndex];
    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };
  extSource.getDimensionInfo = bind$1(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind$1(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}
function getRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    throwError$1(errMsg);
  }
  return upstream.data;
}
function cloneRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  var data = upstream.data;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    throwError$1(errMsg);
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var result = [];
    for (var i = 0, len2 = data.length; i < len2; i++) {
      result.push(data[i].slice());
    }
    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var result = [];
    for (var i = 0, len2 = data.length; i < len2; i++) {
      result.push(extend$3({}, data[i]));
    }
    return result;
  }
}
function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  }
  if (isNumber$1(dim) || !isNaN(dim) && !hasOwn$1(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn$1(dimsByName, dim)) {
    return dimsByName[dim];
  }
}
function cloneAllDimensionInfo(dimensions) {
  return clone$3(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone$3(externalTransform);
  var type = externalTransform.type;
  var errMsg = "";
  if (!type) {
    throwError$1(errMsg);
  }
  var typeParsed = type.split(":");
  if (typeParsed.length !== 2) {
    throwError$1(errMsg);
  }
  var isBuiltIn = false;
  if (typeParsed[0] === "echarts") {
    type = typeParsed[1];
    isBuiltIn = true;
  }
  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  var pipedTransOption = normalizeToArray(rawTransOption);
  var pipeLen = pipedTransOption.length;
  var errMsg = "";
  if (!pipeLen) {
    throwError$1(errMsg);
  }
  for (var i = 0, len2 = pipeLen; i < len2; i++) {
    var transOption = pipedTransOption[i];
    sourceList = applySingleDataTransform(transOption, sourceList);
    if (i !== len2 - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }
  return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
  var errMsg = "";
  if (!upSourceList.length) {
    throwError$1(errMsg);
  }
  if (!isObject$9(transOption)) {
    throwError$1(errMsg);
  }
  var transType = transOption.type;
  var externalTransform = externalTransformMap.get(transType);
  if (!externalTransform) {
    throwError$1(errMsg);
  }
  var extUpSourceList = map$1(upSourceList, function(upSource) {
    return createExternalSource(upSource, externalTransform);
  });
  var resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone$3(transOption.config)
  }));
  return map$1(resultList, function(result, resultIndex) {
    var errMsg2 = "";
    if (!isObject$9(result)) {
      throwError$1(errMsg2);
    }
    if (!result.data) {
      throwError$1(errMsg2);
    }
    var sourceFormat = detectSourceFormat(result.data);
    if (!isSupportedSourceFormat(sourceFormat)) {
      throwError$1(errMsg2);
    }
    var resultMetaRawOption;
    var firstUpSource = upSourceList[0];
    if (firstUpSource && resultIndex === 0 && !result.dimensions) {
      var startIndex = firstUpSource.startIndex;
      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }
    return createSource(result.data, resultMetaRawOption, null);
  });
}
function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
var dataCtors = {
  "float": CtorFloat64Array,
  "int": CtorInt32Array$1,
  "ordinal": Array,
  "number": Array,
  "time": CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
  var Ctor = originalChunk.constructor;
  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end2, append2) {
  var DataCtor = dataCtors[dimType || "float"];
  if (append2) {
    var oldStore = store[dimIdx];
    var oldLen = oldStore && oldStore.length;
    if (!(oldLen === end2)) {
      var newStore = new DataCtor(end2);
      for (var j = 0; j < oldLen; j++) {
        newStore[j] = oldStore[j];
      }
      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end2);
  }
}
var DataStore = function() {
  function DataStore2() {
    this._chunks = [];
    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
    this._provider = provider;
    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    var source = provider.getSource();
    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
    this._dimValueGetter = dimValueGetter || defaultGetter;
    this._rawExtent = [];
    shouldRetrieveDataByName(source);
    this._dimensions = map$1(inputDimensions, function(dim) {
      return {
        type: dim.type,
        property: dim.property
      };
    });
    this._initDataFromProvider(0, provider.count());
  };
  DataStore2.prototype.getProvider = function() {
    return this._provider;
  };
  DataStore2.prototype.getSource = function() {
    return this._provider.getSource();
  };
  DataStore2.prototype.ensureCalculationDimension = function(dimName, type) {
    var calcDimNameToIdx = this._calcDimNameToIdx;
    var dimensions = this._dimensions;
    var calcDimIdx = calcDimNameToIdx.get(dimName);
    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }
    dimensions[calcDimIdx] = {
      type
    };
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  };
  DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
    var chunk = this._chunks[dimIdx];
    var dim = this._dimensions[dimIdx];
    var rawExtents = this._rawExtent;
    var offset2 = dim.ordinalOffset || 0;
    var len2 = chunk.length;
    if (offset2 === 0) {
      rawExtents[dimIdx] = getInitialExtent();
    }
    var dimRawExtent = rawExtents[dimIdx];
    for (var i = offset2; i < len2; i++) {
      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
      if (!isNaN(val)) {
        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
      }
    }
    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len2;
    dim.type = "ordinal";
  };
  DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
    var dimInfo = this._dimensions[dimIdx];
    var ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  };
  DataStore2.prototype.getDimensionProperty = function(dimIndex) {
    var item = this._dimensions[dimIndex];
    return item && item.property;
  };
  DataStore2.prototype.appendData = function(data) {
    var provider = this._provider;
    var start2 = this.count();
    provider.appendData(data);
    var end2 = provider.count();
    if (!provider.persistent) {
      end2 += start2;
    }
    if (start2 < end2) {
      this._initDataFromProvider(start2, end2, true);
    }
    return [start2, end2];
  };
  DataStore2.prototype.appendValues = function(values, minFillLen) {
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start2 = this.count();
    var end2 = start2 + Math.max(values.length, minFillLen || 0);
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      prepareStore(chunks, i, dim.type, end2, true);
    }
    var emptyDataItem = [];
    for (var idx = start2; idx < end2; idx++) {
      var sourceIdx = idx - start2;
      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
        var dim = dimensions[dimIdx];
        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val;
        var dimRawExtent = rawExtent[dimIdx];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
    }
    this._rawCount = this._count = end2;
    return {
      start: start2,
      end: end2
    };
  };
  DataStore2.prototype._initDataFromProvider = function(start2, end2, append2) {
    var provider = this._provider;
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var dimNames = map$1(dimensions, function(dim2) {
      return dim2.property;
    });
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      if (!rawExtent[i]) {
        rawExtent[i] = getInitialExtent();
      }
      prepareStore(chunks, i, dim.type, end2, append2);
    }
    if (provider.fillStorage) {
      provider.fillStorage(start2, end2, chunks, rawExtent);
    } else {
      var dataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        dataItem = provider.getItem(idx, dataItem);
        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          var dimStorage = chunks[dimIdx];
          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
          dimStorage[idx] = val;
          var dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
    }
    if (!provider.persistent && provider.clean) {
      provider.clean();
    }
    this._rawCount = this._count = end2;
    this._extent = [];
  };
  DataStore2.prototype.count = function() {
    return this._count;
  };
  DataStore2.prototype.get = function(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  };
  DataStore2.prototype.getValues = function(dimensions, idx) {
    var values = [];
    var dimArr = [];
    if (idx == null) {
      idx = dimensions;
      dimensions = [];
      for (var i = 0; i < this._dimensions.length; i++) {
        dimArr.push(i);
      }
    } else {
      dimArr = dimensions;
    }
    for (var i = 0, len2 = dimArr.length; i < len2; i++) {
      values.push(this.get(dimArr[i], idx));
    }
    return values;
  };
  DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  };
  DataStore2.prototype.getSum = function(dim) {
    var dimData = this._chunks[dim];
    var sum = 0;
    if (dimData) {
      for (var i = 0, len2 = this.count(); i < len2; i++) {
        var value = this.get(dim, i);
        if (!isNaN(value)) {
          sum += value;
        }
      }
    }
    return sum;
  };
  DataStore2.prototype.getMedian = function(dim) {
    var dimDataArray = [];
    this.each([dim], function(val) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    });
    var sortedDimDataArray = dimDataArray.sort(function(a2, b2) {
      return a2 - b2;
    });
    var len2 = this.count();
    return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
  };
  DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    var indices = this._indices;
    var rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    var left2 = 0;
    var right2 = this._count - 1;
    while (left2 <= right2) {
      var mid = (left2 + right2) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left2 = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right2 = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  };
  DataStore2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    var chunks = this._chunks;
    var dimData = chunks[dim];
    var nearestIndices = [];
    if (!dimData) {
      return nearestIndices;
    }
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0;
    for (var i = 0, len2 = this.count(); i < len2; i++) {
      var dataIndex = this.getRawIndex(i);
      var diff = value - dimData[dataIndex];
      var dist2 = Math.abs(diff);
      if (dist2 <= maxDistance) {
        if (dist2 < minDist || dist2 === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff;
          nearestIndicesLen = 0;
        }
        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = i;
        }
      }
    }
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };
  DataStore2.prototype.getIndices = function() {
    var newIndices;
    var indices = this._indices;
    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (var i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());
      for (var i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }
    return newIndices;
  };
  DataStore2.prototype.filter = function(dims, cb) {
    if (!this._count) {
      return this;
    }
    var newStore = this.clone();
    var count2 = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(count2);
    var value = [];
    var dimSize = dims.length;
    var offset2 = 0;
    var dim0 = dims[0];
    var chunks = newStore._chunks;
    for (var i = 0; i < count2; i++) {
      var keep = void 0;
      var rawIdx = newStore.getRawIndex(i);
      if (dimSize === 0) {
        keep = cb(i);
      } else if (dimSize === 1) {
        var val = chunks[dim0][rawIdx];
        keep = cb(val, i);
      } else {
        var k = 0;
        for (; k < dimSize; k++) {
          value[k] = chunks[dims[k]][rawIdx];
        }
        value[k] = i;
        keep = cb.apply(null, value);
      }
      if (keep) {
        newIndices[offset2++] = rawIdx;
      }
    }
    if (offset2 < count2) {
      newStore._indices = newIndices;
    }
    newStore._count = offset2;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.selectRange = function(range) {
    var newStore = this.clone();
    var len2 = newStore._count;
    if (!len2) {
      return this;
    }
    var dims = keys$1(range);
    var dimSize = dims.length;
    if (!dimSize) {
      return this;
    }
    var originalCount = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(originalCount);
    var offset2 = 0;
    var dim0 = dims[0];
    var min3 = range[dim0][0];
    var max3 = range[dim0][1];
    var storeArr = newStore._chunks;
    var quickFinished = false;
    if (!newStore._indices) {
      var idx = 0;
      if (dimSize === 1) {
        var dimStorage = storeArr[dims[0]];
        for (var i = 0; i < len2; i++) {
          var val = dimStorage[i];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset2++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = storeArr[dims[0]];
        var dimStorage2 = storeArr[dims[1]];
        var min22 = range[dims[1]][0];
        var max22 = range[dims[1]][1];
        for (var i = 0; i < len2; i++) {
          var val = dimStorage[i];
          var val2 = dimStorage2[i];
          if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min22 && val2 <= max22 || isNaN(val2))) {
            newIndices[offset2++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i = 0; i < originalCount; i++) {
          var rawIndex = newStore.getRawIndex(i);
          var val = storeArr[dims[0]][rawIndex];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset2++] = rawIndex;
          }
        }
      } else {
        for (var i = 0; i < originalCount; i++) {
          var keep = true;
          var rawIndex = newStore.getRawIndex(i);
          for (var k = 0; k < dimSize; k++) {
            var dimk = dims[k];
            var val = storeArr[dimk][rawIndex];
            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset2++] = newStore.getRawIndex(i);
          }
        }
      }
    }
    if (offset2 < originalCount) {
      newStore._indices = newIndices;
    }
    newStore._count = offset2;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.map = function(dims, cb) {
    var target = this.clone(dims);
    this._updateDims(target, dims, cb);
    return target;
  };
  DataStore2.prototype.modify = function(dims, cb) {
    this._updateDims(this, dims, cb);
  };
  DataStore2.prototype._updateDims = function(target, dims, cb) {
    var targetChunks = target._chunks;
    var tmpRetValue = [];
    var dimSize = dims.length;
    var dataCount = target.count();
    var values = [];
    var rawExtent = target._rawExtent;
    for (var i = 0; i < dims.length; i++) {
      rawExtent[dims[i]] = getInitialExtent();
    }
    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      var rawIndex = target.getRawIndex(dataIndex);
      for (var k = 0; k < dimSize; k++) {
        values[k] = targetChunks[dims[k]][rawIndex];
      }
      values[dimSize] = dataIndex;
      var retValue = cb && cb.apply(null, values);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (var i = 0; i < retValue.length; i++) {
          var dim = dims[i];
          var val = retValue[i];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = targetChunks[dim];
          if (dimStore) {
            dimStore[rawIndex] = val;
          }
          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }
          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
  };
  DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
    var target = this.clone([valueDimension], true);
    var targetStorage = target._chunks;
    var dimStore = targetStorage[valueDimension];
    var len2 = this.count();
    var sampledIndex = 0;
    var frameSize = Math.floor(1 / rate);
    var currentRawIndex = this.getRawIndex(0);
    var maxArea;
    var area;
    var nextRawIndex;
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
    newIndices[sampledIndex++] = currentRawIndex;
    for (var i = 1; i < len2 - 1; i += frameSize) {
      var nextFrameStart = Math.min(i + frameSize, len2 - 1);
      var nextFrameEnd = Math.min(i + frameSize * 2, len2);
      var avgX = (nextFrameEnd + nextFrameStart) / 2;
      var avgY = 0;
      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y = dimStore[rawIndex];
        if (isNaN(y)) {
          continue;
        }
        avgY += y;
      }
      avgY /= nextFrameEnd - nextFrameStart;
      var frameStart = i;
      var frameEnd = Math.min(i + frameSize, len2);
      var pointAX = i - 1;
      var pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      var firstNaNIndex = -1;
      var countNaN = 0;
      for (var idx = frameStart; idx < frameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y = dimStore[rawIndex];
        if (isNaN(y)) {
          countNaN++;
          if (firstNaNIndex < 0) {
            firstNaNIndex = rawIndex;
          }
          continue;
        }
        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
        if (area > maxArea) {
          maxArea = area;
          nextRawIndex = rawIndex;
        }
      }
      if (countNaN > 0 && countNaN < frameEnd - frameStart) {
        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
      }
      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex;
    }
    newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  };
  DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var target = this.clone([dimension], true);
    var targetStorage = target._chunks;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len2 = this.count();
    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
    var offset2 = 0;
    for (var i = 0; i < len2; i += frameSize) {
      if (frameSize > len2 - i) {
        frameSize = len2 - i;
        frameValues.length = frameSize;
      }
      for (var k = 0; k < frameSize; k++) {
        var dataIdx = this.getRawIndex(i + k);
        frameValues[k] = dimStore[dataIdx];
      }
      var value = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len2 - 1));
      dimStore[sampleFrameIdx] = value;
      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }
      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }
      newIndices[offset2++] = sampleFrameIdx;
    }
    target._count = offset2;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype.each = function(dims, cb) {
    if (!this._count) {
      return;
    }
    var dimSize = dims.length;
    var chunks = this._chunks;
    for (var i = 0, len2 = this.count(); i < len2; i++) {
      var rawIdx = this.getRawIndex(i);
      switch (dimSize) {
        case 0:
          cb(i);
          break;
        case 1:
          cb(chunks[dims[0]][rawIdx], i);
          break;
        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
          break;
        default:
          var k = 0;
          var value = [];
          for (; k < dimSize; k++) {
            value[k] = chunks[dims[k]][rawIdx];
          }
          value[k] = i;
          cb.apply(null, value);
      }
    }
  };
  DataStore2.prototype.getDataExtent = function(dim) {
    var dimData = this._chunks[dim];
    var initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    var currEnd = this.count();
    var useRaw = !this._indices;
    var dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    var min3 = dimExtent[0];
    var max3 = dimExtent[1];
    for (var i = 0; i < currEnd; i++) {
      var rawIdx = this.getRawIndex(i);
      var value = dimData[rawIdx];
      value < min3 && (min3 = value);
      value > max3 && (max3 = value);
    }
    dimExtent = [min3, max3];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  DataStore2.prototype.getRawDataItem = function(idx) {
    var rawIdx = this.getRawIndex(idx);
    if (!this._provider.persistent) {
      var val = [];
      var chunks = this._chunks;
      for (var i = 0; i < chunks.length; i++) {
        val.push(chunks[i][rawIdx]);
      }
      return val;
    } else {
      return this._provider.getItem(rawIdx);
    }
  };
  DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
    var target = new DataStore2();
    var chunks = this._chunks;
    var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
      obj[dimIdx] = true;
      return obj;
    }, {});
    if (clonedDimsMap) {
      for (var i = 0; i < chunks.length; i++) {
        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
      }
    } else {
      target._chunks = chunks;
    }
    this._copyCommonProps(target);
    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype._copyCommonProps = function(target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone$3(this._extent);
    target._rawExtent = clone$3(this._rawExtent);
  };
  DataStore2.prototype._cloneIndices = function() {
    if (this._indices) {
      var Ctor = this._indices.constructor;
      var indices = void 0;
      if (Ctor === Array) {
        var thisCount = this._indices.length;
        indices = new Ctor(thisCount);
        for (var i = 0; i < thisCount; i++) {
          indices[i] = this._indices[i];
        }
      } else {
        indices = new Ctor(this._indices);
      }
      return indices;
    }
    return null;
  };
  DataStore2.prototype._getRawIdxIdentity = function(idx) {
    return idx;
  };
  DataStore2.prototype._getRawIdx = function(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  };
  DataStore2.prototype._updateGetRawIdx = function() {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  };
  DataStore2.internalField = function() {
    function getDimValueSimply(dataItem, property2, dataIndex, dimIndex) {
      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
    }
    defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function(dataItem, property2, dataIndex, dimIndex) {
        return parseDataValue(dataItem[property2], this._dimensions[dimIndex]);
      },
      keyedColumns: getDimValueSimply,
      original: function(dataItem, property2, dataIndex, dimIndex) {
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
      },
      typedArray: function(dataItem, property2, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
  }();
  return DataStore2;
}();
var DataStore$1 = DataStore;
var SourceManager = function() {
  function SourceManager2(sourceHost) {
    this._sourceList = [];
    this._storeList = [];
    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  SourceManager2.prototype.dirty = function() {
    this._setLocalSource([], []);
    this._storeList = [];
    this._dirty = true;
  };
  SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;
    if (this._versionSignBase > 9e10) {
      this._versionSignBase = 0;
    }
  };
  SourceManager2.prototype._getVersionSign = function() {
    return this._sourceHost.uid + "_" + this._versionSignBase;
  };
  SourceManager2.prototype.prepareSource = function() {
    if (this._isDirty()) {
      this._createSource();
      this._dirty = false;
    }
  };
  SourceManager2.prototype._createSource = function() {
    this._setLocalSource([], []);
    var sourceHost = this._sourceHost;
    var upSourceMgrList = this._getUpstreamSourceManagers();
    var hasUpstream = !!upSourceMgrList.length;
    var resultSourceList;
    var upstreamSignList;
    if (isSeries(sourceHost)) {
      var seriesModel = sourceHost;
      var data = void 0;
      var sourceFormat = void 0;
      var upSource = void 0;
      if (hasUpstream) {
        var upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } else {
        data = seriesModel.get("data", true);
        sourceFormat = isTypedArray$2(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
        upstreamSignList = [];
      }
      var newMetaRawOption = this._getSourceMetaRawOption() || {};
      var upMetaRawOption = upSource && upSource.metaRawOption || {};
      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data, {
        seriesLayoutBy,
        sourceHeader,
        dimensions
      }, sourceFormat)] : [];
    } else {
      var datasetModel = sourceHost;
      if (hasUpstream) {
        var result = this._applyTransform(upSourceMgrList);
        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } else {
        var sourceData = datasetModel.get("source", true);
        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
        upstreamSignList = [];
      }
    }
    this._setLocalSource(resultSourceList, upstreamSignList);
  };
  SourceManager2.prototype._applyTransform = function(upMgrList) {
    var datasetModel = this._sourceHost;
    var transformOption = datasetModel.get("transform", true);
    var fromTransformResult = datasetModel.get("fromTransformResult", true);
    if (fromTransformResult != null) {
      var errMsg = "";
      if (upMgrList.length !== 1) {
        doThrow(errMsg);
      }
    }
    var sourceList;
    var upSourceList = [];
    var upstreamSignList = [];
    each$e(upMgrList, function(upMgr) {
      upMgr.prepareSource();
      var upSource = upMgr.getSource(fromTransformResult || 0);
      var errMsg2 = "";
      if (fromTransformResult != null && !upSource) {
        doThrow(errMsg2);
      }
      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });
    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {
        datasetIndex: datasetModel.componentIndex
      });
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }
    return {
      sourceList,
      upstreamSignList
    };
  };
  SourceManager2.prototype._isDirty = function() {
    if (this._dirty) {
      return true;
    }
    var upSourceMgrList = this._getUpstreamSourceManagers();
    for (var i = 0; i < upSourceMgrList.length; i++) {
      var upSrcMgr = upSourceMgrList[i];
      if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  };
  SourceManager2.prototype.getSource = function(sourceIndex) {
    sourceIndex = sourceIndex || 0;
    var source = this._sourceList[sourceIndex];
    if (!source) {
      var upSourceMgrList = this._getUpstreamSourceManagers();
      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }
    return source;
  };
  SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
    var schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  };
  SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
    var sourceIndex = 0;
    var storeList = this._storeList;
    var cachedStoreMap = storeList[sourceIndex];
    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }
    var cachedStore = cachedStoreMap[sourceReadKey];
    if (!cachedStore) {
      var upSourceMgr = this._getUpstreamSourceManagers()[0];
      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore$1();
        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }
      cachedStoreMap[sourceReadKey] = cachedStore;
    }
    return cachedStore;
  };
  SourceManager2.prototype._getUpstreamSourceManagers = function() {
    var sourceHost = this._sourceHost;
    if (isSeries(sourceHost)) {
      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map$1(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
        return datasetModel2.getSourceManager();
      });
    }
  };
  SourceManager2.prototype._getSourceMetaRawOption = function() {
    var sourceHost = this._sourceHost;
    var seriesLayoutBy;
    var sourceHeader;
    var dimensions;
    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
      sourceHeader = sourceHost.get("sourceHeader", true);
      dimensions = sourceHost.get("dimensions", true);
    } else if (!this._getUpstreamSourceManagers().length) {
      var model = sourceHost;
      seriesLayoutBy = model.get("seriesLayoutBy", true);
      sourceHeader = model.get("sourceHeader", true);
      dimensions = model.get("dimensions", true);
    }
    return {
      seriesLayoutBy,
      sourceHeader,
      dimensions
    };
  };
  return SourceManager2;
}();
function isSeries(sourceHost) {
  return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
  throw new Error(errMsg);
}
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipTextStyle(textStyle, renderMode) {
  var nameFontColor = textStyle.color || "#6e7079";
  var nameFontSize = textStyle.fontSize || 12;
  var nameFontWeight = textStyle.fontWeight || "400";
  var valueFontColor = textStyle.color || "#464646";
  var valueFontSize = textStyle.fontSize || 14;
  var valueFontWeight = textStyle.fontWeight || "900";
  if (renderMode === "html") {
    return {
      nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
      valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
}
var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
function createTooltipMarkup(type, option) {
  option.type = type;
  return option;
}
function isSectionFragment(frag) {
  return frag.type === "section";
}
function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    var gapLevel_1 = 0;
    var subBlockLen = frag.blocks.length;
    var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each$e(frag.blocks, function(subBlock) {
      var subGapLevel = getBlockGapLevel(subBlock);
      if (subGapLevel >= gapLevel_1) {
        gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel_1;
  }
  return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var noHeader = fragment.noHeader;
  var gaps = getGap(getBlockGapLevel(fragment));
  var subMarkupTextList = [];
  var subBlocks = fragment.blocks || [];
  assert(!subBlocks || isArray$4(subBlocks));
  subBlocks = subBlocks || [];
  var orderMode = ctx.orderMode;
  if (fragment.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    var orderMap = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (hasOwn$1(orderMap, orderMode)) {
      var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort(function(a2, b2) {
        return comparator_1.evaluate(a2.sortParam, b2.sortParam);
      });
    } else if (orderMode === "seriesDesc") {
      subBlocks.reverse();
    }
  }
  each$e(subBlocks, function(subBlock, idx) {
    var valueFormatter = fragment.valueFormatter;
    var subMarkupText2 = getBuilder(subBlock)(valueFormatter ? extend$3(extend$3({}, ctx), {
      valueFormatter
    }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
    subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
  });
  var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
  if (noHeader) {
    return subMarkupText;
  }
  var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
  var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
  if (ctx.renderMode === "richText") {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML('<div style="' + nameStyle + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
  }
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var renderMode = ctx.renderMode;
  var noName = fragment.noName;
  var noValue = fragment.noValue;
  var noMarker = !fragment.markerType;
  var name = fragment.name;
  var useUTC = ctx.useUTC;
  var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
    value = isArray$4(value) ? value : [value];
    return map$1(value, function(val, idx) {
      return makeValueReadable(val, isArray$4(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
    });
  };
  if (noName && noValue) {
    return;
  }
  var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || "#333", renderMode);
  var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
  var valueTypeOption = fragment.valueType;
  var readableValueList = noValue ? [] : valueFormatter(fragment.value);
  var valueAlignRight = !noMarker || !noName;
  var valueCloseToMarker = !noMarker && noName;
  var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
  return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment) {
    return;
  }
  var builder = getBuilder(fragment);
  var ctx = {
    useUTC,
    renderMode,
    orderMode,
    markupStyleCreator,
    valueFormatter: fragment.valueFormatter
  };
  return builder(ctx, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}
function wrapBlockHTML(encodedContent, topGap) {
  var clearfix = '<div style="clear:both"></div>';
  var marginCSS = "margin: " + topGap + "px 0 0";
  return '<div style="' + marginCSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name, leftHasMarker, style) {
  var marginCss = leftHasMarker ? "margin-left:2px" : "";
  return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  var paddingStr = valueCloseToMarker ? "10px" : "20px";
  var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
  valueList = isArray$4(valueList) ? valueList : [valueList];
  return '<span style="' + alignCSS + ";" + style + '">' + map$1(valueList, function(value) {
    return encodeHTML(value);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}
function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
  var styles2 = [style];
  var paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles2.push({
    padding: [0, 0, 0, paddingLeft],
    align: "right"
  });
  return ctx.markupStyleCreator.wrapRichTextStyle(isArray$4(values) ? values.join("  ") : values, styles2);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  var style = series.getData().getItemVisual(dataIndex, "style");
  var color2 = style[series.visualDrawType];
  return convertToColorString(color2);
}
function getPaddingFromTooltipModel(model, renderMode) {
  var padding = model.get("padding");
  return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
var TooltipMarkupStyleCreator = function() {
  function TooltipMarkupStyleCreator2() {
    this.richTextStyles = {};
    this._nextStyleNameId = getRandomIdBase();
  }
  TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
    return "__EC_aUTo_" + this._nextStyleNameId++;
  };
  TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
    var markerId = renderMode === "richText" ? this._generateStyleName() : null;
    var marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode,
      markerId
    });
    if (isString$2(marker)) {
      return marker;
    } else {
      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  };
  TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text2, styles2) {
    var finalStl = {};
    if (isArray$4(styles2)) {
      each$e(styles2, function(stl) {
        return extend$3(finalStl, stl);
      });
    } else {
      extend$3(finalStl, styles2);
    }
    var styleName = this._generateStyleName();
    this.richTextStyles[styleName] = finalStl;
    return "{" + styleName + "|" + text2 + "}";
  };
  return TooltipMarkupStyleCreator2;
}();
function defaultSeriesFormatTooltip(opt) {
  var series = opt.series;
  var dataIndex = opt.dataIndex;
  var multipleSeries = opt.multipleSeries;
  var data = series.getData();
  var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
  var tooltipDimLen = tooltipDims.length;
  var value = series.getRawValue(dataIndex);
  var isValueArr = isArray$4(value);
  var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
  var inlineValue;
  var inlineValueType;
  var subBlocks;
  var sortParam;
  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks;
    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    var dimInfo = data.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value[0] : value;
  }
  var seriesNameSpecified = isNameSpecified(series);
  var seriesName = seriesNameSpecified && series.name || "";
  var itemName = data.getName(dataIndex);
  var inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup("section", {
    header: seriesName,
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam,
    blocks: [createTooltipMarkup("nameValue", {
      markerType: "item",
      markerColor,
      name: inlineName,
      noName: !trim$1(inlineName),
      value: inlineValue,
      valueType: inlineValueType
    })].concat(subBlocks || [])
  });
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
  var data = series.getData();
  var isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
    var dimItem = data.getDimensionInfo(idx);
    return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  var inlineValues = [];
  var inlineValueTypes = [];
  var blocks = [];
  tooltipDims.length ? each$e(tooltipDims, function(dim) {
    setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
  }) : each$e(value, setEachItem);
  function setEachItem(val, dim) {
    var dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }
    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup("nameValue", {
        markerType: "subItem",
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val);
      inlineValueTypes.push(dimInfo.type);
    }
  }
  return {
    inlineValues,
    inlineValueTypes,
    blocks
  };
}
var inner$d = makeInner();
function getSelectionKey(data, dataIndex) {
  return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel = function(_super) {
  __extends(SeriesModel2, _super);
  function SeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._selectedDataIndicesMap = {};
    return _this;
  }
  SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    var sourceManager = inner$d(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    var data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;
    inner$d(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeSubType = this.subType;
    if (ComponentModel$1.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    merge(option, ecModel.getTheme().get(this.subType));
    merge(option, this.getDefaultOption());
    defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
    newSeriesOption = merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    var sourceManager = inner$d(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    var data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner$d(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.fillDataTextStyle = function(data) {
    if (data && !isTypedArray$2(data)) {
      var props2 = ["show"];
      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          defaultEmphasis(data[i], "label", props2);
        }
      }
    }
  };
  SeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return;
  };
  SeriesModel2.prototype.appendData = function(params) {
    var data = this.getRawData();
    data.appendData(params.data);
  };
  SeriesModel2.prototype.getData = function(dataType) {
    var task = getCurrentTask(this);
    if (task) {
      var data = task.context.data;
      return dataType == null ? data : data.getLinkedData(dataType);
    } else {
      return inner$d(this).data;
    }
  };
  SeriesModel2.prototype.getAllData = function() {
    var mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
      data: mainData
    }];
  };
  SeriesModel2.prototype.setData = function(data) {
    var task = getCurrentTask(this);
    if (task) {
      var context = task.context;
      context.outputData = data;
      if (task !== this.dataTask) {
        context.data = data;
      }
    }
    inner$d(this).data = data;
  };
  SeriesModel2.prototype.getEncode = function() {
    var encode = this.get("encode", true);
    if (encode) {
      return createHashMap(encode);
    }
  };
  SeriesModel2.prototype.getSourceManager = function() {
    return inner$d(this).sourceManager;
  };
  SeriesModel2.prototype.getSource = function() {
    return this.getSourceManager().getSource();
  };
  SeriesModel2.prototype.getRawData = function() {
    return inner$d(this).dataBeforeProcessed;
  };
  SeriesModel2.prototype.getColorBy = function() {
    var colorBy = this.get("colorBy");
    return colorBy || "series";
  };
  SeriesModel2.prototype.isColorBySeries = function() {
    return this.getColorBy() === "series";
  };
  SeriesModel2.prototype.getBaseAxis = function() {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  };
  SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
  };
  SeriesModel2.prototype.isAnimationEnabled = function() {
    var ecModel = this.ecModel;
    if (env$1.node && !(ecModel && ecModel.ssr)) {
      return false;
    }
    var animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return !!animationEnabled;
  };
  SeriesModel2.prototype.restoreData = function() {
    this.dataTask.dirty();
  };
  SeriesModel2.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
    var ecModel = this.ecModel;
    var color2 = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
    if (!color2) {
      color2 = ecModel.getColorFromPalette(name, scope, requestColorNum);
    }
    return color2;
  };
  SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  };
  SeriesModel2.prototype.getProgressive = function() {
    return this.get("progressive");
  };
  SeriesModel2.prototype.getProgressiveThreshold = function() {
    return this.get("progressiveThreshold");
  };
  SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  };
  SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return;
    }
    var selectedMode = this.option.selectedMode;
    var data = this.getData(dataType);
    if (selectedMode === "series" || selectedMap === "all") {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }
    for (var i = 0; i < innerDataIndices.length; i++) {
      var dataIndex = innerDataIndices[i];
      var nameOrId = getSelectionKey(data, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  };
  SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
    var tmpArr2 = [];
    for (var i = 0; i < innerDataIndices.length; i++) {
      tmpArr2[0] = innerDataIndices[i];
      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
    }
  };
  SeriesModel2.prototype.getSelectedDataIndices = function() {
    if (this.option.selectedMap === "all") {
      return [].slice.call(this.getData().getIndices());
    }
    var selectedDataIndicesMap = this._selectedDataIndicesMap;
    var nameOrIds = keys$1(selectedDataIndicesMap);
    var dataIndices = [];
    for (var i = 0; i < nameOrIds.length; i++) {
      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];
      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }
    return dataIndices;
  };
  SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return false;
    }
    var data = this.getData(dataType);
    return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
  };
  SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }
    var universalTransitionOpt = this.option.universalTransition;
    if (!universalTransitionOpt) {
      return false;
    }
    if (universalTransitionOpt === true) {
      return true;
    }
    return universalTransitionOpt && universalTransitionOpt.enabled;
  };
  SeriesModel2.prototype._innerSelect = function(data, innerDataIndices) {
    var _a2, _b2;
    var option = this.option;
    var selectedMode = option.selectedMode;
    var len2 = innerDataIndices.length;
    if (!selectedMode || !len2) {
      return;
    }
    if (selectedMode === "series") {
      option.selectedMap = "all";
    } else if (selectedMode === "multiple") {
      if (!isObject$9(option.selectedMap)) {
        option.selectedMap = {};
      }
      var selectedMap = option.selectedMap;
      for (var i = 0; i < len2; i++) {
        var dataIndex = innerDataIndices[i];
        var nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
      }
    } else if (selectedMode === "single" || selectedMode === true) {
      var lastDataIndex = innerDataIndices[len2 - 1];
      var nameOrId = getSelectionKey(data, lastDataIndex);
      option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
      this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data.getRawIndex(lastDataIndex), _b2);
    }
  };
  SeriesModel2.prototype._initSelectedMapFromData = function(data) {
    if (this.option.selectedMap) {
      return;
    }
    var dataIndices = [];
    if (data.hasItemOption) {
      data.each(function(idx) {
        var rawItem = data.getRawDataItem(idx);
        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }
    if (dataIndices.length > 0) {
      this._innerSelect(data, dataIndices);
    }
  };
  SeriesModel2.registerClass = function(clz) {
    return ComponentModel$1.registerClass(clz);
  };
  SeriesModel2.protoInitialize = function() {
    var proto2 = SeriesModel2.prototype;
    proto2.type = "series.__base__";
    proto2.seriesIndex = 0;
    proto2.ignoreStyleOnData = false;
    proto2.hasSymbolVisual = false;
    proto2.defaultSymbol = "circle";
    proto2.visualStyleAccessPath = "itemStyle";
    proto2.visualDrawType = "fill";
  }();
  return SeriesModel2;
}(ComponentModel$1);
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, ComponentModel$1);
function autoSeriesName(seriesModel) {
  var name = seriesModel.name;
  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name;
  }
}
function getSeriesAutoName(seriesModel) {
  var data = seriesModel.getRawData();
  var dataDims = data.mapDimensionsAll("seriesName");
  var nameArr = [];
  each$e(dataDims, function(dataDim) {
    var dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param, context) {
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data, seriesModel) {
  each$e(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
    data.wrapMethod(methodName, curry$1(onDataChange, seriesModel));
  });
}
function onDataChange(seriesModel, newList) {
  var task = getCurrentTask(seriesModel);
  if (task) {
    task.setOutputEnd((newList || this).count());
  }
  return newList;
}
function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    var task = pipeline.currentTask;
    if (task) {
      var agentStubMap = task.agentStubMap;
      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }
    return task;
  }
}
var SeriesModel$1 = SeriesModel;
var ComponentView = function() {
  function ComponentView2() {
    this.group = new Group$3();
    this.uid = getUID("viewComponent");
  }
  ComponentView2.prototype.init = function(ecModel, api) {
  };
  ComponentView2.prototype.render = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.dispose = function(ecModel, api) {
  };
  ComponentView2.prototype.updateView = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateLayout = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateVisual = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {
  };
  ComponentView2.prototype.eachRendered = function(cb) {
    var group = this.group;
    if (group) {
      group.traverse(cb);
    }
  };
  return ComponentView2;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var ComponentView$1 = ComponentView;
function createRenderPlanner() {
  var inner2 = makeInner();
  return function(seriesModel) {
    var fields = inner2(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = !!fields.large;
    var originalProgressive = !!fields.progressiveRender;
    var large = fields.large = !!(pipelineContext && pipelineContext.large);
    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
  };
}
var inner$c = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView = function() {
  function ChartView2() {
    this.group = new Group$3();
    this.uid = getUID("viewChart");
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {
      view: this
    };
  }
  ChartView2.prototype.init = function(ecModel, api) {
  };
  ChartView2.prototype.render = function(seriesModel, ecModel, api, payload) {
  };
  ChartView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      return;
    }
    toggleHighlight(data, payload, "emphasis");
  };
  ChartView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      return;
    }
    toggleHighlight(data, payload, "normal");
  };
  ChartView2.prototype.remove = function(ecModel, api) {
    this.group.removeAll();
  };
  ChartView2.prototype.dispose = function(ecModel, api) {
  };
  ChartView2.prototype.updateView = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.eachRendered = function(cb) {
    traverseElements(this.group, cb);
  };
  ChartView2.markUpdateMethod = function(payload, methodName) {
    inner$c(payload).updateMethod = methodName;
  };
  ChartView2.protoInitialize = function() {
    var proto2 = ChartView2.prototype;
    proto2.type = "chart";
  }();
  return ChartView2;
}();
function elSetState(el, state, highlightDigit) {
  if (el && isHighDownDispatcher(el)) {
    (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
  }
}
function toggleHighlight(data, payload, state) {
  var dataIndex = queryDataIndex(data, payload);
  var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each$e(normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function(el) {
      elSetState(el, state, highlightDigit);
    });
  }
}
enableClassExtend(ChartView);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload;
  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view2 = context.view;
  var updateMethod = payload && inner$c(payload).updateMethod;
  var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view2[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view2[methodName](seriesModel, ecModel, api, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var ChartView$1 = ChartView;
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
function throttle(fn2, delay, debounce2) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer2 = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;
  function exec() {
    lastExec = new Date().getTime();
    timer2 = null;
    fn2.apply(scope, args || []);
  }
  var cb = function() {
    var cbArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      cbArgs[_i] = arguments[_i];
    }
    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce2;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer2);
    if (thisDebounce) {
      timer2 = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer2 = setTimeout(exec, -diff);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn2 = obj[fnAttr];
  if (!fn2) {
    return;
  }
  var originFn = fn2[ORIGIN_METHOD] || fn2;
  var lastThrottleType = fn2[THROTTLE_TYPE];
  var lastRate = fn2[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn2 = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
    fn2[ORIGIN_METHOD] = originFn;
    fn2[THROTTLE_TYPE] = throttleType;
    fn2[RATE] = rate;
  }
  return fn2;
}
function clear$1(obj, fnAttr) {
  var fn2 = obj[fnAttr];
  if (fn2 && fn2[ORIGIN_METHOD]) {
    fn2.clear && fn2.clear();
    obj[fnAttr] = fn2[ORIGIN_METHOD];
  }
}
var inner$b = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
  var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
  if (!styleMapper) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return defaultStyleMappers.itemStyle;
  }
  return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
  var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
  if (!colorKey) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return "fill";
  }
  return colorKey;
}
var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var styleModel = seriesModel.getModel(stylePath);
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var globalStyle = getStyle2(styleModel);
    var decalOption = styleModel.getShallow("decal");
    if (decalOption) {
      data.setVisual("decal", decalOption);
      decalOption.dirty = true;
    }
    var colorKey = getDefaultColorKey(seriesModel, stylePath);
    var color2 = globalStyle[colorKey];
    var colorCallback = isFunction$2(color2) ? color2 : null;
    var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      var colorPalette2 = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette2;
        data.setVisual("colorFromPalette", true);
      }
      globalStyle.fill = globalStyle.fill === "auto" || isFunction$2(globalStyle.fill) ? colorPalette2 : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === "auto" || isFunction$2(globalStyle.stroke) ? colorPalette2 : globalStyle.stroke;
    }
    data.setVisual("style", globalStyle);
    data.setVisual("drawType", colorKey);
    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data.setVisual("colorFromPalette", false);
      return {
        dataEach: function(data2, idx) {
          var dataParams = seriesModel.getDataParams(idx);
          var itemStyle = extend$3({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data2.setItemVisual(idx, "style", itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model$1();
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var colorKey = data.getVisual("drawType");
    return {
      dataEach: data.hasItemOption ? function(data2, idx) {
        var rawItem = data2.getRawDataItem(idx);
        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          var style = getStyle2(sharedModel);
          var existsStyle = data2.ensureUniqueItemVisual(idx, "style");
          extend$3(existsStyle, style);
          if (sharedModel.option.decal) {
            data2.setItemVisual(idx, "decal", sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }
          if (colorKey in style) {
            data2.setItemVisual(idx, "colorFromPalette", false);
          }
        }
      } : null
    };
  }
};
var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset: function(ecModel) {
    var paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var colorBy = seriesModel.getColorBy();
      if (seriesModel.isColorBySeries()) {
        return;
      }
      var key2 = seriesModel.type + "-" + colorBy;
      var colorScope = paletteScopeGroupByType.get(key2);
      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key2, colorScope);
      }
      inner$b(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var dataAll = seriesModel.getRawData();
      var idxMap = {};
      var data = seriesModel.getData();
      var colorScope = inner$b(seriesModel).scope;
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      data.each(function(idx) {
        var rawIdx = data.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      });
      dataAll.each(function(rawIdx) {
        var idx = idxMap[rawIdx];
        var fromPalette = data.getItemVisual(idx, "colorFromPalette");
        if (fromPalette) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
          var dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
        }
      });
    });
  }
};
var PI$4 = Math.PI;
function defaultLoading(api, opts) {
  opts = opts || {};
  defaults$1(opts, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: true,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var group = new Group$3();
  var mask = new Rect$2({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask);
  var textContent = new ZRText$1({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new Rect$2({
    style: {
      fill: "none"
    },
    textContent,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  var arc;
  if (opts.showSpinner) {
    arc = new Arc$1({
      shape: {
        startAngle: -PI$4 / 2,
        endAngle: -PI$4 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc.animateShape(true).when(1e3, {
      endAngle: PI$4 * 3 / 2
    }).start("circularInOut");
    arc.animateShape(true).when(1e3, {
      startAngle: PI$4 * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc);
  }
  group.resize = function() {
    var textWidth = textContent.getBoundingRect().width;
    var r = opts.showSpinner ? opts.spinnerRadius : 0;
    var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
    var cy = api.getHeight() / 2;
    opts.showSpinner && arc.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  group.resize();
  return group;
}
var Scheduler = function() {
  function Scheduler2(ecInstance, api, dataProcessorHandlers, visualHandlers) {
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api;
    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }
  Scheduler2.prototype.restoreData = function(ecModel, payload) {
    ecModel.restoreData(payload);
    this._stageTaskMap.each(function(taskRecord) {
      var overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  };
  Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
    if (!task.__pipeline) {
      return;
    }
    var pipeline = this._pipelineMap.get(task.__pipeline.id);
    var pCtx = pipeline.context;
    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    var step = incremental ? pipeline.step : null;
    var modDataCount = pCtx && pCtx.modDataCount;
    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {
      step,
      modBy,
      modDataCount
    };
  };
  Scheduler2.prototype.getPipeline = function(pipelineId) {
    return this._pipelineMap.get(pipelineId);
  };
  Scheduler2.prototype.updateStreamModes = function(seriesModel, view2) {
    var pipeline = this._pipelineMap.get(seriesModel.uid);
    var data = seriesModel.getData();
    var dataLen = data.count();
    var progressiveRender = pipeline.progressiveEnabled && view2.incrementalPrepareRender && dataLen >= pipeline.threshold;
    var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
    var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender,
      modDataCount,
      large
    };
  };
  Scheduler2.prototype.restorePipelines = function(ecModel) {
    var scheduler = this;
    var pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var progressive = seriesModel.getProgressive();
      var pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  };
  Scheduler2.prototype.prepareStageTasks = function() {
    var stageTaskMap = this._stageTaskMap;
    var ecModel = this.api.getModel();
    var api = this.api;
    each$e(this._allHandlers, function(handler) {
      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
      var errMsg = "";
      assert(!(handler.reset && handler.overallReset), errMsg);
      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
    }, this);
  };
  Scheduler2.prototype.prepareView = function(view2, model, ecModel, api) {
    var renderTask = view2.renderTask;
    var context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api;
    renderTask.__block = !view2.incrementalPrepareRender;
    this._pipe(model, renderTask);
  };
  Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
      block: true
    });
  };
  Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  };
  Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    var unfinished = false;
    var scheduler = this;
    each$e(stageHandlers, function(stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }
      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var overallTask = stageHandlerRecord.overallTask;
      if (overallTask) {
        var overallNeedDirty_1;
        var agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function(stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty_1 = true;
          }
        });
        overallNeedDirty_1 && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
        agentStubMap.each(function(stub) {
          stub.perform(performArgs_1);
        });
        if (overallTask.perform(performArgs_1)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function(task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }
          var performArgs = scheduler.getPerformArgs(task, opt.block);
          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);
          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });
    function needSetDirty(opt2, task) {
      return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
    }
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.performSeriesTasks = function(ecModel) {
    var unfinished;
    ecModel.eachSeries(function(seriesModel) {
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.plan = function() {
    this._pipelineMap.each(function(pipeline) {
      var task = pipeline.tail;
      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }
        task = task.getUpstream();
      } while (task);
    });
  };
  Scheduler2.prototype.updatePayload = function(task, payload) {
    payload !== "remain" && (task.context.payload = payload);
  };
  Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create2);
    } else if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, create2);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(create2);
    }
    function create2(seriesModel) {
      var pipelineId = seriesModel.uid;
      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel,
        api,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler
      };
      scheduler._pipe(seriesModel, task);
    }
  };
  Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
      reset: overallTaskReset
    });
    overallTask.context = {
      ecModel,
      api,
      overallReset: stageHandler.overallReset,
      scheduler
    };
    var oldAgentStubMap = overallTask.agentStubMap;
    var newAgentStubMap = overallTask.agentStubMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    var overallProgress = true;
    var shouldOverallTaskDirty = false;
    var errMsg = "";
    assert(!stageHandler.createOnAllSeries, errMsg);
    if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(createStub);
    } else {
      overallProgress = false;
      each$e(ecModel.getSeries(), createStub);
    }
    function createStub(seriesModel) {
      var pipelineId = seriesModel.uid;
      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      })));
      stub.context = {
        model: seriesModel,
        overallProgress
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      scheduler._pipe(seriesModel, stub);
    }
    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  };
  Scheduler2.prototype._pipe = function(seriesModel, task) {
    var pipelineId = seriesModel.uid;
    var pipeline = this._pipelineMap.get(pipelineId);
    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  };
  Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
    if (isFunction$2(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }
    stageHandler.uid = getUID("stageHandler");
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  };
  return Scheduler2;
}();
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map$1(resetDefines, function(v2, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    var data = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (var i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e2) {
  }
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, GlobalModel$1);
mockMethods(apiMock, ExtensionAPI$1);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
  seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (var name_1 in Clz.prototype) {
    target[name_1] = noop$2;
  }
}
var Scheduler$1 = Scheduler;
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
var lightTheme = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};
var contrastColor = "#B9B8CE";
var backgroundColor = "#100C2A";
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
};
var colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"];
var theme = {
  darkMode: true,
  color: colorPalette,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var darkTheme = theme;
var ECEventProcessor = function() {
  function ECEventProcessor2() {
  }
  ECEventProcessor2.prototype.normalizeQuery = function(query) {
    var cptQuery = {};
    var dataQuery = {};
    var otherQuery = {};
    if (isString$2(query)) {
      var condCptType = parseClassType(query);
      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } else {
      var suffixes_1 = ["Index", "Name", "Id"];
      var dataKeys_1 = {
        name: 1,
        dataIndex: 1,
        dataType: 1
      };
      each$e(query, function(val, key2) {
        var reserved = false;
        for (var i = 0; i < suffixes_1.length; i++) {
          var propSuffix = suffixes_1[i];
          var suffixPos = key2.lastIndexOf(propSuffix);
          if (suffixPos > 0 && suffixPos === key2.length - propSuffix.length) {
            var mainType = key2.slice(0, suffixPos);
            if (mainType !== "data") {
              cptQuery.mainType = mainType;
              cptQuery[propSuffix.toLowerCase()] = val;
              reserved = true;
            }
          }
        }
        if (dataKeys_1.hasOwnProperty(key2)) {
          dataQuery[key2] = val;
          reserved = true;
        }
        if (!reserved) {
          otherQuery[key2] = val;
        }
      });
    }
    return {
      cptQuery,
      dataQuery,
      otherQuery
    };
  };
  ECEventProcessor2.prototype.filter = function(eventType, query) {
    var eventInfo = this.eventInfo;
    if (!eventInfo) {
      return true;
    }
    var targetEl = eventInfo.targetEl;
    var packedEvent = eventInfo.packedEvent;
    var model = eventInfo.model;
    var view2 = eventInfo.view;
    if (!model || !view2) {
      return true;
    }
    var cptQuery = query.cptQuery;
    var dataQuery = query.dataQuery;
    return check2(cptQuery, model, "mainType") && check2(cptQuery, model, "subType") && check2(cptQuery, model, "index", "componentIndex") && check2(cptQuery, model, "name") && check2(cptQuery, model, "id") && check2(dataQuery, packedEvent, "name") && check2(dataQuery, packedEvent, "dataIndex") && check2(dataQuery, packedEvent, "dataType") && (!view2.filterForExposedEvent || view2.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
    function check2(query2, host, prop, propOnHost) {
      return query2[prop] == null || host[propOnHost || prop] === query2[prop];
    }
  };
  ECEventProcessor2.prototype.afterTrigger = function() {
    this.eventInfo = null;
  };
  return ECEventProcessor2;
}();
var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
var seriesSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    if (seriesModel.legendIcon) {
      data.setVisual("legendIcon", seriesModel.legendIcon);
    }
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    var symbolOptions = {};
    var symbolOptionsCb = {};
    var hasCallback = false;
    for (var i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
      var symbolPropName = SYMBOL_PROPS_WITH_CB[i];
      var val = seriesModel.get(symbolPropName);
      if (isFunction$2(val)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val;
      } else {
        symbolOptions[symbolPropName] = val;
      }
    }
    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data.setVisual(extend$3({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get("symbolKeepAspect")
    }, symbolOptions));
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var symbolPropsCb = keys$1(symbolOptionsCb);
    function dataEach(data2, idx) {
      var rawValue = seriesModel.getRawValue(idx);
      var params = seriesModel.getDataParams(idx);
      for (var i2 = 0; i2 < symbolPropsCb.length; i2++) {
        var symbolPropName2 = symbolPropsCb[i2];
        data2.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params));
      }
    }
    return {
      dataEach: hasCallback ? dataEach : null
    };
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    function dataEach(data2, idx) {
      var itemModel = data2.getItemModel(idx);
      for (var i = 0; i < SYMBOL_PROPS.length; i++) {
        var symbolPropName = SYMBOL_PROPS[i];
        var val = itemModel.getShallow(symbolPropName, true);
        if (val != null) {
          data2.setItemVisual(idx, symbolPropName, val);
        }
      }
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
function getItemVisualFromData(data, dataIndex, key2) {
  switch (key2) {
    case "color":
      var style = data.getItemVisual(dataIndex, "style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getItemVisual(dataIndex, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getItemVisual(dataIndex, key2);
  }
}
function getVisualFromData(data, key2) {
  switch (key2) {
    case "color":
      var style = data.getVisual("style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getVisual(key2);
  }
}
function setItemVisualFromData(data, dataIndex, key2, value) {
  switch (key2) {
    case "color":
      var style = data.ensureUniqueItemVisual(dataIndex, "style");
      style[data.getVisual("drawType")] = value;
      data.setItemVisual(dataIndex, "colorFromPalette", false);
      break;
    case "opacity":
      data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      data.setItemVisual(dataIndex, key2, value);
      break;
  }
}
function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    var seriesIndices = [];
    ecModel.eachComponent({
      mainType: "series",
      subType: seriesType2,
      query: payload
    }, function(seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }
  each$e([[seriesType2 + "ToggleSelect", "toggleSelect"], [seriesType2 + "Select", "select"], [seriesType2 + "UnSelect", "unselect"]], function(eventsMap) {
    ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
      payload = extend$3({}, payload);
      api.dispatchAction(extend$3(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
  var legacyEventName = type + eventPostfix;
  if (!ecIns.isSilent(legacyEventName)) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(seriesModel) {
      var seriesIndex = seriesModel.seriesIndex;
      var selectedMap = seriesModel.option.selectedMap;
      var selected = payload.selected;
      for (var i = 0; i < selected.length; i++) {
        if (selected[i].seriesIndex === seriesIndex) {
          var data = seriesModel.getData();
          var dataIndex = queryDataIndex(data, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray$4(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
            selected: isString$2(selectedMap) ? selectedMap : extend$3({}, selectedMap)
          });
        }
      }
    });
  }
}
function handleLegacySelectEvents(messageCenter, ecIns, api) {
  messageCenter.on("selectchanged", function(params) {
    var ecModel = api.getModel();
    if (params.isFromClick) {
      handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
    } else if (params.fromAction === "select") {
      handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
    } else if (params.fromAction === "unselect") {
      handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
    }
  });
}
function findEventDispatcher(target, det, returnFirstMatch) {
  var found;
  while (target) {
    if (det(target)) {
      found = target;
      if (returnFirstMatch) {
        break;
      }
    }
    target = target.__hostTarget || target.parent;
  }
  return found;
}
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap$2 = function() {
  function WeakMap2() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  WeakMap2.prototype.get = function(key2) {
    return this._guard(key2)[this._id];
  };
  WeakMap2.prototype.set = function(key2, value) {
    var target = this._guard(key2);
    if (supportDefineProperty) {
      Object.defineProperty(target, this._id, {
        value,
        enumerable: false,
        configurable: true
      });
    } else {
      target[this._id] = value;
    }
    return this;
  };
  WeakMap2.prototype["delete"] = function(key2) {
    if (this.has(key2)) {
      delete this._guard(key2)[this._id];
      return true;
    }
    return false;
  };
  WeakMap2.prototype.has = function(key2) {
    return !!this._guard(key2)[this._id];
  };
  WeakMap2.prototype._guard = function(key2) {
    if (key2 !== Object(key2)) {
      throw TypeError("Value of WeakMap is not a non-null object.");
    }
    return key2;
  };
  return WeakMap2;
}();
var WeakMap$3 = WeakMap$2;
var Triangle = Path$1.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
var Diamond = Path$1.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
var Pin = Path$1.extend({
  type: "pin",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var x2 = shape.x;
    var y = shape.y;
    var w2 = shape.width / 5 * 3;
    var h2 = Math.max(w2, shape.height);
    var r = w2 / 2;
    var dy = r * r / (h2 - r);
    var cy = y - h2 + r + dy;
    var angle = Math.asin(dy / r);
    var dx = Math.cos(angle) * r;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r * 0.6;
    var cpLen2 = r * 0.7;
    path.moveTo(x2 - dx, cy + dy);
    path.arc(x2, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x2 + dx - tanX * cpLen, cy + dy + tanY * cpLen, x2, y - cpLen2, x2, y);
    path.bezierCurveTo(x2, y - cpLen2, x2 - dx + tanX * cpLen, cy + dy + tanY * cpLen, x2 - dx, cy + dy);
    path.closePath();
  }
});
var Arrow = Path$1.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x2 = shape.x;
    var y = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x2, y);
    ctx.lineTo(x2 + dx, y + height);
    ctx.lineTo(x2, y + height / 4 * 3);
    ctx.lineTo(x2 - dx, y + height);
    ctx.lineTo(x2, y);
    ctx.closePath();
  }
});
var symbolCtors = {
  line: Line$1,
  rect: Rect$2,
  roundRect: Rect$2,
  square: Rect$2,
  circle: Circle$1,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function(x2, y, w2, h2, shape) {
    shape.x1 = x2;
    shape.y1 = y + h2 / 2;
    shape.x2 = x2 + w2;
    shape.y2 = y + h2 / 2;
  },
  rect: function(x2, y, w2, h2, shape) {
    shape.x = x2;
    shape.y = y;
    shape.width = w2;
    shape.height = h2;
  },
  roundRect: function(x2, y, w2, h2, shape) {
    shape.x = x2;
    shape.y = y;
    shape.width = w2;
    shape.height = h2;
    shape.r = Math.min(w2, h2) / 4;
  },
  square: function(x2, y, w2, h2, shape) {
    var size = Math.min(w2, h2);
    shape.x = x2;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function(x2, y, w2, h2, shape) {
    shape.cx = x2 + w2 / 2;
    shape.cy = y + h2 / 2;
    shape.r = Math.min(w2, h2) / 2;
  },
  diamond: function(x2, y, w2, h2, shape) {
    shape.cx = x2 + w2 / 2;
    shape.cy = y + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  },
  pin: function(x2, y, w2, h2, shape) {
    shape.x = x2 + w2 / 2;
    shape.y = y + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  },
  arrow: function(x2, y, w2, h2, shape) {
    shape.x = x2 + w2 / 2;
    shape.y = y + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  },
  triangle: function(x2, y, w2, h2, shape) {
    shape.cx = x2 + w2 / 2;
    shape.cy = y + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  }
};
var symbolBuildProxies = {};
each$e(symbolCtors, function(Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz$1 = Path$1.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(out2, config, rect) {
    var res = calculateTextPosition(out2, config, rect);
    var shape = this.shape;
    if (shape && shape.symbolType === "pin" && config.position === "inside") {
      res.y = rect.y + rect.height * 0.4;
    }
    return res;
  },
  buildPath: function(ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    if (symbolType !== "none") {
      var proxySymbol = symbolBuildProxies[symbolType];
      if (!proxySymbol) {
        symbolType = "rect";
        proxySymbol = symbolBuildProxies[symbolType];
      }
      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
});
function symbolPathSetColor(color2, innerColor2) {
  if (this.type !== "image") {
    var symbolStyle = this.style;
    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color2;
      symbolStyle.fill = innerColor2 || "#fff";
      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === "line") {
      symbolStyle.stroke = color2;
    } else {
      symbolStyle.fill = color2;
    }
    this.markRedraw();
  }
}
function createSymbol(symbolType, x2, y, w2, h2, color2, keepAspect) {
  var isEmpty2 = symbolType.indexOf("empty") === 0;
  if (isEmpty2) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }
  var symbolPath;
  if (symbolType.indexOf("image://") === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect$1(x2, y, w2, h2), keepAspect ? "center" : "cover");
  } else if (symbolType.indexOf("path://") === 0) {
    symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect$1(x2, y, w2, h2), keepAspect ? "center" : "cover");
  } else {
    symbolPath = new SymbolClz$1({
      shape: {
        symbolType,
        x: x2,
        y,
        width: w2,
        height: h2
      }
    });
  }
  symbolPath.__isEmptyBrush = isEmpty2;
  symbolPath.setColor = symbolPathSetColor;
  if (color2) {
    symbolPath.setColor(color2);
  }
  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray$4(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }
  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }
  if (!isArray$4(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }
  return [parsePercent(symbolOffset[0], symbolSize[0]) || 0, parsePercent(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}
function createLinearGradient(ctx, obj, rect) {
  var x2 = obj.x == null ? 0 : obj.x;
  var x22 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x2 = x2 * rect.width + rect.x;
    x22 = x22 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }
  x2 = isNaN(x2) ? 0 : x2;
  x22 = isNaN(x22) ? 1 : x22;
  y = isNaN(y) ? 0 : y;
  y2 = isNaN(y2) ? 0 : y2;
  var canvasGradient = ctx.createLinearGradient(x2, y, x22, y2);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min3 = Math.min(width, height);
  var x2 = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x2 = x2 * width + rect.x;
    y = y * height + rect.y;
    r = r * min3;
  }
  var canvasGradient = ctx.createRadialGradient(x2, y, 0, x2, y, r);
  return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
  var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
  var colorStops = obj.colorStops;
  for (var i = 0; i < colorStops.length; i++) {
    canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
  }
  return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
  return false;
}
function parseInt10(val) {
  return parseInt(val, 10);
}
function getSize$1(root2, whIdx, opts) {
  var wh = ["width", "height"][whIdx];
  var cwh = ["clientWidth", "clientHeight"][whIdx];
  var plt = ["paddingLeft", "paddingTop"][whIdx];
  var prb = ["paddingRight", "paddingBottom"][whIdx];
  if (opts[wh] != null && opts[wh] !== "auto") {
    return parseFloat(opts[wh]);
  }
  var stl = document.defaultView.getComputedStyle(root2);
  return (root2[cwh] || parseInt10(stl[wh]) || parseInt10(root2.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}
function normalizeLineDash(lineType, lineWidth) {
  if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
    return null;
  }
  return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber$1(lineType) ? [lineType] : isArray$4(lineType) ? lineType : null;
}
function getLineDash(el) {
  var style = el.style;
  var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
  var lineDashOffset = style.lineDashOffset;
  if (lineDash) {
    var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
    if (lineScale_1 && lineScale_1 !== 1) {
      lineDash = map$1(lineDash, function(rawVal) {
        return rawVal / lineScale_1;
      });
      lineDashOffset /= lineScale_1;
    }
  }
  return [lineDash, lineDashOffset];
}
var pathProxyForDraw = new PathProxy$1(true);
function styleHasStroke(style) {
  var stroke = style.stroke;
  return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
  return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
  if (style.fillOpacity != null && style.fillOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.fillOpacity * style.opacity;
    ctx.fill();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.fill();
  }
}
function doStrokePath(ctx, style) {
  if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.strokeOpacity * style.opacity;
    ctx.stroke();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.stroke();
  }
}
function createCanvasPattern(ctx, pattern, el) {
  var image = createOrUpdateImage(pattern.image, pattern.__image, el);
  if (isImageReady(image)) {
    var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
    if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
      var matrix2 = new DOMMatrix();
      matrix2.translateSelf(pattern.x || 0, pattern.y || 0);
      matrix2.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
      matrix2.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
      canvasPattern.setTransform(matrix2);
    }
    return canvasPattern;
  }
}
function brushPath(ctx, el, style, inBatch) {
  var _a2;
  var hasStroke = styleHasStroke(style);
  var hasFill = styleHasFill(style);
  var strokePercent = style.strokePercent;
  var strokePart = strokePercent < 1;
  var firstDraw = !el.path;
  if ((!el.silent || strokePart) && firstDraw) {
    el.createPathProxy();
  }
  var path = el.path || pathProxyForDraw;
  var dirtyFlag = el.__dirty;
  if (!inBatch) {
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    var fillGradient = void 0;
    var strokeGradient = void 0;
    var fillPattern = void 0;
    var strokePattern = void 0;
    var rect = void 0;
    if (hasFillGradient || hasStrokeGradient) {
      rect = el.getBoundingRect();
    }
    if (hasFillGradient) {
      fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
      el.__canvasFillGradient = fillGradient;
    }
    if (hasStrokeGradient) {
      strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
      el.__canvasStrokeGradient = strokeGradient;
    }
    if (hasFillPattern) {
      fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
      el.__canvasFillPattern = fillPattern;
    }
    if (hasStrokePattern) {
      strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
      el.__canvasStrokePattern = fillPattern;
    }
    if (hasFillGradient) {
      ctx.fillStyle = fillGradient;
    } else if (hasFillPattern) {
      if (fillPattern) {
        ctx.fillStyle = fillPattern;
      } else {
        hasFill = false;
      }
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = strokeGradient;
    } else if (hasStrokePattern) {
      if (strokePattern) {
        ctx.strokeStyle = strokePattern;
      } else {
        hasStroke = false;
      }
    }
  }
  var scale2 = el.getGlobalScale();
  path.setScale(scale2[0], scale2[1], el.segmentIgnoreThreshold);
  var lineDash;
  var lineDashOffset;
  if (ctx.setLineDash && style.lineDash) {
    _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
  }
  var needsRebuild = true;
  if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
    path.setDPR(ctx.dpr);
    if (strokePart) {
      path.setContext(null);
    } else {
      path.setContext(ctx);
      needsRebuild = false;
    }
    path.reset();
    el.buildPath(path, el.shape, inBatch);
    path.toStatic();
    el.pathUpdated();
  }
  if (needsRebuild) {
    path.rebuildPath(ctx, strokePart ? strokePercent : 1);
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
    ctx.lineDashOffset = lineDashOffset;
  }
  if (!inBatch) {
    if (style.strokeFirst) {
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
      if (hasFill) {
        doFillPath(ctx, style);
      }
    } else {
      if (hasFill) {
        doFillPath(ctx, style);
      }
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
    }
  }
  if (lineDash) {
    ctx.setLineDash([]);
  }
}
function brushImage(ctx, el, style) {
  var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
  if (!image || !isImageReady(image)) {
    return;
  }
  var x2 = style.x || 0;
  var y = style.y || 0;
  var width = el.getWidth();
  var height = el.getHeight();
  var aspect = image.width / image.height;
  if (width == null && height != null) {
    width = height * aspect;
  } else if (height == null && width != null) {
    height = width / aspect;
  } else if (width == null && height == null) {
    width = image.width;
    height = image.height;
  }
  if (style.sWidth && style.sHeight) {
    var sx = style.sx || 0;
    var sy = style.sy || 0;
    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x2, y, width, height);
  } else if (style.sx && style.sy) {
    var sx = style.sx;
    var sy = style.sy;
    var sWidth = width - sx;
    var sHeight = height - sy;
    ctx.drawImage(image, sx, sy, sWidth, sHeight, x2, y, width, height);
  } else {
    ctx.drawImage(image, x2, y, width, height);
  }
}
function brushText(ctx, el, style) {
  var _a2;
  var text2 = style.text;
  text2 != null && (text2 += "");
  if (text2) {
    ctx.font = style.font || DEFAULT_FONT;
    ctx.textAlign = style.textAlign;
    ctx.textBaseline = style.textBaseline;
    var lineDash = void 0;
    var lineDashOffset = void 0;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (style.strokeFirst) {
      if (styleHasStroke(style)) {
        ctx.strokeText(text2, style.x, style.y);
      }
      if (styleHasFill(style)) {
        ctx.fillText(text2, style.x, style.y);
      }
    } else {
      if (styleHasFill(style)) {
        ctx.fillText(text2, style.x, style.y);
      }
      if (styleHasStroke(style)) {
        ctx.strokeText(text2, style.x, style.y);
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
  var styleChanged = false;
  if (!forceSetAll) {
    prevStyle = prevStyle || {};
    if (style === prevStyle) {
      return false;
    }
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    flushPathDrawn(ctx, scope);
    styleChanged = true;
    var opacity = Math.max(Math.min(style.opacity, 1), 0);
    ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
  }
  if (forceSetAll || style.blend !== prevStyle.blend) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
  }
  for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
    var propName = SHADOW_NUMBER_PROPS[i];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = ctx.dpr * (style[propName] || 0);
    }
  }
  if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
  }
  return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
  var style = getStyle$1(el, scope.inHover);
  var prevStyle = forceSetAll ? null : prevEl && getStyle$1(prevEl, scope.inHover) || {};
  if (style === prevStyle) {
    return false;
  }
  var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
  if (forceSetAll || style.fill !== prevStyle.fill) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
  }
  if (forceSetAll || style.stroke !== prevStyle.stroke) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
  }
  if (el.hasStroke()) {
    var lineWidth = style.lineWidth;
    var newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
    if (ctx.lineWidth !== newLineWidth) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.lineWidth = newLineWidth;
    }
  }
  for (var i = 0; i < STROKE_PROPS.length; i++) {
    var prop = STROKE_PROPS[i];
    var propName = prop[0];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = style[propName] || prop[1];
    }
  }
  return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
  return bindCommonProps(ctx, getStyle$1(el, scope.inHover), prevEl && getStyle$1(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
  var m2 = el.transform;
  var dpr2 = ctx.dpr || 1;
  if (m2) {
    ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
}
function updateClipStatus(clipPaths, ctx, scope) {
  var allClipped = false;
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    allClipped = allClipped || clipPath.isZeroArea();
    setContextTransform(ctx, clipPath);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
  }
  scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
  if (m0 && m1) {
    return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
  } else if (!m0 && !m1) {
    return false;
  }
  return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
  var hasFill = styleHasFill(style);
  var hasStroke = styleHasStroke(style);
  return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
  scope.batchFill && ctx.fill();
  scope.batchStroke && ctx.stroke();
  scope.batchFill = "";
  scope.batchStroke = "";
}
function getStyle$1(el, inHover) {
  return inHover ? el.__hoverStyle || el.style : el.style;
}
function brushSingle(ctx, el) {
  brush$2(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
}
function brush$2(ctx, el, scope, isLast) {
  var m2 = el.transform;
  if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
    el.__dirty &= ~REDRAW_BIT;
    el.__isRendered = false;
    return;
  }
  var clipPaths = el.__clipPaths;
  var prevElClipPaths = scope.prevElClipPaths;
  var forceSetTransform = false;
  var forceSetStyle = false;
  if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
    if (prevElClipPaths && prevElClipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.restore();
      forceSetStyle = forceSetTransform = true;
      scope.prevElClipPaths = null;
      scope.allClipped = false;
      scope.prevEl = null;
    }
    if (clipPaths && clipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.save();
      updateClipStatus(clipPaths, ctx, scope);
      forceSetTransform = true;
    }
    scope.prevElClipPaths = clipPaths;
  }
  if (scope.allClipped) {
    el.__isRendered = false;
    return;
  }
  el.beforeBrush && el.beforeBrush();
  el.innerBeforeBrush();
  var prevEl = scope.prevEl;
  if (!prevEl) {
    forceSetStyle = forceSetTransform = true;
  }
  var canBatchPath = el instanceof Path$1 && el.autoBatch && canPathBatch(el.style);
  if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
    flushPathDrawn(ctx, scope);
    setContextTransform(ctx, el);
  } else if (!canBatchPath) {
    flushPathDrawn(ctx, scope);
  }
  var style = getStyle$1(el, scope.inHover);
  if (el instanceof Path$1) {
    if (scope.lastDrawType !== DRAW_TYPE_PATH) {
      forceSetStyle = true;
      scope.lastDrawType = DRAW_TYPE_PATH;
    }
    bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
    if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
      ctx.beginPath();
    }
    brushPath(ctx, el, style, canBatchPath);
    if (canBatchPath) {
      scope.batchFill = style.fill || "";
      scope.batchStroke = style.stroke || "";
    }
  } else {
    if (el instanceof TSpan$1) {
      if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_TEXT;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushText(ctx, el, style);
    } else if (el instanceof ZRImage$1) {
      if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_IMAGE;
      }
      bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushImage(ctx, el, style);
    } else if (el.getTemporalDisplayables) {
      if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
      }
      brushIncremental(ctx, el, scope);
    }
  }
  if (canBatchPath && isLast) {
    flushPathDrawn(ctx, scope);
  }
  el.innerAfterBrush();
  el.afterBrush && el.afterBrush();
  scope.prevEl = el;
  el.__dirty = 0;
  el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
  var displayables = el.getDisplayables();
  var temporalDisplayables = el.getTemporalDisplayables();
  ctx.save();
  var innerScope = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: false,
    viewWidth: scope.viewWidth,
    viewHeight: scope.viewHeight,
    inHover: scope.inHover
  };
  var i;
  var len2;
  for (i = el.getCursor(), len2 = displayables.length; i < len2; i++) {
    var displayable = displayables[i];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush$2(ctx, displayable, innerScope, i === len2 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
    var displayable = temporalDisplayables[i_1];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush$2(ctx, displayable, innerScope, i_1 === len_1 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  el.clearTemporalDisplayables();
  el.notClear = true;
  ctx.restore();
}
var decalMap = new WeakMap$3();
var decalCache = new LRU$1(100);
var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function createOrUpdatePatternFromDecal(decalObject, api) {
  if (decalObject === "none") {
    return null;
  }
  var dpr2 = api.getDevicePixelRatio();
  var zr = api.getZr();
  var isSVG = zr.painter.type === "svg";
  if (decalObject.dirty) {
    decalMap["delete"](decalObject);
  }
  var oldPattern = decalMap.get(decalObject);
  if (oldPattern) {
    return oldPattern;
  }
  var decalOpt = defaults$1(decalObject, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: true,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  if (decalOpt.backgroundColor === "none") {
    decalOpt.backgroundColor = null;
  }
  var pattern = {
    repeat: "repeat"
  };
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;
  function setPatternnSource(pattern2) {
    var keys2 = [dpr2];
    var isValidKey = true;
    for (var i = 0; i < decalKeys.length; ++i) {
      var value = decalOpt[decalKeys[i]];
      if (value != null && !isArray$4(value) && !isString$2(value) && !isNumber$1(value) && typeof value !== "boolean") {
        isValidKey = false;
        break;
      }
      keys2.push(value);
    }
    var cacheKey;
    if (isValidKey) {
      cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
      var cache = decalCache.get(cacheKey);
      if (cache) {
        isSVG ? pattern2.svgElement = cache : pattern2.image = cache;
      }
    }
    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    var symbolArray = normalizeSymbolArray(decalOpt.symbol);
    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    var canvas = !isSVG && platformApi.createCanvas();
    var svgRoot = isSVG && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    };
    var pSize = getPatternSize();
    var ctx;
    if (canvas) {
      canvas.width = pSize.width * dpr2;
      canvas.height = pSize.height * dpr2;
      ctx = canvas.getContext("2d");
    }
    brushDecal();
    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }
    pattern2.image = canvas;
    pattern2.svgElement = svgRoot;
    pattern2.svgWidth = pSize.width;
    pattern2.svgHeight = pSize.height;
    function getPatternSize() {
      var width = 1;
      for (var i2 = 0, xlen = lineBlockLengthsX.length; i2 < xlen; ++i2) {
        width = getLeastCommonMultiple(width, lineBlockLengthsX[i2]);
      }
      var symbolRepeats = 1;
      for (var i2 = 0, xlen = symbolArray.length; i2 < xlen; ++i2) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i2].length);
      }
      width *= symbolRepeats;
      var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
      return {
        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
      };
    }
    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
      var ySum = 0;
      for (var i2 = 0; i2 < dashArrayY.length; ++i2) {
        ySum += dashArrayY[i2];
      }
      if (ySum <= 0) {
        return;
      }
      var y = -lineBlockLengthY;
      var yId = 0;
      var yIdTotal = 0;
      var xId0 = 0;
      while (y < pSize.height) {
        if (yId % 2 === 0) {
          var symbolYId = yIdTotal / 2 % symbolArray.length;
          var x2 = 0;
          var xId1 = 0;
          var xId1Total = 0;
          while (x2 < pSize.width * 2) {
            var xSum = 0;
            for (var i2 = 0; i2 < dashArrayX[xId0].length; ++i2) {
              xSum += dashArrayX[xId0][i2];
            }
            if (xSum <= 0) {
              break;
            }
            if (xId1 % 2 === 0) {
              var size = (1 - decalOpt.symbolSize) * 0.5;
              var left2 = x2 + dashArrayX[xId0][xId1] * size;
              var top_1 = y + dashArrayY[yId] * size;
              var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              var height = dashArrayY[yId] * decalOpt.symbolSize;
              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left2, top_1, width, height, symbolArray[symbolYId][symbolXId]);
            }
            x2 += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;
            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }
          ++xId0;
          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }
        y += dashArrayY[yId];
        ++yIdTotal;
        ++yId;
        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }
      function brushSymbol(x3, y2, width2, height2, symbolType) {
        var scale2 = isSVG ? 1 : dpr2;
        var symbol = createSymbol(symbolType, x3 * scale2, y2 * scale2, width2 * scale2, height2 * scale2, decalOpt.color, decalOpt.symbolKeepAspect);
        if (isSVG) {
          var symbolVNode = zr.painter.renderOneToVNode(symbol);
          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [["rect"]];
  }
  if (isString$2(symbol)) {
    return [[symbol]];
  }
  var isAllString = true;
  for (var i = 0; i < symbol.length; ++i) {
    if (!isString$2(symbol[i])) {
      isAllString = false;
      break;
    }
  }
  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }
  var result = [];
  for (var i = 0; i < symbol.length; ++i) {
    if (isString$2(symbol[i])) {
      result.push([symbol[i]]);
    } else {
      result.push(symbol[i]);
    }
  }
  return result;
}
function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }
  if (isNumber$1(dash)) {
    var dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  var isAllNumber = true;
  for (var i = 0; i < dash.length; ++i) {
    if (!isNumber$1(dash[i])) {
      isAllNumber = false;
      break;
    }
  }
  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }
  var result = [];
  for (var i = 0; i < dash.length; ++i) {
    if (isNumber$1(dash[i])) {
      var dashValue = Math.ceil(dash[i]);
      result.push([dashValue, dashValue]);
    } else {
      var dashValue = map$1(dash[i], function(n) {
        return Math.ceil(n);
      });
      if (dashValue.length % 2 === 1) {
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }
  return result;
}
function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === "object" && dash.length === 0) {
    return [0, 0];
  }
  if (isNumber$1(dash)) {
    var dashValue_1 = Math.ceil(dash);
    return [dashValue_1, dashValue_1];
  }
  var dashValue = map$1(dash, function(n) {
    return Math.ceil(n);
  });
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
function getLineBlockLengthX(dash) {
  return map$1(dash, function(line) {
    return getLineBlockLengthY(line);
  });
}
function getLineBlockLengthY(dash) {
  var blockLength = 0;
  for (var i = 0; i < dash.length; ++i) {
    blockLength += dash[i];
  }
  if (dash.length % 2 === 1) {
    return blockLength * 2;
  }
  return blockLength;
}
function decalVisual(ecModel, api) {
  ecModel.eachRawSeries(function(seriesModel) {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    if (data.hasItemVisual()) {
      data.each(function(idx) {
        var decal2 = data.getItemVisual(idx, "decal");
        if (decal2) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api);
        }
      });
    }
    var decal = data.getVisual("decal");
    if (decal) {
      var style = data.getVisual("style");
      style.decal = createOrUpdatePatternFromDecal(decal, api);
    }
  });
}
var lifecycle = new Eventful$1();
var lifecycle$1 = lifecycle;
var implsStore = {};
function registerImpl(name, impl) {
  implsStore[name] = impl;
}
function getImpl(name) {
  return implsStore[name];
}
var hasWindow = typeof window !== "undefined";
var version = "5.3.2";
var dependencies = {
  zrender: "5.3.1"
};
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function createRegisterEventWithLowercaseMessageCenter(method) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function toLowercaseNameAndCallEventful(host, method, args) {
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful$1.prototype[method].apply(host, args);
}
var MessageCenter = function(_super) {
  __extends(MessageCenter2, _super);
  function MessageCenter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return MessageCenter2;
}(Eventful$1);
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var ECharts = function(_super) {
  __extends(ECharts2, _super);
  function ECharts2(dom, theme2, opts) {
    var _this = _super.call(this, new ECEventProcessor()) || this;
    _this._chartsViews = [];
    _this._chartsMap = {};
    _this._componentsViews = [];
    _this._componentsMap = {};
    _this._pendingActions = [];
    opts = opts || {};
    if (isString$2(theme2)) {
      theme2 = themeStorage[theme2];
    }
    _this._dom = dom;
    var defaultRenderer = "canvas";
    var defaultUseDirtyRect = false;
    var zr = _this._zr = init$1(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect
    });
    _this._ssr = opts.ssr;
    _this._throttledZrFlush = throttle(bind$1(zr.flush, zr), 17);
    theme2 = clone$3(theme2);
    theme2 && globalBackwardCompat(theme2, true);
    _this._theme = theme2;
    _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    _this._coordSysMgr = new CoordinateSystem();
    var api = _this._api = createExtensionAPI(_this);
    function prioritySortFunc(a2, b2) {
      return a2.__prio - b2.__prio;
    }
    sort$1(visualFuncs, prioritySortFunc);
    sort$1(dataProcessorFuncs, prioritySortFunc);
    _this._scheduler = new Scheduler$1(_this, api, dataProcessorFuncs, visualFuncs);
    _this._messageCenter = new MessageCenter();
    _this._initEvents();
    _this.resize = bind$1(_this.resize, _this);
    zr.animation.on("frame", _this._onframe, _this);
    bindRenderedEvent(zr, _this);
    bindMouseEvent(zr, _this);
    setAsPrimitive(_this);
    return _this;
  }
  ECharts2.prototype._onframe = function() {
    if (this._disposed) {
      return;
    }
    applyChangedStates(this);
    var scheduler = this._scheduler;
    if (this[PENDING_UPDATE]) {
      var silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;
      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e2;
      }
      this._zr.flush();
      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      var remainTime = TEST_FRAME_REMAIN_TIME;
      var ecModel = this._model;
      var api = this._api;
      scheduler.unfinished = false;
      do {
        var startTime = +new Date();
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api, "remain", {});
        remainTime -= +new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  };
  ECharts2.prototype.getDom = function() {
    return this._dom;
  };
  ECharts2.prototype.getId = function() {
    return this.id;
  };
  ECharts2.prototype.getZr = function() {
    return this._zr;
  };
  ECharts2.prototype.isSSR = function() {
    return this._ssr;
  };
  ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var silent;
    var replaceMerge;
    var transitionOpt;
    if (isObject$9(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    if (!this._model || notMerge) {
      var optionManager = new OptionManager$1(this._api);
      var theme2 = this._theme;
      var ecModel = this._model = new GlobalModel$1();
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme2, this._locale, optionManager);
    }
    this._model.setOption(option, {
      replaceMerge
    }, optionPreprocessorFuncs);
    var updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };
    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent,
        updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false;
      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e2) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
      if (!this._ssr) {
        this._zr.flush();
      }
      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  ECharts2.prototype.setTheme = function() {
  };
  ECharts2.prototype.getModel = function() {
    return this._model;
  };
  ECharts2.prototype.getOption = function() {
    return this._model && this._model.getOption();
  };
  ECharts2.prototype.getWidth = function() {
    return this._zr.getWidth();
  };
  ECharts2.prototype.getHeight = function() {
    return this._zr.getHeight();
  };
  ECharts2.prototype.getDevicePixelRatio = function() {
    return this._zr.painter.dpr || hasWindow && window.devicePixelRatio || 1;
  };
  ECharts2.prototype.getRenderedCanvas = function(opts) {
    return this.renderToCanvas(opts);
  };
  ECharts2.prototype.renderToCanvas = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  };
  ECharts2.prototype.renderToSVGString = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  };
  ECharts2.prototype.getSvgDataURL = function() {
    if (!env$1.svgSupported) {
      return;
    }
    var zr = this._zr;
    var list2 = zr.storage.getDisplayList();
    each$e(list2, function(el) {
      el.stopAnimation(null, true);
    });
    return zr.painter.toDataURL();
  };
  ECharts2.prototype.getDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self2 = this;
    each$e(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component) {
        var view2 = self2._componentsMap[component.__viewId];
        if (!view2.group.ignore) {
          excludesComponentViews.push(view2);
          view2.group.ignore = true;
        }
      });
    });
    var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each$e(excludesComponentViews, function(view2) {
      view2.group.ignore = false;
    });
    return url;
  };
  ECharts2.prototype.getConnectedDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var isSvg = opts.type === "svg";
    var groupId = this.group;
    var mathMin2 = Math.min;
    var mathMax2 = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      var left_1 = MAX_NUMBER;
      var top_1 = MAX_NUMBER;
      var right_1 = -MAX_NUMBER;
      var bottom_1 = -MAX_NUMBER;
      var canvasList_1 = [];
      var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each$e(instances, function(chart, id) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone$3(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left_1 = mathMin2(boundingRect.left, left_1);
          top_1 = mathMin2(boundingRect.top, top_1);
          right_1 = mathMax2(boundingRect.right, right_1);
          bottom_1 = mathMax2(boundingRect.bottom, bottom_1);
          canvasList_1.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left_1 *= dpr_1;
      top_1 *= dpr_1;
      right_1 *= dpr_1;
      bottom_1 *= dpr_1;
      var width = right_1 - left_1;
      var height = bottom_1 - top_1;
      var targetCanvas = platformApi.createCanvas();
      var zr_1 = init$1(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr_1.resize({
        width,
        height
      });
      if (isSvg) {
        var content_1 = "";
        each$e(canvasList_1, function(item) {
          var x2 = item.left - left_1;
          var y = item.top - top_1;
          content_1 += '<g transform="translate(' + x2 + "," + y + ')">' + item.dom + "</g>";
        });
        zr_1.painter.getSvgRoot().innerHTML = content_1;
        if (opts.connectedBackgroundColor) {
          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr_1.refreshImmediately();
        return zr_1.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr_1.add(new Rect$2({
            shape: {
              x: 0,
              y: 0,
              width,
              height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each$e(canvasList_1, function(item) {
          var img = new ZRImage$1({
            style: {
              x: item.left * dpr_1 - left_1,
              y: item.top * dpr_1 - top_1,
              image: item.dom
            }
          });
          zr_1.add(img);
        });
        zr_1.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  };
  ECharts2.prototype.convertToPixel = function(finder, value) {
    return doConvertPixel(this, "convertToPixel", finder, value);
  };
  ECharts2.prototype.convertFromPixel = function(finder, value) {
    return doConvertPixel(this, "convertFromPixel", finder, value);
  };
  ECharts2.prototype.containPixel = function(finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var ecModel = this._model;
    var result;
    var findResult = parseFinder$1(ecModel, finder);
    each$e(findResult, function(models, key2) {
      key2.indexOf("Models") >= 0 && each$e(models, function(model) {
        var coordSys = model.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value);
        } else if (key2 === "seriesModels") {
          var view2 = this._chartsMap[model.__viewId];
          if (view2 && view2.containPoint) {
            result = result || view2.containPoint(value, model);
          }
        } else
          ;
      }, this);
    }, this);
    return !!result;
  };
  ECharts2.prototype.getVisual = function(finder, visualType) {
    var ecModel = this._model;
    var parsedFinder = parseFinder$1(ecModel, finder, {
      defaultMainType: "series"
    });
    var seriesModel = parsedFinder.seriesModel;
    var data = seriesModel.getData();
    var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
  };
  ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };
  ECharts2.prototype._initEvents = function() {
    var _this = this;
    each$e(MOUSE_EVENT_NAMES, function(eveName) {
      var handler = function(e2) {
        var ecModel = _this.getModel();
        var el = e2.target;
        var params;
        var isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else {
          el && findEventDispatcher(el, function(parent2) {
            var ecData = getECData(parent2);
            if (ecData && ecData.dataIndex != null) {
              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};
              return true;
            } else if (ecData.eventData) {
              params = extend$3({}, ecData.eventData);
              return true;
            }
          }, true);
        }
        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view2 = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
          params.event = e2;
          params.type = eveName;
          _this._$eventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model,
            view: view2
          };
          _this.trigger(eveName, params);
        }
      };
      handler.zrEventfulCallAtLast = true;
      _this._zr.on(eveName, handler, _this);
    });
    each$e(eventActionMap, function(actionType, eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    each$e(["selectchanged"], function(eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    handleLegacySelectEvents(this._messageCenter, this, this._api);
  };
  ECharts2.prototype.isDisposed = function() {
    return this._disposed;
  };
  ECharts2.prototype.clear = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({
      series: []
    }, true);
  };
  ECharts2.prototype.dispose = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    var dom = this.getDom();
    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    }
    var chart = this;
    var api = chart._api;
    var ecModel = chart._model;
    each$e(chart._componentsViews, function(component) {
      component.dispose(ecModel, api);
    });
    each$e(chart._chartsViews, function(chart2) {
      chart2.dispose(ecModel, api);
    });
    chart._zr.dispose();
    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances[chart.id];
  };
  ECharts2.prototype.resize = function(opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    var ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    var needPrepare = ecModel.resetOption("media");
    var silent = opts && opts.silent;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: "resize",
        animation: extend$3({
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e2) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e2;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.showLoading = function(name, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject$9(name)) {
      cfg = name;
      name = "";
    }
    name = name || "default";
    this.hideLoading();
    if (!loadingEffects[name]) {
      return;
    }
    var el = loadingEffects[name](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  ECharts2.prototype.hideLoading = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  ECharts2.prototype.makeActionFromEvent = function(eventObj) {
    var payload = extend$3({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  ECharts2.prototype.dispatchAction = function(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject$9(opt)) {
      opt = {
        silent: !!opt
      };
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);
      return;
    }
    var silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    var flush = opt.flush;
    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env$1.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.updateLabelLayout = function() {
    lifecycle$1.trigger("series:layoutlabels", this._model, this._api, {
      updatedSeries: []
    });
  };
  ECharts2.prototype.appendData = function(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  };
  ECharts2.internalField = function() {
    prepare = function(ecIns) {
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecIns._model);
      scheduler.prepareStageTasks();
      prepareView(ecIns, true);
      prepareView(ecIns, false);
      scheduler.plan();
    };
    prepareView = function(ecIns, isComponent) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;
      for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
      }
      isComponent ? ecModel.eachComponent(function(componentType, model) {
        componentType !== "series" && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);
      function doPrepare(model) {
        var requireNewView = model.__requireNewView;
        model.__requireNewView = false;
        var viewId = "_ec_" + model.id + "_" + model.type;
        var view3 = !requireNewView && viewMap[viewId];
        if (!view3) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? ComponentView$1.getClass(classType.main, classType.sub) : ChartView$1.getClass(classType.sub);
          view3 = new Clazz();
          view3.init(ecModel, api);
          viewMap[viewId] = view3;
          viewList.push(view3);
          zr.add(view3.group);
        }
        model.__viewId = view3.__id = viewId;
        view3.__alive = true;
        view3.__model = model;
        view3.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view3, model, ecModel, api);
      }
      for (var i = 0; i < viewList.length; ) {
        var view2 = viewList[i];
        if (!view2.__alive) {
          !isComponent && view2.renderTask.dispose();
          zr.remove(view2.group);
          view2.dispose(ecModel, api);
          viewList.splice(i, 1);
          if (viewMap[view2.__id] === view2) {
            delete viewMap[view2.__id];
          }
          view2.__id = view2.group.__ecComponentInfo = null;
        } else {
          i++;
        }
      }
    };
    updateDirectly = function(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      ecModel.setUpdatePayload(payload);
      if (!mainType) {
        each$e([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
        return;
      }
      var query = {};
      query[mainType + "Id"] = payload[mainType + "Id"];
      query[mainType + "Index"] = payload[mainType + "Index"];
      query[mainType + "Name"] = payload[mainType + "Name"];
      var condition = {
        mainType,
        query
      };
      subType && (condition.subType = subType);
      var excludeSeriesId = payload.excludeSeriesId;
      var excludeSeriesIdMap;
      if (excludeSeriesId != null) {
        excludeSeriesIdMap = createHashMap();
        each$e(normalizeToArray(excludeSeriesId), function(id) {
          var modelId = convertOptionIdName(id, null);
          if (modelId != null) {
            excludeSeriesIdMap.set(modelId, true);
          }
        });
      }
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        if (isHighDownPayload(payload)) {
          if (model instanceof SeriesModel$1) {
            if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
              blurSeriesFromHighlightPayload(model, payload, ecIns._api);
            }
          } else {
            var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
            if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
              blurComponent(model.mainType, model.componentIndex, ecIns._api);
            }
            if (dispatchers) {
              each$e(dispatchers, function(dispatcher) {
                payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
              });
            }
          }
        } else if (isSelectChangePayload(payload)) {
          if (model instanceof SeriesModel$1) {
            toggleSelectionFromPayload(model, payload, ecIns._api);
            updateSeriesElementSelection(model);
            markStatusToUpdate(ecIns);
          }
        }
      }, ecIns);
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
      }, ecIns);
      function callView(view2) {
        view2 && view2.__alive && view2[method] && view2[method](view2.__model, ecModel, ecIns._api, payload);
      }
    };
    updateMethods = {
      prepareAndUpdate: function(payload) {
        prepare(this);
        updateMethods.update.call(this, payload, {
          optionChanged: payload.newOption != null
        });
      },
      update: function(payload, updateParams) {
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel);
        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload);
        updateStreamModes(this, ecModel);
        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload, updateParams);
        var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
        var darkMode = ecModel.get("darkMode");
        zr.setBackgroundColor(backgroundColor2);
        if (darkMode != null && darkMode !== "auto") {
          zr.setDarkMode(darkMode);
        }
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateTransform: function(payload) {
        var _this = this;
        var ecModel = this._model;
        var api = this._api;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        var componentDirtyList = [];
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType === "series") {
            return;
          }
          var componentView = _this.getViewOfComponentModel(componentModel);
          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        });
        renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateView: function(payload) {
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ChartView$1.markUpdateMethod(payload, "updateView");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });
        render(this, ecModel, this._api, payload, {});
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateVisual: function(payload) {
        var _this = this;
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ecModel.eachSeries(function(seriesModel) {
          seriesModel.getData().clearAllVisual();
        });
        ChartView$1.markUpdateMethod(payload, "updateVisual");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          visualType: "visual",
          setDirty: true
        });
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType !== "series") {
            var componentView = _this.getViewOfComponentModel(componentModel);
            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
          }
        });
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
        });
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateLayout: function(payload) {
        updateMethods.update.call(this, payload);
      }
    };
    doConvertPixel = function(ecIns, methodName, finder, value) {
      if (ecIns._disposed) {
        disposedWarning(ecIns.id);
        return;
      }
      var ecModel = ecIns._model;
      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
      var result;
      var parsedFinder = parseFinder$1(ecModel, finder);
      for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
          return result;
        }
      }
    };
    updateStreamModes = function(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function(seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    };
    doDispatchAction = function(payload, silent) {
      var _this = this;
      var ecModel = this.getModel();
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo2 = actionWrap.actionInfo;
      var cptTypeTmp = (actionInfo2.update || "update").split(":");
      var updateMethod = cptTypeTmp.pop();
      var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
      this[IN_MAIN_PROCESS_KEY] = true;
      var payloads = [payload];
      var batched = false;
      if (payload.batch) {
        batched = true;
        payloads = map$1(payload.batch, function(item) {
          item = defaults$1(extend$3({}, item), payload);
          item.batch = null;
          return item;
        });
      }
      var eventObjBatch = [];
      var eventObj;
      var isSelectChange = isSelectChangePayload(payload);
      var isHighDown = isHighDownPayload(payload);
      if (isHighDown) {
        allLeaveBlur(this._api);
      }
      each$e(payloads, function(batchItem) {
        eventObj = actionWrap.action(batchItem, _this._model, _this._api);
        eventObj = eventObj || extend$3({}, batchItem);
        eventObj.type = actionInfo2.event || eventObj.type;
        eventObjBatch.push(eventObj);
        if (isHighDown) {
          var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
          var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
          updateDirectly(_this, updateMethod, batchItem, componentMainType);
          markStatusToUpdate(_this);
        } else if (isSelectChange) {
          updateDirectly(_this, updateMethod, batchItem, "series");
          markStatusToUpdate(_this);
        } else if (cptType) {
          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      });
      if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
        try {
          if (this[PENDING_UPDATE]) {
            prepare(this);
            updateMethods.update.call(this, payload);
            this[PENDING_UPDATE] = null;
          } else {
            updateMethods[updateMethod].call(this, payload);
          }
        } catch (e2) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e2;
        }
      }
      if (batched) {
        eventObj = {
          type: actionInfo2.event || payloadType,
          escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }
      this[IN_MAIN_PROCESS_KEY] = false;
      if (!silent) {
        var messageCenter = this._messageCenter;
        messageCenter.trigger(eventObj.type, eventObj);
        if (isSelectChange) {
          var newObj = {
            type: "selectchanged",
            escapeConnect,
            selected: getAllSelectedIndices(ecModel),
            isFromClick: payload.isFromClick || false,
            fromAction: payload.type,
            fromActionPayload: payload
          };
          messageCenter.trigger(newObj.type, newObj);
        }
      }
    };
    flushPendingActions = function(silent) {
      var pendingActions = this._pendingActions;
      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    };
    triggerUpdatedEvent = function(silent) {
      !silent && this.trigger("updated");
    };
    bindRenderedEvent = function(zr, ecIns) {
      zr.on("rendered", function(params) {
        ecIns.trigger("rendered", params);
        if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger("finished");
        }
      });
    };
    bindMouseEvent = function(zr, ecIns) {
      zr.on("mouseover", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("mouseout", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("click", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, function(target) {
          return getECData(target).dataIndex != null;
        }, true);
        if (dispatcher) {
          var actionType = dispatcher.selected ? "unselect" : "select";
          var ecData = getECData(dispatcher);
          ecIns._api.dispatchAction({
            type: actionType,
            dataType: ecData.dataType,
            dataIndexInside: ecData.dataIndex,
            seriesIndex: ecData.seriesIndex,
            isFromClick: true
          });
        }
      });
    };
    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.clearColorPalette();
      });
    }
    function allocateZlevels(ecModel) {
      var componentZLevels = [];
      var seriesZLevels = [];
      var hasSeperateZLevel = false;
      ecModel.eachComponent(function(componentType, componentModel) {
        var zlevel = componentModel.get("zlevel") || 0;
        var z = componentModel.get("z") || 0;
        var zlevelKey = componentModel.getZLevelKey();
        hasSeperateZLevel = hasSeperateZLevel || !!zlevelKey;
        (componentType === "series" ? seriesZLevels : componentZLevels).push({
          zlevel,
          z,
          idx: componentModel.componentIndex,
          type: componentType,
          key: zlevelKey
        });
      });
      if (hasSeperateZLevel) {
        var zLevels = componentZLevels.concat(seriesZLevels);
        var lastSeriesZLevel_1;
        var lastSeriesKey_1;
        sort$1(zLevels, function(a2, b2) {
          if (a2.zlevel === b2.zlevel) {
            return a2.z - b2.z;
          }
          return a2.zlevel - b2.zlevel;
        });
        each$e(zLevels, function(item) {
          var componentModel = ecModel.getComponent(item.type, item.idx);
          var zlevel = item.zlevel;
          var key2 = item.key;
          if (lastSeriesZLevel_1 != null) {
            zlevel = Math.max(lastSeriesZLevel_1, zlevel);
          }
          if (key2) {
            if (zlevel === lastSeriesZLevel_1 && key2 !== lastSeriesKey_1) {
              zlevel++;
            }
            lastSeriesKey_1 = key2;
          } else if (lastSeriesKey_1) {
            if (zlevel === lastSeriesZLevel_1) {
              zlevel++;
            }
            lastSeriesKey_1 = "";
          }
          lastSeriesZLevel_1 = zlevel;
          componentModel.setZLevel(zlevel);
        });
      }
    }
    render = function(ecIns, ecModel, api, payload, updateParams) {
      allocateZlevels(ecModel);
      renderComponents(ecIns, ecModel, api, payload, updateParams);
      each$e(ecIns._chartsViews, function(chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload, updateParams);
      each$e(ecIns._chartsViews, function(chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    };
    renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
      each$e(dirtyList || ecIns._componentsViews, function(componentView) {
        var componentModel = componentView.__model;
        clearStates(componentModel, componentView);
        componentView.render(componentModel, ecModel, api, payload);
        updateZ2(componentModel, componentView);
        updateStates(componentModel, componentView);
      });
    };
    renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
      var scheduler = ecIns._scheduler;
      updateParams = extend$3(updateParams || {}, {
        updatedSeries: ecModel.getSeries()
      });
      lifecycle$1.trigger("series:beforeupdate", ecModel, api, updateParams);
      var unfinished = false;
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);
        clearStates(seriesModel, chartView);
        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }
        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
          unfinished = true;
        }
        chartView.group.silent = !!seriesModel.get("silent");
        updateBlend(seriesModel, chartView);
        updateSeriesElementSelection(seriesModel);
      });
      scheduler.unfinished = unfinished || scheduler.unfinished;
      lifecycle$1.trigger("series:layoutlabels", ecModel, api, updateParams);
      lifecycle$1.trigger("series:transition", ecModel, api, updateParams);
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        updateZ2(seriesModel, chartView);
        updateStates(seriesModel, chartView);
      });
      updateHoverLayerStatus(ecIns, ecModel);
      lifecycle$1.trigger("series:afterupdate", ecModel, api, updateParams);
    };
    markStatusToUpdate = function(ecIns) {
      ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
      ecIns.getZr().wakeUp();
    };
    applyChangedStates = function(ecIns) {
      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
        return;
      }
      ecIns.getZr().storage.traverse(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        applyElementStates(el);
      });
      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
    };
    function applyElementStates(el) {
      var newStates = [];
      var oldStates = el.currentStates;
      for (var i = 0; i < oldStates.length; i++) {
        var stateName = oldStates[i];
        if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
          newStates.push(stateName);
        }
      }
      if (el.selected && el.states.select) {
        newStates.push("select");
      }
      if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
        newStates.push("emphasis");
      } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
        newStates.push("blur");
      }
      el.useStates(newStates);
    }
    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage2 = zr.storage;
      var elCount = 0;
      storage2.traverse(function(el) {
        if (!el.isGroup) {
          elCount++;
        }
      });
      if (elCount > ecModel.get("hoverLayerThreshold") && !env$1.node && !env$1.worker) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.__alive) {
            chartView.eachRendered(function(el) {
              if (el.states.emphasis) {
                el.states.emphasis.hoverLayer = true;
              }
            });
          }
        });
      }
    }
    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get("blendMode") || null;
      chartView.eachRendered(function(el) {
        if (!el.isGroup) {
          el.style.blend = blendMode;
        }
      });
    }
    function updateZ2(model, view2) {
      if (model.preventAutoZ) {
        return;
      }
      var z = model.get("z") || 0;
      var zlevel = model.get("zlevel") || 0;
      view2.eachRendered(function(el) {
        doUpdateZ(el, z, zlevel, -Infinity);
        return true;
      });
    }
    function doUpdateZ(el, z, zlevel, maxZ2) {
      var label = el.getTextContent();
      var labelLine = el.getTextGuideLine();
      var isGroup = el.isGroup;
      if (isGroup) {
        var children2 = el.childrenRef();
        for (var i = 0; i < children2.length; i++) {
          maxZ2 = Math.max(doUpdateZ(children2[i], z, zlevel, maxZ2), maxZ2);
        }
      } else {
        el.z = z;
        el.zlevel = zlevel;
        maxZ2 = Math.max(el.z2, maxZ2);
      }
      if (label) {
        label.z = z;
        label.zlevel = zlevel;
        isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
      }
      if (labelLine) {
        var textGuideLineConfig = el.textGuideLineConfig;
        labelLine.z = z;
        labelLine.zlevel = zlevel;
        isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
      }
      return maxZ2;
    }
    function clearStates(model, view2) {
      view2.eachRendered(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        var textContent = el.getTextContent();
        var textGuide = el.getTextGuideLine();
        if (el.stateTransition) {
          el.stateTransition = null;
        }
        if (textContent && textContent.stateTransition) {
          textContent.stateTransition = null;
        }
        if (textGuide && textGuide.stateTransition) {
          textGuide.stateTransition = null;
        }
        if (el.hasState()) {
          el.prevStates = el.currentStates;
          el.clearStates();
        } else if (el.prevStates) {
          el.prevStates = null;
        }
      });
    }
    function updateStates(model, view2) {
      var stateAnimationModel = model.getModel("stateAnimation");
      var enableAnimation = model.isAnimationEnabled();
      var duration = stateAnimationModel.get("duration");
      var stateTransition = duration > 0 ? {
        duration,
        delay: stateAnimationModel.get("delay"),
        easing: stateAnimationModel.get("easing")
      } : null;
      view2.eachRendered(function(el) {
        if (el.states && el.states.emphasis) {
          if (isElementRemoved(el)) {
            return;
          }
          if (el instanceof Path$1) {
            savePathStates(el);
          }
          if (el.__dirty) {
            var prevStates = el.prevStates;
            if (prevStates) {
              el.useStates(prevStates);
            }
          }
          if (enableAnimation) {
            el.stateTransition = stateTransition;
            var textContent = el.getTextContent();
            var textGuide = el.getTextGuideLine();
            if (textContent) {
              textContent.stateTransition = stateTransition;
            }
            if (textGuide) {
              textGuide.stateTransition = stateTransition;
            }
          }
          if (el.__dirty) {
            applyElementStates(el);
          }
        }
      });
    }
    createExtensionAPI = function(ecIns) {
      return new (function(_super2) {
        __extends(class_1, _super2);
        function class_1() {
          return _super2 !== null && _super2.apply(this, arguments) || this;
        }
        class_1.prototype.getCoordinateSystems = function() {
          return ecIns._coordSysMgr.getCoordinateSystems();
        };
        class_1.prototype.getComponentByElement = function(el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;
            if (modelInfo != null) {
              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
            }
            el = el.parent;
          }
        };
        class_1.prototype.enterEmphasis = function(el, highlightDigit) {
          enterEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
          leaveEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterBlur = function(el) {
          enterBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveBlur = function(el) {
          leaveBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterSelect = function(el) {
          enterSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveSelect = function(el) {
          leaveSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.getModel = function() {
          return ecIns.getModel();
        };
        class_1.prototype.getViewOfComponentModel = function(componentModel) {
          return ecIns.getViewOfComponentModel(componentModel);
        };
        class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
          return ecIns.getViewOfSeriesModel(seriesModel);
        };
        return class_1;
      }(ExtensionAPI$1))(ecIns);
    };
    enableConnect = function(chart) {
      function updateConnectedChartsStatus(charts, status) {
        for (var i = 0; i < charts.length; i++) {
          var otherChart = charts[i];
          otherChart[CONNECT_STATUS_KEY] = status;
        }
      }
      each$e(eventActionMap, function(actionType, eventType) {
        chart._messageCenter.on(eventType, function(event) {
          if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }
            var action_1 = chart.makeActionFromEvent(event);
            var otherCharts_1 = [];
            each$e(instances, function(otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts_1.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
            each$e(otherCharts_1, function(otherChart) {
              if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                otherChart.dispatchAction(action_1);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
          }
        });
      });
    };
  }();
  return ECharts2;
}(Eventful$1);
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(eventName, cb, ctx) {
  var self2 = this;
  function wrapped() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    cb && cb.apply && cb.apply(this, args2);
    self2.off(eventName, wrapped);
  }
  this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function disposedWarning(id) {
}
var actions = {};
var eventActionMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = +new Date() - 0;
var groupIdBase = +new Date() - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init(dom, theme2, opts) {
  var isClient2 = !(opts && opts.ssr);
  if (isClient2) {
    var existInstance = getInstanceByDom(dom);
    if (existInstance) {
      return existInstance;
    }
  }
  var chart = new ECharts(dom, theme2, opts);
  chart.id = "ec_" + idBase++;
  instances[chart.id] = chart;
  isClient2 && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  lifecycle$1.trigger("afterinit", chart);
  return chart;
}
function connect(groupId) {
  if (isArray$4(groupId)) {
    var charts = groupId;
    groupId = null;
    each$e(charts, function(chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || "g_" + groupIdBase++;
    each$e(charts, function(chart) {
      chart.group = groupId;
    });
  }
  connectedGroups[groupId] = true;
  return groupId;
}
function disConnect(groupId) {
  connectedGroups[groupId] = false;
}
var disconnect = disConnect;
function dispose(chart) {
  if (isString$2(chart)) {
    chart = instances[chart];
  } else if (!(chart instanceof ECharts)) {
    chart = getInstanceByDom(chart);
  }
  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
function getInstanceByDom(dom) {
  return instances[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(key2) {
  return instances[key2];
}
function registerTheme(name, theme2) {
  themeStorage[name] = theme2;
}
function registerPreprocessor(preprocessorFunc) {
  if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(postInitFunc) {
  registerUpdateLifecycle("afterinit", postInitFunc);
}
function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
  lifecycle$1.on(name, cb);
}
function registerAction(actionInfo2, eventName, action) {
  if (isFunction$2(eventName)) {
    action = eventName;
    eventName = "";
  }
  var actionType = isObject$9(actionInfo2) ? actionInfo2.type : [actionInfo2, actionInfo2 = {
    event: eventName
  }][0];
  actionInfo2.event = (actionInfo2.event || actionType).toLowerCase();
  eventName = actionInfo2.event;
  if (eventActionMap[eventName]) {
    return;
  }
  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
  if (!actions[actionType]) {
    actions[actionType] = {
      action,
      actionInfo: actionInfo2
    };
  }
  eventActionMap[eventName] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
  CoordinateSystem.register(type, coordSysCreator);
}
function getCoordinateSystemDimensions(type) {
  var coordSysCreator = CoordinateSystem.get(type);
  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn2, defaultPriority, visualType) {
  if (isFunction$2(priority) || isObject$9(priority)) {
    fn2 = priority;
    priority = defaultPriority;
  }
  if (indexOf(registeredTasks, fn2) >= 0) {
    return;
  }
  registeredTasks.push(fn2);
  var stageHandler = Scheduler$1.wrapStageHandler(fn2, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn2;
  targetList.push(stageHandler);
}
function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
function setCanvasCreator(creator) {
  setPlatformAPI({
    createCanvas: creator
  });
}
function registerMap$1(mapName, geoJson, specialAreas) {
  var registerMap2 = getImpl("registerMap");
  registerMap2 && registerMap2(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
  var getMap2 = getImpl("getMap");
  return getMap2 && getMap2(mapName);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop$2);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop$2);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop$2);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop$2);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop$2);
registerTheme("light", lightTheme);
registerTheme("dark", darkTheme);
var dataTool = {};
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
  return item;
}
var DataDiffer = function() {
  function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
    this._diffModeMultiple = diffMode === "multiple";
  }
  DataDiffer2.prototype.add = function(func) {
    this._add = func;
    return this;
  };
  DataDiffer2.prototype.update = function(func) {
    this._update = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToOne = function(func) {
    this._updateManyToOne = func;
    return this;
  };
  DataDiffer2.prototype.updateOneToMany = function(func) {
    this._updateOneToMany = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToMany = function(func) {
    this._updateManyToMany = func;
    return this;
  };
  DataDiffer2.prototype.remove = function(func) {
    this._remove = func;
    return this;
  };
  DataDiffer2.prototype.execute = function() {
    this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
  };
  DataDiffer2.prototype._executeOneToOne = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var newDataIndexMap = {};
    var oldDataKeyArr = new Array(oldArr.length);
    var newDataKeyArr = new Array(newArr.length);
    this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i = 0; i < oldArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (newIdxMapValLen > 1) {
        var newIdx = newIdxMapVal.shift();
        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }
        this._update && this._update(newIdx, i);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i);
      } else {
        this._remove && this._remove(i);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._executeMultiple = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i = 0; i < oldDataKeyArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var oldIdxMapVal = oldDataIndexMap[oldKey];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
          this._remove && this._remove(oldIdxMapVal[i_1]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
    for (var i = 0; i < newDataKeyArr.length; i++) {
      var newKey = newDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[newKey];
      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (idxMapValLen > 1) {
        for (var j = 0; j < idxMapValLen; j++) {
          this._add && this._add(newIdxMapVal[j]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      }
      newDataIndexMap[newKey] = null;
    }
  };
  DataDiffer2.prototype._initIndexMap = function(arr, map2, keyArr, keyGetterName) {
    var cbModeMultiple = this._diffModeMultiple;
    for (var i = 0; i < arr.length; i++) {
      var key2 = "_ec_" + this[keyGetterName](arr[i], i);
      if (!cbModeMultiple) {
        keyArr[i] = key2;
      }
      if (!map2) {
        continue;
      }
      var idxMapVal = map2[key2];
      var idxMapValLen = dataIndexMapValueLength(idxMapVal);
      if (idxMapValLen === 0) {
        map2[key2] = i;
        if (cbModeMultiple) {
          keyArr.push(key2);
        }
      } else if (idxMapValLen === 1) {
        map2[key2] = [idxMapVal, i];
      } else {
        idxMapVal.push(i);
      }
    }
  };
  return DataDiffer2;
}();
var DataDiffer$1 = DataDiffer;
var DimensionUserOuput = function() {
  function DimensionUserOuput2(encode, dimRequest) {
    this._encode = encode;
    this._schema = dimRequest;
  }
  DimensionUserOuput2.prototype.get = function() {
    return {
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  };
  DimensionUserOuput2.prototype._getFullDimensionNames = function() {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }
    return this._cachedDimNames;
  };
  return DimensionUserOuput2;
}();
function summarizeDimensions(data, schema) {
  var summary = {};
  var encode = summary.encode = {};
  var notExtraCoordDimMap = createHashMap();
  var defaultedLabel = [];
  var defaultedTooltip = [];
  var userOutputEncode = {};
  each$e(data.dimensions, function(dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var coordDim = dimItem.coordDim;
    if (coordDim) {
      var coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1);
        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
      }
      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }
    VISUAL_DIMENSIONS.each(function(v2, otherDim) {
      var encodeArr = getOrCreateEncodeArr(encode, otherDim);
      var dimIndex = dimItem.otherDims[otherDim];
      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  var dataDimsOnCoord = [];
  var encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function(v2, coordDim) {
    var dimArr = encode[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0];
    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map$1(dataDimsOnCoord, function(dimName) {
    return data.getDimensionInfo(dimName).storeDimIndex;
  });
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  var encodeLabel = encode.label;
  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }
  var encodeTooltip = encode.tooltip;
  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }
  encode.defaultedLabel = defaultedLabel;
  encode.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}
function getOrCreateEncodeArr(encode, dim) {
  if (!encode.hasOwnProperty(dim)) {
    encode[dim] = [];
  }
  return encode[dim];
}
function getDimensionTypeByAxis(axisType) {
  return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
  return !(dimType === "ordinal" || dimType === "time");
}
var SeriesDimensionDefine = function() {
  function SeriesDimensionDefine2(opt) {
    this.otherDims = {};
    if (opt != null) {
      extend$3(this, opt);
    }
  }
  return SeriesDimensionDefine2;
}();
var SeriesDimensionDefine$1 = SeriesDimensionDefine;
var inner$a = makeInner();
var dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
};
var SeriesDataSchema = function() {
  function SeriesDataSchema2(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;
    this._updateDimOmitted(opt.dimensionOmitted);
  }
  SeriesDataSchema2.prototype.isDimensionOmitted = function() {
    return this._dimOmitted;
  };
  SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;
    if (!dimensionOmitted) {
      return;
    }
    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  };
  SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  };
  SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
    var dimensionsDefine = this.source.dimensionsDefine;
    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  };
  SeriesDataSchema2.prototype.makeStoreSchema = function() {
    var dimCount = this._fullDimCount;
    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
    var dimHash = "";
    var dims = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
      var property2 = void 0;
      var type = void 0;
      var ordinalMeta = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property2 = willRetrieveDataByName ? seriesDimDef.name : null;
        type = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          property2 = willRetrieveDataByName ? sourceDimDef.name : null;
          type = sourceDimDef.type;
        }
      }
      dims.push({
        property: property2,
        type,
        ordinalMeta
      });
      if (willRetrieveDataByName && property2 != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict ? property2.replace(/\`/g, "`1").replace(/\$/g, "`2") : property2;
      }
      dimHash += "$";
      dimHash += dimTypeShort[type] || "f";
      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }
      dimHash += "$";
    }
    var source = this.source;
    var hash2 = [source.seriesLayoutBy, source.startIndex, dimHash].join("$$");
    return {
      dimensions: dims,
      hash: hash2
    };
  };
  SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
    var result = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
      var name_1 = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name_1 = seriesDimDef.name;
        }
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          name_1 = sourceDimDef.name;
        }
      }
      result.push(name_1);
    }
    return result;
  };
  SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++;
    this._updateDimOmitted(true);
  };
  return SeriesDataSchema2;
}();
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  var dataDimNameMap = createHashMap();
  for (var i = 0; i < (dimsDef || []).length; i++) {
    var dimDefItemRaw = dimsDef[i];
    var userDimName = isObject$9(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i);
    }
  }
  return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
  var innerSource = inner$a(source);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}
var isObject$7 = isObject$9;
var map = map$1;
var CtorInt32Array = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
var CLONE_PROPERTIES = ["_approximateExtent"];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData = function() {
  function SeriesData2(dimensionsInput, hostModel) {
    this.type = "list";
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._approximateExtent = {};
    this._calculationInfo = {};
    this.hasItemOption = false;
    this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"];
    this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
    var dimensions;
    var assignStoreDimIdx = false;
    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }
    dimensions = dimensions || ["x", "y"];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};
    var needsHasOwn = false;
    var emptyObj = {};
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfoInput = dimensions[i];
      var dimensionInfo = isString$2(dimInfoInput) ? new SeriesDimensionDefine$1({
        name: dimInfoInput
      }) : !(dimInfoInput instanceof SeriesDimensionDefine$1) ? new SeriesDimensionDefine$1(dimInfoInput) : dimInfoInput;
      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
      if (otherDims.itemName === 0) {
        this._nameDimIdx = i;
      }
      if (otherDims.itemId === 0) {
        this._idDimIdx = i;
      }
      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i;
      }
    }
    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;
    this._initGetDimensionInfo(needsHasOwn);
    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;
    if (this._dimOmitted) {
      var dimIdxToName_1 = this._dimIdxToName = createHashMap();
      each$e(dimensionNames, function(dimName) {
        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  SeriesData2.prototype.getDimension = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx == null) {
      return dim;
    }
    dimIdx = dim;
    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    }
    var dimName = this._dimIdxToName.get(dimIdx);
    if (dimName != null) {
      return dimName;
    }
    var sourceDimDef = this._schema.getSourceDimension(dimIdx);
    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  };
  SeriesData2.prototype.getDimensionIndex = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx != null) {
      return dimIdx;
    }
    if (dim == null) {
      return -1;
    }
    var dimInfo = this._getDimInfo(dim);
    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  };
  SeriesData2.prototype._recognizeDimIndex = function(dim) {
    if (isNumber$1(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  };
  SeriesData2.prototype._getStoreDimIndex = function(dim) {
    var dimIdx = this.getDimensionIndex(dim);
    return dimIdx;
  };
  SeriesData2.prototype.getDimensionInfo = function(dim) {
    return this._getDimInfo(this.getDimension(dim));
  };
  SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
    var dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? function(dimName) {
      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
    } : function(dimName) {
      return dimensionInfos[dimName];
    };
  };
  SeriesData2.prototype.getDimensionsOnCoord = function() {
    return this._dimSummary.dataDimsOnCoord.slice();
  };
  SeriesData2.prototype.mapDimension = function(coordDim, idx) {
    var dimensionsSummary = this._dimSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    var dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  };
  SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
    var dimensionsSummary = this._dimSummary;
    var dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  };
  SeriesData2.prototype.getStore = function() {
    return this._store;
  };
  SeriesData2.prototype.initData = function(data, nameList, dimValueGetter) {
    var _this = this;
    var store;
    if (data instanceof DataStore$1) {
      store = data;
    }
    if (!store) {
      var dimensions = this.dimensions;
      var provider = isSourceInstance(data) || isArrayLike$1(data) ? new DefaultDataProvider(data, dimensions.length) : data;
      store = new DataStore$1();
      var dimensionInfos = map(dimensions, function(dimName) {
        return {
          type: _this._dimInfos[dimName].type,
          property: dimName
        };
      });
      store.initData(provider, dimensionInfos, dimValueGetter);
    }
    this._store = store;
    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};
    this._doInit(0, store.count());
    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  };
  SeriesData2.prototype.appendData = function(data) {
    var range = this._store.appendData(data);
    this._doInit(range[0], range[1]);
  };
  SeriesData2.prototype.appendValues = function(values, names2) {
    var _a2 = this._store.appendValues(values, names2.length), start2 = _a2.start, end2 = _a2.end;
    var shouldMakeIdFromName = this._shouldMakeIdFromName();
    this._updateOrdinalMeta();
    if (names2) {
      for (var idx = start2; idx < end2; idx++) {
        var sourceIdx = idx - start2;
        this._nameList[idx] = names2[sourceIdx];
        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  };
  SeriesData2.prototype._updateOrdinalMeta = function() {
    var store = this._store;
    var dimensions = this.dimensions;
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfo = this._dimInfos[dimensions[i]];
      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  };
  SeriesData2.prototype._shouldMakeIdFromName = function() {
    var provider = this._store.getProvider();
    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  };
  SeriesData2.prototype._doInit = function(start2, end2) {
    if (start2 >= end2) {
      return;
    }
    var store = this._store;
    var provider = store.getProvider();
    this._updateOrdinalMeta();
    var nameList = this._nameList;
    var idList = this._idList;
    var sourceFormat = provider.getSource().sourceFormat;
    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
    if (isFormatOriginal && !provider.pure) {
      var sharedDataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        var dataItem = provider.getItem(idx, sharedDataItem);
        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        if (dataItem) {
          var itemName = dataItem.name;
          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }
          var itemId = dataItem.id;
          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }
    if (this._shouldMakeIdFromName()) {
      for (var idx = start2; idx < end2; idx++) {
        makeIdFromName(this, idx);
      }
    }
    prepareInvertedIndex(this);
  };
  SeriesData2.prototype.getApproximateExtent = function(dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.setApproximateExtent = function(extent3, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent3.slice();
  };
  SeriesData2.prototype.getCalculationInfo = function(key2) {
    return this._calculationInfo[key2];
  };
  SeriesData2.prototype.setCalculationInfo = function(key2, value) {
    isObject$7(key2) ? extend$3(this._calculationInfo, key2) : this._calculationInfo[key2] = value;
  };
  SeriesData2.prototype.getName = function(idx) {
    var rawIndex = this.getRawIndex(idx);
    var name = this._nameList[rawIndex];
    if (name == null && this._nameDimIdx != null) {
      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }
    if (name == null) {
      name = "";
    }
    return name;
  };
  SeriesData2.prototype._getCategory = function(dimIdx, idx) {
    var ordinal = this._store.get(dimIdx, idx);
    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }
    return ordinal;
  };
  SeriesData2.prototype.getId = function(idx) {
    return getId(this, this.getRawIndex(idx));
  };
  SeriesData2.prototype.count = function() {
    return this._store.count();
  };
  SeriesData2.prototype.get = function(dim, idx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  };
  SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  };
  SeriesData2.prototype.getIndices = function() {
    return this._store.getIndices();
  };
  SeriesData2.prototype.getDataExtent = function(dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getSum = function(dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getMedian = function(dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getValues = function(dimensions, idx) {
    var _this = this;
    var store = this._store;
    return isArray$4(dimensions) ? store.getValues(map(dimensions, function(dim) {
      return _this._getStoreDimIndex(dim);
    }), idx) : store.getValues(dimensions);
  };
  SeriesData2.prototype.hasValue = function(idx) {
    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
    for (var i = 0, len2 = dataDimIndicesOnCoord.length; i < len2; i++) {
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
        return false;
      }
    }
    return true;
  };
  SeriesData2.prototype.indexOfName = function(name) {
    for (var i = 0, len2 = this._store.count(); i < len2; i++) {
      if (this.getName(i) === name) {
        return i;
      }
    }
    return -1;
  };
  SeriesData2.prototype.getRawIndex = function(idx) {
    return this._store.getRawIndex(idx);
  };
  SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  };
  SeriesData2.prototype.rawIndexOf = function(dim, value) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];
    var rawIndex = invertedIndices[value];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  };
  SeriesData2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
  };
  SeriesData2.prototype.each = function(dims, cb, ctx) {
    if (isFunction$2(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.each(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };
  SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
    if (isFunction$2(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return this;
  };
  SeriesData2.prototype.selectRange = function(range) {
    var _this = this;
    var innerRange = {};
    var dims = keys$1(range);
    each$e(dims, function(dim) {
      var dimIdx = _this._getStoreDimIndex(dim);
      innerRange[dimIdx] = range[dim];
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  };
  SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
    if (isFunction$2(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    ctx = ctx || this;
    var result = [];
    this.each(dims, function() {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  };
  SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    var list2 = cloneListForMapAndSample(this);
    list2._store = this._store.map(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return list2;
  };
  SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.modify(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };
  SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var list2 = cloneListForMapAndSample(this);
    list2._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list2;
  };
  SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
    var list2 = cloneListForMapAndSample(this);
    list2._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list2;
  };
  SeriesData2.prototype.getRawDataItem = function(idx) {
    return this._store.getRawDataItem(idx);
  };
  SeriesData2.prototype.getItemModel = function(idx) {
    var hostModel = this.hostModel;
    var dataItem = this.getRawDataItem(idx);
    return new Model$1(dataItem, hostModel, hostModel && hostModel.ecModel);
  };
  SeriesData2.prototype.diff = function(otherList) {
    var thisList = this;
    return new DataDiffer$1(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
      return getId(otherList, idx);
    }, function(idx) {
      return getId(thisList, idx);
    });
  };
  SeriesData2.prototype.getVisual = function(key2) {
    var visual = this._visual;
    return visual && visual[key2];
  };
  SeriesData2.prototype.setVisual = function(kvObj, val) {
    this._visual = this._visual || {};
    if (isObject$7(kvObj)) {
      extend$3(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val;
    }
  };
  SeriesData2.prototype.getItemVisual = function(idx, key2) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key2];
    if (val == null) {
      return this.getVisual(key2);
    }
    return val;
  };
  SeriesData2.prototype.hasItemVisual = function() {
    return this._itemVisuals.length > 0;
  };
  SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key2) {
    var itemVisuals = this._itemVisuals;
    var itemVisual = itemVisuals[idx];
    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }
    var val = itemVisual[key2];
    if (val == null) {
      val = this.getVisual(key2);
      if (isArray$4(val)) {
        val = val.slice();
      } else if (isObject$7(val)) {
        val = extend$3({}, val);
      }
      itemVisual[key2] = val;
    }
    return val;
  };
  SeriesData2.prototype.setItemVisual = function(idx, key2, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject$7(key2)) {
      extend$3(itemVisual, key2);
    } else {
      itemVisual[key2] = value;
    }
  };
  SeriesData2.prototype.clearAllVisual = function() {
    this._visual = {};
    this._itemVisuals = [];
  };
  SeriesData2.prototype.setLayout = function(key2, val) {
    isObject$7(key2) ? extend$3(this._layout, key2) : this._layout[key2] = val;
  };
  SeriesData2.prototype.getLayout = function(key2) {
    return this._layout[key2];
  };
  SeriesData2.prototype.getItemLayout = function(idx) {
    return this._itemLayouts[idx];
  };
  SeriesData2.prototype.setItemLayout = function(idx, layout2, merge2) {
    this._itemLayouts[idx] = merge2 ? extend$3(this._itemLayouts[idx] || {}, layout2) : layout2;
  };
  SeriesData2.prototype.clearItemLayouts = function() {
    this._itemLayouts.length = 0;
  };
  SeriesData2.prototype.setItemGraphicEl = function(idx, el) {
    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el);
    this._graphicEls[idx] = el;
  };
  SeriesData2.prototype.getItemGraphicEl = function(idx) {
    return this._graphicEls[idx];
  };
  SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
    each$e(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  SeriesData2.prototype.cloneShallow = function(list2) {
    if (!list2) {
      list2 = new SeriesData2(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);
    }
    transferProperties(list2, this);
    list2._store = this._store;
    return list2;
  };
  SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (!isFunction$2(originalMethod)) {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice(arguments)));
    };
  };
  SeriesData2.internalField = function() {
    prepareInvertedIndex = function(data) {
      var invertedIndicesMap = data._invertedIndicesMap;
      each$e(invertedIndicesMap, function(invertedIndices, dim) {
        var dimInfo = data._dimInfos[dim];
        var ordinalMeta = dimInfo.ordinalMeta;
        var store = data._store;
        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
          for (var i = 0; i < invertedIndices.length; i++) {
            invertedIndices[i] = INDEX_NOT_FOUND;
          }
          for (var i = 0; i < store.count(); i++) {
            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
          }
        }
      });
    };
    getIdNameFromStore = function(data, dimIdx, idx) {
      return convertOptionIdName(data._getCategory(dimIdx, idx), null);
    };
    getId = function(data, rawIndex) {
      var id = data._idList[rawIndex];
      if (id == null && data._idDimIdx != null) {
        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
      }
      if (id == null) {
        id = ID_PREFIX + rawIndex;
      }
      return id;
    };
    normalizeDimensions = function(dimensions) {
      if (!isArray$4(dimensions)) {
        dimensions = dimensions != null ? [dimensions] : [];
      }
      return dimensions;
    };
    cloneListForMapAndSample = function(original) {
      var list2 = new SeriesData2(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);
      transferProperties(list2, original);
      return list2;
    };
    transferProperties = function(target, source) {
      each$e(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      each$e(CLONE_PROPERTIES, function(propName) {
        target[propName] = clone$3(source[propName]);
      });
      target._calculationInfo = extend$3({}, source._calculationInfo);
    };
    makeIdFromName = function(data, idx) {
      var nameList = data._nameList;
      var idList = data._idList;
      var nameDimIdx = data._nameDimIdx;
      var idDimIdx = data._idDimIdx;
      var name = nameList[idx];
      var id = idList[idx];
      if (name == null && nameDimIdx != null) {
        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
      }
      if (id == null && idDimIdx != null) {
        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
      }
      if (id == null && name != null) {
        var nameRepeatCount = data._nameRepeatCount;
        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
        id = name;
        if (nmCnt > 1) {
          id += "__ec__" + nmCnt;
        }
        idList[idx] = id;
      }
    };
  }();
  return SeriesData2;
}();
var SeriesData$1 = SeriesData;
function createDimensions(source, opt) {
  return prepareSeriesDataSchema(source, opt).dimensions;
}
function prepareSeriesDataSchema(source, opt) {
  if (!isSourceInstance(source)) {
    source = createSourceFromSeriesDataOption(source);
  }
  opt = opt || {};
  var sysDims = opt.coordDimensions || [];
  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
  var coordDimNameMap = createHashMap();
  var resultList = [];
  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
  var encodeDef = opt.encodeDefine;
  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source, dimCount);
  }
  var encodeDefMap = createHashMap(encodeDef);
  var indicesMap = new CtorInt32Array$1(dimCount);
  for (var i = 0; i < indicesMap.length; i++) {
    indicesMap[i] = -1;
  }
  function getResultItem(dimIdx) {
    var idx = indicesMap[dimIdx];
    if (idx < 0) {
      var dimDefItemRaw = dimsDef[dimIdx];
      var dimDefItem = isObject$9(dimDefItemRaw) ? dimDefItemRaw : {
        name: dimDefItemRaw
      };
      var resultItem2 = new SeriesDimensionDefine$1();
      var userDimName = dimDefItem.name;
      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        resultItem2.name = resultItem2.displayName = userDimName;
      }
      dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
      var newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem2.storeDimIndex = dimIdx;
      resultList.push(resultItem2);
      return resultItem2;
    }
    return resultList[idx];
  }
  if (!omitUnusedDimensions) {
    for (var i = 0; i < dimCount; i++) {
      getResultItem(i);
    }
  }
  encodeDefMap.each(function(dataDimsRaw, coordDim2) {
    var dataDims = normalizeToArray(dataDimsRaw).slice();
    if (dataDims.length === 1 && !isString$2(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim2, false);
      return;
    }
    var validDataDims = encodeDefMap.set(coordDim2, []);
    each$e(dataDims, function(resultDimIdxOrName, idx) {
      var resultDimIdx2 = isString$2(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
      if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
        validDataDims[idx] = resultDimIdx2;
        applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
      }
    });
  });
  var availDimIdx = 0;
  each$e(sysDims, function(sysDimItemRaw) {
    var coordDim2;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;
    var sysDimItem;
    if (isString$2(sysDimItemRaw)) {
      coordDim2 = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim2 = sysDimItem.name;
      var ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend$3({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta;
      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }
    var dataDims = encodeDefMap.get(coordDim2);
    if (dataDims === false) {
      return;
    }
    dataDims = normalizeToArray(dataDims);
    if (!dataDims.length) {
      for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }
        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    }
    each$e(dataDims, function(resultDimIdx2, coordDimIndex) {
      var resultItem2 = getResultItem(resultDimIdx2);
      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem2.type = sysDimItem.type;
      }
      applyDim(defaults$1(resultItem2, sysDimItem), coordDim2, coordDimIndex);
      if (resultItem2.name == null && sysDimItemDimsDef) {
        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject$9(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
        resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      }
      sysDimItemOtherDims && defaults$1(resultItem2.otherDims, sysDimItemOtherDims);
    });
  });
  function applyDim(resultItem2, coordDim2, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
      resultItem2.otherDims[coordDim2] = coordDimIndex;
    } else {
      resultItem2.coordDim = coordDim2;
      resultItem2.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim2, true);
    }
  }
  var generateCoord = opt.generateCoord;
  var generateCoordCount = opt.generateCoordCount;
  var fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  var extra = generateCoord || "value";
  function ifNoNameFillWithCoordName(resultItem2) {
    if (resultItem2.name == null) {
      resultItem2.name = resultItem2.coordDim;
    }
  }
  if (!omitUnusedDimensions) {
    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = getResultItem(resultDimIdx);
      var coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      ifNoNameFillWithCoordName(resultItem);
      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
  } else {
    each$e(resultList, function(resultItem2) {
      ifNoNameFillWithCoordName(resultItem2);
    });
    resultList.sort(function(item0, item1) {
      return item0.storeDimIndex - item1.storeDimIndex;
    });
  }
  removeDuplication(resultList);
  return new SeriesDataSchema({
    source,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}
function removeDuplication(result) {
  var duplicationMap = createHashMap();
  for (var i = 0; i < result.length; i++) {
    var dim = result[i];
    var dimOriginalName = dim.name;
    var count2 = duplicationMap.get(dimOriginalName) || 0;
    if (count2 > 0) {
      dim.name = dimOriginalName + (count2 - 1);
    }
    count2++;
    duplicationMap.set(dimOriginalName, count2);
  }
}
function getDimCount(source, sysDims, dimsDef, optDimCount) {
  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each$e(sysDims, function(sysDimItem) {
    var sysDimItemDimsDef;
    if (isObject$9(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}
function genCoordDimName(name, map2, fromZero) {
  var mapData = map2.data;
  if (fromZero || mapData.hasOwnProperty(name)) {
    var i = 0;
    while (mapData.hasOwnProperty(name + i)) {
      i++;
    }
    name += i;
  }
  map2.set(name, true);
  return name;
}
var CoordSysInfo = function() {
  function CoordSysInfo2(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }
  return CoordSysInfo2;
}();
function getCoordSysInfoBySeries(seriesModel) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var result = new CoordSysInfo(coordSysName);
  var fetch = fetchers[coordSysName];
  if (fetch) {
    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
    var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    result.coordSysDims = ["x", "y"];
    axisMap.set("x", xAxisModel);
    axisMap.set("y", yAxisModel);
    if (isCategory(xAxisModel)) {
      categoryAxisMap.set("x", xAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(yAxisModel)) {
      categoryAxisMap.set("y", yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
    var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    result.coordSysDims = ["single"];
    axisMap.set("single", singleAxisModel);
    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set("single", singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function(seriesModel, result, axisMap, categoryAxisMap) {
    var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
    var angleAxisModel = polarModel.findAxisModel("angleAxis");
    result.coordSysDims = ["radius", "angle"];
    axisMap.set("radius", radiusAxisModel);
    axisMap.set("angle", angleAxisModel);
    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set("radius", radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set("angle", angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function(seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ["lng", "lat"];
  },
  parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
    var ecModel = seriesModel.ecModel;
    var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each$e(parallelModel.parallelAxisIndex, function(axisIndex, index2) {
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axisDim = coordSysDims[index2];
      axisMap.set(axisDim, axisModel);
      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);
        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index2;
        }
      }
    });
  }
};
function isCategory(axisModel) {
  return axisModel.get("type") === "category";
}
function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  var byIndex = opt.byIndex;
  var stackedCoordDimension = opt.stackedCoordDimension;
  var dimensionDefineList;
  var schema;
  var store;
  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  }
  var mayStack = !!(seriesModel && seriesModel.get("stack"));
  var stackedByDimInfo;
  var stackedDimInfo;
  var stackResultDimension;
  var stackedOverDimension;
  each$e(dimensionDefineList, function(dimensionInfo, index2) {
    if (isString$2(dimensionInfo)) {
      dimensionDefineList[index2] = dimensionInfo = {
        name: dimensionInfo
      };
    }
    if (mayStack && !dimensionInfo.isExtraCoord) {
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      }
      if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });
  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    byIndex = true;
  }
  if (stackedDimInfo) {
    stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
    stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }
    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
    var stackedDimType = stackedDimInfo.type;
    var stackedDimCoordIndex_1 = 0;
    each$e(dimensionDefineList, function(dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
        stackedDimCoordIndex_1++;
      }
    });
    var stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim_1,
      coordDimIndex: stackedDimCoordIndex_1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    var stackResultDimensionDefine = {
      name: stackedOverDimension,
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex_1 + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };
    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }
      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }
  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension,
    stackResultDimension
  };
}
function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data, stackedDim) {
  return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var coordSysDimDefs;
  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map$1(coordSysInfo.coordSysDims, function(dim) {
      var dimInfo = {
        name: dim
      };
      var axisModel = coordSysInfo.axisMap.get(dim);
      if (axisModel) {
        var axisType = axisModel.get("type");
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }
      return dimInfo;
    });
  }
  if (!coordSysDimDefs) {
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
  }
  return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  var firstCategoryDimIndex;
  var hasNameEncode;
  coordSysInfo && each$e(dimInfoList, function(dimInfo, dimIndex) {
    var coordDim = dimInfo.coordDim;
    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }
      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }
    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });
  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }
  return firstCategoryDimIndex;
}
function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  var sourceManager = seriesModel.getSourceManager();
  var source;
  var isOriginalSource = false;
  if (sourceRaw) {
    isOriginalSource = true;
    source = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source = sourceManager.getSource();
    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }
  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  var useEncodeDefaulter = opt.useEncodeDefaulter;
  var encodeDefaulter = isFunction$2(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry$1(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  var createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  var schema = prepareSeriesDataSchema(source, createDimensionOptions);
  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  var stackCalculationInfo = enableDataStack(seriesModel, {
    schema,
    store
  });
  var data = new SeriesData$1(schema, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data.hasItemOption = false;
  data.initData(isOriginalSource ? source : store, null, dimValueGetter);
  return data;
}
function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var sampleItem = firstDataNotNull(source.data || []);
    return !isArray$4(getDataItemValue(sampleItem));
  }
}
function firstDataNotNull(arr) {
  var i = 0;
  while (i < arr.length && arr[i] == null) {
    i++;
  }
  return arr[i];
}
var Scale = function() {
  function Scale2(setting2) {
    this._setting = setting2 || {};
    this._extent = [Infinity, -Infinity];
  }
  Scale2.prototype.getSetting = function(name) {
    return this._setting[name];
  };
  Scale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
  };
  Scale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  Scale2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Scale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = start2;
    }
    if (!isNaN(end2)) {
      thisExtent[1] = end2;
    }
  };
  Scale2.prototype.isInExtentRange = function(value) {
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  Scale2.prototype.isBlank = function() {
    return this._isBlank;
  };
  Scale2.prototype.setBlank = function(isBlank) {
    this._isBlank = isBlank;
  };
  return Scale2;
}();
enableClassManagement(Scale);
var Scale$1 = Scale;
var uidBase = 0;
var OrdinalMeta = function() {
  function OrdinalMeta2(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
  }
  OrdinalMeta2.createByAxisModel = function(axisModel) {
    var option = axisModel.option;
    var data = option.data;
    var categories = data && map$1(data, getName);
    return new OrdinalMeta2({
      categories,
      needCollect: !categories,
      deduplication: option.dedplication !== false
    });
  };
  OrdinalMeta2.prototype.getOrdinal = function(category) {
    return this._getOrCreateMap().get(category);
  };
  OrdinalMeta2.prototype.parseAndCollect = function(category) {
    var index2;
    var needCollect = this._needCollect;
    if (!isString$2(category) && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index2 = this.categories.length;
      this.categories[index2] = category;
      return index2;
    }
    var map2 = this._getOrCreateMap();
    index2 = map2.get(category);
    if (index2 == null) {
      if (needCollect) {
        index2 = this.categories.length;
        this.categories[index2] = category;
        map2.set(category, index2);
      } else {
        index2 = NaN;
      }
    }
    return index2;
  };
  OrdinalMeta2.prototype._getOrCreateMap = function() {
    return this._map || (this._map = createHashMap(this.categories));
  };
  return OrdinalMeta2;
}();
function getName(obj) {
  if (isObject$9(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + "";
  }
}
var OrdinalMeta$1 = OrdinalMeta;
function isIntervalOrLogScale(scale2) {
  return scale2.type === "interval" || scale2.type === "log";
}
function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent3[1] - extent3[0];
  var interval = result.interval = nice(span / splitNumber, true);
  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }
  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  }
  var precision = result.intervalPrecision = getIntervalPrecision(interval);
  var niceTickExtent = result.niceTickExtent = [round$4(Math.ceil(extent3[0] / interval) * interval, precision), round$4(Math.floor(extent3[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent3);
  return result;
}
function increaseInterval(interval) {
  var exp10 = Math.pow(10, quantityExponent(interval));
  var f = interval / exp10;
  if (!f) {
    f = 1;
  } else if (f === 2) {
    f = 3;
  } else if (f === 3) {
    f = 5;
  } else {
    f *= 2;
  }
  return round$4(f * exp10);
}
function getIntervalPrecision(interval) {
  return getPrecision(interval) + 2;
}
function clamp(niceTickExtent, idx, extent3) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
}
function fixExtent(niceTickExtent, extent3) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
  clamp(niceTickExtent, 0, extent3);
  clamp(niceTickExtent, 1, extent3);
  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain$1(val, extent3) {
  return val >= extent3[0] && val <= extent3[1];
}
function normalize(val, extent3) {
  if (extent3[1] === extent3[0]) {
    return 0.5;
  }
  return (val - extent3[0]) / (extent3[1] - extent3[0]);
}
function scale(val, extent3) {
  return val * (extent3[1] - extent3[0]) + extent3[0];
}
var OrdinalScale = function(_super) {
  __extends(OrdinalScale2, _super);
  function OrdinalScale2(setting2) {
    var _this = _super.call(this, setting2) || this;
    _this.type = "ordinal";
    var ordinalMeta = _this.getSetting("ordinalMeta");
    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta$1({});
    }
    if (isArray$4(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta$1({
        categories: map$1(ordinalMeta, function(item) {
          return isObject$9(item) ? item.value : item;
        })
      });
    }
    _this._ordinalMeta = ordinalMeta;
    _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
    return _this;
  }
  OrdinalScale2.prototype.parse = function(val) {
    if (val == null) {
      return NaN;
    }
    return isString$2(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
  };
  OrdinalScale2.prototype.contain = function(rank2) {
    rank2 = this.parse(rank2);
    return contain$1(rank2, this._extent) && this._ordinalMeta.categories[rank2] != null;
  };
  OrdinalScale2.prototype.normalize = function(val) {
    val = this._getTickNumber(this.parse(val));
    return normalize(val, this._extent);
  };
  OrdinalScale2.prototype.scale = function(val) {
    val = Math.round(scale(val, this._extent));
    return this.getRawOrdinalNumber(val);
  };
  OrdinalScale2.prototype.getTicks = function() {
    var ticks = [];
    var extent3 = this._extent;
    var rank2 = extent3[0];
    while (rank2 <= extent3[1]) {
      ticks.push({
        value: rank2
      });
      rank2++;
    }
    return ticks;
  };
  OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
    return;
  };
  OrdinalScale2.prototype.setSortInfo = function(info) {
    if (info == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }
    var infoOrdinalNumbers = info.ordinalNumbers;
    var ordinalsByTick = this._ordinalNumbersByTick = [];
    var ticksByOrdinal = this._ticksByOrdinalNumber = [];
    var tickNum = 0;
    var allCategoryLen = this._ordinalMeta.categories.length;
    for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
      var ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    }
    var unusedOrdinal = 0;
    for (; tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  };
  OrdinalScale2.prototype._getTickNumber = function(ordinal) {
    var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  };
  OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
    var ordinalNumbersByTick = this._ordinalNumbersByTick;
    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  };
  OrdinalScale2.prototype.getLabel = function(tick) {
    if (!this.isBlank()) {
      var ordinalNumber = this.getRawOrdinalNumber(tick.value);
      var cateogry = this._ordinalMeta.categories[ordinalNumber];
      return cateogry == null ? "" : cateogry + "";
    }
  };
  OrdinalScale2.prototype.count = function() {
    return this._extent[1] - this._extent[0] + 1;
  };
  OrdinalScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  OrdinalScale2.prototype.isInExtentRange = function(value) {
    value = this._getTickNumber(value);
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  OrdinalScale2.prototype.getOrdinalMeta = function() {
    return this._ordinalMeta;
  };
  OrdinalScale2.prototype.calcNiceTicks = function() {
  };
  OrdinalScale2.prototype.calcNiceExtent = function() {
  };
  OrdinalScale2.type = "ordinal";
  return OrdinalScale2;
}(Scale$1);
Scale$1.registerClass(OrdinalScale);
var OrdinalScale$1 = OrdinalScale;
var roundNumber = round$4;
var IntervalScale = function(_super) {
  __extends(IntervalScale2, _super);
  function IntervalScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "interval";
    _this._interval = 0;
    _this._intervalPrecision = 2;
    return _this;
  }
  IntervalScale2.prototype.parse = function(val) {
    return val;
  };
  IntervalScale2.prototype.contain = function(val) {
    return contain$1(val, this._extent);
  };
  IntervalScale2.prototype.normalize = function(val) {
    return normalize(val, this._extent);
  };
  IntervalScale2.prototype.scale = function(val) {
    return scale(val, this._extent);
  };
  IntervalScale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = parseFloat(start2);
    }
    if (!isNaN(end2)) {
      thisExtent[1] = parseFloat(end2);
    }
  };
  IntervalScale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
    this.setExtent(extent3[0], extent3[1]);
  };
  IntervalScale2.prototype.getInterval = function() {
    return this._interval;
  };
  IntervalScale2.prototype.setInterval = function(interval) {
    this._interval = interval;
    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  };
  IntervalScale2.prototype.getTicks = function(expandToNicedExtent) {
    var interval = this._interval;
    var extent3 = this._extent;
    var niceTickExtent = this._niceExtent;
    var intervalPrecision = this._intervalPrecision;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    var safeLimit = 1e4;
    if (extent3[0] < niceTickExtent[0]) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[0]
        });
      }
    }
    var tick = niceTickExtent[0];
    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      });
      tick = roundNumber(tick + interval, intervalPrecision);
      if (tick === ticks[ticks.length - 1].value) {
        break;
      }
      if (ticks.length > safeLimit) {
        return [];
      }
    }
    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
    if (extent3[1] > lastNiceTick) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[1]
        });
      }
    }
    return ticks;
  };
  IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
    var ticks = this.getTicks(true);
    var minorTicks = [];
    var extent3 = this.getExtent();
    for (var i = 1; i < ticks.length; i++) {
      var nextTick2 = ticks[i];
      var prevTick = ticks[i - 1];
      var count2 = 0;
      var minorTicksGroup = [];
      var interval = nextTick2.value - prevTick.value;
      var minorInterval = interval / splitNumber;
      while (count2 < splitNumber - 1) {
        var minorTick = roundNumber(prevTick.value + (count2 + 1) * minorInterval);
        if (minorTick > extent3[0] && minorTick < extent3[1]) {
          minorTicksGroup.push(minorTick);
        }
        count2++;
      }
      minorTicks.push(minorTicksGroup);
    }
    return minorTicks;
  };
  IntervalScale2.prototype.getLabel = function(data, opt) {
    if (data == null) {
      return "";
    }
    var precision = opt && opt.precision;
    if (precision == null) {
      precision = getPrecision(data.value) || 0;
    } else if (precision === "auto") {
      precision = this._intervalPrecision;
    }
    var dataNum = roundNumber(data.value, precision, true);
    return addCommas(dataNum);
  };
  IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      return;
    }
    if (span < 0) {
      span = -span;
      extent3.reverse();
    }
    var result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  };
  IntervalScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      if (extent3[0] !== 0) {
        var expandSize = extent3[0];
        if (!opt.fixMax) {
          extent3[1] += expandSize / 2;
          extent3[0] -= expandSize / 2;
        } else {
          extent3[0] -= expandSize / 2;
        }
      } else {
        extent3[1] = 1;
      }
    }
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      extent3[0] = 0;
      extent3[1] = 1;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    var interval = this._interval;
    if (!opt.fixMin) {
      extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
    }
    if (!opt.fixMax) {
      extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
    }
  };
  IntervalScale2.prototype.setNiceExtent = function(min3, max3) {
    this._niceExtent = [min3, max3];
  };
  IntervalScale2.type = "interval";
  return IntervalScale2;
}(Scale$1);
Scale$1.registerClass(IntervalScale);
var IntervalScale$1 = IntervalScale;
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray$4(arg)) {
    return supportFloat32Array ? new Float32Array(arg) : arg;
  }
  return new Float32ArrayCtor(arg);
}
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId$1(seriesModel) {
  return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey$1(axis) {
  return axis.dim + axis.index;
}
function prepareLayoutBarSeries(seriesType2, ecModel) {
  var seriesModels = [];
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
function getValueAxesMinGaps(barSeries) {
  var axisValues = {};
  each$e(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    if (baseAxis.type !== "time" && baseAxis.type !== "value") {
      return;
    }
    var data = seriesModel.getData();
    var key3 = baseAxis.dim + "_" + baseAxis.index;
    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
    var store = data.getStore();
    for (var i = 0, cnt = store.count(); i < cnt; ++i) {
      var value = store.get(dimIdx, i);
      if (!axisValues[key3]) {
        axisValues[key3] = [value];
      } else {
        axisValues[key3].push(value);
      }
    }
  });
  var axisMinGaps = {};
  for (var key2 in axisValues) {
    if (axisValues.hasOwnProperty(key2)) {
      var valuesInAxis = axisValues[key2];
      if (valuesInAxis) {
        valuesInAxis.sort(function(a2, b2) {
          return a2 - b2;
        });
        var min3 = null;
        for (var j = 1; j < valuesInAxis.length; ++j) {
          var delta = valuesInAxis[j] - valuesInAxis[j - 1];
          if (delta > 0) {
            min3 = min3 === null ? delta : Math.min(min3, delta);
          }
        }
        axisMinGaps[key2] = min3;
      }
    }
  }
  return axisMinGaps;
}
function makeColumnLayout(barSeries) {
  var axisMinGaps = getValueAxesMinGaps(barSeries);
  var seriesInfoList = [];
  each$e(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === "value" || baseAxis.type === "time") {
      var key2 = baseAxis.dim + "_" + baseAxis.index;
      var minGap = axisMinGaps[key2];
      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      var scale2 = baseAxis.scale.getExtent();
      var scaleSpan = Math.abs(scale2[1] - scale2[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
    } else {
      var data = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    }
    var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
    var barMinWidth = parsePercent(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    seriesInfoList.push({
      bandWidth,
      barWidth,
      barMaxWidth,
      barMinWidth,
      barGap,
      barCategoryGap,
      axisKey: getAxisKey$1(baseAxis),
      stackId: getSeriesStackId$1(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
  var columnsMap = {};
  each$e(seriesInfoList, function(seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = seriesInfo.barWidth;
    if (barWidth && !stacks[stackId].width) {
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }
    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$e(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGapPercent = columnsOnAxis.categoryGap;
    if (categoryGapPercent == null) {
      var columnCount = keys$1(stacks).length;
      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
    }
    var categoryGap = parsePercent(categoryGapPercent, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each$e(stacks, function(column) {
      var maxWidth = column.maxWidth;
      var minWidth = column.minWidth;
      if (!column.width) {
        var finalWidth = autoWidth;
        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        }
        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }
        if (finalWidth !== autoWidth) {
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        var finalWidth = column.width;
        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        }
        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }
        column.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$e(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset2 = -widthSum / 2;
    each$e(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth,
        offset: offset2,
        width: column.width
      };
      offset2 += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    var result = barWidthAndOffset[getAxisKey$1(axis)];
    if (result != null && seriesModel != null) {
      return result[getSeriesStackId$1(seriesModel)];
    }
    return result;
  }
}
function layout$2(seriesType2, ecModel) {
  var seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
  var barWidthAndOffset = makeColumnLayout(seriesModels);
  each$e(seriesModels, function(seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId$1(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey$1(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    data.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
}
function createProgressiveLayout(seriesType2) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var valueAxis2 = cartesian.getOtherAxis(baseAxis);
      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis2.dim));
      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var drawBackground = seriesModel.get("showBackground", true);
      var valueDim = data.mapDimension(valueAxis2.dim);
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      var stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
      var isValueAxisH = valueAxis2.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
      var isLarge = isInLargeMode(seriesModel);
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
      var columnWidth = data.getLayout("size");
      var columnOffset = data.getLayout("offset");
      return {
        progress: function(params, data2) {
          var count2 = params.count;
          var largePoints = isLarge && createFloat32Array(count2 * 3);
          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count2 * 3);
          var largeDataIndices = isLarge && createFloat32Array(count2);
          var coordLayout = cartesian.master.getRect();
          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          var dataIndex;
          var store = data2.getStore();
          var idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            var baseValue = store.get(baseDimIdx, dataIndex);
            var baseCoord = valueAxisStart;
            var startValue = void 0;
            if (stacked) {
              startValue = +value - store.get(valueDimIdx, dataIndex);
            }
            var x2 = void 0;
            var y = void 0;
            var width = void 0;
            var height = void 0;
            if (isValueAxisH) {
              var coord = cartesian.dataToPoint([value, baseValue]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([startValue, baseValue]);
                baseCoord = startCoord[0];
              }
              x2 = baseCoord;
              y = coord[1] + columnOffset;
              width = coord[0] - baseCoord;
              height = columnWidth;
              if (Math.abs(width) < barMinHeight) {
                width = (width < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              var coord = cartesian.dataToPoint([baseValue, value]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([baseValue, startValue]);
                baseCoord = startCoord[1];
              }
              x2 = coord[0] + columnOffset;
              y = baseCoord;
              width = columnWidth;
              height = coord[1] - baseCoord;
              if (Math.abs(height) < barMinHeight) {
                height = (height <= 0 ? -1 : 1) * barMinHeight;
              }
            }
            if (!isLarge) {
              data2.setItemLayout(dataIndex, {
                x: x2,
                y,
                width,
                height
              });
            } else {
              largePoints[idxOffset] = x2;
              largePoints[idxOffset + 1] = y;
              largePoints[idxOffset + 2] = isValueAxisH ? width : height;
              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x2;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }
              largeDataIndices[dataIndex] = dataIndex;
            }
            idxOffset += 3;
          }
          if (isLarge) {
            data2.setLayout({
              largePoints,
              largeDataIndices,
              largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}
function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis2) {
  return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? 1 : 0));
}
var bisect = function(a2, x2, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a2[mid][1] < x2) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
};
var TimeScale = function(_super) {
  __extends(TimeScale2, _super);
  function TimeScale2(settings) {
    var _this = _super.call(this, settings) || this;
    _this.type = "time";
    return _this;
  }
  TimeScale2.prototype.getLabel = function(tick) {
    var useUTC = this.getSetting("useUTC");
    return format$1(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
  };
  TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
    var isUTC = this.getSetting("useUTC");
    var lang = this.getSetting("locale");
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  };
  TimeScale2.prototype.getTicks = function() {
    var interval = this._interval;
    var extent3 = this._extent;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    ticks.push({
      value: extent3[0],
      level: 0
    });
    var useUTC = this.getSetting("useUTC");
    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
    ticks = ticks.concat(innerTicks);
    ticks.push({
      value: extent3[1],
      level: 0
    });
    return ticks;
  };
  TimeScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      extent3[0] -= ONE_DAY;
      extent3[1] += ONE_DAY;
    }
    if (extent3[1] === -Infinity && extent3[0] === Infinity) {
      var d2 = new Date();
      extent3[1] = +new Date(d2.getFullYear(), d2.getMonth(), d2.getDate());
      extent3[0] = extent3[1] - ONE_DAY;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  };
  TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    this._approxInterval = span / approxTickNum;
    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }
    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }
    var scaleIntervalsLen = scaleIntervals.length;
    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
    this._interval = scaleIntervals[idx][1];
    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  };
  TimeScale2.prototype.parse = function(val) {
    return isNumber$1(val) ? val : +parseDate(val);
  };
  TimeScale2.prototype.contain = function(val) {
    return contain$1(this.parse(val), this._extent);
  };
  TimeScale2.prototype.normalize = function(val) {
    return normalize(this.parse(val), this._extent);
  };
  TimeScale2.prototype.scale = function(val) {
    return scale(val, this._extent);
  };
  TimeScale2.type = "time";
  return TimeScale2;
}(IntervalScale$1);
var scaleIntervals = [
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
];
function isUnitValueSame(unit, valueA, valueB, isUTC) {
  var dateA = parseDate(valueA);
  var dateB = parseDate(valueB);
  var isSame = function(unit2) {
    return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
  };
  var isSameYear = function() {
    return isSame("year");
  };
  var isSameMonth = function() {
    return isSameYear() && isSame("month");
  };
  var isSameDay = function() {
    return isSameMonth() && isSame("day");
  };
  var isSameHour = function() {
    return isSameDay() && isSame("hour");
  };
  var isSameMinute = function() {
    return isSameHour() && isSame("minute");
  };
  var isSameSecond = function() {
    return isSameMinute() && isSame("second");
  };
  var isSameMilliSecond = function() {
    return isSameSecond() && isSame("millisecond");
  };
  switch (unit) {
    case "year":
      return isSameYear();
    case "month":
      return isSameMonth();
    case "day":
      return isSameDay();
    case "hour":
      return isSameHour();
    case "minute":
      return isSameMinute();
    case "second":
      return isSameSecond();
    case "millisecond":
      return isSameMilliSecond();
  }
}
function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
  var APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(date, unitName, isUTC) {
  var outDate = new Date(date);
  switch (getPrimaryTimeUnit(unitName)) {
    case "year":
    case "month":
      outDate[monthSetterName(isUTC)](0);
    case "day":
      outDate[dateSetterName(isUTC)](1);
    case "hour":
      outDate[hoursSetterName(isUTC)](0);
    case "minute":
      outDate[minutesSetterName(isUTC)](0);
    case "second":
      outDate[secondsSetterName(isUTC)](0);
      outDate[millisecondsSetterName(isUTC)](0);
  }
  return outDate.getTime();
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
  var safeLimit = 1e4;
  var unitNames = timeUnits;
  var iter = 0;
  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out2) {
    var date = new Date(minTimestamp);
    var dateTime = minTimestamp;
    var d2 = date[getMethodName]();
    while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
      out2.push({
        value: dateTime
      });
      d2 += interval;
      date[setMethodName](d2);
      dateTime = date.getTime();
    }
    out2.push({
      value: dateTime,
      notAdd: true
    });
  }
  function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
    var newAddedTicks = [];
    var isFirstLevel = !lastLevelTicks.length;
    if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
      return;
    }
    if (isFirstLevel) {
      lastLevelTicks = [{
        value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
      }, {
        value: extent3[1]
      }];
    }
    for (var i2 = 0; i2 < lastLevelTicks.length - 1; i2++) {
      var startTick = lastLevelTicks[i2].value;
      var endTick = lastLevelTicks[i2 + 1].value;
      if (startTick === endTick) {
        continue;
      }
      var interval = void 0;
      var getterName = void 0;
      var setterName = void 0;
      var isDate = false;
      switch (unitName) {
        case "year":
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;
        case "half-year":
        case "quarter":
        case "month":
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;
        case "week":
        case "half-week":
        case "day":
          interval = getDateInterval(approxInterval);
          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate = true;
          break;
        case "half-day":
        case "quarter-day":
        case "hour":
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;
        case "minute":
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;
        case "second":
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;
        case "millisecond":
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }
      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
      if (unitName === "year" && levelTicks2.length > 1 && i2 === 0) {
        levelTicks2.unshift({
          value: levelTicks2[0].value - interval
        });
      }
    }
    for (var i2 = 0; i2 < newAddedTicks.length; i2++) {
      levelTicks2.push(newAddedTicks[i2]);
    }
    return newAddedTicks;
  }
  var levelsTicks = [];
  var currentLevelTicks = [];
  var tickCount = 0;
  var lastLevelTickCount = 0;
  for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
    var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
    if (!isPrimaryTimeUnit(unitNames[i])) {
      continue;
    }
    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;
    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount;
        currentLevelTicks.sort(function(a2, b2) {
          return a2.value - b2.value;
        });
        var levelTicksRemoveDuplicated = [];
        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
          var tickValue = currentLevelTicks[i_1].value;
          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
            if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
              tickCount++;
            }
          }
        }
        var targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        }
        levelsTicks.push(levelTicksRemoveDuplicated);
        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
          break;
        }
      }
      currentLevelTicks = [];
    }
  }
  var levelsTicksInExtent = filter$2(map$1(levelsTicks, function(levelTicks2) {
    return filter$2(levelTicks2, function(tick) {
      return tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd;
    });
  }), function(levelTicks2) {
    return levelTicks2.length > 0;
  });
  var ticks = [];
  var maxLevel = levelsTicksInExtent.length - 1;
  for (var i = 0; i < levelsTicksInExtent.length; ++i) {
    var levelTicks = levelsTicksInExtent[i];
    for (var k = 0; k < levelTicks.length; ++k) {
      ticks.push({
        value: levelTicks[k].value,
        level: maxLevel - i
      });
    }
  }
  ticks.sort(function(a2, b2) {
    return a2.value - b2.value;
  });
  var result = [];
  for (var i = 0; i < ticks.length; ++i) {
    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
      result.push(ticks[i]);
    }
  }
  return result;
}
Scale$1.registerClass(TimeScale);
var TimeScale$1 = TimeScale;
var scaleProto = Scale$1.prototype;
var intervalScaleProto = IntervalScale$1.prototype;
var roundingErrorFix = round$4;
var mathFloor$1 = Math.floor;
var mathCeil$1 = Math.ceil;
var mathPow$1 = Math.pow;
var mathLog$1 = Math.log;
var LogScale = function(_super) {
  __extends(LogScale2, _super);
  function LogScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    _this.base = 10;
    _this._originalScale = new IntervalScale$1();
    _this._interval = 0;
    return _this;
  }
  LogScale2.prototype.getTicks = function(expandToNicedExtent) {
    var originalScale = this._originalScale;
    var extent3 = this._extent;
    var originalExtent = originalScale.getExtent();
    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
    return map$1(ticks, function(tick) {
      var val = tick.value;
      var powVal = round$4(mathPow$1(this.base, val));
      powVal = val === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return {
        value: powVal
      };
    }, this);
  };
  LogScale2.prototype.setExtent = function(start2, end2) {
    var base2 = this.base;
    start2 = mathLog$1(start2) / mathLog$1(base2);
    end2 = mathLog$1(end2) / mathLog$1(base2);
    intervalScaleProto.setExtent.call(this, start2, end2);
  };
  LogScale2.prototype.getExtent = function() {
    var base2 = this.base;
    var extent3 = scaleProto.getExtent.call(this);
    extent3[0] = mathPow$1(base2, extent3[0]);
    extent3[1] = mathPow$1(base2, extent3[1]);
    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
    this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
    return extent3;
  };
  LogScale2.prototype.unionExtent = function(extent3) {
    this._originalScale.unionExtent(extent3);
    var base2 = this.base;
    extent3[0] = mathLog$1(extent3[0]) / mathLog$1(base2);
    extent3[1] = mathLog$1(extent3[1]) / mathLog$1(base2);
    scaleProto.unionExtent.call(this, extent3);
  };
  LogScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (span === Infinity || span <= 0) {
      return;
    }
    var interval = quantity(span);
    var err = approxTickNum / span * interval;
    if (err <= 0.5) {
      interval *= 10;
    }
    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }
    var niceExtent = [round$4(mathCeil$1(extent3[0] / interval) * interval), round$4(mathFloor$1(extent3[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  };
  LogScale2.prototype.calcNiceExtent = function(opt) {
    intervalScaleProto.calcNiceExtent.call(this, opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  };
  LogScale2.prototype.parse = function(val) {
    return val;
  };
  LogScale2.prototype.contain = function(val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return contain$1(val, this._extent);
  };
  LogScale2.prototype.normalize = function(val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return normalize(val, this._extent);
  };
  LogScale2.prototype.scale = function(val) {
    val = scale(val, this._extent);
    return mathPow$1(this.base, val);
  };
  LogScale2.type = "log";
  return LogScale2;
}(Scale$1);
var proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecision(originalVal));
}
Scale$1.registerClass(LogScale);
var LogScale$1 = LogScale;
var ScaleRawExtentInfo = function() {
  function ScaleRawExtentInfo2(scale2, model, originalExtent) {
    this._prepareParams(scale2, model, originalExtent);
  }
  ScaleRawExtentInfo2.prototype._prepareParams = function(scale2, model, dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    var isOrdinal = this._isOrdinal = scale2.type === "ordinal";
    this._needCrossZero = scale2.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
    var modelMinRaw = this._modelMinRaw = model.get("min", true);
    if (isFunction$2(modelMinRaw)) {
      this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== "dataMin") {
      this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw);
    }
    var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
    if (isFunction$2(modelMaxRaw)) {
      this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== "dataMax") {
      this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw);
    }
    if (isOrdinal) {
      this._axisDataLen = model.getCategories().length;
    } else {
      var boundaryGap = model.get("boundaryGap");
      var boundaryGapArr = isArray$4(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
      if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [parsePercent$1(boundaryGapArr[0], 1), parsePercent$1(boundaryGapArr[1], 1)];
      }
    }
  };
  ScaleRawExtentInfo2.prototype.calculate = function() {
    var isOrdinal = this._isOrdinal;
    var dataMin = this._dataMin;
    var dataMax = this._dataMax;
    var axisDataLen = this._axisDataLen;
    var boundaryGapInner = this._boundaryGapInner;
    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
    var min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
    var max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
    var minFixed = min3 != null;
    var maxFixed = max3 != null;
    if (min3 == null) {
      min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }
    if (max3 == null) {
      max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }
    (min3 == null || !isFinite(min3)) && (min3 = NaN);
    (max3 == null || !isFinite(max3)) && (max3 = NaN);
    var isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
    if (this._needCrossZero) {
      if (min3 > 0 && max3 > 0 && !minFixed) {
        min3 = 0;
      }
      if (min3 < 0 && max3 < 0 && !maxFixed) {
        max3 = 0;
      }
    }
    var determinedMin = this._determinedMin;
    var determinedMax = this._determinedMax;
    if (determinedMin != null) {
      min3 = determinedMin;
      minFixed = true;
    }
    if (determinedMax != null) {
      max3 = determinedMax;
      maxFixed = true;
    }
    return {
      min: min3,
      max: max3,
      minFixed,
      maxFixed,
      isBlank
    };
  };
  ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val) {
    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
  };
  ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val) {
    var attr2 = DETERMINED_MIN_MAX_ATTR[minMaxName];
    this[attr2] = val;
  };
  ScaleRawExtentInfo2.prototype.freeze = function() {
    this.frozen = true;
  };
  return ScaleRawExtentInfo2;
}();
var DETERMINED_MIN_MAX_ATTR = {
  min: "_determinedMin",
  max: "_determinedMax"
};
var DATA_MIN_MAX_ATTR = {
  min: "_dataMin",
  max: "_dataMax"
};
function ensureScaleRawExtentInfo(scale2, model, originalExtent) {
  var rawExtentInfo = scale2.rawExtentInfo;
  if (rawExtentInfo) {
    return rawExtentInfo;
  }
  rawExtentInfo = new ScaleRawExtentInfo(scale2, model, originalExtent);
  scale2.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale2, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale2.parse(minMax);
}
function getScaleExtent(scale2, model) {
  var scaleType = scale2.type;
  var rawExtentResult = ensureScaleRawExtentInfo(scale2, model, scale2.getExtent()).calculate();
  scale2.setBlank(rawExtentResult.isBlank);
  var min3 = rawExtentResult.min;
  var max3 = rawExtentResult.max;
  var ecModel = model.ecModel;
  if (ecModel && scaleType === "time") {
    var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
    var isBaseAxisAndHasBarSeries_1 = false;
    each$e(barSeriesModels, function(seriesModel) {
      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
    });
    if (isBaseAxisAndHasBarSeries_1) {
      var barWidthAndOffset = makeColumnLayout(barSeriesModels);
      var adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
      min3 = adjustedScale.min;
      max3 = adjustedScale.max;
    }
  }
  return {
    extent: [min3, max3],
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}
function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
  var axisExtent = model.axis.getExtent();
  var axisLength = axisExtent[1] - axisExtent[0];
  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
  if (barsOnCurrentAxis === void 0) {
    return {
      min: min3,
      max: max3
    };
  }
  var minOverflow = Infinity;
  each$e(barsOnCurrentAxis, function(item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  var maxOverflow = -Infinity;
  each$e(barsOnCurrentAxis, function(item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  var totalOverFlow = minOverflow + maxOverflow;
  var oldRange = max3 - min3;
  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max3 += overflowBuffer * (maxOverflow / totalOverFlow);
  min3 -= overflowBuffer * (minOverflow / totalOverFlow);
  return {
    min: min3,
    max: max3
  };
}
function niceScaleExtent(scale2, inModel) {
  var model = inModel;
  var extentInfo = getScaleExtent(scale2, model);
  var extent3 = extentInfo.extent;
  var splitNumber = model.get("splitNumber");
  if (scale2 instanceof LogScale$1) {
    scale2.base = model.get("logBase");
  }
  var scaleType = scale2.type;
  var interval = model.get("interval");
  var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
  scale2.setExtent(extent3[0], extent3[1]);
  scale2.calcNiceExtent({
    splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get("minInterval") : null,
    maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
  });
  if (interval != null) {
    scale2.setInterval && scale2.setInterval(interval);
  }
}
function createScaleByModel$1(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new (Scale$1.getClass(axisType) || IntervalScale$1)();
    }
  }
}
function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min3 = dataExtent[0];
  var max3 = dataExtent[1];
  return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
}
function makeLabelFormatter(axis) {
  var labelFormatter = axis.getLabelModel().get("formatter");
  var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
  if (axis.scale.type === "time") {
    return function(tpl) {
      return function(tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, tpl);
      };
    }(labelFormatter);
  } else if (isString$2(labelFormatter)) {
    return function(tpl) {
      return function(tick) {
        var label = axis.scale.getLabel(tick);
        var text2 = tpl.replace("{value}", label != null ? label : "");
        return text2;
      };
    }(labelFormatter);
  } else if (isFunction$2(labelFormatter)) {
    return function(cb) {
      return function(tick, idx) {
        if (categoryTickStart != null) {
          idx = tick.value - categoryTickStart;
        }
        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
          level: tick.level
        } : null);
      };
    }(labelFormatter);
  } else {
    return function(tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
function estimateLabelUnionRect(axis) {
  var axisModel = axis.model;
  var scale2 = axis.scale;
  if (!axisModel.get(["axisLabel", "show"]) || scale2.isBlank()) {
    return;
  }
  var realNumberScaleTicks;
  var tickCount;
  var categoryScaleExtent = scale2.getExtent();
  if (scale2 instanceof OrdinalScale$1) {
    tickCount = scale2.count();
  } else {
    realNumberScaleTicks = scale2.getTicks();
    tickCount = realNumberScaleTicks.length;
  }
  var axisLabelModel = axis.getLabelModel();
  var labelFormatter = makeLabelFormatter(axis);
  var rect;
  var step = 1;
  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }
  for (var i = 0; i < tickCount; i += step) {
    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
      value: categoryScaleExtent[0] + i
    };
    var label = labelFormatter(tick, i);
    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }
  return rect;
}
function rotateTextRect(textRect, rotate2) {
  var rotateRadians = rotate2 * Math.PI / 180;
  var beforeWidth = textRect.width;
  var beforeHeight = textRect.height;
  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
  var rotatedRect = new BoundingRect$1(textRect.x, textRect.y, afterWidth, afterHeight);
  return rotatedRect;
}
function getOptionCategoryInterval(model) {
  var interval = model.get("interval");
  return interval == null ? "auto" : interval;
}
function shouldShowAllLabels(axis) {
  return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
  var dataDimMap = {};
  each$e(data.mapDimensionsAll(axisDim), function(dataDim) {
    dataDimMap[getStackedDimension(data, dataDim)] = true;
  });
  return keys$1(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data, axisDim) {
  if (data) {
    each$e(getDataDimensionsOnAxis(data, axisDim), function(dim) {
      var seriesExtent = data.getApproximateExtent(dim);
      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
    });
  }
}
var AxisModelCommonMixin = function() {
  function AxisModelCommonMixin2() {
  }
  AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
    var option = this.option;
    return !option.scale;
  };
  AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
    return;
  };
  return AxisModelCommonMixin2;
}();
function createList(seriesModel) {
  return createSeriesData(null, seriesModel);
}
var dataStack = {
  isDimensionStacked,
  enableDataStack,
  getStackedDimension
};
function createScale(dataExtent, option) {
  var axisModel = option;
  if (!(option instanceof Model$1)) {
    axisModel = new Model$1(option);
  }
  var scale2 = createScaleByModel$1(axisModel);
  scale2.setExtent(dataExtent[0], dataExtent[1]);
  niceScaleExtent(scale2, axisModel);
  return scale2;
}
function mixinAxisModelCommonMethods(Model2) {
  mixin(Model2, AxisModelCommonMixin);
}
function createTextStyle(textStyleModel, opts) {
  opts = opts || {};
  return createTextStyle$1(textStyleModel, null, null, opts.state !== "normal");
}
var helper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createList,
  getLayoutRect: getLayoutRect$1,
  dataStack,
  createScale,
  mixinAxisModelCommonMethods,
  getECData,
  createTextStyle,
  createDimensions,
  createSymbol,
  enableHoverEmphasis
}, Symbol.toStringTag, { value: "Module" }));
var extensions = [];
var extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap: registerMap$1,
  registerImpl,
  PRIORITY,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  registerComponentModel: function(ComponentModelClass) {
    ComponentModel$1.registerClass(ComponentModelClass);
  },
  registerComponentView: function(ComponentViewClass) {
    ComponentView$1.registerClass(ComponentViewClass);
  },
  registerSeriesModel: function(SeriesModelClass) {
    SeriesModel$1.registerClass(SeriesModelClass);
  },
  registerChartView: function(ChartViewClass) {
    ChartView$1.registerClass(ChartViewClass);
  },
  registerSubTypeDefaulter: function(componentType, defaulter) {
    ComponentModel$1.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter: function(painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use(ext) {
  if (isArray$4(ext)) {
    each$e(ext, function(singleExt) {
      use(singleExt);
    });
    return;
  }
  if (indexOf(extensions, ext) >= 0) {
    return;
  }
  extensions.push(ext);
  if (isFunction$2(ext)) {
    ext = {
      install: ext
    };
  }
  ext.install(extensionRegisters);
}
var EPSILON = 1e-8;
function isAroundEqual(a2, b2) {
  return Math.abs(a2 - b2) < EPSILON;
}
function contain(points2, x2, y) {
  var w2 = 0;
  var p2 = points2[0];
  if (!p2) {
    return false;
  }
  for (var i = 1; i < points2.length; i++) {
    var p22 = points2[i];
    w2 += windingLine(p2[0], p2[1], p22[0], p22[1], x2, y);
    p2 = p22;
  }
  var p0 = points2[0];
  if (!isAroundEqual(p2[0], p0[0]) || !isAroundEqual(p2[1], p0[1])) {
    w2 += windingLine(p2[0], p2[1], p0[0], p0[1], x2, y);
  }
  return w2 !== 0;
}
var TMP_TRANSFORM = [];
function transformPoints(points2, transform2) {
  for (var p2 = 0; p2 < points2.length; p2++) {
    applyTransform$1(points2[p2], points2[p2], transform2);
  }
}
function updateBBoxFromPoints(points2, min3, max3, projection) {
  for (var i = 0; i < points2.length; i++) {
    var p2 = points2[i];
    if (projection) {
      p2 = projection.project(p2);
    }
    if (p2 && isFinite(p2[0]) && isFinite(p2[1])) {
      min$2(min3, min3, p2);
      max$2(max3, max3, p2);
    }
  }
}
function centroid(points2) {
  var signedArea = 0;
  var cx = 0;
  var cy = 0;
  var len2 = points2.length;
  var x0 = points2[len2 - 1][0];
  var y0 = points2[len2 - 1][1];
  for (var i = 0; i < len2; i++) {
    var x1 = points2[i][0];
    var y1 = points2[i][1];
    var a2 = x0 * y1 - x1 * y0;
    signedArea += a2;
    cx += (x0 + x1) * a2;
    cy += (y0 + y1) * a2;
    x0 = x1;
    y0 = y1;
  }
  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points2[0][0] || 0, points2[0][1] || 0];
}
var Region = function() {
  function Region2(name) {
    this.name = name;
  }
  Region2.prototype.setCenter = function(center2) {
    this._center = center2;
  };
  Region2.prototype.getCenter = function() {
    var center2 = this._center;
    if (!center2) {
      center2 = this._center = this.calcCenter();
    }
    return center2;
  };
  return Region2;
}();
var GeoJSONPolygonGeometry = function() {
  function GeoJSONPolygonGeometry2(exterior, interiors) {
    this.type = "polygon";
    this.exterior = exterior;
    this.interiors = interiors;
  }
  return GeoJSONPolygonGeometry2;
}();
var GeoJSONLineStringGeometry = function() {
  function GeoJSONLineStringGeometry2(points2) {
    this.type = "linestring";
    this.points = points2;
  }
  return GeoJSONLineStringGeometry2;
}();
var GeoJSONRegion = function(_super) {
  __extends(GeoJSONRegion2, _super);
  function GeoJSONRegion2(name, geometries, cp) {
    var _this = _super.call(this, name) || this;
    _this.type = "geoJSON";
    _this.geometries = geometries;
    _this._center = cp && [cp[0], cp[1]];
    return _this;
  }
  GeoJSONRegion2.prototype.calcCenter = function() {
    var geometries = this.geometries;
    var largestGeo;
    var largestGeoSize = 0;
    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];
      var exterior = geo.exterior;
      var size = exterior && exterior.length;
      if (size > largestGeoSize) {
        largestGeo = geo;
        largestGeoSize = size;
      }
    }
    if (largestGeo) {
      return centroid(largestGeo.exterior);
    }
    var rect = this.getBoundingRect();
    return [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.getBoundingRect = function(projection) {
    var rect = this._rect;
    if (rect && !projection) {
      return rect;
    }
    var min3 = [Infinity, Infinity];
    var max3 = [-Infinity, -Infinity];
    var geometries = this.geometries;
    each$e(geometries, function(geo) {
      if (geo.type === "polygon") {
        updateBBoxFromPoints(geo.exterior, min3, max3, projection);
      } else {
        each$e(geo.points, function(points2) {
          updateBBoxFromPoints(points2, min3, max3, projection);
        });
      }
    });
    if (!(isFinite(min3[0]) && isFinite(min3[1]) && isFinite(max3[0]) && isFinite(max3[1]))) {
      min3[0] = min3[1] = max3[0] = max3[1] = 0;
    }
    rect = new BoundingRect$1(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    if (!projection) {
      this._rect = rect;
    }
    return rect;
  };
  GeoJSONRegion2.prototype.contain = function(coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;
    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }
    loopGeo:
      for (var i = 0, len2 = geometries.length; i < len2; i++) {
        var geo = geometries[i];
        if (geo.type !== "polygon") {
          continue;
        }
        var exterior = geo.exterior;
        var interiors = geo.interiors;
        if (contain(exterior, coord[0], coord[1])) {
          for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
            if (contain(interiors[k], coord[0], coord[1])) {
              continue loopGeo;
            }
          }
          return true;
        }
      }
    return false;
  };
  GeoJSONRegion2.prototype.transformTo = function(x2, y, width, height) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;
    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }
    var target = new BoundingRect$1(x2, y, width, height);
    var transform2 = rect.calculateTransform(target);
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];
      if (geo.type === "polygon") {
        transformPoints(geo.exterior, transform2);
        each$e(geo.interiors, function(interior) {
          transformPoints(interior, transform2);
        });
      } else {
        each$e(geo.points, function(points2) {
          transformPoints(points2, transform2);
        });
      }
    }
    rect = this._rect;
    rect.copy(target);
    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.cloneShallow = function(name) {
    name == null && (name = this.name);
    var newRegion = new GeoJSONRegion2(name, this.geometries, this._center);
    newRegion._rect = this._rect;
    newRegion.transformTo = null;
    return newRegion;
  };
  return GeoJSONRegion2;
}(Region);
var GeoSVGRegion = function(_super) {
  __extends(GeoSVGRegion2, _super);
  function GeoSVGRegion2(name, elOnlyForCalculate) {
    var _this = _super.call(this, name) || this;
    _this.type = "geoSVG";
    _this._elOnlyForCalculate = elOnlyForCalculate;
    return _this;
  }
  GeoSVGRegion2.prototype.calcCenter = function() {
    var el = this._elOnlyForCalculate;
    var rect = el.getBoundingRect();
    var center2 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    var mat = identity$1(TMP_TRANSFORM);
    var target = el;
    while (target && !target.isGeoSVGGraphicRoot) {
      mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    invert(mat, mat);
    applyTransform$1(center2, center2, mat);
    return center2;
  };
  return GeoSVGRegion2;
}(Region);
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }
  var jsonCompressed = json;
  var encodeScale = jsonCompressed.UTF8Scale;
  if (encodeScale == null) {
    encodeScale = 1024;
  }
  var features2 = jsonCompressed.features;
  each$e(features2, function(feature) {
    var geometry = feature.geometry;
    var encodeOffsets = geometry.encodeOffsets;
    var coordinates = geometry.coordinates;
    if (!encodeOffsets) {
      return;
    }
    switch (geometry.type) {
      case "LineString":
        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
        break;
      case "Polygon":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiLineString":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiPolygon":
        each$e(coordinates, function(rings, idx) {
          return decodeRings(rings, encodeOffsets[idx], encodeScale);
        });
    }
  });
  jsonCompressed.UTF8Encoding = false;
  return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
  for (var c = 0; c < rings.length; c++) {
    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
  }
}
function decodeRing(coordinate2, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];
  for (var i = 0; i < coordinate2.length; i += 2) {
    var x2 = coordinate2.charCodeAt(i) - 64;
    var y = coordinate2.charCodeAt(i + 1) - 64;
    x2 = x2 >> 1 ^ -(x2 & 1);
    y = y >> 1 ^ -(y & 1);
    x2 += prevX;
    y += prevY;
    prevX = x2;
    prevY = y;
    result.push([x2 / encodeScale, y / encodeScale]);
  }
  return result;
}
function parseGeoJSON(geoJson, nameProperty) {
  geoJson = decode(geoJson);
  return map$1(filter$2(geoJson.features, function(featureObj) {
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function(featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var geometries = [];
    switch (geo.type) {
      case "Polygon":
        var coordinates = geo.coordinates;
        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
        break;
      case "MultiPolygon":
        each$e(geo.coordinates, function(item) {
          if (item[0]) {
            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
          }
        });
        break;
      case "LineString":
        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
        break;
      case "MultiLineString":
        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
    }
    var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}
var number = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  linearMap: linearMap$2,
  round: round$4,
  asc: asc$2,
  getPrecision,
  getPrecisionSafe,
  getPixelPrecision,
  getPercentWithPrecision,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
  remRadian,
  isRadianAroundZero,
  parseDate,
  quantity,
  quantityExponent,
  nice,
  quantile,
  reformIntervals,
  isNumeric,
  numericToNumber
}, Symbol.toStringTag, { value: "Module" }));
var time = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parse: parseDate,
  format: format$1
}, Symbol.toStringTag, { value: "Module" }));
var graphic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extendShape,
  extendPath,
  makePath,
  makeImage,
  mergePath,
  resizePath,
  createIcon,
  updateProps: updateProps$1,
  initProps,
  getTransform: getTransform$1,
  clipPointsByRect,
  clipRectByRect,
  registerShape,
  getShapeClass,
  Group: Group$3,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$1,
  Rect: Rect$2,
  Line: Line$1,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1
}, Symbol.toStringTag, { value: "Module" }));
var format = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCommas,
  toCamelCase,
  normalizeCssArray,
  encodeHTML,
  formatTpl,
  getTooltipMarker,
  formatTime,
  capitalFirst,
  truncateText,
  getTextRect
}, Symbol.toStringTag, { value: "Module" }));
var util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  map: map$1,
  each: each$e,
  indexOf,
  inherits,
  reduce,
  filter: filter$2,
  bind: bind$1,
  curry: curry$1,
  isArray: isArray$4,
  isString: isString$2,
  isObject: isObject$9,
  isFunction: isFunction$2,
  extend: extend$3,
  defaults: defaults$1,
  clone: clone$3,
  merge
}, Symbol.toStringTag, { value: "Module" }));
var inner$9 = makeInner();
function createAxisLabels(axis) {
  return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
function createAxisTicks(axis, tickModel) {
  return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
    ticks: map$1(axis.scale.getTicks(), function(tick) {
      return tick.value;
    })
  };
}
function makeCategoryLabels(axis) {
  var labelModel = axis.getLabelModel();
  var result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get("show") || axis.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: result.labelCategoryInterval
  } : result;
}
function makeCategoryLabelsActually(axis, labelModel) {
  var labelsCache = getListCache(axis, "labels");
  var optionLabelInterval = getOptionCategoryInterval(labelModel);
  var result = listCacheGet$1(labelsCache, optionLabelInterval);
  if (result) {
    return result;
  }
  var labels;
  var numericLabelInterval;
  if (isFunction$2(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  }
  return listCacheSet$1(labelsCache, optionLabelInterval, {
    labels,
    labelCategoryInterval: numericLabelInterval
  });
}
function makeCategoryTicks(axis, tickModel) {
  var ticksCache = getListCache(axis, "ticks");
  var optionTickInterval = getOptionCategoryInterval(tickModel);
  var result = listCacheGet$1(ticksCache, optionTickInterval);
  if (result) {
    return result;
  }
  var ticks;
  var tickCategoryInterval;
  if (!tickModel.get("show") || axis.scale.isBlank()) {
    ticks = [];
  }
  if (isFunction$2(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } else if (optionTickInterval === "auto") {
    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
    tickCategoryInterval = labelsResult.labelCategoryInterval;
    ticks = map$1(labelsResult.labels, function(labelItem) {
      return labelItem.tickValue;
    });
  } else {
    tickCategoryInterval = optionTickInterval;
    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
  }
  return listCacheSet$1(ticksCache, optionTickInterval, {
    ticks,
    tickCategoryInterval
  });
}
function makeRealNumberLabels(axis) {
  var ticks = axis.scale.getTicks();
  var labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map$1(ticks, function(tick, idx) {
      return {
        level: tick.level,
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value
      };
    })
  };
}
function getListCache(axis, prop) {
  return inner$9(axis)[prop] || (inner$9(axis)[prop] = []);
}
function listCacheGet$1(cache, key2) {
  for (var i = 0; i < cache.length; i++) {
    if (cache[i].key === key2) {
      return cache[i].value;
    }
  }
}
function listCacheSet$1(cache, key2, value) {
  cache.push({
    key: key2,
    value
  });
  return value;
}
function makeAutoCategoryInterval(axis) {
  var result = inner$9(axis).autoInterval;
  return result != null ? result : inner$9(axis).autoInterval = axis.calculateCategoryInterval();
}
function calculateCategoryInterval(axis) {
  var params = fetchAutoCategoryIntervalCalculationParams(axis);
  var labelFormatter = makeLabelFormatter(axis);
  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var tickCount = ordinalScale.count();
  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }
  var step = 1;
  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }
  var tickValue = ordinalExtent[0];
  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  var unitW = Math.abs(unitSpan * Math.cos(rotation));
  var unitH = Math.abs(unitSpan * Math.sin(rotation));
  var maxW = 0;
  var maxH = 0;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    var width = 0;
    var height = 0;
    var rect = getBoundingRect(labelFormatter({
      value: tickValue
    }), params.font, "center", "top");
    width = rect.width * 1.3;
    height = rect.height * 1.3;
    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }
  var dw = maxW / unitW;
  var dh = maxH / unitH;
  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  var cache = inner$9(axis.model);
  var axisExtent = axis.getExtent();
  var lastAutoInterval = cache.lastAutoInterval;
  var lastTickCount = cache.lastTickCount;
  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
    interval = lastAutoInterval;
  } else {
    cache.lastTickCount = tickCount;
    cache.lastAutoInterval = interval;
    cache.axisExtent0 = axisExtent[0];
    cache.axisExtent1 = axisExtent[1];
  }
  return interval;
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
  var labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get("rotate") || 0,
    font: labelModel.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  var labelFormatter = makeLabelFormatter(axis);
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var labelModel = axis.getLabelModel();
  var result = [];
  var step = Math.max((categoryInterval || 0) + 1, 1);
  var startTick = ordinalExtent[0];
  var tickCount = ordinalScale.count();
  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  }
  var showAllLabel = shouldShowAllLabels(axis);
  var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
  var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  }
  var tickValue = startTick;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }
  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }
  function addItem(tickValue2) {
    var tickObj = {
      value: tickValue2
    };
    result.push(onlyTick ? tickValue2 : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue2
    });
  }
  return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  var ordinalScale = axis.scale;
  var labelFormatter = makeLabelFormatter(axis);
  var result = [];
  each$e(ordinalScale.getTicks(), function(tick) {
    var rawLabel = ordinalScale.getLabel(tick);
    var tickValue = tick.value;
    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel,
        tickValue
      });
    }
  });
  return result;
}
var NORMALIZED_EXTENT = [0, 1];
var Axis = function() {
  function Axis2(dim, scale2, extent3) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale2;
    this._extent = extent3 || [0, 0];
  }
  Axis2.prototype.contain = function(coord) {
    var extent3 = this._extent;
    var min3 = Math.min(extent3[0], extent3[1]);
    var max3 = Math.max(extent3[0], extent3[1]);
    return coord >= min3 && coord <= max3;
  };
  Axis2.prototype.containData = function(data) {
    return this.scale.contain(data);
  };
  Axis2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Axis2.prototype.getPixelPrecision = function(dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  };
  Axis2.prototype.setExtent = function(start2, end2) {
    var extent3 = this._extent;
    extent3[0] = start2;
    extent3[1] = end2;
  };
  Axis2.prototype.dataToCoord = function(data, clamp2) {
    var extent3 = this._extent;
    var scale2 = this.scale;
    data = scale2.normalize(data);
    if (this.onBand && scale2.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale2.count());
    }
    return linearMap$2(data, NORMALIZED_EXTENT, extent3, clamp2);
  };
  Axis2.prototype.coordToData = function(coord, clamp2) {
    var extent3 = this._extent;
    var scale2 = this.scale;
    if (this.onBand && scale2.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale2.count());
    }
    var t = linearMap$2(coord, extent3, NORMALIZED_EXTENT, clamp2);
    return this.scale.scale(t);
  };
  Axis2.prototype.pointToData = function(point, clamp2) {
    return;
  };
  Axis2.prototype.getTicksCoords = function(opt) {
    opt = opt || {};
    var tickModel = opt.tickModel || this.getTickModel();
    var result = createAxisTicks(this, tickModel);
    var ticks = result.ticks;
    var ticksCoords = map$1(ticks, function(tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    var alignWithLabel = tickModel.get("alignWithLabel");
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  };
  Axis2.prototype.getMinorTicksCoords = function() {
    if (this.scale.type === "ordinal") {
      return [];
    }
    var minorTickModel = this.model.getModel("minorTick");
    var splitNumber = minorTickModel.get("splitNumber");
    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }
    var minorTicks = this.scale.getMinorTicks(splitNumber);
    var minorTicksCoords = map$1(minorTicks, function(minorTicksGroup) {
      return map$1(minorTicksGroup, function(minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  };
  Axis2.prototype.getViewLabels = function() {
    return createAxisLabels(this).labels;
  };
  Axis2.prototype.getLabelModel = function() {
    return this.model.getModel("axisLabel");
  };
  Axis2.prototype.getTickModel = function() {
    return this.model.getModel("axisTick");
  };
  Axis2.prototype.getBandWidth = function() {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
    len2 === 0 && (len2 = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len2;
  };
  Axis2.prototype.calculateCategoryInterval = function() {
    return calculateCategoryInterval(this);
  };
  return Axis2;
}();
function fixExtentWithBands(extent3, nTick) {
  var size = extent3[1] - extent3[0];
  var len2 = nTick;
  var margin = size / len2 / 2;
  extent3[0] += margin;
  extent3[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
  var ticksLen = ticksCoords.length;
  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }
  var axisExtent = axis.getExtent();
  var last;
  var diffSize;
  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last = ticksCoords[1] = {
      coord: axisExtent[0]
    };
  } else {
    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each$e(ticksCoords, function(ticksItem) {
      ticksItem.coord -= shift_1 / 2;
    });
    var dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last = {
      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
    };
    ticksCoords.push(last);
  }
  var inverse = axisExtent[0] > axisExtent[1];
  if (littleThan2(ticksCoords[0].coord, axisExtent[0])) {
    clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }
  if (clamp2 && littleThan2(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({
      coord: axisExtent[0]
    });
  }
  if (littleThan2(axisExtent[1], last.coord)) {
    clamp2 ? last.coord = axisExtent[1] : ticksCoords.pop();
  }
  if (clamp2 && littleThan2(last.coord, axisExtent[1])) {
    ticksCoords.push({
      coord: axisExtent[1]
    });
  }
  function littleThan2(a2, b2) {
    a2 = round$4(a2);
    b2 = round$4(b2);
    return inverse ? a2 > b2 : a2 < b2;
  }
}
var Axis$1 = Axis;
function extendComponentModel(proto2) {
  var Model2 = ComponentModel$1.extend(proto2);
  ComponentModel$1.registerClass(Model2);
  return Model2;
}
function extendComponentView(proto2) {
  var View2 = ComponentView$1.extend(proto2);
  ComponentView$1.registerClass(View2);
  return View2;
}
function extendSeriesModel(proto2) {
  var Model2 = SeriesModel$1.extend(proto2);
  SeriesModel$1.registerClass(Model2);
  return Model2;
}
function extendChartView(proto2) {
  var View2 = ChartView$1.extend(proto2);
  ChartView$1.registerClass(View2);
  return View2;
}
PathProxy$1.CMD;
function projectPointToLine(x1, y1, x2, y2, x3, y, out2, limitToEnds) {
  var dx = x3 - x1;
  var dy = y - y1;
  var dx1 = x2 - x1;
  var dy1 = y2 - y1;
  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen;
  var projectedLen = dx * dx1 + dy * dy1;
  var t = projectedLen / lineLen;
  if (limitToEnds) {
    t = Math.min(Math.max(t, 0), 1);
  }
  t *= lineLen;
  var ox = out2[0] = x1 + t * dx1;
  var oy = out2[1] = y1 + t * dy1;
  return Math.sqrt((ox - x3) * (ox - x3) + (oy - y) * (oy - y));
}
var pt0 = new Point$1();
var pt1 = new Point$1();
var pt2 = new Point$1();
var dir = new Point$1();
var dir2 = new Point$1();
var tmpArr = [];
var tmpProjPoint = new Point$1();
function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }
  minTurnAngle = minTurnAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt0, pt1);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(dir2);
  var minTurnAngleCos = Math.cos(minTurnAngle);
  if (minTurnAngleCos < angleCos) {
    var d2 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    tmpProjPoint.scaleAndAdd(dir2, d2 / Math.tan(Math.PI - minTurnAngle));
    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
    if (isNaN(t)) {
      return;
    }
    if (t < 0) {
      Point$1.copy(tmpProjPoint, pt1);
    } else if (t > 1) {
      Point$1.copy(tmpProjPoint, pt2);
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }
  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt1, pt0);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(surfaceNormal);
  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
  if (angleCos < maxSurfaceAngleCos) {
    var d2 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    var HALF_PI = Math.PI / 2;
    var angle2 = Math.acos(dir2.dot(surfaceNormal));
    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;
    if (newAngle >= HALF_PI) {
      Point$1.copy(tmpProjPoint, pt2);
    } else {
      tmpProjPoint.scaleAndAdd(dir2, d2 / Math.tan(Math.PI / 2 - newAngle));
      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t)) {
        return;
      }
      if (t < 0) {
        Point$1.copy(tmpProjPoint, pt1);
      } else if (t > 1) {
        Point$1.copy(tmpProjPoint, pt2);
      }
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  var isNormal = stateName === "normal";
  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
  stateObj.ignore = ignore;
  var smooth = stateModel.get("smooth");
  if (smooth && smooth === true) {
    smooth = 0.3;
  }
  stateObj.shape = stateObj.shape || {};
  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }
  var styleObj = stateModel.getModel("lineStyle").getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (!points2) {
    return;
  }
  path.moveTo(points2[0][0], points2[0][1]);
  if (smooth > 0 && points2.length >= 3) {
    var len1 = dist$1(points2[0], points2[1]);
    var len2 = dist$1(points2[1], points2[2]);
    if (!len1 || !len2) {
      path.lineTo(points2[1][0], points2[1][1]);
      path.lineTo(points2[2][0], points2[2][1]);
      return;
    }
    var moveLen = Math.min(len1, len2) * smooth;
    var midPoint0 = lerp$1([], points2[1], points2[0], moveLen / len1);
    var midPoint2 = lerp$1([], points2[1], points2[2], moveLen / len2);
    var midPoint1 = lerp$1([], midPoint0, midPoint2, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points2[2][0], points2[2][1]);
  } else {
    for (var i = 1; i < points2.length; i++) {
      path.lineTo(points2[i][0], points2[i][1]);
    }
  }
}
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  var labelLine = targetEl.getTextGuideLine();
  var label = targetEl.getTextContent();
  if (!label) {
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }
    return;
  }
  var normalModel = statesModels.normal;
  var showNormal = normalModel.get("show");
  var labelIgnoreNormal = label.ignore;
  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateName = DISPLAY_STATES[i];
    var stateModel = statesModels[stateName];
    var isNormal = stateName === "normal";
    if (stateModel) {
      var stateShow = stateModel.get("show");
      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
      if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
        var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
        if (stateObj) {
          stateObj.ignore = true;
        }
        continue;
      }
      if (!labelLine) {
        labelLine = new Polyline$1();
        targetEl.setTextGuideLine(labelLine);
        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, "normal", statesModels.normal);
        }
        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }
      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }
  if (labelLine) {
    defaults$1(labelLine.style, defaultStyle);
    labelLine.style.fill = null;
    var showAbove = normalModel.get("showAbove");
    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false;
    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || "labelLine";
  var statesModels = {
    normal: itemModel.getModel(labelLineName)
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }
  return statesModels;
}
function prepareLayoutList(input) {
  var list2 = [];
  for (var i = 0; i < input.length; i++) {
    var rawItem = input[i];
    if (rawItem.defaultAttr.ignore) {
      continue;
    }
    var label = rawItem.label;
    var transform2 = label.getComputedTransform();
    var localRect = label.getBoundingRect();
    var isAxisAligned = !transform2 || transform2[1] < 1e-5 && transform2[2] < 1e-5;
    var minMargin = label.style.margin || 0;
    var globalRect = localRect.clone();
    globalRect.applyTransform(transform2);
    globalRect.x -= minMargin / 2;
    globalRect.y -= minMargin / 2;
    globalRect.width += minMargin;
    globalRect.height += minMargin;
    var obb = isAxisAligned ? new OrientedBoundingRect$1(localRect, transform2) : null;
    list2.push({
      label,
      labelLine: rawItem.labelLine,
      rect: globalRect,
      localRect,
      obb,
      priority: rawItem.priority,
      defaultAttr: rawItem.defaultAttr,
      layoutOption: rawItem.computedLayoutOption,
      axisAligned: isAxisAligned,
      transform: transform2
    });
  }
  return list2;
}
function shiftLayout(list2, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  var len2 = list2.length;
  if (len2 < 2) {
    return;
  }
  list2.sort(function(a2, b2) {
    return a2.rect[xyDim] - b2.rect[xyDim];
  });
  var lastPos = 0;
  var delta;
  var adjusted = false;
  var totalShifts = 0;
  for (var i = 0; i < len2; i++) {
    var item = list2[i];
    var rect = item.rect;
    delta = rect[xyDim] - lastPos;
    if (delta < 0) {
      rect[xyDim] -= delta;
      item.label[xyDim] -= delta;
      adjusted = true;
    }
    var shift = Math.max(-delta, 0);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }
  if (totalShifts > 0 && balanceShift) {
    shiftList(-totalShifts / len2, 0, len2);
  }
  var first = list2[0];
  var last = list2[len2 - 1];
  var minGap;
  var maxGap;
  updateMinMaxGap();
  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1);
  updateMinMaxGap();
  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }
  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }
  function updateMinMaxGap() {
    minGap = first.rect[xyDim] - minBound;
    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
  }
  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len2);
        var remained = moveFromMaxGap + gapThisBound;
        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }
  function shiftList(delta2, start2, end2) {
    if (delta2 !== 0) {
      adjusted = true;
    }
    for (var i2 = start2; i2 < end2; i2++) {
      var item2 = list2[i2];
      var rect2 = item2.rect;
      rect2[xyDim] += delta2;
      item2.label[xyDim] += delta2;
    }
  }
  function squeezeGaps(delta2, maxSqeezePercent) {
    var gaps = [];
    var totalGaps = 0;
    for (var i2 = 1; i2 < len2; i2++) {
      var prevItemRect = list2[i2 - 1].rect;
      var gap = Math.max(list2[i2].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }
    if (!totalGaps) {
      return;
    }
    var squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
    if (delta2 > 0) {
      for (var i2 = 0; i2 < len2 - 1; i2++) {
        var movement = gaps[i2] * squeezePercent;
        shiftList(movement, 0, i2 + 1);
      }
    } else {
      for (var i2 = len2 - 1; i2 > 0; i2--) {
        var movement = gaps[i2 - 1] * squeezePercent;
        shiftList(-movement, i2, len2);
      }
    }
  }
  function squeezeWhenBailout(delta2) {
    var dir3 = delta2 < 0 ? -1 : 1;
    delta2 = Math.abs(delta2);
    var moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
    for (var i2 = 0; i2 < len2 - 1; i2++) {
      if (dir3 > 0) {
        shiftList(moveForEachLabel, 0, i2 + 1);
      } else {
        shiftList(-moveForEachLabel, len2 - i2 - 1, len2);
      }
      delta2 -= moveForEachLabel;
      if (delta2 <= 0) {
        return;
      }
    }
  }
  return adjusted;
}
function shiftLayoutOnY(list2, topBound, bottomBound, balanceShift) {
  return shiftLayout(list2, "y", "height", topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  var displayedLabels = [];
  labelList.sort(function(a2, b2) {
    return b2.priority - a2.priority;
  });
  var globalRect = new BoundingRect$1(0, 0, 0, 0);
  function hideEl(el) {
    if (!el.ignore) {
      var emphasisState = el.ensureState("emphasis");
      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }
    el.ignore = true;
  }
  for (var i = 0; i < labelList.length; i++) {
    var labelItem = labelList[i];
    var isAxisAligned = labelItem.axisAligned;
    var localRect = labelItem.localRect;
    var transform2 = labelItem.transform;
    var label = labelItem.label;
    var labelLine = labelItem.labelLine;
    globalRect.copy(labelItem.rect);
    globalRect.width -= 0.1;
    globalRect.height -= 0.1;
    globalRect.x += 0.05;
    globalRect.y += 0.05;
    var obb = labelItem.obb;
    var overlapped = false;
    for (var j = 0; j < displayedLabels.length; j++) {
      var existsTextCfg = displayedLabels[j];
      if (!globalRect.intersect(existsTextCfg.rect)) {
        continue;
      }
      if (isAxisAligned && existsTextCfg.axisAligned) {
        overlapped = true;
        break;
      }
      if (!existsTextCfg.obb) {
        existsTextCfg.obb = new OrientedBoundingRect$1(existsTextCfg.localRect, existsTextCfg.transform);
      }
      if (!obb) {
        obb = new OrientedBoundingRect$1(localRect, transform2);
      }
      if (obb.intersect(existsTextCfg.obb)) {
        overlapped = true;
        break;
      }
    }
    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr("ignore", labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}
var echarts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  registerLocale,
  version,
  dependencies,
  PRIORITY,
  init,
  connect,
  disConnect,
  disconnect,
  dispose,
  getInstanceByDom,
  getInstanceById,
  registerTheme,
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  getCoordinateSystemDimensions,
  registerLayout,
  registerVisual,
  registerLoading,
  setCanvasCreator,
  registerMap: registerMap$1,
  getMap,
  registerTransform,
  dataTool,
  throttle,
  use,
  setPlatformAPI,
  parseGeoJSON,
  parseGeoJson: parseGeoJSON,
  env: env$1,
  Model: Model$1,
  Axis: Axis$1,
  innerDrawElementOnCanvas: brushSingle,
  zrender,
  matrix,
  vector,
  zrUtil: util$1,
  color,
  helper,
  number,
  time,
  graphic,
  format,
  util,
  List: SeriesData$1,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  extendComponentModel,
  extendComponentView,
  extendSeriesModel,
  extendChartView
}, Symbol.toStringTag, { value: "Module" }));
var LineSeriesModel = function(_super) {
  __extends(LineSeriesModel2, _super);
  function LineSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LineSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  LineSeriesModel2.prototype.getInitialData = function(option) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  LineSeriesModel2.prototype.getLegendIcon = function(opt) {
    var group = new Group$3();
    var line = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line);
    line.setStyle(opt.lineStyle);
    var visualType = this.getData().getVisual("symbol");
    var visualRotate = this.getData().getVisual("symbolRotate");
    var symbolType = visualType === "none" ? "circle" : visualType;
    var size = opt.itemHeight * 0.8;
    var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symbolType.indexOf("empty") > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = "#fff";
      symbol.style.lineWidth = 2;
    }
    return group;
  };
  LineSeriesModel2.type = "series.line";
  LineSeriesModel2.dependencies = ["grid", "polar"];
  LineSeriesModel2.defaultOption = {
    z: 3,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    clip: true,
    label: {
      position: "top"
    },
    endLabel: {
      show: false,
      valueAnimation: true,
      distance: 8
    },
    lineStyle: {
      width: 2,
      type: "solid"
    },
    emphasis: {
      scale: true
    },
    step: false,
    smooth: false,
    smoothMonotone: null,
    symbol: "emptyCircle",
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    showAllSymbol: "auto",
    connectNulls: false,
    sampling: "none",
    animationEasing: "linear",
    progressive: 0,
    hoverLayerThreshold: Infinity,
    universalTransition: {
      divideShape: "clone"
    },
    triggerLineEvent: false
  };
  return LineSeriesModel2;
}(SeriesModel$1);
var LineSeries = LineSeriesModel;
function getDefaultLabel(data, dataIndex) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  var len2 = labelDims.length;
  if (len2 === 1) {
    var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + "" : null;
  } else if (len2) {
    var vals = [];
    for (var i = 0; i < labelDims.length; i++) {
      vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
    }
    return vals.join(" ");
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  if (!isArray$4(interpolatedValue)) {
    return interpolatedValue + "";
  }
  var vals = [];
  for (var i = 0; i < labelDims.length; i++) {
    var dimIndex = data.getDimensionIndex(labelDims[i]);
    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }
  return vals.join(" ");
}
var Symbol$3 = function(_super) {
  __extends(Symbol2, _super);
  function Symbol2(data, idx, seriesScope, opts) {
    var _this = _super.call(this) || this;
    _this.updateData(data, idx, seriesScope, opts);
    return _this;
  }
  Symbol2.prototype._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
    this.removeAll();
    var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  Symbol2.prototype.stopSymbolAnimation = function(toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  };
  Symbol2.prototype.getSymbolType = function() {
    return this._symbolType;
  };
  Symbol2.prototype.getSymbolPath = function() {
    return this.childAt(0);
  };
  Symbol2.prototype.highlight = function() {
    enterEmphasis(this.childAt(0));
  };
  Symbol2.prototype.downplay = function() {
    leaveEmphasis(this.childAt(0));
  };
  Symbol2.prototype.setZ = function(zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };
  Symbol2.prototype.setDraggable = function(draggable) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = draggable ? "move" : symbolPath.cursor;
  };
  Symbol2.prototype.updateData = function(data, idx, seriesScope, opts) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, "symbol") || "circle";
    var seriesModel = data.hostModel;
    var symbolSize = Symbol2.getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;
    var disableAnimation = opts && opts.disableAnimation;
    if (isInit) {
      var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      var target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps$1(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope, opts);
    if (isInit) {
      var symbolPath = this.childAt(0);
      if (!disableAnimation) {
        var target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }
    if (disableAnimation) {
      this.childAt(0).stopAnimation("leave");
    }
  };
  Symbol2.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var emphasisItemStyle;
    var blurItemStyle;
    var selectItemStyle;
    var focus;
    var blurScope;
    var emphasisDisabled;
    var labelStatesModels;
    var hoverScale;
    var cursorStyle;
    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }
    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
      blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      emphasisDisabled = emphasisModel.get("disabled");
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow("scale");
      cursorStyle = itemModel.getShallow("cursor");
    }
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    var symbolStyle = data.getItemVisual(idx, "style");
    var visualColor = symbolStyle.fill;
    if (symbolPath instanceof ZRImage$1) {
      var pathStyle = symbolPath.style;
      symbolPath.useStyle(extend$3({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        symbolPath.useStyle(extend$3({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      }
      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }
    var liftZ = data.getItemVisual(idx, "liftZ");
    var z2Origin = this._z2;
    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }
    var useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    });
    function getLabelDefaultText(idx2) {
      return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
    }
    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    var emphasisState = symbolPath.ensureState("emphasis");
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState("select").style = selectItemStyle;
    symbolPath.ensureState("blur").style = blurItemStyle;
    if (hoverScale) {
      var scaleRatio = Math.max(isNumber$1(hoverScale) ? hoverScale : 1.1, 3 / this._sizeY);
      emphasisState.scaleX = this._sizeX * scaleRatio;
      emphasisState.scaleY = this._sizeY * scaleRatio;
    }
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Symbol2.prototype.setSymbolScale = function(scale2) {
    this.scaleX = this.scaleY = scale2;
  };
  Symbol2.prototype.fadeOut = function(cb, seriesModel, opt) {
    var symbolPath = this.childAt(0);
    var dataIndex = getECData(this).dataIndex;
    var animationOpt = opt && opt.animation;
    this.silent = symbolPath.silent = true;
    if (opt && opt.fadeLabel) {
      var textContent = symbolPath.getTextContent();
      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex,
          removeOpt: animationOpt,
          cb: function() {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }
    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {
      dataIndex,
      cb,
      removeOpt: animationOpt
    });
  };
  Symbol2.getSymbolSize = function(data, idx) {
    return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
  };
  return Symbol2;
}(Group$3);
function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}
var SymbolClz = Symbol$3;
function symbolNeedsDraw(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject$9(opt)) {
    opt = {
      isIgnore: opt
    };
  }
  return opt || {};
}
function makeSeriesScope(data) {
  var seriesModel = data.hostModel;
  var emphasisModel = seriesModel.getModel("emphasis");
  return {
    emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
    blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: emphasisModel.get("focus"),
    blurScope: emphasisModel.get("blurScope"),
    emphasisDisabled: emphasisModel.get("disabled"),
    hoverScale: emphasisModel.get("scale"),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get("cursor")
  };
}
var SymbolDraw = function() {
  function SymbolDraw2(SymbolCtor) {
    this.group = new Group$3();
    this._SymbolCtor = SymbolCtor || SymbolClz;
  }
  SymbolDraw2.prototype.updateData = function(data, opt) {
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._SymbolCtor;
    var disableAnimation = opt.disableAnimation;
    var seriesScope = makeSeriesScope(data);
    var symbolUpdateOpt = {
      disableAnimation
    };
    var getSymbolPoint = opt.getSymbolPoint || function(idx) {
      return data.getItemLayout(idx);
    };
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      var point = getSymbolPoint(newIdx);
      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = getSymbolPoint(newIdx);
      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
      if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        var target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps$1(symbolEl, target, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      }, seriesModel);
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  };
  SymbolDraw2.prototype.updateLayout = function() {
    var _this = this;
    var data = this._data;
    if (data) {
      data.eachItemGraphicEl(function(el, idx) {
        var point = _this._getSymbolPoint(idx);
        el.setPosition(point);
        el.markRedraw();
      });
    }
  };
  SymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  };
  SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point = data.getItemLayout(idx);
      if (symbolNeedsDraw(data, point, idx, opt)) {
        var el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  };
  SymbolDraw2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  SymbolDraw2.prototype.remove = function(enableAnimation) {
    var group = this.group;
    var data = this._data;
    if (data && enableAnimation) {
      data.eachItemGraphicEl(function(el) {
        el.fadeOut(function() {
          group.remove(el);
        }, data.hostModel);
      });
    } else {
      group.removeAll();
    }
  };
  return SymbolDraw2;
}();
var SymbolDraw$1 = SymbolDraw;
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis2 = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis2, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis2.dim;
  var valueDim = data.mapDimension(valueAxisDim);
  var baseDim = data.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
  var dims = map$1(coordSys.dimensions, function(coordDim) {
    return data.mapDimension(coordDim);
  });
  var stacked = false;
  var stackResultDim = data.getCalculationInfo("stackResultDimension");
  if (isDimensionStacked(data, dims[0])) {
    stacked = true;
    dims[0] = stackResultDim;
  }
  if (isDimensionStacked(data, dims[1])) {
    stacked = true;
    dims[1] = stackResultDim;
  }
  return {
    dataDimsForPoint: dims,
    valueStart,
    valueAxisDim,
    baseAxisDim,
    stacked: !!stacked,
    valueDim,
    baseDim,
    baseDataOffset,
    stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(valueAxis2, valueOrigin) {
  var valueStart = 0;
  var extent3 = valueAxis2.scale.getExtent();
  if (valueOrigin === "start") {
    valueStart = extent3[0];
  } else if (valueOrigin === "end") {
    valueStart = extent3[1];
  } else if (isNumber$1(valueOrigin) && !isNaN(valueOrigin)) {
    valueStart = valueOrigin;
  } else {
    if (extent3[0] > 0) {
      valueStart = extent3[0];
    } else if (extent3[1] < 0) {
      valueStart = extent3[1];
    }
  }
  return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  var value = NaN;
  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
  }
  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }
  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}
function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function(idx) {
    diffResult.push({
      cmd: "+",
      idx
    });
  }).update(function(newIdx, oldIdx) {
    diffResult.push({
      cmd: "=",
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function(idx) {
    diffResult.push({
      cmd: "-",
      idx
    });
  }).execute();
  return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff = diffData(oldData, newData);
  var currPoints = [];
  var nextPoints = [];
  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  var oldPoints = oldData.getLayout("points") || [];
  var newPoints = newData.getLayout("points") || [];
  for (var i = 0; i < diff.length; i++) {
    var diffItem = diff[i];
    var pointAdded = true;
    var oldIdx2 = void 0;
    var newIdx2 = void 0;
    switch (diffItem.cmd) {
      case "=":
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        var currentX = oldPoints[oldIdx2];
        var currentY = oldPoints[oldIdx2 + 1];
        var nextX = newPoints[newIdx2];
        var nextY = newPoints[newIdx2 + 1];
        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }
        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;
      case "+":
        var newIdx = diffItem.idx;
        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;
      case "-":
        pointAdded = false;
    }
    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  }
  sortedIndices.sort(function(a2, b2) {
    return rawIndices[a2] - rawIndices[b2];
  });
  var len2 = currPoints.length;
  var sortedCurrPoints = createFloat32Array(len2);
  var sortedNextPoints = createFloat32Array(len2);
  var sortedCurrStackedPoints = createFloat32Array(len2);
  var sortedNextStackedPoints = createFloat32Array(len2);
  var sortedStatus = [];
  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    var i2 = i * 2;
    var idx2 = idx * 2;
    sortedCurrPoints[i2] = currPoints[idx2];
    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i2] = nextPoints[idx2];
    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i] = status[idx];
  }
  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}
var mathMin$4 = Math.min;
var mathMax$4 = Math.max;
function isPointNull$1(x2, y) {
  return isNaN(x2) || isNaN(y);
}
function drawSegment(ctx, points2, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
  var prevX;
  var prevY;
  var cpx0;
  var cpy0;
  var cpx1;
  var cpy1;
  var idx = start2;
  var k = 0;
  for (; k < segLen; k++) {
    var x2 = points2[idx * 2];
    var y = points2[idx * 2 + 1];
    if (idx >= allLen || idx < 0) {
      break;
    }
    if (isPointNull$1(x2, y)) {
      if (connectNulls) {
        idx += dir3;
        continue;
      }
      break;
    }
    if (idx === start2) {
      ctx[dir3 > 0 ? "moveTo" : "lineTo"](x2, y);
      cpx0 = x2;
      cpy0 = y;
    } else {
      var dx = x2 - prevX;
      var dy = y - prevY;
      if (dx * dx + dy * dy < 0.5) {
        idx += dir3;
        continue;
      }
      if (smooth > 0) {
        var nextIdx = idx + dir3;
        var nextX = points2[nextIdx * 2];
        var nextY = points2[nextIdx * 2 + 1];
        while (nextX === x2 && nextY === y && k < segLen) {
          k++;
          nextIdx += dir3;
          idx += dir3;
          nextX = points2[nextIdx * 2];
          nextY = points2[nextIdx * 2 + 1];
          x2 = points2[idx * 2];
          y = points2[idx * 2 + 1];
          dx = x2 - prevX;
          dy = y - prevY;
        }
        var tmpK = k + 1;
        if (connectNulls) {
          while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir3;
            nextX = points2[nextIdx * 2];
            nextY = points2[nextIdx * 2 + 1];
          }
        }
        var ratioNextSeg = 0.5;
        var vx = 0;
        var vy = 0;
        var nextCpx0 = void 0;
        var nextCpy0 = void 0;
        if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
          cpx1 = x2;
          cpy1 = y;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          var dx0 = x2 - prevX;
          var dx1 = nextX - x2;
          var dy0 = y - prevY;
          var dy1 = nextY - y;
          var lenPrevSeg = void 0;
          var lenNextSeg = void 0;
          if (smoothMonotone === "x") {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            var dir_1 = vx > 0 ? 1 : -1;
            cpx1 = x2 - dir_1 * lenPrevSeg * smooth;
            cpy1 = y;
            nextCpx0 = x2 + dir_1 * lenNextSeg * smooth;
            nextCpy0 = y;
          } else if (smoothMonotone === "y") {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            var dir_2 = vy > 0 ? 1 : -1;
            cpx1 = x2;
            cpy1 = y - dir_2 * lenPrevSeg * smooth;
            nextCpx0 = x2;
            nextCpy0 = y + dir_2 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x2 - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y - vy * smooth * (1 - ratioNextSeg);
            nextCpx0 = x2 + vx * smooth * ratioNextSeg;
            nextCpy0 = y + vy * smooth * ratioNextSeg;
            nextCpx0 = mathMin$4(nextCpx0, mathMax$4(nextX, x2));
            nextCpy0 = mathMin$4(nextCpy0, mathMax$4(nextY, y));
            nextCpx0 = mathMax$4(nextCpx0, mathMin$4(nextX, x2));
            nextCpy0 = mathMax$4(nextCpy0, mathMin$4(nextY, y));
            vx = nextCpx0 - x2;
            vy = nextCpy0 - y;
            cpx1 = x2 - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y - vy * lenPrevSeg / lenNextSeg;
            cpx1 = mathMin$4(cpx1, mathMax$4(prevX, x2));
            cpy1 = mathMin$4(cpy1, mathMax$4(prevY, y));
            cpx1 = mathMax$4(cpx1, mathMin$4(prevX, x2));
            cpy1 = mathMax$4(cpy1, mathMin$4(prevY, y));
            vx = x2 - cpx1;
            vy = y - cpy1;
            nextCpx0 = x2 + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
          }
        }
        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x2, y);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x2, y);
      }
    }
    prevX = x2;
    prevY = y;
    idx += dir3;
  }
  return k;
}
var ECPolylineShape = function() {
  function ECPolylineShape2() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }
  return ECPolylineShape2;
}();
var ECPolyline = function(_super) {
  __extends(ECPolyline2, _super);
  function ECPolyline2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polyline";
    return _this;
  }
  ECPolyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  ECPolyline2.prototype.getDefaultShape = function() {
    return new ECPolylineShape();
  };
  ECPolyline2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var i = 0;
    var len2 = points2.length / 2;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      i += drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  };
  ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }
    var path = this.path;
    var data = path.data;
    var CMD2 = PathProxy$1.CMD;
    var x0;
    var y0;
    var isDimX = dim === "x";
    var roots2 = [];
    for (var i = 0; i < data.length; ) {
      var cmd = data[i++];
      var x2 = void 0;
      var y = void 0;
      var x22 = void 0;
      var y2 = void 0;
      var x3 = void 0;
      var y3 = void 0;
      var t = void 0;
      switch (cmd) {
        case CMD2.M:
          x0 = data[i++];
          y0 = data[i++];
          break;
        case CMD2.L:
          x2 = data[i++];
          y = data[i++];
          t = isDimX ? (xOrY - x0) / (x2 - x0) : (xOrY - y0) / (y - y0);
          if (t <= 1 && t >= 0) {
            var val = isDimX ? (y - y0) * t + y0 : (x2 - x0) * t + x0;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }
          x0 = x2;
          y0 = y;
          break;
        case CMD2.C:
          x2 = data[i++];
          y = data[i++];
          x22 = data[i++];
          y2 = data[i++];
          x3 = data[i++];
          y3 = data[i++];
          var nRoot = isDimX ? cubicRootAt(x0, x2, x22, x3, xOrY, roots2) : cubicRootAt(y0, y, y2, y3, xOrY, roots2);
          if (nRoot > 0) {
            for (var i_1 = 0; i_1 < nRoot; i_1++) {
              var t_1 = roots2[i_1];
              if (t_1 <= 1 && t_1 >= 0) {
                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x2, x22, x3, t_1);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }
          x0 = x3;
          y0 = y3;
          break;
      }
    }
  };
  return ECPolyline2;
}(Path$1);
var ECPolygonShape = function(_super) {
  __extends(ECPolygonShape2, _super);
  function ECPolygonShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return ECPolygonShape2;
}(ECPolylineShape);
var ECPolygon = function(_super) {
  __extends(ECPolygon2, _super);
  function ECPolygon2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polygon";
    return _this;
  }
  ECPolygon2.prototype.getDefaultShape = function() {
    return new ECPolygonShape();
  };
  ECPolygon2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len2 = points2.length / 2;
    var smoothMonotone = shape.smoothMonotone;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      var k = drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  };
  return ECPolygon2;
}(Path$1);
function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  var rect = cartesian.getArea();
  var x2 = rect.x;
  var y = rect.y;
  var width = rect.width;
  var height = rect.height;
  var lineWidth = seriesModel.get(["lineStyle", "width"]) || 2;
  x2 -= lineWidth / 2;
  y -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth;
  x2 = Math.floor(x2);
  width = Math.round(width);
  var clipPath = new Rect$2({
    shape: {
      x: x2,
      y,
      width,
      height
    }
  });
  if (hasAnimation) {
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isAxisInversed = baseAxis.inverse;
    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }
      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }
      clipPath.shape.height = 0;
    }
    var duringCb = isFunction$2(during) ? function(percent) {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width,
        height,
        x: x2,
        y
      }
    }, seriesModel, null, done, duringCb);
  }
  return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
  var sectorArea = polar.getArea();
  var r0 = round$4(sectorArea.r0, 1);
  var r = round$4(sectorArea.r, 1);
  var clipPath = new Sector$1({
    shape: {
      cx: round$4(polar.cx, 1),
      cy: round$4(polar.cy, 1),
      r0,
      r,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });
  if (hasAnimation) {
    var isRadial = polar.getBaseAxis().dim === "angle";
    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }
    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r
      }
    }, seriesModel);
  }
  return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === "polar") {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === "cartesian2d") {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }
  return null;
}
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }
  for (var i = 0; i < points1.length; i++) {
    if (points1[i] !== points2[i]) {
      return;
    }
  }
  return true;
}
function bboxFromPoints(points2) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  for (var i = 0; i < points2.length; ) {
    var x2 = points2[i++];
    var y = points2[i++];
    if (!isNaN(x2)) {
      minX = Math.min(x2, minX);
      maxX = Math.max(x2, maxX);
    }
    if (!isNaN(y)) {
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
  }
  return [[minX, minY], [maxX, maxY]];
}
function getBoundingDiff(points1, points2) {
  var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
  var _b2 = bboxFromPoints(points2), min22 = _b2[0], max22 = _b2[1];
  return Math.max(Math.abs(min1[0] - min22[0]), Math.abs(min1[1] - min22[1]), Math.abs(max1[0] - max22[0]), Math.abs(max1[1] - max22[1]));
}
function getSmooth(smooth) {
  return isNumber$1(smooth) ? smooth : smooth ? 0.5 : 0;
}
function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }
  var len2 = data.count();
  var points2 = createFloat32Array(len2 * 2);
  for (var idx = 0; idx < len2; idx++) {
    var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
    points2[idx * 2] = pt[0];
    points2[idx * 2 + 1] = pt[1];
  }
  return points2;
}
function turnPointsIntoStep(points2, coordSys, stepTurnAt, connectNulls) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
  var stepPoints = [];
  var i = 0;
  var stepPt = [];
  var pt = [];
  var nextPt = [];
  var filteredPoints = [];
  if (connectNulls) {
    for (i = 0; i < points2.length; i += 2) {
      if (!isNaN(points2[i]) && !isNaN(points2[i + 1])) {
        filteredPoints.push(points2[i], points2[i + 1]);
      }
    }
    points2 = filteredPoints;
  }
  for (i = 0; i < points2.length - 2; i += 2) {
    nextPt[0] = points2[i + 2];
    nextPt[1] = points2[i + 3];
    pt[0] = points2[i];
    pt[1] = points2[i + 1];
    stepPoints.push(pt[0], pt[1]);
    switch (stepTurnAt) {
      case "end":
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;
      case "middle":
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;
      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  }
  stepPoints.push(points2[i++], points2[i++]);
  return stepPoints;
}
function clipColorStops(colorStops, maxSize) {
  var newColorStops = [];
  var len2 = colorStops.length;
  var prevOutOfRangeColorStop;
  var prevInRangeColorStop;
  function lerpStop(stop0, stop1, clippedCoord) {
    var coord0 = stop0.coord;
    var p2 = (clippedCoord - coord0) / (stop1.coord - coord0);
    var color2 = lerp(p2, [stop0.color, stop1.color]);
    return {
      coord: clippedCoord,
      color: color2
    };
  }
  for (var i = 0; i < len2; i++) {
    var stop_1 = colorStops[i];
    var coord = stop_1.coord;
    if (coord < 0) {
      prevOutOfRangeColorStop = stop_1;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
      } else if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
      }
      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
        prevOutOfRangeColorStop = null;
      }
      newColorStops.push(stop_1);
      prevInRangeColorStop = stop_1;
    }
  }
  return newColorStops;
}
function getVisualGradient(data, coordSys, api) {
  var visualMetaList = data.getVisual("visualMeta");
  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    return;
  }
  if (coordSys.type !== "cartesian2d") {
    return;
  }
  var coordDim;
  var visualMeta;
  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
    coordDim = dimInfo && dimInfo.coordDim;
    if (coordDim === "x" || coordDim === "y") {
      visualMeta = visualMetaList[i];
      break;
    }
  }
  if (!visualMeta) {
    return;
  }
  var axis = coordSys.getAxis(coordDim);
  var colorStops = map$1(visualMeta.stops, function(stop2) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
      color: stop2.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();
  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }
  var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
  var inRangeStopLen = colorStopsInRange.length;
  if (!inRangeStopLen && stopLen) {
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }
  var tinyExtent = 10;
  var minCoord = colorStopsInRange[0].coord - tinyExtent;
  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;
  if (coordSpan < 1e-3) {
    return "transparent";
  }
  each$e(colorStopsInRange, function(stop2) {
    stop2.offset = (stop2.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || "transparent"
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || "transparent"
  });
  var gradient = new LinearGradient$1(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + "2"] = maxCoord;
  return gradient;
}
function getIsIgnoreFunc(seriesModel, data, coordSys) {
  var showAllSymbol = seriesModel.get("showAllSymbol");
  var isAuto = showAllSymbol === "auto";
  if (showAllSymbol && !isAuto) {
    return;
  }
  var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
  if (!categoryAxis2) {
    return;
  }
  if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
    return;
  }
  var categoryDataDim = data.mapDimension(categoryAxis2.dim);
  var labelMap = {};
  each$e(categoryAxis2.getViewLabels(), function(labelItem) {
    var ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function(dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}
function canShowAllSymbolForCategory(categoryAxis2, data) {
  var axisExtent = categoryAxis2.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
  isNaN(availSize) && (availSize = 0);
  var dataLen = data.count();
  var step = Math.max(1, Math.round(dataLen / 5));
  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (SymbolClz.getSymbolSize(data, dataIndex)[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
      return false;
    }
  }
  return true;
}
function isPointNull(x2, y) {
  return isNaN(x2) || isNaN(y);
}
function getLastIndexNotNull(points2) {
  var len2 = points2.length / 2;
  for (; len2 > 0; len2--) {
    if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
      break;
    }
  }
  return len2 - 1;
}
function getPointAtIndex(points2, idx) {
  return [points2[idx * 2], points2[idx * 2 + 1]];
}
function getIndexRange(points2, xOrY, dim) {
  var len2 = points2.length / 2;
  var dimIdx = dim === "x" ? 0 : 1;
  var a2;
  var b2;
  var prevIndex = 0;
  var nextIndex = -1;
  for (var i = 0; i < len2; i++) {
    b2 = points2[i * 2 + dimIdx];
    if (isNaN(b2) || isNaN(points2[i * 2 + 1 - dimIdx])) {
      continue;
    }
    if (i === 0) {
      a2 = b2;
      continue;
    }
    if (a2 <= xOrY && b2 >= xOrY || a2 >= xOrY && b2 <= xOrY) {
      nextIndex = i;
      break;
    }
    prevIndex = i;
    a2 = b2;
  }
  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a2) / (b2 - a2)
  };
}
function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(["endLabel", "show"])) {
    return true;
  }
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    if (seriesModel.get([SPECIAL_STATES[i], "endLabel", "show"])) {
      return true;
    }
  }
  return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    var endLabelModel_1 = seriesModel.getModel("endLabel");
    var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
    var data_1 = seriesModel.getData();
    var labelAnimationRecord_1 = {
      lastFrameIndex: 0
    };
    var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
    } : null;
    var isHorizontal = coordSys.getBaseAxis().isHorizontal();
    var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
      var endLabel = lineView._endLabel;
      if (endLabel && hasAnimation) {
        if (labelAnimationRecord_1.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord_1.originalX,
            y: labelAnimationRecord_1.originalY
          });
        }
      }
    }, during);
    if (!seriesModel.get("clip", true)) {
      var rectShape = clipPath.shape;
      var expandSize = Math.max(rectShape.width, rectShape.height);
      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    }
    if (during) {
      during(1, clipPath);
    }
    return clipPath;
  } else {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
  var baseAxis = coordSys.getBaseAxis();
  var isHorizontal = baseAxis.isHorizontal();
  var isBaseInversed = baseAxis.inverse;
  var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
  var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
  return {
    normal: {
      align: endLabelModel.get("align") || align,
      verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
    }
  };
}
var LineView = function(_super) {
  __extends(LineView2, _super);
  function LineView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineView2.prototype.init = function() {
    var lineGroup = new Group$3();
    var symbolDraw = new SymbolDraw$1();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  };
  LineView2.prototype.render = function(seriesModel, ecModel, api) {
    var _this = this;
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel("lineStyle");
    var areaStyleModel = seriesModel.getModel("areaStyle");
    var points2 = data.getLayout("points") || [];
    var isCoordSysPolar = coordSys.type === "polar";
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get("animation");
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get("origin");
    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    var showSymbol = seriesModel.get("showSymbol");
    var connectNulls = seriesModel.get("connectNulls");
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    if (!showSymbol) {
      symbolDraw.remove();
    }
    group.add(lineGroup);
    var step = !isCoordSysPolar ? seriesModel.get("step") : false;
    var clipShapeForSymbol;
    if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
      clipShapeForSymbol = coordSys.getArea();
      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }
    this._clipShapeForSymbol = clipShapeForSymbol;
    var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual("style")[data.getVisual("drawType")];
    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
      if (step) {
        points2 = turnPointsIntoStep(points2, coordSys, step, connectNulls);
        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
        }
      }
      polyline = this._newPolyline(points2);
      if (isAreaChart) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      var oldClipPath = lineGroup.getClipPath();
      if (oldClipPath) {
        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      }
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
        } else {
          if (step) {
            points2 = turnPointsIntoStep(points2, coordSys, step, connectNulls);
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
            }
          }
          polyline.setShape({
            points: points2
          });
          polygon && polygon.setShape({
            points: points2,
            stackedOnPoints
          });
        }
      }
    }
    var emphasisModel = seriesModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var emphasisDisabled = emphasisModel.get("disabled");
    polyline.useStyle(defaults$1(lineStyleModel.getLineStyle(), {
      fill: "none",
      stroke: visualColor,
      lineJoin: "bevel"
    }));
    setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
    if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
      var emphasisLineStyle = polyline.getState("emphasis").style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    }
    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
    var smooth = getSmooth(seriesModel.get("smooth"));
    var smoothMonotone = seriesModel.get("smoothMonotone");
    polyline.setShape({
      smooth,
      smoothMonotone,
      connectNulls
    });
    if (polygon) {
      var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
      var stackedOnSmooth = 0;
      polygon.useStyle(defaults$1(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: "bevel",
        decal: data.getVisual("style").decal
      }));
      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
      }
      polygon.setShape({
        smooth,
        stackedOnSmooth,
        smoothMonotone,
        connectNulls
      });
      setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
      getECData(polygon).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
    }
    var changePolyState = function(toState) {
      _this._changePolyState(toState);
    };
    data.eachItemGraphicEl(function(el) {
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data;
    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points2;
    this._step = step;
    this._valueOrigin = valueOrigin;
    if (seriesModel.get("triggerLineEvent")) {
      this.packEventData(seriesModel, polyline);
      polygon && this.packEventData(seriesModel, polygon);
    }
  };
  LineView2.prototype.packEventData = function(seriesModel, el) {
    getECData(el).eventData = {
      componentType: "series",
      componentSubType: "line",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "line"
    };
  };
  LineView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("emphasis");
    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var points2 = data.getLayout("points");
      var symbol = data.getItemGraphicEl(dataIndex);
      if (!symbol) {
        var x2 = points2[dataIndex * 2];
        var y = points2[dataIndex * 2 + 1];
        if (isNaN(x2) || isNaN(y)) {
          return;
        }
        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x2, y)) {
          return;
        }
        var zlevel = seriesModel.get("zlevel");
        var z = seriesModel.get("z");
        symbol = new SymbolClz(data, dataIndex);
        symbol.x = x2;
        symbol.y = y;
        symbol.setZ(zlevel, z);
        var symbolLabel = symbol.getSymbolPath().getTextContent();
        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol);
        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }
      symbol.highlight();
    } else {
      ChartView$1.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("normal");
    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);
      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      ChartView$1.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype._changePolyState = function(toState) {
    var polygon = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon && setStatesFlag(polygon, toState);
  };
  LineView2.prototype._newPolyline = function(points2) {
    var polyline = this._polyline;
    if (polyline) {
      this._lineGroup.remove(polyline);
    }
    polyline = new ECPolyline({
      shape: {
        points: points2
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });
    this._lineGroup.add(polyline);
    this._polyline = polyline;
    return polyline;
  };
  LineView2.prototype._newPolygon = function(points2, stackedOnPoints) {
    var polygon = this._polygon;
    if (polygon) {
      this._lineGroup.remove(polygon);
    }
    polygon = new ECPolygon({
      shape: {
        points: points2,
        stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });
    this._lineGroup.add(polygon);
    this._polygon = polygon;
    return polygon;
  };
  LineView2.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
    var isHorizontalOrRadial;
    var isCoordSysPolar;
    var baseAxis = coordSys.getBaseAxis();
    var isAxisInverse = baseAxis.inverse;
    if (coordSys.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
      isCoordSysPolar = true;
    }
    var seriesModel = data.hostModel;
    var seriesDuration = seriesModel.get("animationDuration");
    if (isFunction$2(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }
    var seriesDalay = seriesModel.get("animationDelay") || 0;
    var seriesDalayValue = isFunction$2(seriesDalay) ? seriesDalay(null) : seriesDalay;
    data.eachItemGraphicEl(function(symbol, idx) {
      var el = symbol;
      if (el) {
        var point = [symbol.x, symbol.y];
        var start2 = void 0;
        var end2 = void 0;
        var current = void 0;
        if (clipShape) {
          if (isCoordSysPolar) {
            var polarClip = clipShape;
            var coord = coordSys.pointToCoord(point);
            if (isHorizontalOrRadial) {
              start2 = polarClip.startAngle;
              end2 = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start2 = polarClip.r0;
              end2 = polarClip.r;
              current = coord[0];
            }
          } else {
            var gridClip = clipShape;
            if (isHorizontalOrRadial) {
              start2 = gridClip.x;
              end2 = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start2 = gridClip.y + gridClip.height;
              end2 = gridClip.y;
              current = symbol.y;
            }
          }
        }
        var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
        if (isAxisInverse) {
          ratio = 1 - ratio;
        }
        var delay = isFunction$2(seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
        var symbolPath = el.getSymbolPath();
        var text2 = symbolPath.getTextContent();
        el.attr({
          scaleX: 0,
          scaleY: 0
        });
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay
        });
        if (text2) {
          text2.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay
          });
        }
        symbolPath.disableLabelAnimation = true;
      }
    });
  };
  LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
    var endLabelModel = seriesModel.getModel("endLabel");
    if (anyStateShowEndLabel(seriesModel)) {
      var data_2 = seriesModel.getData();
      var polyline = this._polyline;
      var points2 = data_2.getLayout("points");
      if (!points2) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }
      var endLabel = this._endLabel;
      if (!endLabel) {
        endLabel = this._endLabel = new ZRText$1({
          z2: 200
        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      }
      var dataIndex = getLastIndexNotNull(points2);
      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
          inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: function(dataIndex2, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();
      this._endLabel = null;
    }
  };
  LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    var endLabel = this._endLabel;
    var polyline = this._polyline;
    if (endLabel) {
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }
      var points2 = data.getLayout("points");
      var seriesModel = data.hostModel;
      var connectNulls = seriesModel.get("connectNulls");
      var precision = endLabelModel.get("precision");
      var distance2 = endLabelModel.get("distance") || 0;
      var baseAxis = coordSys.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isBaseInversed = baseAxis.inverse;
      var clipShape = clipRect.shape;
      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      var distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
      var distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
      var dim = isHorizontal ? "x" : "y";
      var dataIndexRange = getIndexRange(points2, xOrY, dim);
      var indices = dataIndexRange.range;
      var diff = indices[1] - indices[0];
      var value = void 0;
      if (diff >= 1) {
        if (diff > 1 && !connectNulls) {
          var pt = getPointAtIndex(points2, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          var pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          var startValue = seriesModel.getRawValue(indices[0]);
          var endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }
        animationRecord.lastFrameIndex = indices[0];
      } else {
        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        var pt = getPointAtIndex(points2, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }
      if (valueAnimation) {
        labelInner(endLabel).setLabelText(value);
      }
    }
  };
  LineView2.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next2 = diff.next;
    var stackedOnNext = diff.stackedOnNext;
    if (step) {
      current = turnPointsIntoStep(diff.current, coordSys, step, connectNulls);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step, connectNulls);
      next2 = turnPointsIntoStep(diff.next, coordSys, step, connectNulls);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step, connectNulls);
    }
    if (getBoundingDiff(current, next2) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next2
      });
      if (polygon) {
        polygon.stopAnimation();
        polygon.setShape({
          points: next2,
          stackedOnPoints: stackedOnNext
        });
      }
      return;
    }
    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    var target = {
      shape: {
        points: next2
      }
    };
    if (diff.current !== current) {
      target.shape.__points = diff.next;
    }
    polyline.stopAnimation();
    updateProps$1(polyline, target, seriesModel);
    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      updateProps$1(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }
    var updatedDataInfo = [];
    var diffStatus = diff.status;
    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;
      if (cmd === "=") {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);
        if (el) {
          updatedDataInfo.push({
            el,
            ptIdx: i
          });
        }
      }
    }
    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function() {
        polygon && polygon.dirtyShape();
        var points2 = polyline.shape.__points;
        for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
          var el2 = updatedDataInfo[i2].el;
          var offset2 = updatedDataInfo[i2].ptIdx * 2;
          el2.x = points2[offset2];
          el2.y = points2[offset2 + 1];
          el2.markRedraw();
        }
      });
    }
  };
  LineView2.prototype.remove = function(ecModel) {
    var group = this.group;
    var oldData = this._data;
    this._lineGroup.removeAll();
    this._symbolDraw.remove(true);
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  };
  LineView2.type = "line";
  return LineView2;
}(ChartView$1);
var LineView$1 = LineView;
function pointsLayout(seriesType2, forceStoreInTypedArray) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      var dims = map$1(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked(data, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked(data, dims[1])) {
        dims[1] = stackResultDim;
      }
      var store = data.getStore();
      var dimIdx0 = data.getDimensionIndex(dims[0]);
      var dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress: function(params, data2) {
          var segCount = params.end - params.start;
          var points2 = useTypedArray && createFloat32Array(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];
          for (var i = params.start, offset2 = 0; i < params.end; i++) {
            var point = void 0;
            if (dimLen === 1) {
              var x2 = store.get(dimIdx0, i);
              point = coordSys.dataToPoint(x2, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i);
              tmpIn[1] = store.get(dimIdx1, i);
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points2[offset2++] = point[0];
              points2[offset2++] = point[1];
            } else {
              data2.setItemLayout(i, point.slice());
            }
          }
          useTypedArray && data2.setLayout("points", points2);
        }
      };
    }
  };
}
var samplers = {
  average: function(frame) {
    var sum = 0;
    var count2 = 0;
    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum += frame[i];
        count2++;
      }
    }
    return count2 === 0 ? NaN : sum / count2;
  },
  sum: function(frame) {
    var sum = 0;
    for (var i = 0; i < frame.length; i++) {
      sum += frame[i] || 0;
    }
    return sum;
  },
  max: function(frame) {
    var max3 = -Infinity;
    for (var i = 0; i < frame.length; i++) {
      frame[i] > max3 && (max3 = frame[i]);
    }
    return isFinite(max3) ? max3 : NaN;
  },
  min: function(frame) {
    var min3 = Infinity;
    for (var i = 0; i < frame.length; i++) {
      frame[i] < min3 && (min3 = frame[i]);
    }
    return isFinite(min3) ? min3 : NaN;
  },
  nearest: function(frame) {
    return frame[0];
  }
};
var indexSampler = function(frame) {
  return Math.round(frame.length / 2);
};
function dataSample(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get("sampling");
      var coordSys = seriesModel.coordinateSystem;
      var count2 = data.count();
      if (count2 > 10 && coordSys.type === "cartesian2d" && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis2 = coordSys.getOtherAxis(baseAxis);
        var extent3 = baseAxis.getExtent();
        var dpr2 = api.getDevicePixelRatio();
        var size = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
        var rate = Math.round(count2 / size);
        if (isFinite(rate) && rate > 1) {
          if (sampling === "lttb") {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
          }
          var sampler = void 0;
          if (isString$2(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction$2(sampling)) {
            sampler = sampling;
          }
          if (sampler) {
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}
function install$u(registers) {
  registers.registerChartView(LineView$1);
  registers.registerSeriesModel(LineSeries);
  registers.registerLayout(pointsLayout("line", true));
  registers.registerVisual({
    seriesType: "line",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
      if (lineStyle && !lineStyle.stroke) {
        lineStyle.stroke = data.getVisual("style").fill;
      }
      data.setVisual("legendLineStyle", lineStyle);
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
var BaseBarSeriesModel = function(_super) {
  __extends(BaseBarSeriesModel2, _super);
  function BaseBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BaseBarSeriesModel2.type;
    return _this;
  }
  BaseBarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  BaseBarSeriesModel2.prototype.getMarkerPosition = function(value) {
    var coordSys = this.coordinateSystem;
    if (coordSys && coordSys.clampData) {
      var pt = coordSys.dataToPoint(coordSys.clampData(value));
      var data = this.getData();
      var offset2 = data.getLayout("offset");
      var size = data.getLayout("size");
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset2 + size / 2;
      return pt;
    }
    return [NaN, NaN];
  };
  BaseBarSeriesModel2.type = "series.__base_bar__";
  BaseBarSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    barMinHeight: 0,
    barMinAngle: 0,
    large: false,
    largeThreshold: 400,
    progressive: 3e3,
    progressiveChunkMode: "mod"
  };
  return BaseBarSeriesModel2;
}(SeriesModel$1);
SeriesModel$1.registerClass(BaseBarSeriesModel);
var BaseBarSeriesModel$1 = BaseBarSeriesModel;
var BarSeriesModel = function(_super) {
  __extends(BarSeriesModel2, _super);
  function BarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BarSeriesModel2.type;
    return _this;
  }
  BarSeriesModel2.prototype.getInitialData = function() {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get("realtimeSort", true) || null
    });
  };
  BarSeriesModel2.prototype.getProgressive = function() {
    return this.get("large") ? this.get("progressive") : false;
  };
  BarSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.get("progressiveThreshold");
    var largeThreshold = this.get("largeThreshold");
    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }
    return progressiveThreshold;
  };
  BarSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  };
  BarSeriesModel2.type = "series.bar";
  BarSeriesModel2.dependencies = ["grid", "polar"];
  BarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    clip: true,
    roundCap: false,
    showBackground: false,
    backgroundStyle: {
      color: "rgba(180, 180, 180, 0.2)",
      borderColor: null,
      borderWidth: 0,
      borderType: "solid",
      borderRadius: 0,
      shadowBlur: 0,
      shadowColor: null,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    realtimeSort: false
  });
  return BarSeriesModel2;
}(BaseBarSeriesModel$1);
var BarSeries = BarSeriesModel;
var SausageShape = function() {
  function SausageShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return SausageShape2;
}();
var SausagePath = function(_super) {
  __extends(SausagePath2, _super);
  function SausagePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "sausage";
    return _this;
  }
  SausagePath2.prototype.getDefaultShape = function() {
    return new SausageShape();
  };
  SausagePath2.prototype.buildPath = function(ctx, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var dr = (r - r0) * 0.5;
    var rCenter = r0 + dr;
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var PI22 = Math.PI * 2;
    var lessThanCircle = clockwise ? endAngle - startAngle < PI22 : startAngle - endAngle < PI22;
    if (!lessThanCircle) {
      startAngle = endAngle - (clockwise ? PI22 : -PI22);
    }
    var unitStartX = Math.cos(startAngle);
    var unitStartY = Math.sin(startAngle);
    var unitEndX = Math.cos(endAngle);
    var unitEndY = Math.sin(endAngle);
    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
    }
    ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    }
  };
  return SausagePath2;
}(Path$1);
var Sausage = SausagePath;
function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  var isRoundCap = opts.isRoundCap;
  return function(out2, opts2, boundingRect) {
    var textPosition = opts2.position;
    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out2, opts2, boundingRect);
    }
    var mappedSectorPosition = positionMapping(textPosition);
    var distance2 = opts2.distance != null ? opts2.distance : 5;
    var sector = this.shape;
    var cx = sector.cx;
    var cy = sector.cy;
    var r = sector.r;
    var r0 = sector.r0;
    var middleR = (r + r0) / 2;
    var startAngle = sector.startAngle;
    var endAngle = sector.endAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
    var mathCos2 = Math.cos;
    var mathSin2 = Math.sin;
    var x2 = cx + r * mathCos2(startAngle);
    var y = cy + r * mathSin2(startAngle);
    var textAlign = "left";
    var textVerticalAlign = "top";
    switch (mappedSectorPosition) {
      case "startArc":
        x2 = cx + (r0 - distance2) * mathCos2(middleAngle);
        y = cy + (r0 - distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "insideStartArc":
        x2 = cx + (r0 + distance2) * mathCos2(middleAngle);
        y = cy + (r0 + distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "startAngle":
        x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
        y = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideStartAngle":
        x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
        y = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "middle":
        x2 = cx + middleR * mathCos2(middleAngle);
        y = cy + middleR * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "endArc":
        x2 = cx + (r + distance2) * mathCos2(middleAngle);
        y = cy + (r + distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideEndArc":
        x2 = cx + (r - distance2) * mathCos2(middleAngle);
        y = cy + (r - distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "endAngle":
        x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
        y = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "insideEndAngle":
        x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
        y = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      default:
        return calculateTextPosition(out2, opts2, boundingRect);
    }
    out2 = out2 || {};
    out2.x = x2;
    out2.y = y;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  };
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
  if (isNumber$1(rotateType)) {
    sector.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray$4(textPosition)) {
    sector.setTextConfig({
      rotation: 0
    });
    return;
  }
  var shape = sector.shape;
  var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  var middleAngle = (startAngle + endAngle) / 2;
  var anchorAngle;
  var mappedSectorPosition = positionMapping(textPosition);
  switch (mappedSectorPosition) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      anchorAngle = middleAngle;
      break;
    case "startAngle":
    case "insideStartAngle":
      anchorAngle = startAngle;
      break;
    case "endAngle":
    case "insideEndAngle":
      anchorAngle = endAngle;
      break;
    default:
      sector.setTextConfig({
        rotation: 0
      });
      return;
  }
  var rotate2 = Math.PI * 1.5 - anchorAngle;
  if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
    rotate2 -= Math.PI;
  }
  sector.setTextConfig({
    rotation: rotate2
  });
}
function adjustAngleDistanceX(angle, distance2, isEnd) {
  return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle, distance2, isEnd) {
  return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
}
var mathMax$3 = Math.max;
var mathMin$3 = Math.min;
function getClipArea(coord, data) {
  var coordSysClipArea = coord.getArea && coord.getArea();
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var baseAxis = coord.getBaseAxis();
    if (baseAxis.type !== "category" || !baseAxis.onBand) {
      var expandWidth = data.getLayout("bandWidth");
      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }
  return coordSysClipArea;
}
var BarView = function(_super) {
  __extends(BarView2, _super);
  function BarView2() {
    var _this = _super.call(this) || this;
    _this.type = BarView2.type;
    _this._isFirstFrame = true;
    return _this;
  }
  BarView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    this._model = seriesModel;
    this._removeOnRenderedListener(api);
    this._updateDrawMode(seriesModel);
    var coordinateSystemType = seriesModel.get("coordinateSystem");
    if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
    }
  };
  BarView2.prototype.incrementalPrepareRender = function(seriesModel) {
    this._clear();
    this._updateDrawMode(seriesModel);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype.incrementalRender = function(params, seriesModel) {
    this._progressiveEls = [];
    this._incrementalRenderLarge(params, seriesModel);
  };
  BarView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  BarView2.prototype._updateDrawMode = function(seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  };
  BarView2.prototype._renderNormal = function(seriesModel, ecModel, api, payload) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;
    if (coord.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
    }
    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api);
    }
    var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
    var coordSysClipArea = getClipArea(coord, data);
    group.removeClipPath();
    var roundCap = seriesModel.get("roundCap", true);
    var drawBackground = seriesModel.get("showBackground", true);
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var barBorderRadius = backgroundModel.get("borderRadius") || 0;
    var bgEls = [];
    var oldBgEls = this._backgroundEls;
    var isInitSort = payload && payload.isInitSort;
    var isChangeOrder = payload && payload.type === "changeAxisOrder";
    function createBackground(dataIndex) {
      var bgLayout = getLayout[coord.type](data, dataIndex);
      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle());
      if (coord.type === "cartesian2d") {
        bgEl.setShape("r", barBorderRadius);
      }
      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    data.diff(oldData).add(function(dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      var layout2 = getLayout[coord.type](data, dataIndex, itemModel);
      if (drawBackground) {
        createBackground(dataIndex);
      }
      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout2)) {
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
      }
      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el, {
          shape: layout2
        }, seriesModel, dataIndex);
      }
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function(newIndex, oldIndex) {
      var itemModel = data.getItemModel(newIndex);
      var layout2 = getLayout[coord.type](data, newIndex, itemModel);
      if (drawBackground) {
        var bgEl = void 0;
        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          }
          bgEls[newIndex] = bgEl;
        }
        var bgLayout = getLayout[coord.type](data, newIndex);
        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps$1(bgEl, {
          shape
        }, animationModel, newIndex);
      }
      var el = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout2)) {
        group.remove(el);
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
        if (isClipped) {
          group.remove(el);
        }
      }
      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
      } else {
        saveOldStyle(el);
      }
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      if (isChangeOrder) {
        var textEl = el.getTextContent();
        if (textEl) {
          var labelInnerStore = labelInner(textEl);
          if (labelInnerStore.prevValue != null) {
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } else {
        updateStyle(el, data, newIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps$1(el, {
          shape: layout2
        }, seriesModel, newIndex, null);
      }
      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function(dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);
      el && removeElementWithFadeOut(el, seriesModel, dataIndex);
    }).execute();
    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group$3());
    bgGroup.removeAll();
    for (var i = 0; i < bgEls.length; ++i) {
      bgGroup.add(bgEls[i]);
    }
    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  };
  BarView2.prototype._renderLarge = function(seriesModel, ecModel, api) {
    this._clear();
    createLarge(seriesModel, this.group);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
    this._removeBackground();
    createLarge(seriesModel, this.group, this._progressiveEls, true);
  };
  BarView2.prototype._updateLargeClip = function(seriesModel) {
    var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    var group = this.group;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  };
  BarView2.prototype._enableRealtimeSort = function(realtimeSortCfg, data, api) {
    var _this = this;
    if (!data.count()) {
      return;
    }
    var baseAxis = realtimeSortCfg.baseAxis;
    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api);
      this._isFirstFrame = false;
    } else {
      var orderMapping_1 = function(idx) {
        var el = data.getItemGraphicEl(idx);
        var shape = el && el.shape;
        return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
      };
      this._onRendered = function() {
        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
      };
      api.getZr().on("rendered", this._onRendered);
    }
  };
  BarView2.prototype._dataSort = function(data, baseAxis, orderMapping) {
    var info = [];
    data.each(data.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
      var mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue,
        ordinalNumber
      });
    });
    info.sort(function(a2, b2) {
      return b2.mappedValue - a2.mappedValue;
    });
    return {
      ordinalNumbers: map$1(info, function(item) {
        return item.ordinalNumber;
      })
    };
  };
  BarView2.prototype._isOrderChangedWithinSameData = function(data, orderMapping, baseAxis) {
    var scale2 = baseAxis.scale;
    var ordinalDataDim = data.mapDimension(baseAxis.dim);
    var lastValue = Number.MAX_VALUE;
    for (var tickNum = 0, len2 = scale2.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
      var rawIdx = data.rawIndexOf(ordinalDataDim, scale2.getRawOrdinalNumber(tickNum));
      var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
      if (value > lastValue) {
        return true;
      }
      lastValue = value;
    }
    return false;
  };
  BarView2.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
    var scale2 = baseAxis.scale;
    var extent3 = scale2.getExtent();
    var tickNum = Math.max(0, extent3[0]);
    var tickMax = Math.min(extent3[1], scale2.getOrdinalMeta().categories.length - 1);
    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale2.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  };
  BarView2.prototype._updateSortWithinSameData = function(data, orderMapping, baseAxis, api) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }
    var sortInfo = this._dataSort(data, baseAxis, orderMapping);
    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api);
      api.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        axisId: baseAxis.index,
        sortInfo
      });
    }
  };
  BarView2.prototype._dispatchInitSort = function(data, realtimeSortCfg, api) {
    var baseAxis = realtimeSortCfg.baseAxis;
    var sortResult = this._dataSort(data, baseAxis, function(dataIdx) {
      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
    });
    api.dispatchAction({
      type: "changeAxisOrder",
      componentType: baseAxis.dim + "Axis",
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  };
  BarView2.prototype.remove = function(ecModel, api) {
    this._clear(this._model);
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype.dispose = function(ecModel, api) {
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype._removeOnRenderedListener = function(api) {
    if (this._onRendered) {
      api.getZr().off("rendered", this._onRendered);
      this._onRendered = null;
    }
  };
  BarView2.prototype._clear = function(model) {
    var group = this.group;
    var data = this._data;
    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();
      this._backgroundEls = [];
      data.eachItemGraphicEl(function(el) {
        removeElementWithFadeOut(el, model, getECData(el).dataIndex);
      });
    } else {
      group.removeAll();
    }
    this._data = null;
    this._isFirstFrame = true;
  };
  BarView2.prototype._removeBackground = function() {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  };
  BarView2.type = "bar";
  return BarView2;
}(ChartView$1);
var clip = {
  cartesian2d: function(coordSysBoundingRect, layout2) {
    var signWidth = layout2.width < 0 ? -1 : 1;
    var signHeight = layout2.height < 0 ? -1 : 1;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    var x2 = mathMax$3(layout2.x, coordSysBoundingRect.x);
    var x22 = mathMin$3(layout2.x + layout2.width, coordSysX2);
    var y = mathMax$3(layout2.y, coordSysBoundingRect.y);
    var y2 = mathMin$3(layout2.y + layout2.height, coordSysY2);
    var xClipped = x22 < x2;
    var yClipped = y2 < y;
    layout2.x = xClipped && x2 > coordSysX2 ? x22 : x2;
    layout2.y = yClipped && y > coordSysY2 ? y2 : y;
    layout2.width = xClipped ? 0 : x22 - x2;
    layout2.height = yClipped ? 0 : y2 - y;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    return xClipped || yClipped;
  },
  polar: function(coordSysClipArea, layout2) {
    var signR = layout2.r0 <= layout2.r ? 1 : -1;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    var r = mathMin$3(layout2.r, coordSysClipArea.r);
    var r0 = mathMax$3(layout2.r0, coordSysClipArea.r0);
    layout2.r = r;
    layout2.r0 = r0;
    var clipped = r - r0 < 0;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    return clipped;
  }
};
var elementCreator = {
  cartesian2d: function(seriesModel, data, newIndex, layout2, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    var rect = new Rect$2({
      shape: extend$3({}, layout2),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = "item";
    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? "height" : "width";
      rectShape[animateProperty] = 0;
    }
    return rect;
  },
  polar: function(seriesModel, data, newIndex, layout2, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    var ShapeClass = !isRadial && roundCap ? Sausage : Sector$1;
    var sector = new ShapeClass({
      shape: layout2,
      z2: 1
    });
    sector.name = "item";
    var positionMap = createPolarPositionMapping(isRadial);
    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === Sausage
    });
    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? "r" : "endAngle";
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout2.startAngle;
      animateTarget[animateProperty] = layout2[animateProperty];
      (isUpdate ? updateProps$1 : initProps)(sector, {
        shape: animateTarget
      }, animationModel);
    }
    return sector;
  }
};
function shouldRealtimeSort(seriesModel, coordSys) {
  var realtimeSortOption = seriesModel.get("realtimeSort", true);
  var baseAxis = coordSys.getBaseAxis();
  if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
    return {
      baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout2, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  var seriesTarget;
  var axisTarget;
  if (isHorizontal) {
    axisTarget = {
      x: layout2.x,
      width: layout2.width
    };
    seriesTarget = {
      y: layout2.y,
      height: layout2.height
    };
  } else {
    axisTarget = {
      y: layout2.y,
      height: layout2.height
    };
    seriesTarget = {
      x: layout2.x,
      width: layout2.width
    };
  }
  if (!isChangeOrder) {
    (isUpdate ? updateProps$1 : initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }
  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps$1 : initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props2) {
  for (var i = 0; i < props2.length; i++) {
    if (!isFinite(obj[props2[i]])) {
      return true;
    }
  }
  return false;
}
var rectPropties = ["x", "y", "width", "height"];
var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
var isValidLayout = {
  cartesian2d: function(layout2) {
    return !checkPropertiesNotValid(layout2, rectPropties);
  },
  polar: function(layout2) {
    return !checkPropertiesNotValid(layout2, polarPropties);
  }
};
var getLayout = {
  cartesian2d: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout2) : 0;
    var signX = layout2.width > 0 ? 1 : -1;
    var signY = layout2.height > 0 ? 1 : -1;
    return {
      x: layout2.x + signX * fixedLineWidth / 2,
      y: layout2.y + signY * fixedLineWidth / 2,
      width: layout2.width - signX * fixedLineWidth,
      height: layout2.height - signY * fixedLineWidth
    };
  },
  polar: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    return {
      cx: layout2.cx,
      cy: layout2.cy,
      r0: layout2.r0,
      r: layout2.r,
      startAngle: layout2.startAngle,
      endAngle: layout2.endAngle,
      clockwise: layout2.clockwise
    };
  }
};
function isZeroOnPolar(layout2) {
  return layout2.startAngle != null && layout2.endAngle != null && layout2.startAngle === layout2.endAngle;
}
function createPolarPositionMapping(isRadial) {
  return function(isRadial2) {
    var arcOrAngle = isRadial2 ? "Arc" : "Angle";
    return function(position2) {
      switch (position2) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return position2 + arcOrAngle;
        default:
          return position2;
      }
    };
  }(isRadial);
}
function updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, isPolar) {
  var style = data.getItemVisual(dataIndex, "style");
  if (!isPolar) {
    el.setShape("r", itemModel.get(["itemStyle", "borderRadius"]) || 0);
  }
  el.useStyle(style);
  var cursorStyle = itemModel.getShallow("cursor");
  cursorStyle && el.attr("cursor", cursorStyle);
  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout2.r >= layout2.r0 ? "endArc" : "startArc" : layout2.endAngle >= layout2.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout2.height >= 0 ? "bottom" : "top" : layout2.width >= 0 ? "right" : "left";
  var labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  var label = el.getTextContent();
  if (isPolar && label) {
    var position2 = itemModel.get(["label", "position"]);
    el.textConfig.inside = position2 === "middle" ? true : null;
    setSectorTextRotation(el, position2 === "outside" ? labelPositionOutside : position2, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
  }
  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value) {
    return getDefaultInterpolatedLabel(data, value);
  });
  var emphasisModel = itemModel.getModel(["emphasis"]);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  setStatesStylesFromModel(el, itemModel);
  if (isZeroOnPolar(layout2)) {
    el.style.fill = "none";
    el.style.stroke = "none";
    each$e(el.states, function(state) {
      if (state.style) {
        state.style.fill = state.style.stroke = "none";
      }
    });
  }
}
function getLineWidth(itemModel, rawLayout) {
  var borderColor = itemModel.get(["itemStyle", "borderColor"]);
  if (!borderColor || borderColor === "none") {
    return 0;
  }
  var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}
var LagePathShape = function() {
  function LagePathShape2() {
  }
  return LagePathShape2;
}();
var LargePath = function(_super) {
  __extends(LargePath2, _super);
  function LargePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "largeBar";
    return _this;
  }
  LargePath2.prototype.getDefaultShape = function() {
    return new LagePathShape();
  };
  LargePath2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var baseDimIdx = this.baseDimIdx;
    var valueDimIdx = 1 - this.baseDimIdx;
    var startPoint = [];
    var size = [];
    var barWidth = this.barWidth;
    for (var i = 0; i < points2.length; i += 3) {
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points2[i + 2];
      startPoint[baseDimIdx] = points2[i + baseDimIdx];
      startPoint[valueDimIdx] = points2[i + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
    }
  };
  return LargePath2;
}(Path$1);
function createLarge(seriesModel, group, progressiveEls, incremental) {
  var data = seriesModel.getData();
  var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
  var largeDataIndices = data.getLayout("largeDataIndices");
  var barWidth = data.getLayout("size");
  var backgroundModel = seriesModel.getModel("backgroundStyle");
  var bgPoints = data.getLayout("largeBackgroundPoints");
  if (bgPoints) {
    var bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }
  var el = new LargePath({
    shape: {
      points: data.getLayout("largePoints")
    },
    incremental: !!incremental,
    z2: 1
  });
  el.baseDimIdx = baseDimIdx;
  el.largeDataIndices = largeDataIndices;
  el.barWidth = barWidth;
  group.add(el);
  el.useStyle(data.getVisual("style"));
  getECData(el).seriesIndex = seriesModel.seriesIndex;
  if (!seriesModel.get("silent")) {
    el.on("mousedown", largePathUpdateDataIndex);
    el.on("mousemove", largePathUpdateDataIndex);
  }
  progressiveEls && progressiveEls.push(el);
}
var largePathUpdateDataIndex = throttle(function(event) {
  var largePath = this;
  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x2, y) {
  var baseDimIdx = largePath.baseDimIdx;
  var valueDimIdx = 1 - baseDimIdx;
  var points2 = largePath.shape.points;
  var largeDataIndices = largePath.largeDataIndices;
  var startPoint = [];
  var size = [];
  var barWidth = largePath.barWidth;
  for (var i = 0, len2 = points2.length / 3; i < len2; i++) {
    var ii = i * 3;
    size[baseDimIdx] = barWidth;
    size[valueDimIdx] = points2[ii + 2];
    startPoint[baseDimIdx] = points2[ii + baseDimIdx];
    startPoint[valueDimIdx] = points2[ii + valueDimIdx];
    if (size[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size[valueDimIdx];
      size[valueDimIdx] = -size[valueDimIdx];
    }
    if (x2 >= startPoint[0] && x2 <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {
      return largeDataIndices[i];
    }
  }
  return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout2, coord) {
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var rectShape = layout2;
    var coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    var coordLayout = coord.getArea();
    var sectorShape = layout2;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout2) {
  var ElementClz = coord.type === "polar" ? Sector$1 : Rect$2;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout2, coord),
    silent: true,
    z2: 0
  });
}
var BarView$1 = BarView;
function install$t(registers) {
  registers.registerChartView(BarView$1);
  registers.registerSeriesModel(BarSeries);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$2, "bar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
  registers.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}
var PI2$1 = Math.PI * 2;
var RADIAN$1 = Math.PI / 180;
function getViewRect$1(seriesModel, api) {
  return getLayoutRect$1(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function getBasicPieLayout(seriesModel, api) {
  var viewRect2 = getViewRect$1(seriesModel, api);
  var center2 = seriesModel.get("center");
  var radius = seriesModel.get("radius");
  if (!isArray$4(radius)) {
    radius = [0, radius];
  }
  if (!isArray$4(center2)) {
    center2 = [center2, center2];
  }
  var width = parsePercent(viewRect2.width, api.getWidth());
  var height = parsePercent(viewRect2.height, api.getHeight());
  var size = Math.min(width, height);
  var cx = parsePercent(center2[0], width) + viewRect2.x;
  var cy = parsePercent(center2[1], height) + viewRect2.y;
  var r0 = parsePercent(radius[0], size / 2);
  var r = parsePercent(radius[1], size / 2);
  return {
    cx,
    cy,
    r0,
    r
  };
}
function pieLayout(seriesType2, ecModel, api) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var viewRect2 = getViewRect$1(seriesModel, api);
    var _a2 = getBasicPieLayout(seriesModel, api), cx = _a2.cx, cy = _a2.cy, r = _a2.r, r0 = _a2.r0;
    var startAngle = -seriesModel.get("startAngle") * RADIAN$1;
    var minAngle = seriesModel.get("minAngle") * RADIAN$1;
    var validDataCount = 0;
    data.each(valueDim, function(value) {
      !isNaN(value) && validDataCount++;
    });
    var sum = data.getSum(valueDim);
    var unitRadian = Math.PI / (sum || validDataCount) * 2;
    var clockwise = seriesModel.get("clockwise");
    var roseType = seriesModel.get("roseType");
    var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    var extent3 = data.getDataExtent(valueDim);
    extent3[0] = 0;
    var restAngle = PI2$1;
    var valueSumLargerThanMinAngle = 0;
    var currentAngle = startAngle;
    var dir3 = clockwise ? 1 : -1;
    data.setLayout({
      viewRect: viewRect2,
      r
    });
    data.each(valueDim, function(value, idx) {
      var angle;
      if (isNaN(value)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? NaN : r
        });
        return;
      }
      if (roseType !== "area") {
        angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle = PI2$1 / validDataCount;
      }
      if (angle < minAngle) {
        angle = minAngle;
        restAngle -= minAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }
      var endAngle = currentAngle + dir3 * angle;
      data.setItemLayout(idx, {
        angle,
        startAngle: currentAngle,
        endAngle,
        clockwise,
        cx,
        cy,
        r0,
        r: roseType ? linearMap$2(value, extent3, [r0, r]) : r
      });
      currentAngle = endAngle;
    });
    if (restAngle < PI2$1 && validDataCount) {
      if (restAngle <= 1e-3) {
        var angle_1 = PI2$1 / validDataCount;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_1 = data.getItemLayout(idx);
            layout_1.angle = angle_1;
            layout_1.startAngle = startAngle + dir3 * idx * angle_1;
            layout_1.endAngle = startAngle + dir3 * (idx + 1) * angle_1;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_2 = data.getItemLayout(idx);
            var angle = layout_2.angle === minAngle ? minAngle : value * unitRadian;
            layout_2.startAngle = currentAngle;
            layout_2.endAngle = currentAngle + dir3 * angle;
            currentAngle += dir3 * angle;
          }
        });
      }
    }
  });
}
function dataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var name = data.getName(idx);
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(name)) {
            return false;
          }
        }
        return true;
      });
    }
  };
}
var RADIAN = Math.PI / 180;
function adjustSingleSide(list2, cx, cy, r, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list2.length < 2) {
    return;
  }
  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    var rB = semi.rB;
    var rB2 = rB * rB;
    for (var i2 = 0; i2 < semi.list.length; i2++) {
      var item = semi.list[i2];
      var dy = Math.abs(item.label.y - cy);
      var rA = r + item.len;
      var rA2 = rA * rA;
      var dx2 = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
      var newX = cx + (dx2 + item.len2) * dir3;
      var deltaX = newX - item.label.x;
      var newTargetWidth = item.targetTextWidth - deltaX * dir3;
      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  }
  function recalculateX(items) {
    var topSemi = {
      list: [],
      maxY: 0
    };
    var bottomSemi = {
      list: [],
      maxY: 0
    };
    for (var i2 = 0; i2 < items.length; i2++) {
      if (items[i2].labelAlignTo !== "none") {
        continue;
      }
      var item = items[i2];
      var semi = item.label.y > cy ? bottomSemi : topSemi;
      var dy = Math.abs(item.label.y - cy);
      if (dy >= semi.maxY) {
        var dx2 = item.label.x - cx - item.len2 * dir3;
        var rA = r + item.len;
        var rB = Math.abs(dx2) < rA ? Math.sqrt(dy * dy / (1 - dx2 * dx2 / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }
      semi.list.push(item);
    }
    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }
  var len2 = list2.length;
  for (var i = 0; i < len2; i++) {
    if (list2[i].position === "outer" && list2[i].labelAlignTo === "labelLine") {
      var dx = list2[i].label.x - farthestX;
      list2[i].linePoints[1][0] += dx;
      list2[i].label.x = farthestX;
    }
  }
  if (shiftLayoutOnY(list2, viewTop, viewTop + viewHeight)) {
    recalculateX(list2);
  }
}
function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
  var leftList = [];
  var rightList = [];
  var leftmostX = Number.MAX_VALUE;
  var rightmostX = -Number.MAX_VALUE;
  for (var i = 0; i < labelLayoutList.length; i++) {
    var label = labelLayoutList[i].label;
    if (isPositionCenter(labelLayoutList[i])) {
      continue;
    }
    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i]);
    }
  }
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      if (layout2.labelStyleWidth != null) {
        continue;
      }
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var targetTextWidth = void 0;
      if (layout2.labelAlignTo === "edge") {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout2.labelDistance - viewLeft - layout2.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout2.edgeDistance - linePoints[2][0] - layout2.labelDistance;
        }
      } else if (layout2.labelAlignTo === "labelLine") {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout2.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout2.bleedMargin;
        }
      }
      layout2.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout2, targetTextWidth);
    }
  }
  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var isAlignToEdge = layout2.labelAlignTo === "edge";
      var padding = label.style.padding;
      var paddingH = padding ? padding[1] + padding[3] : 0;
      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      var realTextWidth = layout2.rect.width + extraPaddingH;
      var dist2 = linePoints[1][0] - linePoints[2][0];
      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout2.edgeDistance + realTextWidth + layout2.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout2.edgeDistance - realTextWidth - layout2.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout2.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout2.labelDistance;
        }
        linePoints[1][0] = linePoints[2][0] + dist2;
      }
      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
function constrainTextWidth(layout2, availableWidth, forceRecalculate) {
  if (forceRecalculate === void 0) {
    forceRecalculate = false;
  }
  if (layout2.labelStyleWidth != null) {
    return;
  }
  var label = layout2.label;
  var style = label.style;
  var textRect = layout2.rect;
  var bgColor = style.backgroundColor;
  var padding = style.padding;
  var paddingH = padding ? padding[1] + padding[3] : 0;
  var overflow = style.overflow;
  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
  if (availableWidth < oldOuterWidth || forceRecalculate) {
    var oldHeight = textRect.height;
    if (overflow && overflow.match("break")) {
      label.setStyle("backgroundColor", null);
      label.setStyle("width", availableWidth - paddingH);
      var innerRect = label.getBoundingRect();
      label.setStyle("width", Math.ceil(innerRect.width));
      label.setStyle("backgroundColor", bgColor);
    } else {
      var availableInnerWidth = availableWidth - paddingH;
      var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout2.unconstrainedWidth ? null : availableInnerWidth : null;
      label.setStyle("width", newWidth);
    }
    var newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    var margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}
function isPositionCenter(sectorShape) {
  return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
  var data = seriesModel.getData();
  var labelLayoutList = [];
  var cx;
  var cy;
  var hasLabelRotate = false;
  var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN;
  var viewRect2 = data.getLayout("viewRect");
  var r = data.getLayout("r");
  var viewWidth = viewRect2.width;
  var viewLeft = viewRect2.x;
  var viewTop = viewRect2.y;
  var viewHeight = viewRect2.height;
  function setNotShow(el) {
    el.ignore = true;
  }
  function isLabelShown(label2) {
    if (!label2.ignore) {
      return true;
    }
    for (var key2 in label2.states) {
      if (label2.states[key2].ignore === false) {
        return true;
      }
    }
    return false;
  }
  data.each(function(idx) {
    var sector = data.getItemGraphicEl(idx);
    var sectorShape = sector.shape;
    var label2 = sector.getTextContent();
    var labelLine2 = sector.getTextGuideLine();
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel("label");
    var labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
    var labelDistance = labelModel.get("distanceToLabelLine");
    var labelAlignTo = labelModel.get("alignTo");
    var edgeDistance = parsePercent(labelModel.get("edgeDistance"), viewWidth);
    var bleedMargin = labelModel.get("bleedMargin");
    var labelLineModel = itemModel.getModel("labelLine");
    var labelLineLen = labelLineModel.get("length");
    labelLineLen = parsePercent(labelLineLen, viewWidth);
    var labelLineLen2 = labelLineModel.get("length2");
    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);
    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each$e(label2.states, setNotShow);
      label2.ignore = true;
      return;
    }
    if (!isLabelShown(label2)) {
      return;
    }
    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    var nx = Math.cos(midAngle);
    var ny = Math.sin(midAngle);
    var textX;
    var textY;
    var linePoints2;
    var textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
    if (labelPosition === "center") {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = "center";
    } else {
      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;
      if (!isLabelInside) {
        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        var y3 = y2;
        if (labelAlignTo === "edge") {
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }
        textY = y3;
        linePoints2 = [[x1, y1], [x2, y2], [x3, y3]];
      }
      textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
    }
    var PI3 = Math.PI;
    var labelRotate = 0;
    var rotate2 = labelModel.get("rotate");
    if (isNumber$1(rotate2)) {
      labelRotate = rotate2 * (PI3 / 180);
    } else if (labelPosition === "center") {
      labelRotate = 0;
    } else if (rotate2 === "radial" || rotate2 === true) {
      var radialAngle = nx < 0 ? -midAngle + PI3 : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
      var rad = Math.atan2(nx, ny);
      if (rad < 0) {
        rad = PI3 * 2 + rad;
      }
      var isDown = ny > 0;
      if (isDown) {
        rad = PI3 + rad;
      }
      labelRotate = rad - PI3;
    }
    hasLabelRotate = !!labelRotate;
    label2.x = textX;
    label2.y = textY;
    label2.rotation = labelRotate;
    label2.setStyle({
      verticalAlign: "middle"
    });
    if (!isLabelInside) {
      var textRect = label2.getBoundingRect().clone();
      textRect.applyTransform(label2.getComputedTransform());
      var margin = (label2.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label: label2,
        labelLine: labelLine2,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get("minTurnAngle"),
        maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
        surfaceNormal: new Point$1(nx, ny),
        linePoints: linePoints2,
        textAlign,
        labelDistance,
        labelAlignTo,
        edgeDistance,
        bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label2.style.width
      });
    } else {
      label2.setStyle({
        align: textAlign
      });
      var selectState2 = label2.states.select;
      if (selectState2) {
        selectState2.x += label2.x;
        selectState2.y += label2.y;
      }
    }
    sector.setTextConfig({
      inside: isLabelInside
    });
  });
  if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
  }
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    var label = layout2.label;
    var labelLine = layout2.labelLine;
    var notShowLabel = isNaN(label.x) || isNaN(label.y);
    if (label) {
      label.setStyle({
        align: layout2.textAlign
      });
      if (notShowLabel) {
        each$e(label.states, setNotShow);
        label.ignore = true;
      }
      var selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    if (labelLine) {
      var linePoints = layout2.linePoints;
      if (notShowLabel || !linePoints) {
        each$e(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout2.minTurnAngle);
        limitSurfaceAngle(linePoints, layout2.surfaceNormal, layout2.maxSurfaceAngle);
        labelLine.setShape({
          points: linePoints
        });
        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point$1(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}
function getSectorCornerRadius(model, shape, zeroIfNull) {
  var cornerRadius = model.get("borderRadius");
  if (cornerRadius == null) {
    return zeroIfNull ? {
      cornerRadius: 0
    } : null;
  }
  if (!isArray$4(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }
  var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map$1(cornerRadius, function(cr) {
      return parsePercent$1(cr, dr);
    })
  };
}
var PiePiece = function(_super) {
  __extends(PiePiece2, _super);
  function PiePiece2(data, idx, startAngle) {
    var _this = _super.call(this) || this;
    _this.z2 = 2;
    var text2 = new ZRText$1();
    _this.setTextContent(text2);
    _this.updateData(data, idx, startAngle, true);
    return _this;
  }
  PiePiece2.prototype.updateData = function(data, idx, startAngle, firstCreate) {
    var sector = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var emphasisModel = itemModel.getModel("emphasis");
    var layout2 = data.getItemLayout(idx);
    var sectorShape = extend$3(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout2, true), layout2);
    if (isNaN(sectorShape.startAngle)) {
      sector.setShape(sectorShape);
      return;
    }
    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow("animationType");
      if (seriesModel.ecModel.ssr) {
        initProps(sector, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex: idx,
          isFrom: true
        });
        sector.originX = sectorShape.cx;
        sector.originY = sectorShape.cy;
      } else if (animationType === "scale") {
        sector.shape.r = layout2.r0;
        initProps(sector, {
          shape: {
            r: layout2.r
          }
        }, seriesModel, idx);
      } else {
        if (startAngle != null) {
          sector.setShape({
            startAngle,
            endAngle: startAngle
          });
          initProps(sector, {
            shape: {
              startAngle: layout2.startAngle,
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout2.startAngle;
          updateProps$1(sector, {
            shape: {
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        }
      }
    } else {
      saveOldStyle(sector);
      updateProps$1(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }
    sector.useStyle(data.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector, itemModel);
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var offset2 = seriesModel.get("selectedOffset");
    var dx = Math.cos(midAngle) * offset2;
    var dy = Math.sin(midAngle) * offset2;
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._updateLabel(seriesModel, data, idx);
    sector.ensureState("emphasis").shape = extend$3({
      r: layout2.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout2));
    extend$3(sector.ensureState("select"), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout2)
    });
    extend$3(sector.ensureState("blur"), {
      shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout2)
    });
    var labelLine = sector.getTextGuideLine();
    var labelText = sector.getTextContent();
    labelLine && extend$3(labelLine.ensureState("select"), {
      x: dx,
      y: dy
    });
    extend$3(labelText.ensureState("select"), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  PiePiece2.prototype._updateLabel = function(seriesModel, data, idx) {
    var sector = this;
    var itemModel = data.getItemModel(idx);
    var labelLineModel = itemModel.getModel("labelLine");
    var style = data.getItemVisual(idx, "style");
    var visualColor = style && style.fill;
    var visualOpacity = style && style.opacity;
    setLabelStyle(sector, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
    });
    var labelText = sector.getTextContent();
    sector.setTextConfig({
      position: null,
      rotation: null
    });
    labelText.attr({
      z2: 10
    });
    var labelPosition = seriesModel.get(["label", "position"]);
    if (labelPosition !== "outside" && labelPosition !== "outer") {
      sector.removeTextGuideLine();
    } else {
      var polyline = this.getTextGuideLine();
      if (!polyline) {
        polyline = new Polyline$1();
        this.setTextGuideLine(polyline);
      }
      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
      });
    }
  };
  return PiePiece2;
}(Sector$1);
var PieView = function(_super) {
  __extends(PieView2, _super);
  function PieView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }
  PieView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var startAngle;
    if (!oldData && data.count() > 0) {
      var shape = data.getItemLayout(0);
      for (var s2 = 1; isNaN(shape && shape.startAngle) && s2 < data.count(); ++s2) {
        shape = data.getItemLayout(s2);
      }
      if (shape) {
        startAngle = shape.startAngle;
      }
    }
    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    }
    if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
      var sector = new Sector$1({
        shape: getBasicPieLayout(seriesModel, api)
      });
      sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
      this._emptyCircleSector = sector;
      group.add(sector);
    }
    data.diff(oldData).add(function(idx) {
      var piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function(newIdx, oldIdx) {
      var piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off("click");
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function(idx) {
      var piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel);
    if (seriesModel.get("animationTypeUpdate") !== "expansion") {
      this._data = data;
    }
  };
  PieView2.prototype.dispose = function() {
  };
  PieView2.prototype.containPoint = function(point, seriesModel) {
    var data = seriesModel.getData();
    var itemLayout = data.getItemLayout(0);
    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };
  PieView2.type = "pie";
  return PieView2;
}(ChartView$1);
var PieView$1 = PieView;
function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray$4(opt) && {
    coordDimensions: opt
  } || extend$3({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  var source = seriesModel.getSource();
  var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
  var list2 = new SeriesData$1(dimensions, seriesModel);
  list2.initData(source, nameList);
  return list2;
}
var LegendVisualProvider = function() {
  function LegendVisualProvider2(getDataWithEncodedVisual, getRawData2) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData2;
  }
  LegendVisualProvider2.prototype.getAllNames = function() {
    var rawData = this._getRawData();
    return rawData.mapArray(rawData.getName);
  };
  LegendVisualProvider2.prototype.containName = function(name) {
    var rawData = this._getRawData();
    return rawData.indexOfName(name) >= 0;
  };
  LegendVisualProvider2.prototype.indexOfName = function(name) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.indexOfName(name);
  };
  LegendVisualProvider2.prototype.getItemVisual = function(dataIndex, key2) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.getItemVisual(dataIndex, key2);
  };
  return LegendVisualProvider2;
}();
var LegendVisualProvider$1 = LegendVisualProvider;
var PieSeriesModel = function(_super) {
  __extends(PieSeriesModel2, _super);
  function PieSeriesModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PieSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    this._defaultLabelLine(option);
  };
  PieSeriesModel2.prototype.mergeOption = function() {
    _super.prototype.mergeOption.apply(this, arguments);
  };
  PieSeriesModel2.prototype.getInitialData = function() {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
  };
  PieSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var data = this.getData();
    var params = _super.prototype.getDataParams.call(this, dataIndex);
    var valueList = [];
    data.each(data.mapDimension("value"), function(value) {
      valueList.push(value);
    });
    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get("percentPrecision"));
    params.$vars.push("percent");
    return params;
  };
  PieSeriesModel2.prototype._defaultLabelLine = function(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };
  PieSeriesModel2.type = "series.pie";
  PieSeriesModel2.defaultOption = {
    z: 2,
    legendHoverLink: true,
    colorBy: "data",
    center: ["50%", "50%"],
    radius: [0, "75%"],
    clockwise: true,
    startAngle: 90,
    minAngle: 0,
    minShowLabelAngle: 0,
    selectedOffset: 10,
    percentPrecision: 2,
    stillShowZeroSum: true,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    width: null,
    height: null,
    label: {
      rotate: 0,
      show: true,
      overflow: "truncate",
      position: "outer",
      alignTo: "none",
      edgeDistance: "25%",
      bleedMargin: 10,
      distanceToLabelLine: 5
    },
    labelLine: {
      show: true,
      length: 15,
      length2: 15,
      smooth: false,
      minTurnAngle: 90,
      maxSurfaceAngle: 90,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      borderWidth: 1,
      borderJoin: "round"
    },
    showEmptyCircle: true,
    emptyCircleStyle: {
      color: "lightgray",
      opacity: 1
    },
    labelLayout: {
      hideOverlap: true
    },
    emphasis: {
      scale: true,
      scaleSize: 5
    },
    avoidLabelOverlap: true,
    animationType: "expansion",
    animationDuration: 1e3,
    animationTypeUpdate: "transition",
    animationEasingUpdate: "cubicInOut",
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut"
  };
  return PieSeriesModel2;
}(SeriesModel$1);
var PieSeriesModel$1 = PieSeriesModel;
function negativeDataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var valueDim = data.mapDimension("value");
        var curValue = data.get(valueDim, idx);
        if (isNumber$1(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }
        return true;
      });
    }
  };
}
function install$s(registers) {
  registers.registerChartView(PieView$1);
  registers.registerSeriesModel(PieSeriesModel$1);
  createLegacyDataSelectAction("pie", registers.registerAction);
  registers.registerLayout(curry$1(pieLayout, "pie"));
  registers.registerProcessor(dataFilter("pie"));
  registers.registerProcessor(negativeDataFilter("pie"));
}
var GridModel = function(_super) {
  __extends(GridModel2, _super);
  function GridModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridModel2.type = "grid";
  GridModel2.dependencies = ["xAxis", "yAxis"];
  GridModel2.layoutMode = "box";
  GridModel2.defaultOption = {
    show: false,
    z: 0,
    left: "10%",
    top: 60,
    right: "10%",
    bottom: 70,
    containLabel: false,
    backgroundColor: "rgba(0,0,0,0)",
    borderWidth: 1,
    borderColor: "#ccc"
  };
  return GridModel2;
}(ComponentModel$1);
var GridModel$1 = GridModel;
var CartesianAxisModel = function(_super) {
  __extends(CartesianAxisModel2, _super);
  function CartesianAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
  };
  CartesianAxisModel2.type = "cartesian2dAxis";
  return CartesianAxisModel2;
}(ComponentModel$1);
mixin(CartesianAxisModel, AxisModelCommonMixin);
var defaultOption$1 = {
  show: true,
  z: 0,
  inverse: false,
  name: "",
  nameLocation: "end",
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  nameTextStyle: {},
  nameGap: 15,
  silent: false,
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    inside: false,
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    inside: false,
    rotate: 0,
    showMinLabel: null,
    showMaxLabel: null,
    margin: 8,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
};
var categoryAxis = merge({
  boundaryGap: true,
  deduplication: null,
  splitLine: {
    show: false
  },
  axisTick: {
    alignWithLabel: false,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption$1);
var valueAxis = merge({
  boundaryGap: [0, 0],
  axisLine: {
    show: "auto"
  },
  axisTick: {
    show: "auto"
  },
  splitNumber: 5,
  minorTick: {
    show: false,
    splitNumber: 5,
    length: 3,
    lineStyle: {}
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption$1);
var timeAxis = merge({
  splitNumber: 6,
  axisLabel: {
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = defaults$1({
  logBase: 10
}, valueAxis);
var axisDefault = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each$e(AXIS_TYPES, function(v2, axisType) {
    var defaultOption2 = merge(merge({}, axisDefault[axisType], true), extraDefaultOption, true);
    var AxisModel = function(_super) {
      __extends(AxisModel2, _super);
      function AxisModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = axisName + "Axis." + axisType;
        return _this;
      }
      AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge(option, themeModel.get(axisType + "Axis"));
        merge(option, this.getDefaultOption());
        option.type = getAxisType(option);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      AxisModel2.prototype.optionUpdated = function() {
        var thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this);
        }
      };
      AxisModel2.prototype.getCategories = function(rawData) {
        var option = this.option;
        if (option.type === "category") {
          if (rawData) {
            return option.data;
          }
          return this.__ordinalMeta.categories;
        }
      };
      AxisModel2.prototype.getOrdinalMeta = function() {
        return this.__ordinalMeta;
      };
      AxisModel2.type = axisName + "Axis." + axisType;
      AxisModel2.defaultOption = defaultOption2;
      return AxisModel2;
    }(BaseAxisModelClass);
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
}
function getAxisType(option) {
  return option.type || (option.data ? "category" : "value");
}
var Cartesian = function() {
  function Cartesian2(name) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name || "";
  }
  Cartesian2.prototype.getAxis = function(dim) {
    return this._axes[dim];
  };
  Cartesian2.prototype.getAxes = function() {
    return map$1(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  };
  Cartesian2.prototype.getAxesByScale = function(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter$2(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  };
  Cartesian2.prototype.addAxis = function(axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  };
  return Cartesian2;
}();
var Cartesian$1 = Cartesian;
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale2) {
  return scale2.type === "interval" || scale2.type === "time";
}
var Cartesian2D = function(_super) {
  __extends(Cartesian2D2, _super);
  function Cartesian2D2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cartesian2d";
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  Cartesian2D2.prototype.calcAffineTransform = function() {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis("x").scale;
    var yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    var scaleX = (end2[0] - start2[0]) / xScaleSpan;
    var scaleY = (end2[1] - start2[1]) / yScaleSpan;
    var translateX = start2[0] - xScaleExtent[0] * scaleX;
    var translateY = start2[1] - yScaleExtent[0] * scaleY;
    var m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m2);
  };
  Cartesian2D2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  };
  Cartesian2D2.prototype.containPoint = function(point) {
    var axisX = this.getAxis("x");
    var axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  };
  Cartesian2D2.prototype.containData = function(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
  };
  Cartesian2D2.prototype.dataToPoint = function(data, clamp2, out2) {
    out2 = out2 || [];
    var xVal = data[0];
    var yVal = data[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform$1(out2, data, this._transform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
    out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
    return out2;
  };
  Cartesian2D2.prototype.clampData = function(data, out2) {
    var xScale = this.getAxis("x").scale;
    var yScale = this.getAxis("y").scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x2 = xScale.parse(data[0]);
    var y = yScale.parse(data[1]);
    out2 = out2 || [];
    out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x2), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out2;
  };
  Cartesian2D2.prototype.pointToData = function(point, clamp2) {
    var out2 = [];
    if (this._invTransform) {
      return applyTransform$1(out2, point, this._invTransform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
    out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
    return out2;
  };
  Cartesian2D2.prototype.getOtherAxis = function(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  };
  Cartesian2D2.prototype.getArea = function() {
    var xExtent = this.getAxis("x").getGlobalExtent();
    var yExtent = this.getAxis("y").getGlobalExtent();
    var x2 = Math.min(xExtent[0], xExtent[1]);
    var y = Math.min(yExtent[0], yExtent[1]);
    var width = Math.max(xExtent[0], xExtent[1]) - x2;
    var height = Math.max(yExtent[0], yExtent[1]) - y;
    return new BoundingRect$1(x2, y, width, height);
  };
  return Cartesian2D2;
}(Cartesian$1);
var Cartesian2D$1 = Cartesian2D;
var Axis2D = function(_super) {
  __extends(Axis2D2, _super);
  function Axis2D2(dim, scale2, coordExtent, axisType, position2) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.index = 0;
    _this.type = axisType || "value";
    _this.position = position2 || "bottom";
    return _this;
  }
  Axis2D2.prototype.isHorizontal = function() {
    var position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  };
  Axis2D2.prototype.getGlobalExtent = function(asc2) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc2 && ret[0] > ret[1] && ret.reverse();
    return ret;
  };
  Axis2D2.prototype.pointToData = function(point, clamp2) {
    return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
  };
  Axis2D2.prototype.setCategorySortInfo = function(info) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  };
  return Axis2D2;
}(Axis$1);
var Axis2D$1 = Axis2D;
function layout$1(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid2 = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout2 = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid2.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get("offset") || 0;
  var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  }
  layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
  layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
  layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
  if (axisModel.get(["axisTick", "inside"])) {
    layout2.tickDirection = -layout2.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout2.labelDirection = -layout2.labelDirection;
  }
  var labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout2.z2 = 1;
  return layout2;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(seriesModel) {
  var axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each$e(axisModelMap, function(v2, key2) {
    var axisType = key2.replace(/Model$/, "");
    var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
    axisModelMap[key2] = axisModel;
  });
  return axisModelMap;
}
var mathLog = Math.log;
function alignScaleTicks(scale2, axisModel, alignToScale) {
  var intervalScaleProto2 = IntervalScale$1.prototype;
  var alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
  var alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
  var alignToSplitNumber = alignToTicks.length - 1;
  var alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
  var scaleExtent = getScaleExtent(scale2, axisModel);
  var rawExtent = scaleExtent.extent;
  var isMinFixed = scaleExtent.fixMin;
  var isMaxFixed = scaleExtent.fixMax;
  if (scale2.type === "log") {
    var logBase = mathLog(scale2.base);
    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];
  }
  scale2.setExtent(rawExtent[0], rawExtent[1]);
  scale2.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  var extent3 = intervalScaleProto2.getExtent.call(scale2);
  if (isMinFixed) {
    rawExtent[0] = extent3[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent3[1];
  }
  var interval = intervalScaleProto2.getInterval.call(scale2);
  var min3 = rawExtent[0];
  var max3 = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max3 - min3) / alignToSplitNumber;
  } else if (isMinFixed) {
    max3 = rawExtent[0] + interval * alignToSplitNumber;
    while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max3 = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min3 = rawExtent[1] - interval * alignToSplitNumber;
    while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min3 = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    var nicedSplitNumber = scale2.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    var range = interval * alignToSplitNumber;
    max3 = Math.ceil(rawExtent[1] / interval) * interval;
    min3 = round$4(max3 - range);
    if (min3 < 0 && rawExtent[0] >= 0) {
      min3 = 0;
      max3 = round$4(range);
    } else if (max3 > 0 && rawExtent[1] <= 0) {
      max3 = 0;
      min3 = -round$4(range);
    }
  }
  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto2.setExtent.call(scale2, min3 + interval * t0, max3 + interval * t1);
  intervalScaleProto2.setInterval.call(scale2, interval);
  if (t0 || t1) {
    intervalScaleProto2.setNiceExtent.call(scale2, min3 + interval, max3 - interval);
  }
}
var Grid = function() {
  function Grid2(gridModel, ecModel, api) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api);
    this.model = gridModel;
  }
  Grid2.prototype.getRect = function() {
    return this._rect;
  };
  Grid2.prototype.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      var alignTo;
      var axesIndices = keys$1(axes);
      var len2 = axesIndices.length;
      if (!len2) {
        return;
      }
      var axisNeedsAlign = [];
      for (var i = len2 - 1; i >= 0; i--) {
        var idx = +axesIndices[i];
        var axis = axes[idx];
        var model = axis.model;
        var scale2 = axis.scale;
        if (isIntervalOrLogScale(scale2) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale2, model);
          if (isIntervalOrLogScale(scale2)) {
            alignTo = axis;
          }
        }
      }
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each$e(axisNeedsAlign, function(axis2) {
          alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    var onZeroRecords = {};
    each$e(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each$e(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api);
  };
  Grid2.prototype.resize = function(gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
    var gridRect = getLayoutRect$1(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (isContainLabel) {
      each$e(axesList, function(axis) {
        if (!axis.model.get(["axisLabel", "inside"])) {
          var labelUnionRect = estimateLabelUnionRect(axis);
          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? "height" : "width";
            var margin = axis.model.get(["axisLabel", "margin"]);
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    each$e(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
    function adjustAxes() {
      each$e(axesList, function(axis) {
        var isHorizontal = axis.isHorizontal();
        var extent3 = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent3[idx], extent3[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  Grid2.prototype.getAxis = function(dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  };
  Grid2.prototype.getAxes = function() {
    return this._axesList.slice();
  };
  Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key2 = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key2];
    }
    if (isObject$9(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
        return coordList[i];
      }
    }
  };
  Grid2.prototype.getCartesians = function() {
    return this._coordsList.slice();
  };
  Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };
  Grid2.prototype._findConvertTarget = function(finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      var grid2 = gridModel.coordinateSystem;
      if (grid2 === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {
      cartesian,
      axis
    };
  };
  Grid2.prototype.containPoint = function(point) {
    var coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  };
  Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
    var _this = this;
    var grid2 = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each$e(axesMap.x, function(xAxis, xAxisIndex) {
      each$e(axesMap.y, function(yAxis, yAxisIndex) {
        var key2 = "x" + xAxisIndex + "y" + yAxisIndex;
        var cartesian = new Cartesian2D$1(key2);
        cartesian.master = _this;
        cartesian.model = gridModel;
        _this._coordsMap[key2] = cartesian;
        _this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        var axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D$1(dimName, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        var isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid2;
        axis.index = idx;
        grid2._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  Grid2.prototype._updateScale = function(ecModel, gridModel) {
    each$e(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        var categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis("x");
        var yAxis = cartesian.getAxis("y");
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);
    function unionExtent(data, axis) {
      each$e(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  };
  Grid2.prototype.getTooltipAxes = function(dim) {
    var baseAxes = [];
    var otherAxes = [];
    each$e(this.getCartesians(), function(cartesian) {
      var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes,
      otherAxes
    };
  };
  Grid2.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      var grid2 = new Grid2(gridModel, ecModel, api);
      grid2.name = "grid_" + idx;
      grid2.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid2;
      grids.push(grid2);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }
      var axesModelMap = findAxisModels(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();
      var grid2 = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid2.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  };
  Grid2.dimensions = cartesian2DDimensions;
  return Grid2;
}();
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(["axisLine", "onZero"]);
  var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
var Grid$1 = Grid;
var PI$3 = Math.PI;
var AxisBuilder = function() {
  function AxisBuilder2(axisModel, opt) {
    this.group = new Group$3();
    this.opt = opt;
    this.axisModel = axisModel;
    defaults$1(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: function() {
        return true;
      }
    });
    var transformGroup = new Group$3({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    });
    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }
  AxisBuilder2.prototype.hasBuilder = function(name) {
    return !!builders[name];
  };
  AxisBuilder2.prototype.add = function(name) {
    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
  };
  AxisBuilder2.prototype.getGroup = function() {
    return this.group;
  };
  AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI$3)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI$3) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  };
  AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  };
  AxisBuilder2.isLabelSilent = function(axisModel) {
    var tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  };
  return AxisBuilder2;
}();
var builders = {
  axisLine: function(opt, axisModel, group, transformGroup) {
    var shown = axisModel.get(["axisLine", "show"]);
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisLine");
    }
    if (!shown) {
      return;
    }
    var extent3 = axisModel.axis.getExtent();
    var matrix2 = transformGroup.transform;
    var pt12 = [extent3[0], 0];
    var pt22 = [extent3[1], 0];
    if (matrix2) {
      applyTransform$1(pt12, pt12, matrix2);
      applyTransform$1(pt22, pt22, matrix2);
    }
    var lineStyle = extend$3({
      lineCap: "round"
    }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
    var line = new Line$1({
      subPixelOptimize: true,
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    line.anid = "line";
    group.add(line);
    var arrows = axisModel.get(["axisLine", "symbol"]);
    if (arrows != null) {
      var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
      if (isString$2(arrows)) {
        arrows = [arrows, arrows];
      }
      if (isString$2(arrowSize) || isNumber$1(arrowSize)) {
        arrowSize = [arrowSize, arrowSize];
      }
      var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
      var symbolWidth_1 = arrowSize[0];
      var symbolHeight_1 = arrowSize[1];
      each$e([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
      }], function(point, index2) {
        if (arrows[index2] !== "none" && arrows[index2] != null) {
          var symbol = createSymbol(arrows[index2], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
          var r = point.r + point.offset;
          symbol.attr({
            rotation: point.rotate,
            x: pt12[0] + r * Math.cos(opt.rotation),
            y: pt12[1] - r * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel: function(opt, axisModel, group, transformGroup) {
    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
    if (axisModel.get(["axisLabel", "hideOverlap"])) {
      var labelList = prepareLayoutList(map$1(labelEls, function(label) {
        return {
          label,
          priority: label.z2,
          defaultAttr: {
            ignore: label.ignore
          }
        };
      }));
      hideOverlap(labelList);
    }
  },
  axisName: function(opt, axisModel, group, transformGroup) {
    var name = retrieve(opt.axisName, axisModel.get("name"));
    if (!name) {
      return;
    }
    var nameLocation = axisModel.get("nameLocation");
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel("nameTextStyle");
    var gap = axisModel.get("nameGap") || 0;
    var extent3 = axisModel.axis.getExtent();
    var gapSignal = extent3[0] > extent3[1] ? -1 : 1;
    var pos = [
      nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
      isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
    ];
    var labelLayout;
    var nameRotation = axisModel.get("nameRotate");
    if (nameRotation != null) {
      nameRotation = nameRotation * PI$3 / 180;
    }
    var axisNameAvailableWidth;
    if (isNameLocationCenter(nameLocation)) {
      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
    } else {
      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;
      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }
    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get("nameTruncate", true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    var textEl = new ZRText$1({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle$1(textStyleModel, {
        text: name,
        font: textFont,
        overflow: "truncate",
        width: maxWidth,
        ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
        align: textStyleModel.get("align") || labelLayout.textAlign,
        verticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name
    });
    textEl.__fullText = name;
    textEl.anid = "name";
    if (axisModel.get("triggerEvent")) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisName";
      eventData.name = name;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};
function endTextLayout(rotation, textPosition, textRotate, extent3) {
  var rotationDiff = remRadian(textRotate - rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent3[0] > extent3[1];
  var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
  if (isRadianAroundZero(rotationDiff - PI$3 / 2)) {
    textVerticalAlign = onLeft ? "bottom" : "top";
    textAlign = "center";
  } else if (isRadianAroundZero(rotationDiff - PI$3 * 1.5)) {
    textVerticalAlign = onLeft ? "top" : "bottom";
    textAlign = "center";
  } else {
    textVerticalAlign = "middle";
    if (rotationDiff < PI$3 * 1.5 && rotationDiff > PI$3 / 2) {
      textAlign = onLeft ? "left" : "right";
    } else {
      textAlign = onLeft ? "right" : "left";
    }
  }
  return {
    rotation: rotationDiff,
    textAlign,
    textVerticalAlign
  };
}
function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  }
  var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
  var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick2 = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];
  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick2);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }
  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}
function ignoreEl(el) {
  el && (el.ignore = true);
}
function isTwoLabelOverlapped(current, next2) {
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next2 && next2.getBoundingRect().clone();
  if (!firstRect || !nextRect) {
    return;
  }
  var mRotationBack = identity$1([]);
  rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(mul([], mRotationBack, next2.getLocalTransform()));
  return firstRect.intersect(nextRect);
}
function isNameLocationCenter(nameLocation) {
  return nameLocation === "middle" || nameLocation === "center";
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  var tickEls = [];
  var pt12 = [];
  var pt22 = [];
  for (var i = 0; i < ticksCoords.length; i++) {
    var tickCoord = ticksCoords[i].coord;
    pt12[0] = tickCoord;
    pt12[1] = 0;
    pt22[0] = tickCoord;
    pt22[1] = tickEndCoord;
    if (tickTransform) {
      applyTransform$1(pt12, pt12, tickTransform);
      applyTransform$1(pt22, pt22, tickTransform);
    }
    var tickEl = new Line$1({
      subPixelOptimize: true,
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    tickEl.anid = anidPrefix + "_" + ticksCoords[i].tickValue;
    tickEls.push(tickEl);
  }
  return tickEls;
}
function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var tickModel = axisModel.getModel("axisTick");
  var shown = tickModel.get("show");
  if (shown === "auto" && opt.handleAutoShown) {
    shown = opt.handleAutoShown("axisTick");
  }
  if (!shown || axis.scale.isBlank()) {
    return;
  }
  var lineStyleModel = tickModel.getModel("lineStyle");
  var tickEndCoord = opt.tickDirection * tickModel.get("length");
  var ticksCoords = axis.getTicksCoords();
  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults$1(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }), "ticks");
  for (var i = 0; i < ticksEls.length; i++) {
    group.add(ticksEls[i]);
  }
  return ticksEls;
}
function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  var axis = axisModel.axis;
  var minorTickModel = axisModel.getModel("minorTick");
  if (!minorTickModel.get("show") || axis.scale.isBlank()) {
    return;
  }
  var minorTicksCoords = axis.getMinorTicksCoords();
  if (!minorTicksCoords.length) {
    return;
  }
  var lineStyleModel = minorTickModel.getModel("lineStyle");
  var tickEndCoord = tickDirection * minorTickModel.get("length");
  var minorTickLineStyle = defaults$1(lineStyleModel.getLineStyle(), defaults$1(axisModel.getModel("axisTick").getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }));
  for (var i = 0; i < minorTicksCoords.length; i++) {
    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
    for (var k = 0; k < minorTicksEls.length; k++) {
      group.add(minorTicksEls[k]);
    }
  }
}
function buildAxisLabel(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
  if (!show || axis.scale.isBlank()) {
    return;
  }
  var labelModel = axisModel.getModel("axisLabel");
  var labelMargin = labelModel.get("margin");
  var labels = axis.getViewLabels();
  var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI$3 / 180;
  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  var labelEls = [];
  var silent = AxisBuilder.isLabelSilent(axisModel);
  var triggerEvent = axisModel.get("triggerEvent");
  each$e(labels, function(labelItem, index2) {
    var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;
    if (rawCategoryData && rawCategoryData[tickValue]) {
      var rawCategoryItem = rawCategoryData[tickValue];
      if (isObject$9(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model$1(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }
    var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
    var tickCoord = axis.dataToCoord(tickValue);
    var textEl = new ZRText$1({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout.rotation,
      silent,
      z2: 10 + (labelItem.level || 0),
      style: createTextStyle$1(itemLabelModel, {
        text: formattedLabel,
        align: itemLabelModel.getShallow("align", true) || labelLayout.textAlign,
        verticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout.textVerticalAlign,
        fill: isFunction$2(textColor) ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, index2) : textColor
      })
    });
    textEl.anid = "label_" + tickValue;
    if (triggerEvent) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisLabel";
      eventData.value = rawLabel;
      eventData.tickIndex = index2;
      if (axis.type === "category") {
        eventData.dataIndex = tickValue;
      }
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}
var AxisBuilder$1 = AxisBuilder;
function collect(ecModel, api) {
  var result = {
    axesInfo: {},
    seriesInvolved: false,
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api);
  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}
function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent("tooltip");
  var globalAxisPointerModel = ecModel.getComponent("axisPointer");
  var linksOption = globalAxisPointerModel.get("link", true) || [];
  var linkGroups = [];
  each$e(api.getCoordinateSystems(), function(coordSys) {
    if (!coordSys.axisPointerEnabled) {
      return;
    }
    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys;
    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
    each$e(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null));
    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
      var triggerAxis = baseTooltipModel.get("trigger") === "axis";
      var cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
      if (triggerAxis || cross) {
        each$e(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
      }
      if (cross) {
        each$e(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, "cross", false));
      }
    }
    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get("show");
      if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }
      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get("triggerTooltip");
      }
      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get("snap");
      var axisKey = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === "category";
      var axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis,
        coordSys,
        axisPointerModel,
        triggerTooltip,
        involveSeries,
        snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);
      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
  var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
  var volatileOption = {};
  each$e(fields, function(field) {
    volatileOption[field] = clone$3(tooltipAxisPointerModel.get(field));
  });
  volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
  if (tooltipAxisPointerModel.get("type") === "cross") {
    volatileOption.type = "line";
  }
  var labelOption = volatileOption.label || (volatileOption.label = {});
  labelOption.show == null && (labelOption.show = false);
  if (fromTooltip === "cross") {
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
      crossStyle && defaults$1(labelOption, crossStyle.textStyle);
    }
  }
  return axis.model.getModel("axisPointer", new Model$1(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
  ecModel.eachSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
    var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
    if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
      return;
    }
    each$e(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
      var axis = axisInfo.axis;
      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;
  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};
    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
      return i;
    }
  }
}
function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === "all" || isArray$4(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  if (!axisInfo) {
    return;
  }
  var axisPointerModel = axisInfo.axisPointerModel;
  var scale2 = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get("status");
  var value = axisPointerModel.get("value");
  if (value != null) {
    value = scale2.parse(value);
  }
  var useHandle = isHandleTrigger(axisPointerModel);
  if (status == null) {
    option.status = useHandle ? "show" : "hide";
  }
  var extent3 = scale2.getExtent().slice();
  extent3[0] > extent3[1] && extent3.reverse();
  if (value == null || value > extent3[1]) {
    value = extent3[1];
  }
  if (value < extent3[0]) {
    value = extent3[0];
  }
  option.value = value;
  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
  }
}
function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(["handle", "show"]);
}
function makeKey(model) {
  return model.type + "||" + model.id;
}
var axisPointerClazz = {};
var AxisView = function(_super) {
  __extends(AxisView2, _super);
  function AxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisView2.type;
    return _this;
  }
  AxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.axisPointerClass && fixValue(axisModel);
    _super.prototype.render.apply(this, arguments);
    this._doUpdateAxisPointerClass(axisModel, api, true);
  };
  AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
    this._doUpdateAxisPointerClass(axisModel, api, false);
  };
  AxisView2.prototype.remove = function(ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
  };
  AxisView2.prototype.dispose = function(ecModel, api) {
    this._disposeAxisPointer(api);
    _super.prototype.dispose.apply(this, arguments);
  };
  AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
    var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
    if (!Clazz) {
      return;
    }
    var axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
  };
  AxisView2.prototype._disposeAxisPointer = function(api) {
    this._axisPointer && this._axisPointer.dispose(api);
    this._axisPointer = null;
  };
  AxisView2.registerAxisPointerClass = function(type, clazz) {
    axisPointerClazz[type] = clazz;
  };
  AxisView2.getAxisPointerClass = function(type) {
    return type && axisPointerClazz[type];
  };
  AxisView2.type = "axis";
  return AxisView2;
}(ComponentView$1);
var AxisView$1 = AxisView;
var inner$8 = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  var axis = axisModel.axis;
  if (axis.scale.isBlank()) {
    return;
  }
  var splitAreaModel = axisModel.getModel("splitArea");
  var areaStyleModel = splitAreaModel.getModel("areaStyle");
  var areaColors = areaStyleModel.get("color");
  var gridRect = gridModel.coordinateSystem.getRect();
  var ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });
  if (!ticksCoords.length) {
    return;
  }
  var areaColorsLen = areaColors.length;
  var lastSplitAreaColors = inner$8(axisView).splitAreaColors;
  var newSplitAreaColors = createHashMap();
  var colorIndex = 0;
  if (lastSplitAreaColors) {
    for (var i = 0; i < ticksCoords.length; i++) {
      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
        break;
      }
    }
  }
  var prev2 = axis.toGlobalCoord(ticksCoords[0].coord);
  var areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray$4(areaColors) ? areaColors : [areaColors];
  for (var i = 1; i < ticksCoords.length; i++) {
    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
    var x2 = void 0;
    var y = void 0;
    var width = void 0;
    var height = void 0;
    if (axis.isHorizontal()) {
      x2 = prev2;
      y = gridRect.y;
      width = tickCoord - x2;
      height = gridRect.height;
      prev2 = x2 + width;
    } else {
      x2 = gridRect.x;
      y = prev2;
      width = gridRect.width;
      height = tickCoord - y;
      prev2 = y + height;
    }
    var tickValue = ticksCoords[i - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect$2({
      anid: tickValue != null ? "area_" + tickValue : null,
      shape: {
        x: x2,
        y,
        width,
        height
      },
      style: defaults$1({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }
  inner$8(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner$8(axisView).splitAreaColors = null;
}
var axisBuilderAttrs$2 = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs$1 = ["splitArea", "splitLine", "minorSplitLine"];
var CartesianAxisView = function(_super) {
  __extends(CartesianAxisView2, _super);
  function CartesianAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianAxisView2.type;
    _this.axisPointerClass = "CartesianAxisPointer";
    return _this;
  }
  CartesianAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$3();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var gridModel = axisModel.getCoordSysModel();
    var layout2 = layout$1(gridModel, axisModel);
    var axisBuilder = new AxisBuilder$1(axisModel, extend$3({
      handleAutoShown: function(elementType) {
        var cartesians = gridModel.coordinateSystem.getCartesians();
        for (var i = 0; i < cartesians.length; i++) {
          if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
            return true;
          }
        }
        return false;
      }
    }, layout2));
    each$e(axisBuilderAttrs$2, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    each$e(selfBuilderAttrs$1, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders$1[name](this, this._axisGroup, axisModel, gridModel);
      }
    }, this);
    var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }
    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };
  CartesianAxisView2.prototype.remove = function() {
    rectCoordAxisHandleRemove(this);
  };
  CartesianAxisView2.type = "cartesianAxis";
  return CartesianAxisView2;
}(AxisView$1);
var axisElementBuilders$1 = {
  splitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    lineColors = isArray$4(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      var colorIndex = lineCount++ % lineColors.length;
      var tickValue = ticksCoords[i].tickValue;
      axisGroup.add(new Line$1({
        anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
        subPixelOptimize: true,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: defaults$1({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      }));
    }
  },
  minorSplitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    var minorSplitLineModel = axisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        axisGroup.add(new Line$1({
          anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
          subPixelOptimize: true,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: lineStyle,
          silent: true
        }));
      }
    }
  },
  splitArea: function(axisView, axisGroup, axisModel, gridModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  }
};
var CartesianXAxisView = function(_super) {
  __extends(CartesianXAxisView2, _super);
  function CartesianXAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView2.type;
    return _this;
  }
  CartesianXAxisView2.type = "xAxis";
  return CartesianXAxisView2;
}(CartesianAxisView);
var CartesianYAxisView = function(_super) {
  __extends(CartesianYAxisView2, _super);
  function CartesianYAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView.type;
    return _this;
  }
  CartesianYAxisView2.type = "yAxis";
  return CartesianYAxisView2;
}(CartesianAxisView);
var GridView = function(_super) {
  __extends(GridView2, _super);
  function GridView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grid";
    return _this;
  }
  GridView2.prototype.render = function(gridModel, ecModel) {
    this.group.removeAll();
    if (gridModel.get("show")) {
      this.group.add(new Rect$2({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults$1({
          fill: gridModel.get("backgroundColor")
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  };
  GridView2.type = "grid";
  return GridView2;
}(ComponentView$1);
var extraOption = {
  offset: 0
};
function install$r(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel$1);
  registers.registerCoordinateSystem("cartesian2d", Grid$1);
  axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
  axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}
function radarLayout(ecModel) {
  ecModel.eachSeriesByType("radar", function(seriesModel) {
    var data = seriesModel.getData();
    var points2 = [];
    var coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      return;
    }
    var axes = coordSys.getIndicatorAxes();
    each$e(axes, function(axis, axisIndex) {
      data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
        points2[dataIndex] = points2[dataIndex] || [];
        var point = coordSys.dataToPoint(val, axisIndex);
        points2[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
      });
    });
    data.each(function(idx) {
      var firstPoint = find$1(points2[idx], function(point) {
        return isValidPoint(point);
      }) || getValueMissingPoint(coordSys);
      points2[idx].push(firstPoint.slice());
      data.setItemLayout(idx, points2[idx]);
    });
  });
}
function isValidPoint(point) {
  return !isNaN(point[0]) && !isNaN(point[1]);
}
function getValueMissingPoint(coordSys) {
  return [coordSys.cx, coordSys.cy];
}
function radarBackwardCompat(option) {
  var polarOptArr = option.polar;
  if (polarOptArr) {
    if (!isArray$4(polarOptArr)) {
      polarOptArr = [polarOptArr];
    }
    var polarNotRadar_1 = [];
    each$e(polarOptArr, function(polarOpt, idx) {
      if (polarOpt.indicator) {
        if (polarOpt.type && !polarOpt.shape) {
          polarOpt.shape = polarOpt.type;
        }
        option.radar = option.radar || [];
        if (!isArray$4(option.radar)) {
          option.radar = [option.radar];
        }
        option.radar.push(polarOpt);
      } else {
        polarNotRadar_1.push(polarOpt);
      }
    });
    option.polar = polarNotRadar_1;
  }
  each$e(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
      seriesOpt.radarIndex = seriesOpt.polarIndex;
    }
  });
}
var RadarView$2 = function(_super) {
  __extends(RadarView2, _super);
  function RadarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView2.type;
    return _this;
  }
  RadarView2.prototype.render = function(seriesModel, ecModel, api) {
    var polar = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    function createSymbol$1(data2, idx) {
      var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
      if (symbolType === "none") {
        return;
      }
      var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
      var symbolPath = createSymbol(symbolType, -1, -1, 2, 2);
      var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
      symbolPath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 100,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2,
        rotation: symbolRotate * Math.PI / 180 || 0
      });
      return symbolPath;
    }
    function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
      symbolGroup.removeAll();
      for (var i = 0; i < newPoints.length - 1; i++) {
        var symbolPath = createSymbol$1(data2, idx);
        if (symbolPath) {
          symbolPath.__dimIdx = i;
          if (oldPoints[i]) {
            symbolPath.setPosition(oldPoints[i]);
            graphic$1[isInit ? "initProps" : "updateProps"](symbolPath, {
              x: newPoints[i][0],
              y: newPoints[i][1]
            }, seriesModel, idx);
          } else {
            symbolPath.setPosition(newPoints[i]);
          }
          symbolGroup.add(symbolPath);
        }
      }
    }
    function getInitialPoints(points2) {
      return map$1(points2, function(pt) {
        return [polar.cx, polar.cy];
      });
    }
    data.diff(oldData).add(function(idx) {
      var points2 = data.getItemLayout(idx);
      if (!points2) {
        return;
      }
      var polygon = new Polygon$1();
      var polyline = new Polyline$1();
      var target = {
        shape: {
          points: points2
        }
      };
      polygon.shape.points = getInitialPoints(points2);
      polyline.shape.points = getInitialPoints(points2);
      initProps(polygon, target, seriesModel, idx);
      initProps(polyline, target, seriesModel, idx);
      var itemGroup = new Group$3();
      var symbolGroup = new Group$3();
      itemGroup.add(polyline);
      itemGroup.add(polygon);
      itemGroup.add(symbolGroup);
      updateSymbols(polyline.shape.points, points2, symbolGroup, data, idx, true);
      data.setItemGraphicEl(idx, itemGroup);
    }).update(function(newIdx, oldIdx) {
      var itemGroup = oldData.getItemGraphicEl(oldIdx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var target = {
        shape: {
          points: data.getItemLayout(newIdx)
        }
      };
      if (!target.shape.points) {
        return;
      }
      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
      saveOldStyle(polygon);
      saveOldStyle(polyline);
      updateProps$1(polyline, target, seriesModel);
      updateProps$1(polygon, target, seriesModel);
      data.setItemGraphicEl(newIdx, itemGroup);
    }).remove(function(idx) {
      group.remove(oldData.getItemGraphicEl(idx));
    }).execute();
    data.eachItemGraphicEl(function(itemGroup, idx) {
      var itemModel = data.getItemModel(idx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var itemStyle = data.getItemVisual(idx, "style");
      var color2 = itemStyle.fill;
      group.add(itemGroup);
      polyline.useStyle(defaults$1(itemModel.getModel("lineStyle").getLineStyle(), {
        fill: "none",
        stroke: color2
      }));
      setStatesStylesFromModel(polyline, itemModel, "lineStyle");
      setStatesStylesFromModel(polygon, itemModel, "areaStyle");
      var areaStyleModel = itemModel.getModel("areaStyle");
      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
      polygon.ignore = polygonIgnore;
      each$e(["emphasis", "select", "blur"], function(stateName) {
        var stateModel = itemModel.getModel([stateName, "areaStyle"]);
        var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
        polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
      });
      polygon.useStyle(defaults$1(areaStyleModel.getAreaStyle(), {
        fill: color2,
        opacity: 0.7,
        decal: itemStyle.decal
      }));
      var emphasisModel = itemModel.getModel("emphasis");
      var itemHoverStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      symbolGroup.eachChild(function(symbolPath) {
        if (symbolPath instanceof ZRImage$1) {
          var pathStyle = symbolPath.style;
          symbolPath.useStyle(extend$3({
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, itemStyle));
        } else {
          symbolPath.useStyle(itemStyle);
          symbolPath.setColor(color2);
          symbolPath.style.strokeNoScale = true;
        }
        var pathEmphasisState = symbolPath.ensureState("emphasis");
        pathEmphasisState.style = clone$3(itemHoverStyle);
        var defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
        (defaultText == null || isNaN(defaultText)) && (defaultText = "");
        setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          labelDimIndex: symbolPath.__dimIdx,
          defaultText,
          inheritColor: color2,
          defaultOpacity: itemStyle.opacity
        });
      });
      toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    this._data = data;
  };
  RadarView2.prototype.remove = function() {
    this.group.removeAll();
    this._data = null;
  };
  RadarView2.type = "radar";
  return RadarView2;
}(ChartView$1);
var RadarView$3 = RadarView$2;
var RadarSeriesModel = function(_super) {
  __extends(RadarSeriesModel2, _super);
  function RadarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  RadarSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
  };
  RadarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, {
      generateCoord: "indicator_",
      generateCoordCount: Infinity
    });
  };
  RadarSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var coordSys = this.coordinateSystem;
    var indicatorAxes = coordSys.getIndicatorAxes();
    var name = this.getData().getName(dataIndex);
    var nameToDisplay = name === "" ? this.name : name;
    var markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
    return createTooltipMarkup("section", {
      header: nameToDisplay,
      sortBlocks: true,
      blocks: map$1(indicatorAxes, function(axis) {
        var val = data.get(data.mapDimension(axis.dim), dataIndex);
        return createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor,
          name: axis.name,
          value: val,
          sortParam: val
        });
      })
    });
  };
  RadarSeriesModel2.prototype.getTooltipPosition = function(dataIndex) {
    if (dataIndex != null) {
      var data_1 = this.getData();
      var coordSys = this.coordinateSystem;
      var values = data_1.getValues(map$1(coordSys.dimensions, function(dim) {
        return data_1.mapDimension(dim);
      }), dataIndex);
      for (var i = 0, len2 = values.length; i < len2; i++) {
        if (!isNaN(values[i])) {
          var indicatorAxes = coordSys.getIndicatorAxes();
          return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
        }
      }
    }
  };
  RadarSeriesModel2.type = "series.radar";
  RadarSeriesModel2.dependencies = ["radar"];
  RadarSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    coordinateSystem: "radar",
    legendHoverLink: true,
    radarIndex: 0,
    lineStyle: {
      width: 2,
      type: "solid",
      join: "round"
    },
    label: {
      position: "top"
    },
    symbolSize: 8
  };
  return RadarSeriesModel2;
}(SeriesModel$1);
var RadarSeriesModel$1 = RadarSeriesModel;
var valueAxisDefault = axisDefault.value;
function defaultsShow(opt, show) {
  return defaults$1({
    show
  }, opt);
}
var RadarModel = function(_super) {
  __extends(RadarModel2, _super);
  function RadarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarModel2.type;
    return _this;
  }
  RadarModel2.prototype.optionUpdated = function() {
    var boundaryGap = this.get("boundaryGap");
    var splitNumber = this.get("splitNumber");
    var scale2 = this.get("scale");
    var axisLine = this.get("axisLine");
    var axisTick = this.get("axisTick");
    var axisLabel = this.get("axisLabel");
    var nameTextStyle = this.get("axisName");
    var showName = this.get(["axisName", "show"]);
    var nameFormatter = this.get(["axisName", "formatter"]);
    var nameGap = this.get("axisNameGap");
    var triggerEvent = this.get("triggerEvent");
    var indicatorModels = map$1(this.get("indicator") || [], function(indicatorOpt) {
      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
        indicatorOpt.min = 0;
      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
        indicatorOpt.max = 0;
      }
      var iNameTextStyle = nameTextStyle;
      if (indicatorOpt.color != null) {
        iNameTextStyle = defaults$1({
          color: indicatorOpt.color
        }, nameTextStyle);
      }
      var innerIndicatorOpt = merge(clone$3(indicatorOpt), {
        boundaryGap,
        splitNumber,
        scale: scale2,
        axisLine,
        axisTick,
        axisLabel,
        name: indicatorOpt.text,
        showName,
        nameLocation: "end",
        nameGap,
        nameTextStyle: iNameTextStyle,
        triggerEvent
      }, false);
      if (!showName) {
        innerIndicatorOpt.name = "";
      }
      if (isString$2(nameFormatter)) {
        var indName = innerIndicatorOpt.name;
        innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
      } else if (isFunction$2(nameFormatter)) {
        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
      }
      var model = new Model$1(innerIndicatorOpt, null, this.ecModel);
      mixin(model, AxisModelCommonMixin.prototype);
      model.mainType = "radar";
      model.componentIndex = this.componentIndex;
      return model;
    }, this);
    this._indicatorModels = indicatorModels;
  };
  RadarModel2.prototype.getIndicatorModels = function() {
    return this._indicatorModels;
  };
  RadarModel2.type = "radar";
  RadarModel2.defaultOption = {
    z: 0,
    center: ["50%", "50%"],
    radius: "75%",
    startAngle: 90,
    axisName: {
      show: true
    },
    boundaryGap: [0, 0],
    splitNumber: 5,
    axisNameGap: 15,
    scale: false,
    shape: "polygon",
    axisLine: merge({
      lineStyle: {
        color: "#bbb"
      }
    }, valueAxisDefault.axisLine),
    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
    axisTick: defaultsShow(valueAxisDefault.axisTick, false),
    splitLine: defaultsShow(valueAxisDefault.splitLine, true),
    splitArea: defaultsShow(valueAxisDefault.splitArea, true),
    indicator: []
  };
  return RadarModel2;
}(ComponentModel$1);
var RadarModel$1 = RadarModel;
var axisBuilderAttrs$1 = ["axisLine", "axisTickLabel", "axisName"];
var RadarView = function(_super) {
  __extends(RadarView2, _super);
  function RadarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView2.type;
    return _this;
  }
  RadarView2.prototype.render = function(radarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    this._buildAxes(radarModel);
    this._buildSplitLineAndArea(radarModel);
  };
  RadarView2.prototype._buildAxes = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    var axisBuilders = map$1(indicatorAxes, function(indicatorAxis) {
      var axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
      var axisBuilder = new AxisBuilder$1(indicatorAxis.model, {
        axisName,
        position: [radar.cx, radar.cy],
        rotation: indicatorAxis.angle,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1
      });
      return axisBuilder;
    });
    each$e(axisBuilders, function(axisBuilder) {
      each$e(axisBuilderAttrs$1, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
    }, this);
  };
  RadarView2.prototype._buildSplitLineAndArea = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    if (!indicatorAxes.length) {
      return;
    }
    var shape = radarModel.get("shape");
    var splitLineModel = radarModel.getModel("splitLine");
    var splitAreaModel = radarModel.getModel("splitArea");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var showSplitLine = splitLineModel.get("show");
    var showSplitArea = splitAreaModel.get("show");
    var splitLineColors = lineStyleModel.get("color");
    var splitAreaColors = areaStyleModel.get("color");
    var splitLineColorsArr = isArray$4(splitLineColors) ? splitLineColors : [splitLineColors];
    var splitAreaColorsArr = isArray$4(splitAreaColors) ? splitAreaColors : [splitAreaColors];
    var splitLines = [];
    var splitAreas = [];
    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
      var colorIndex2 = idx % areaOrLineColorList.length;
      areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
      return colorIndex2;
    }
    if (shape === "circle") {
      var ticksRadius = indicatorAxes[0].getTicksCoords();
      var cx = radar.cx;
      var cy = radar.cy;
      for (var i = 0; i < ticksRadius.length; i++) {
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Circle$1({
            shape: {
              cx,
              cy,
              r: ticksRadius[i].coord
            }
          }));
        }
        if (showSplitArea && i < ticksRadius.length - 1) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);
          splitAreas[colorIndex].push(new Ring$1({
            shape: {
              cx,
              cy,
              r0: ticksRadius[i].coord,
              r: ticksRadius[i + 1].coord
            }
          }));
        }
      }
    } else {
      var realSplitNumber_1;
      var axesTicksPoints = map$1(indicatorAxes, function(indicatorAxis, idx) {
        var ticksCoords = indicatorAxis.getTicksCoords();
        realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);
        return map$1(ticksCoords, function(tickCoord) {
          return radar.coordToPoint(tickCoord.coord, idx);
        });
      });
      var prevPoints = [];
      for (var i = 0; i <= realSplitNumber_1; i++) {
        var points2 = [];
        for (var j = 0; j < indicatorAxes.length; j++) {
          points2.push(axesTicksPoints[j][i]);
        }
        if (points2[0]) {
          points2.push(points2[0].slice());
        }
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Polyline$1({
            shape: {
              points: points2
            }
          }));
        }
        if (showSplitArea && prevPoints) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);
          splitAreas[colorIndex].push(new Polygon$1({
            shape: {
              points: points2.concat(prevPoints)
            }
          }));
        }
        prevPoints = points2.slice().reverse();
      }
    }
    var lineStyle = lineStyleModel.getLineStyle();
    var areaStyle = areaStyleModel.getAreaStyle();
    each$e(splitAreas, function(splitAreas2, idx) {
      this.group.add(mergePath(splitAreas2, {
        style: defaults$1({
          stroke: "none",
          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
        }, areaStyle),
        silent: true
      }));
    }, this);
    each$e(splitLines, function(splitLines2, idx) {
      this.group.add(mergePath(splitLines2, {
        style: defaults$1({
          fill: "none",
          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
        }, lineStyle),
        silent: true
      }));
    }, this);
  };
  RadarView2.type = "radar";
  return RadarView2;
}(ComponentView$1);
var RadarView$1 = RadarView;
var IndicatorAxis = function(_super) {
  __extends(IndicatorAxis2, _super);
  function IndicatorAxis2(dim, scale2, radiusExtent) {
    var _this = _super.call(this, dim, scale2, radiusExtent) || this;
    _this.type = "value";
    _this.angle = 0;
    _this.name = "";
    return _this;
  }
  return IndicatorAxis2;
}(Axis$1);
var IndicatorAxis$1 = IndicatorAxis;
var Radar = function() {
  function Radar2(radarModel, ecModel, api) {
    this.dimensions = [];
    this._model = radarModel;
    this._indicatorAxes = map$1(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      var dim = "indicator_" + idx;
      var indicatorAxis = new IndicatorAxis$1(dim, new IntervalScale$1());
      indicatorAxis.name = indicatorModel.get("name");
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
  }
  Radar2.prototype.getIndicatorAxes = function() {
    return this._indicatorAxes;
  };
  Radar2.prototype.dataToPoint = function(value, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  };
  Radar2.prototype.coordToPoint = function(coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle = indicatorAxis.angle;
    var x2 = this.cx + coord * Math.cos(angle);
    var y = this.cy - coord * Math.sin(angle);
    return [x2, y];
  };
  Radar2.prototype.pointToData = function(pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx);
    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;
    for (var i = 0; i < this._indicatorAxes.length; i++) {
      var indicatorAxis = this._indicatorAxes[i];
      var diff = Math.abs(radian - indicatorAxis.angle);
      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  };
  Radar2.prototype.resize = function(radarModel, api) {
    var center2 = radarModel.get("center");
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = parsePercent(center2[0], viewWidth);
    this.cy = parsePercent(center2[1], viewHeight);
    this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
    var radius = radarModel.get("radius");
    if (isString$2(radius) || isNumber$1(radius)) {
      radius = [0, radius];
    }
    this.r0 = parsePercent(radius[0], viewSize);
    this.r = parsePercent(radius[1], viewSize);
    each$e(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  };
  Radar2.prototype.update = function(ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    each$e(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
      if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
        return;
      }
      var data = radarSeries.getData();
      each$e(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get("splitNumber");
    var dummyScale = new IntervalScale$1();
    dummyScale.setExtent(0, splitNumber);
    dummyScale.setInterval(1);
    each$e(indicatorAxes, function(indicatorAxis, idx) {
      alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
    });
  };
  Radar2.prototype.convertToPixel = function(ecModel, finder, value) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.containPoint = function(point) {
    console.warn("Not implemented.");
    return false;
  };
  Radar2.create = function(ecModel, api) {
    var radarList = [];
    ecModel.eachComponent("radar", function(radarModel) {
      var radar = new Radar2(radarModel, ecModel, api);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType("radar", function(radarSeries) {
      if (radarSeries.get("coordinateSystem") === "radar") {
        radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
      }
    });
    return radarList;
  };
  Radar2.dimensions = [];
  return Radar2;
}();
var Radar$1 = Radar;
function install$q(registers) {
  registers.registerCoordinateSystem("radar", Radar$1);
  registers.registerComponentModel(RadarModel$1);
  registers.registerComponentView(RadarView$1);
  registers.registerVisual({
    seriesType: "radar",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      data.each(function(idx) {
        data.setItemVisual(idx, "legendIcon", "roundRect");
      });
      data.setVisual("legendIcon", "roundRect");
    }
  });
}
function install$p(registers) {
  use(install$q);
  registers.registerChartView(RadarView$3);
  registers.registerSeriesModel(RadarSeriesModel$1);
  registers.registerLayout(radarLayout);
  registers.registerProcessor(dataFilter("radar"));
  registers.registerPreprocessor(radarBackwardCompat);
}
var ATTR = "\0_ec_interaction_mutex";
function take(zr, resourceKey, userKey) {
  var store = getStore(zr);
  store[resourceKey] = userKey;
}
function release(zr, resourceKey, userKey) {
  var store = getStore(zr);
  var uKey = store[resourceKey];
  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}
function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}
function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
registerAction({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, noop$2);
var RoamController = function(_super) {
  __extends(RoamController2, _super);
  function RoamController2(zr) {
    var _this = _super.call(this) || this;
    _this._zr = zr;
    var mousedownHandler = bind$1(_this._mousedownHandler, _this);
    var mousemoveHandler = bind$1(_this._mousemoveHandler, _this);
    var mouseupHandler = bind$1(_this._mouseupHandler, _this);
    var mousewheelHandler = bind$1(_this._mousewheelHandler, _this);
    var pinchHandler = bind$1(_this._pinchHandler, _this);
    _this.enable = function(controlType, opt) {
      this.disable();
      this._opt = defaults$1(clone$3(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });
      if (controlType == null) {
        controlType = true;
      }
      if (controlType === true || controlType === "move" || controlType === "pan") {
        zr.on("mousedown", mousedownHandler);
        zr.on("mousemove", mousemoveHandler);
        zr.on("mouseup", mouseupHandler);
      }
      if (controlType === true || controlType === "scale" || controlType === "zoom") {
        zr.on("mousewheel", mousewheelHandler);
        zr.on("pinch", pinchHandler);
      }
    };
    _this.disable = function() {
      zr.off("mousedown", mousedownHandler);
      zr.off("mousemove", mousemoveHandler);
      zr.off("mouseup", mouseupHandler);
      zr.off("mousewheel", mousewheelHandler);
      zr.off("pinch", pinchHandler);
    };
    return _this;
  }
  RoamController2.prototype.isDragging = function() {
    return this._dragging;
  };
  RoamController2.prototype.isPinching = function() {
    return this._pinching;
  };
  RoamController2.prototype.setPointerChecker = function(pointerChecker) {
    this.pointerChecker = pointerChecker;
  };
  RoamController2.prototype.dispose = function() {
    this.disable();
  };
  RoamController2.prototype._mousedownHandler = function(e2) {
    if (isMiddleOrRightButtonOnMouseUpDown(e2) || e2.target && e2.target.draggable) {
      return;
    }
    var x2 = e2.offsetX;
    var y = e2.offsetY;
    if (this.pointerChecker && this.pointerChecker(e2, x2, y)) {
      this._x = x2;
      this._y = y;
      this._dragging = true;
    }
  };
  RoamController2.prototype._mousemoveHandler = function(e2) {
    if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt) || e2.gestureEvent === "pinch" || isTaken(this._zr, "globalPan")) {
      return;
    }
    var x2 = e2.offsetX;
    var y = e2.offsetY;
    var oldX = this._x;
    var oldY = this._y;
    var dx = x2 - oldX;
    var dy = y - oldY;
    this._x = x2;
    this._y = y;
    this._opt.preventDefaultMouseMove && stop(e2.event);
    trigger$2(this, "pan", "moveOnMouseMove", e2, {
      dx,
      dy,
      oldX,
      oldY,
      newX: x2,
      newY: y,
      isAvailableBehavior: null
    });
  };
  RoamController2.prototype._mouseupHandler = function(e2) {
    if (!isMiddleOrRightButtonOnMouseUpDown(e2)) {
      this._dragging = false;
    }
  };
  RoamController2.prototype._mousewheelHandler = function(e2) {
    var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
    var shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
    var wheelDelta = e2.wheelDelta;
    var absWheelDeltaDelta = Math.abs(wheelDelta);
    var originX = e2.offsetX;
    var originY = e2.offsetY;
    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    }
    if (shouldZoom) {
      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      var scale2 = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e2, {
        scale: scale2,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
    if (shouldMove) {
      var absDelta = Math.abs(wheelDelta);
      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e2, {
        scrollDelta,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
  };
  RoamController2.prototype._pinchHandler = function(e2) {
    if (isTaken(this._zr, "globalPan")) {
      return;
    }
    var scale2 = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, "zoom", null, e2, {
      scale: scale2,
      originX: e2.pinchX,
      originY: e2.pinchY,
      isAvailableBehavior: null
    });
  };
  return RoamController2;
}(Eventful$1);
function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  if (controller.pointerChecker && controller.pointerChecker(e2, contollerEvent.originX, contollerEvent.originY)) {
    stop(e2.event);
    trigger$2(controller, eventName, behaviorToCheck, e2, contollerEvent);
  }
}
function trigger$2(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  contollerEvent.isAvailableBehavior = bind$1(isAvailableBehavior, null, behaviorToCheck, e2);
  controller.trigger(eventName, contollerEvent);
}
function isAvailableBehavior(behaviorToCheck, e2, settings) {
  var setting2 = settings[behaviorToCheck];
  return !behaviorToCheck || setting2 && (!isString$2(setting2) || e2.event[setting2 + "Key"]);
}
var RoamController$1 = RoamController;
function updateViewOnPan(controllerHost, dx, dy) {
  var target = controllerHost.target;
  target.x += dx;
  target.y += dy;
  target.dirty();
}
function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
  var target = controllerHost.target;
  var zoomLimit = controllerHost.zoomLimit;
  var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
  newZoom *= zoomDelta;
  if (zoomLimit) {
    var zoomMin = zoomLimit.min || 0;
    var zoomMax = zoomLimit.max || Infinity;
    newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
  }
  var zoomScale = newZoom / controllerHost.zoom;
  controllerHost.zoom = newZoom;
  target.x -= (zoomX - target.x) * (zoomScale - 1);
  target.y -= (zoomY - target.y) * (zoomScale - 1);
  target.scaleX *= zoomScale;
  target.scaleY *= zoomScale;
  target.dirty();
}
var IRRELEVANT_EXCLUDES = {
  "axisPointer": 1,
  "tooltip": 1,
  "brush": 1
};
function onIrrelevantElement(e2, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e2.topTarget);
  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;
}
function parseXML(svg) {
  if (isString$2(svg)) {
    var parser2 = new DOMParser();
    svg = parser2.parseFromString(svg, "text/xml");
  }
  var svgNode = svg;
  if (svgNode.nodeType === 9) {
    svgNode = svgNode.firstChild;
  }
  while (svgNode.nodeName.toLowerCase() !== "svg" || svgNode.nodeType !== 1) {
    svgNode = svgNode.nextSibling;
  }
  return svgNode;
}
var nodeParsers;
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
  "fill": "fill",
  "stroke": "stroke",
  "stroke-width": "lineWidth",
  "opacity": "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  "visibility": "visibility",
  "display": "display"
};
var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys$1(INHERITABLE_STYLE_ATTRIBUTES_MAP);
var SELF_STYLE_ATTRIBUTES_MAP = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
};
var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys$1(SELF_STYLE_ATTRIBUTES_MAP);
var SVGParser = function() {
  function SVGParser2() {
    this._defs = {};
    this._root = null;
  }
  SVGParser2.prototype.parse = function(xml, opt) {
    opt = opt || {};
    var svg = parseXML(xml);
    this._defsUsePending = [];
    var root2 = new Group$3();
    this._root = root2;
    var named = [];
    var viewBox = svg.getAttribute("viewBox") || "";
    var width = parseFloat(svg.getAttribute("width") || opt.width);
    var height = parseFloat(svg.getAttribute("height") || opt.height);
    isNaN(width) && (width = null);
    isNaN(height) && (height = null);
    parseAttributes(svg, root2, null, true, false);
    var child = svg.firstChild;
    while (child) {
      this._parseNode(child, root2, named, null, false, false);
      child = child.nextSibling;
    }
    applyDefs(this._defs, this._defsUsePending);
    this._defsUsePending = [];
    var viewBoxRect;
    var viewBoxTransform;
    if (viewBox) {
      var viewBoxArr = splitNumberSequence(viewBox);
      if (viewBoxArr.length >= 4) {
        viewBoxRect = {
          x: parseFloat(viewBoxArr[0] || 0),
          y: parseFloat(viewBoxArr[1] || 0),
          width: parseFloat(viewBoxArr[2]),
          height: parseFloat(viewBoxArr[3])
        };
      }
    }
    if (viewBoxRect && width != null && height != null) {
      viewBoxTransform = makeViewBoxTransform(viewBoxRect, { x: 0, y: 0, width, height });
      if (!opt.ignoreViewBox) {
        var elRoot = root2;
        root2 = new Group$3();
        root2.add(elRoot);
        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
        elRoot.x = viewBoxTransform.x;
        elRoot.y = viewBoxTransform.y;
      }
    }
    if (!opt.ignoreRootClip && width != null && height != null) {
      root2.setClipPath(new Rect$2({
        shape: { x: 0, y: 0, width, height }
      }));
    }
    return {
      root: root2,
      width,
      height,
      viewBoxRect,
      viewBoxTransform,
      named
    };
  };
  SVGParser2.prototype._parseNode = function(xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
    var nodeName = xmlNode.nodeName.toLowerCase();
    var el;
    var namedFromForSub = namedFrom;
    if (nodeName === "defs") {
      isInDefs = true;
    }
    if (nodeName === "text") {
      isInText = true;
    }
    if (nodeName === "defs" || nodeName === "switch") {
      el = parentGroup;
    } else {
      if (!isInDefs) {
        var parser_1 = nodeParsers[nodeName];
        if (parser_1 && hasOwn$1(nodeParsers, nodeName)) {
          el = parser_1.call(this, xmlNode, parentGroup);
          var nameAttr = xmlNode.getAttribute("name");
          if (nameAttr) {
            var newNamed = {
              name: nameAttr,
              namedFrom: null,
              svgNodeTagLower: nodeName,
              el
            };
            named.push(newNamed);
            if (nodeName === "g") {
              namedFromForSub = newNamed;
            }
          } else if (namedFrom) {
            named.push({
              name: namedFrom.name,
              namedFrom,
              svgNodeTagLower: nodeName,
              el
            });
          }
          parentGroup.add(el);
        }
      }
      var parser2 = paintServerParsers[nodeName];
      if (parser2 && hasOwn$1(paintServerParsers, nodeName)) {
        var def = parser2.call(this, xmlNode);
        var id = xmlNode.getAttribute("id");
        if (id) {
          this._defs[id] = def;
        }
      }
    }
    if (el && el.isGroup) {
      var child = xmlNode.firstChild;
      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
        } else if (child.nodeType === 3 && isInText) {
          this._parseText(child, el);
        }
        child = child.nextSibling;
      }
    }
  };
  SVGParser2.prototype._parseText = function(xmlNode, parentGroup) {
    var text2 = new TSpan$1({
      style: {
        text: xmlNode.textContent
      },
      silent: true,
      x: this._textX || 0,
      y: this._textY || 0
    });
    inheritStyle(parentGroup, text2);
    parseAttributes(xmlNode, text2, this._defsUsePending, false, false);
    applyTextAlignment(text2, parentGroup);
    var textStyle = text2.style;
    var fontSize = textStyle.fontSize;
    if (fontSize && fontSize < 9) {
      textStyle.fontSize = 9;
      text2.scaleX *= fontSize / 9;
      text2.scaleY *= fontSize / 9;
    }
    var font = (textStyle.fontSize || textStyle.fontFamily) && [
      textStyle.fontStyle,
      textStyle.fontWeight,
      (textStyle.fontSize || 12) + "px",
      textStyle.fontFamily || "sans-serif"
    ].join(" ");
    textStyle.font = font;
    var rect = text2.getBoundingRect();
    this._textX += rect.width;
    parentGroup.add(text2);
    return text2;
  };
  SVGParser2.internalField = function() {
    nodeParsers = {
      "g": function(xmlNode, parentGroup) {
        var g = new Group$3();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defsUsePending, false, false);
        return g;
      },
      "rect": function(xmlNode, parentGroup) {
        var rect = new Rect$2();
        inheritStyle(parentGroup, rect);
        parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
        rect.setShape({
          x: parseFloat(xmlNode.getAttribute("x") || "0"),
          y: parseFloat(xmlNode.getAttribute("y") || "0"),
          width: parseFloat(xmlNode.getAttribute("width") || "0"),
          height: parseFloat(xmlNode.getAttribute("height") || "0")
        });
        rect.silent = true;
        return rect;
      },
      "circle": function(xmlNode, parentGroup) {
        var circle = new Circle$1();
        inheritStyle(parentGroup, circle);
        parseAttributes(xmlNode, circle, this._defsUsePending, false, false);
        circle.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
          cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
          r: parseFloat(xmlNode.getAttribute("r") || "0")
        });
        circle.silent = true;
        return circle;
      },
      "line": function(xmlNode, parentGroup) {
        var line = new Line$1();
        inheritStyle(parentGroup, line);
        parseAttributes(xmlNode, line, this._defsUsePending, false, false);
        line.setShape({
          x1: parseFloat(xmlNode.getAttribute("x1") || "0"),
          y1: parseFloat(xmlNode.getAttribute("y1") || "0"),
          x2: parseFloat(xmlNode.getAttribute("x2") || "0"),
          y2: parseFloat(xmlNode.getAttribute("y2") || "0")
        });
        line.silent = true;
        return line;
      },
      "ellipse": function(xmlNode, parentGroup) {
        var ellipse = new Ellipse$1();
        inheritStyle(parentGroup, ellipse);
        parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);
        ellipse.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
          cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
          rx: parseFloat(xmlNode.getAttribute("rx") || "0"),
          ry: parseFloat(xmlNode.getAttribute("ry") || "0")
        });
        ellipse.silent = true;
        return ellipse;
      },
      "polygon": function(xmlNode, parentGroup) {
        var pointsStr = xmlNode.getAttribute("points");
        var pointsArr;
        if (pointsStr) {
          pointsArr = parsePoints(pointsStr);
        }
        var polygon = new Polygon$1({
          shape: {
            points: pointsArr || []
          },
          silent: true
        });
        inheritStyle(parentGroup, polygon);
        parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);
        return polygon;
      },
      "polyline": function(xmlNode, parentGroup) {
        var pointsStr = xmlNode.getAttribute("points");
        var pointsArr;
        if (pointsStr) {
          pointsArr = parsePoints(pointsStr);
        }
        var polyline = new Polyline$1({
          shape: {
            points: pointsArr || []
          },
          silent: true
        });
        inheritStyle(parentGroup, polyline);
        parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
        return polyline;
      },
      "image": function(xmlNode, parentGroup) {
        var img = new ZRImage$1();
        inheritStyle(parentGroup, img);
        parseAttributes(xmlNode, img, this._defsUsePending, false, false);
        img.setStyle({
          image: xmlNode.getAttribute("xlink:href") || xmlNode.getAttribute("href"),
          x: +xmlNode.getAttribute("x"),
          y: +xmlNode.getAttribute("y"),
          width: +xmlNode.getAttribute("width"),
          height: +xmlNode.getAttribute("height")
        });
        img.silent = true;
        return img;
      },
      "text": function(xmlNode, parentGroup) {
        var x2 = xmlNode.getAttribute("x") || "0";
        var y = xmlNode.getAttribute("y") || "0";
        var dx = xmlNode.getAttribute("dx") || "0";
        var dy = xmlNode.getAttribute("dy") || "0";
        this._textX = parseFloat(x2) + parseFloat(dx);
        this._textY = parseFloat(y) + parseFloat(dy);
        var g = new Group$3();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defsUsePending, false, true);
        return g;
      },
      "tspan": function(xmlNode, parentGroup) {
        var x2 = xmlNode.getAttribute("x");
        var y = xmlNode.getAttribute("y");
        if (x2 != null) {
          this._textX = parseFloat(x2);
        }
        if (y != null) {
          this._textY = parseFloat(y);
        }
        var dx = xmlNode.getAttribute("dx") || "0";
        var dy = xmlNode.getAttribute("dy") || "0";
        var g = new Group$3();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defsUsePending, false, true);
        this._textX += parseFloat(dx);
        this._textY += parseFloat(dy);
        return g;
      },
      "path": function(xmlNode, parentGroup) {
        var d2 = xmlNode.getAttribute("d") || "";
        var path = createFromString(d2);
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defsUsePending, false, false);
        path.silent = true;
        return path;
      }
    };
  }();
  return SVGParser2;
}();
var paintServerParsers = {
  "lineargradient": function(xmlNode) {
    var x1 = parseInt(xmlNode.getAttribute("x1") || "0", 10);
    var y1 = parseInt(xmlNode.getAttribute("y1") || "0", 10);
    var x2 = parseInt(xmlNode.getAttribute("x2") || "10", 10);
    var y2 = parseInt(xmlNode.getAttribute("y2") || "0", 10);
    var gradient = new LinearGradient$1(x1, y1, x2, y2);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  },
  "radialgradient": function(xmlNode) {
    var cx = parseInt(xmlNode.getAttribute("cx") || "0", 10);
    var cy = parseInt(xmlNode.getAttribute("cy") || "0", 10);
    var r = parseInt(xmlNode.getAttribute("r") || "0", 10);
    var gradient = new RadialGradient$1(cx, cy, r);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  }
};
function parsePaintServerUnit(xmlNode, gradient) {
  var gradientUnits = xmlNode.getAttribute("gradientUnits");
  if (gradientUnits === "userSpaceOnUse") {
    gradient.global = true;
  }
}
function parseGradientColorStops(xmlNode, gradient) {
  var stop2 = xmlNode.firstChild;
  while (stop2) {
    if (stop2.nodeType === 1 && stop2.nodeName.toLocaleLowerCase() === "stop") {
      var offsetStr = stop2.getAttribute("offset");
      var offset2 = void 0;
      if (offsetStr && offsetStr.indexOf("%") > 0) {
        offset2 = parseInt(offsetStr, 10) / 100;
      } else if (offsetStr) {
        offset2 = parseFloat(offsetStr);
      } else {
        offset2 = 0;
      }
      var styleVals = {};
      parseInlineStyle(stop2, styleVals, styleVals);
      var stopColor = styleVals.stopColor || stop2.getAttribute("stop-color") || "#000000";
      gradient.colorStops.push({
        offset: offset2,
        color: stopColor
      });
    }
    stop2 = stop2.nextSibling;
  }
}
function inheritStyle(parent2, child) {
  if (parent2 && parent2.__inheritedStyle) {
    if (!child.__inheritedStyle) {
      child.__inheritedStyle = {};
    }
    defaults$1(child.__inheritedStyle, parent2.__inheritedStyle);
  }
}
function parsePoints(pointsString) {
  var list2 = splitNumberSequence(pointsString);
  var points2 = [];
  for (var i = 0; i < list2.length; i += 2) {
    var x2 = parseFloat(list2[i]);
    var y = parseFloat(list2[i + 1]);
    points2.push([x2, y]);
  }
  return points2;
}
function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
  var disp = el;
  var inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
  var selfStyle = {};
  if (xmlNode.nodeType === 1) {
    parseTransformAttribute(xmlNode, el);
    parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
    if (!onlyInlineStyle) {
      parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
    }
  }
  disp.style = disp.style || {};
  if (inheritedStyle.fill != null) {
    disp.style.fill = getFillStrokeStyle(disp, "fill", inheritedStyle.fill, defsUsePending);
  }
  if (inheritedStyle.stroke != null) {
    disp.style.stroke = getFillStrokeStyle(disp, "stroke", inheritedStyle.stroke, defsUsePending);
  }
  each$e([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = parseFloat(inheritedStyle[propName]);
    }
  });
  each$e([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = inheritedStyle[propName];
    }
  });
  if (isTextGroup) {
    disp.__selfStyle = selfStyle;
  }
  if (inheritedStyle.lineDash) {
    disp.style.lineDash = map$1(splitNumberSequence(inheritedStyle.lineDash), function(str) {
      return parseFloat(str);
    });
  }
  if (inheritedStyle.visibility === "hidden" || inheritedStyle.visibility === "collapse") {
    disp.invisible = true;
  }
  if (inheritedStyle.display === "none") {
    disp.ignore = true;
  }
}
function applyTextAlignment(text2, parentGroup) {
  var parentSelfStyle = parentGroup.__selfStyle;
  if (parentSelfStyle) {
    var textBaseline = parentSelfStyle.textBaseline;
    var zrTextBaseline = textBaseline;
    if (!textBaseline || textBaseline === "auto") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "baseline") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "before-edge" || textBaseline === "text-before-edge") {
      zrTextBaseline = "top";
    } else if (textBaseline === "after-edge" || textBaseline === "text-after-edge") {
      zrTextBaseline = "bottom";
    } else if (textBaseline === "central" || textBaseline === "mathematical") {
      zrTextBaseline = "middle";
    }
    text2.style.textBaseline = zrTextBaseline;
  }
  var parentInheritedStyle = parentGroup.__inheritedStyle;
  if (parentInheritedStyle) {
    var textAlign = parentInheritedStyle.textAlign;
    var zrTextAlign = textAlign;
    if (textAlign) {
      if (textAlign === "middle") {
        zrTextAlign = "center";
      }
      text2.style.textAlign = zrTextAlign;
    }
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(el, method, str, defsUsePending) {
  var urlMatch = str && str.match(urlRegex);
  if (urlMatch) {
    var url = trim$1(urlMatch[1]);
    defsUsePending.push([el, method, url]);
    return;
  }
  if (str === "none") {
    str = null;
  }
  return str;
}
function applyDefs(defs, defsUsePending) {
  for (var i = 0; i < defsUsePending.length; i++) {
    var item = defsUsePending[i];
    item[0].style[item[1]] = defs[item[2]];
  }
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
  return rawStr.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
var DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(xmlNode, node) {
  var transform2 = xmlNode.getAttribute("transform");
  if (transform2) {
    transform2 = transform2.replace(/,/g, " ");
    var transformOps_1 = [];
    var mt = null;
    transform2.replace(transformRegex, function(str, type2, value2) {
      transformOps_1.push(type2, value2);
      return "";
    });
    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {
      var value = transformOps_1[i];
      var type = transformOps_1[i - 1];
      var valueArr = splitNumberSequence(value);
      mt = mt || create();
      switch (type) {
        case "translate":
          translate$2(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || "0")]);
          break;
        case "scale":
          scale$1(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
          break;
        case "rotate":
          rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          break;
        case "skewX":
          var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul(mt, [1, 0, sx, 1, 0, 0], mt);
          break;
        case "skewY":
          var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul(mt, [1, sy, 0, 1, 0, 0], mt);
          break;
        case "matrix":
          mt[0] = parseFloat(valueArr[0]);
          mt[1] = parseFloat(valueArr[1]);
          mt[2] = parseFloat(valueArr[2]);
          mt[3] = parseFloat(valueArr[3]);
          mt[4] = parseFloat(valueArr[4]);
          mt[5] = parseFloat(valueArr[5]);
          break;
      }
    }
    node.setLocalTransform(mt);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  var style = xmlNode.getAttribute("style");
  if (!style) {
    return;
  }
  styleRegex.lastIndex = 0;
  var styleRegResult;
  while ((styleRegResult = styleRegex.exec(style)) != null) {
    var svgStlAttr = styleRegResult[1];
    var zrInheritableStlAttr = hasOwn$1(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrInheritableStlAttr) {
      inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
    }
    var zrSelfStlAttr = hasOwn$1(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrSelfStlAttr) {
      selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
    }
  }
}
function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  for (var i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];
    var attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
  for (var i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];
    var attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
}
function makeViewBoxTransform(viewBoxRect, boundingRect) {
  var scaleX = boundingRect.width / viewBoxRect.width;
  var scaleY = boundingRect.height / viewBoxRect.height;
  var scale2 = Math.min(scaleX, scaleY);
  return {
    scale: scale2,
    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale2 + (boundingRect.x + boundingRect.width / 2),
    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale2 + (boundingRect.y + boundingRect.height / 2)
  };
}
function parseSVG(xml, opt) {
  var parser2 = new SVGParser();
  return parser2.parse(xml, opt);
}
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  "text",
  "tspan",
  "g"
]);
var GeoSVGResource = function() {
  function GeoSVGResource2(mapName, svg) {
    this.type = "geoSVG";
    this._usedGraphicMap = createHashMap();
    this._freedGraphics = [];
    this._mapName = mapName;
    this._parsedXML = parseXML(svg);
  }
  GeoSVGResource2.prototype.load = function() {
    var firstGraphic = this._firstGraphic;
    if (!firstGraphic) {
      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);
      this._freedGraphics.push(firstGraphic);
      this._boundingRect = this._firstGraphic.boundingRect.clone();
      var _a2 = createRegions(firstGraphic.named), regions = _a2.regions, regionsMap = _a2.regionsMap;
      this._regions = regions;
      this._regionsMap = regionsMap;
    }
    return {
      boundingRect: this._boundingRect,
      regions: this._regions,
      regionsMap: this._regionsMap
    };
  };
  GeoSVGResource2.prototype._buildGraphic = function(svgXML) {
    var result;
    var rootFromParse;
    try {
      result = svgXML && parseSVG(svgXML, {
        ignoreViewBox: true,
        ignoreRootClip: true
      }) || {};
      rootFromParse = result.root;
      assert(rootFromParse != null);
    } catch (e2) {
      throw new Error("Invalid svg format\n" + e2.message);
    }
    var root2 = new Group$3();
    root2.add(rootFromParse);
    root2.isGeoSVGGraphicRoot = true;
    var svgWidth = result.width;
    var svgHeight = result.height;
    var viewBoxRect = result.viewBoxRect;
    var boundingRect = this._boundingRect;
    if (!boundingRect) {
      var bRectX = void 0;
      var bRectY = void 0;
      var bRectWidth = void 0;
      var bRectHeight = void 0;
      if (svgWidth != null) {
        bRectX = 0;
        bRectWidth = svgWidth;
      } else if (viewBoxRect) {
        bRectX = viewBoxRect.x;
        bRectWidth = viewBoxRect.width;
      }
      if (svgHeight != null) {
        bRectY = 0;
        bRectHeight = svgHeight;
      } else if (viewBoxRect) {
        bRectY = viewBoxRect.y;
        bRectHeight = viewBoxRect.height;
      }
      if (bRectX == null || bRectY == null) {
        var calculatedBoundingRect = rootFromParse.getBoundingRect();
        if (bRectX == null) {
          bRectX = calculatedBoundingRect.x;
          bRectWidth = calculatedBoundingRect.width;
        }
        if (bRectY == null) {
          bRectY = calculatedBoundingRect.y;
          bRectHeight = calculatedBoundingRect.height;
        }
      }
      boundingRect = this._boundingRect = new BoundingRect$1(bRectX, bRectY, bRectWidth, bRectHeight);
    }
    if (viewBoxRect) {
      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect);
      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
      rootFromParse.x = viewBoxTransform.x;
      rootFromParse.y = viewBoxTransform.y;
    }
    root2.setClipPath(new Rect$2({
      shape: boundingRect.plain()
    }));
    var named = [];
    each$e(result.named, function(namedItem) {
      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
        named.push(namedItem);
        setSilent(namedItem.el);
      }
    });
    return {
      root: root2,
      boundingRect,
      named
    };
  };
  GeoSVGResource2.prototype.useGraphic = function(hostKey) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      return svgGraphic;
    }
    svgGraphic = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML);
    usedRootMap.set(hostKey, svgGraphic);
    return svgGraphic;
  };
  GeoSVGResource2.prototype.freeGraphic = function(hostKey) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      usedRootMap.removeKey(hostKey);
      this._freedGraphics.push(svgGraphic);
    }
  };
  return GeoSVGResource2;
}();
function setSilent(el) {
  el.silent = false;
  if (el.isGroup) {
    el.traverse(function(child) {
      child.silent = false;
    });
  }
}
function createRegions(named) {
  var regions = [];
  var regionsMap = createHashMap();
  each$e(named, function(namedItem) {
    if (namedItem.namedFrom != null) {
      return;
    }
    var region = new GeoSVGRegion(namedItem.name, namedItem.el);
    regions.push(region);
    regionsMap.set(namedItem.name, region);
  });
  return {
    regions,
    regionsMap
  };
}
var geoCoord = [126, 25];
var nanhaiName = "\u5357\u6D77\u8BF8\u5C9B";
var points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var i = 0; i < points$1.length; i++) {
  for (var k = 0; k < points$1[i].length; k++) {
    points$1[i][k][0] /= 10.5;
    points$1[i][k][1] /= -10.5 / 0.75;
    points$1[i][k][0] += geoCoord[0];
    points$1[i][k][1] += geoCoord[1];
  }
}
function fixNanhai(mapType, regions) {
  if (mapType === "china") {
    for (var i = 0; i < regions.length; i++) {
      if (regions[i].name === nanhaiName) {
        return;
      }
    }
    regions.push(new GeoJSONRegion(nanhaiName, map$1(points$1, function(exterior) {
      return {
        type: "polygon",
        exterior
      };
    }), geoCoord));
  }
}
var coordsOffsetMap = {
  "\u5357\u6D77\u8BF8\u5C9B": [32, 80],
  "\u5E7F\u4E1C": [0, -10],
  "\u9999\u6E2F": [10, 5],
  "\u6FB3\u95E8": [-10, 10],
  "\u5929\u6D25": [5, 5]
};
function fixTextCoords(mapType, region) {
  if (mapType === "china") {
    var coordFix = coordsOffsetMap[region.name];
    if (coordFix) {
      var cp = region.getCenter();
      cp[0] += coordFix[0] / 10.5;
      cp[1] += -coordFix[1] / (10.5 / 0.75);
      region.setCenter(cp);
    }
  }
}
var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function fixDiaoyuIsland(mapType, region) {
  if (mapType === "china" && region.name === "\u53F0\u6E7E") {
    region.geometries.push({
      type: "polygon",
      exterior: points[0]
    });
  }
}
var DEFAULT_NAME_PROPERTY = "name";
var GeoJSONResource = function() {
  function GeoJSONResource2(mapName, geoJSON, specialAreas) {
    this.type = "geoJSON";
    this._parsedMap = createHashMap();
    this._mapName = mapName;
    this._specialAreas = specialAreas;
    this._geoJSON = parseInput(geoJSON);
  }
  GeoJSONResource2.prototype.load = function(nameMap, nameProperty) {
    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;
    var parsed = this._parsedMap.get(nameProperty);
    if (!parsed) {
      var rawRegions = this._parseToRegions(nameProperty);
      parsed = this._parsedMap.set(nameProperty, {
        regions: rawRegions,
        boundingRect: calculateBoundingRect(rawRegions)
      });
    }
    var regionsMap = createHashMap();
    var finalRegions = [];
    each$e(parsed.regions, function(region) {
      var regionName = region.name;
      if (nameMap && hasOwn$1(nameMap, regionName)) {
        region = region.cloneShallow(regionName = nameMap[regionName]);
      }
      finalRegions.push(region);
      regionsMap.set(regionName, region);
    });
    return {
      regions: finalRegions,
      boundingRect: parsed.boundingRect || new BoundingRect$1(0, 0, 0, 0),
      regionsMap
    };
  };
  GeoJSONResource2.prototype._parseToRegions = function(nameProperty) {
    var mapName = this._mapName;
    var geoJSON = this._geoJSON;
    var rawRegions;
    try {
      rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
    } catch (e2) {
      throw new Error("Invalid geoJson format\n" + e2.message);
    }
    fixNanhai(mapName, rawRegions);
    each$e(rawRegions, function(region) {
      var regionName = region.name;
      fixTextCoords(mapName, region);
      fixDiaoyuIsland(mapName, region);
      var specialArea = this._specialAreas && this._specialAreas[regionName];
      if (specialArea) {
        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    }, this);
    return rawRegions;
  };
  GeoJSONResource2.prototype.getMapForUser = function() {
    return {
      geoJson: this._geoJSON,
      geoJSON: this._geoJSON,
      specialAreas: this._specialAreas
    };
  };
  return GeoJSONResource2;
}();
function calculateBoundingRect(regions) {
  var rect;
  for (var i = 0; i < regions.length; i++) {
    var regionRect = regions[i].getBoundingRect();
    rect = rect || regionRect.clone();
    rect.union(regionRect);
  }
  return rect;
}
function parseInput(source) {
  return !isString$2(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
}
var storage = createHashMap();
var geoSourceManager = {
  registerMap: function(mapName, rawDef, rawSpecialAreas) {
    if (rawDef.svg) {
      var resource = new GeoSVGResource(mapName, rawDef.svg);
      storage.set(mapName, resource);
    } else {
      var geoJSON = rawDef.geoJson || rawDef.geoJSON;
      if (geoJSON && !rawDef.features) {
        rawSpecialAreas = rawDef.specialAreas;
      } else {
        geoJSON = rawDef;
      }
      var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
      storage.set(mapName, resource);
    }
  },
  getGeoResource: function(mapName) {
    return storage.get(mapName);
  },
  getMapForUser: function(mapName) {
    var resource = storage.get(mapName);
    return resource && resource.type === "geoJSON" && resource.getMapForUser();
  },
  load: function(mapName, nameMap, nameProperty) {
    var resource = storage.get(mapName);
    if (!resource) {
      return;
    }
    return resource.load(nameMap, nameProperty);
  }
};
var OPTION_STYLE_ENABLED_TAGS = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"];
var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var mapLabelRaw = makeInner();
function getFixedItemStyle(model) {
  var itemStyle = model.getItemStyle();
  var areaColor = model.get("areaColor");
  if (areaColor != null) {
    itemStyle.fill = areaColor;
  }
  return itemStyle;
}
function fixLineStyle(styleHost) {
  var style = styleHost.style;
  if (style) {
    style.stroke = style.stroke || style.fill;
    style.fill = null;
  }
}
var MapDraw = function() {
  function MapDraw2(api) {
    var group = new Group$3();
    this.uid = getUID("ec_map_draw");
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: group
    };
    this.group = group;
    group.add(this._regionsGroup = new Group$3());
    group.add(this._svgGroup = new Group$3());
  }
  MapDraw2.prototype.draw = function(mapOrGeoModel, ecModel, api, fromView, payload) {
    var isGeo = mapOrGeoModel.mainType === "geo";
    var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
    isGeo && ecModel.eachComponent({
      mainType: "series",
      subType: "map"
    }, function(mapSeries) {
      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
        data = mapSeries.getData();
      }
    });
    var geo = mapOrGeoModel.coordinateSystem;
    var regionsGroup = this._regionsGroup;
    var group = this.group;
    var transformInfo = geo.getTransformInfo();
    var transformInfoRaw = transformInfo.raw;
    var transformInfoRoam = transformInfo.roam;
    var isFirstDraw = !regionsGroup.childAt(0) || payload;
    if (isFirstDraw) {
      group.x = transformInfoRoam.x;
      group.y = transformInfoRoam.y;
      group.scaleX = transformInfoRoam.scaleX;
      group.scaleY = transformInfoRoam.scaleY;
      group.dirty();
    } else {
      updateProps$1(group, transformInfoRoam, mapOrGeoModel);
    }
    var isVisualEncodedByVisualMap = data && data.getVisual("visualMeta") && data.getVisual("visualMeta").length > 0;
    var viewBuildCtx = {
      api,
      geo,
      mapOrGeoModel,
      data,
      isVisualEncodedByVisualMap,
      isGeo,
      transformInfoRaw
    };
    if (geo.resourceType === "geoJSON") {
      this._buildGeoJSON(viewBuildCtx);
    } else if (geo.resourceType === "geoSVG") {
      this._buildSVG(viewBuildCtx);
    }
    this._updateController(mapOrGeoModel, ecModel, api);
    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);
  };
  MapDraw2.prototype._buildGeoJSON = function(viewBuildCtx) {
    var regionsGroupByName = this._regionsGroupByName = createHashMap();
    var regionsInfoByName = createHashMap();
    var regionsGroup = this._regionsGroup;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
    var data = viewBuildCtx.data;
    var projection = viewBuildCtx.geo.projection;
    var projectionStream = projection && projection.stream;
    function transformPoint(point, project) {
      if (project) {
        point = project(point);
      }
      return point && [point[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point[1] * transformInfoRaw.scaleY + transformInfoRaw.y];
    }
    function transformPolygonPoints(inPoints) {
      var outPoints = [];
      var project = !projectionStream && projection && projection.project;
      for (var i = 0; i < inPoints.length; ++i) {
        var newPt = transformPoint(inPoints[i], project);
        newPt && outPoints.push(newPt);
      }
      return outPoints;
    }
    function getPolyShape(points2) {
      return {
        shape: {
          points: transformPolygonPoints(points2)
        }
      };
    }
    regionsGroup.removeAll();
    each$e(viewBuildCtx.geo.regions, function(region) {
      var regionName = region.name;
      var regionGroup = regionsGroupByName.get(regionName);
      var _a2 = regionsInfoByName.get(regionName) || {}, dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
      if (!regionGroup) {
        regionGroup = regionsGroupByName.set(regionName, new Group$3());
        regionsGroup.add(regionGroup);
        dataIdx = data ? data.indexOfName(regionName) : null;
        regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
        regionsInfoByName.set(regionName, {
          dataIdx,
          regionModel
        });
      }
      var polygonSubpaths = [];
      var polylineSubpaths = [];
      each$e(region.geometries, function(geometry) {
        if (geometry.type === "polygon") {
          var polys = [geometry.exterior].concat(geometry.interiors || []);
          if (projectionStream) {
            polys = projectPolys(polys, projectionStream);
          }
          each$e(polys, function(poly) {
            polygonSubpaths.push(new Polygon$1(getPolyShape(poly)));
          });
        } else {
          var points2 = geometry.points;
          if (projectionStream) {
            points2 = projectPolys(points2, projectionStream, true);
          }
          each$e(points2, function(points3) {
            polylineSubpaths.push(new Polyline$1(getPolyShape(points3)));
          });
        }
      });
      var centerPt = transformPoint(region.getCenter(), projection && projection.project);
      function createCompoundPath(subpaths, isLine) {
        if (!subpaths.length) {
          return;
        }
        var compoundPath = new CompoundPath$1({
          culling: true,
          segmentIgnoreThreshold: 1,
          shape: {
            paths: subpaths
          }
        });
        regionGroup.add(compoundPath);
        applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
        resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);
        if (isLine) {
          fixLineStyle(compoundPath);
          each$e(compoundPath.states, fixLineStyle);
        }
      }
      createCompoundPath(polygonSubpaths);
      createCompoundPath(polylineSubpaths, true);
    });
    regionsGroupByName.each(function(regionGroup, regionName) {
      var _a2 = regionsInfoByName.get(regionName), dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
      resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
      resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
      resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
    }, this);
  };
  MapDraw2.prototype._buildSVG = function(viewBuildCtx) {
    var mapName = viewBuildCtx.geo.map;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    this._svgGroup.x = transformInfoRaw.x;
    this._svgGroup.y = transformInfoRaw.y;
    this._svgGroup.scaleX = transformInfoRaw.scaleX;
    this._svgGroup.scaleY = transformInfoRaw.scaleY;
    if (this._svgResourceChanged(mapName)) {
      this._freeSVG();
      this._useSVG(mapName);
    }
    var svgDispatcherMap = this._svgDispatcherMap = createHashMap();
    var focusSelf = false;
    each$e(this._svgGraphicRecord.named, function(namedItem) {
      var regionName = namedItem.name;
      var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
      var data = viewBuildCtx.data;
      var svgNodeTagLower = namedItem.svgNodeTagLower;
      var el = namedItem.el;
      var dataIdx = data ? data.indexOfName(regionName) : null;
      var regionModel = mapOrGeoModel.getRegionModel(regionName);
      if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable$1) {
        applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
      }
      if (el instanceof Displayable$1) {
        el.culling = true;
      }
      el.z2EmphasisLift = 0;
      if (!namedItem.namedFrom) {
        if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
          resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
        }
        resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
        resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
        if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
          var focus_1 = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
          if (focus_1 === "self") {
            focusSelf = true;
          }
          var els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);
          els.push(el);
        }
      }
    }, this);
    this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
  };
  MapDraw2.prototype._enableBlurEntireSVG = function(focusSelf, viewBuildCtx) {
    if (focusSelf && viewBuildCtx.isGeo) {
      var blurStyle = viewBuildCtx.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle();
      var opacity_1 = blurStyle.opacity;
      this._svgGraphicRecord.root.traverse(function(el) {
        if (!el.isGroup) {
          setDefaultStateProxy(el);
          var style = el.ensureState("blur").style || {};
          if (style.opacity == null && opacity_1 != null) {
            style.opacity = opacity_1;
          }
          el.ensureState("emphasis");
        }
      });
    }
  };
  MapDraw2.prototype.remove = function() {
    this._regionsGroup.removeAll();
    this._regionsGroupByName = null;
    this._svgGroup.removeAll();
    this._freeSVG();
    this._controller.dispose();
    this._controllerHost = null;
  };
  MapDraw2.prototype.findHighDownDispatchers = function(name, geoModel) {
    if (name == null) {
      return [];
    }
    var geo = geoModel.coordinateSystem;
    if (geo.resourceType === "geoJSON") {
      var regionsGroupByName = this._regionsGroupByName;
      if (regionsGroupByName) {
        var regionGroup = regionsGroupByName.get(name);
        return regionGroup ? [regionGroup] : [];
      }
    } else if (geo.resourceType === "geoSVG") {
      return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];
    }
  };
  MapDraw2.prototype._svgResourceChanged = function(mapName) {
    return this._svgMapName !== mapName;
  };
  MapDraw2.prototype._useSVG = function(mapName) {
    var resource = geoSourceManager.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      var svgGraphic = resource.useGraphic(this.uid);
      this._svgGroup.add(svgGraphic.root);
      this._svgGraphicRecord = svgGraphic;
      this._svgMapName = mapName;
    }
  };
  MapDraw2.prototype._freeSVG = function() {
    var mapName = this._svgMapName;
    if (mapName == null) {
      return;
    }
    var resource = geoSourceManager.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      resource.freeGraphic(this.uid);
    }
    this._svgGraphicRecord = null;
    this._svgDispatcherMap = null;
    this._svgGroup.removeAll();
    this._svgMapName = null;
  };
  MapDraw2.prototype._updateController = function(mapOrGeoModel, ecModel, api) {
    var geo = mapOrGeoModel.coordinateSystem;
    var controller = this._controller;
    var controllerHost = this._controllerHost;
    controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
    controllerHost.zoom = geo.getZoom();
    controller.enable(mapOrGeoModel.get("roam") || false);
    var mainType = mapOrGeoModel.mainType;
    function makeActionBase() {
      var action = {
        type: "geoRoam",
        componentType: mainType
      };
      action[mainType + "Id"] = mapOrGeoModel.id;
      return action;
    }
    controller.off("pan").on("pan", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api.dispatchAction(extend$3(makeActionBase(), {
        dx: e2.dx,
        dy: e2.dy,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.off("zoom").on("zoom", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api.dispatchAction(extend$3(makeActionBase(), {
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.setPointerChecker(function(e2, x2, y) {
      return geo.containPoint([x2, y]) && !onIrrelevantElement(e2, api, mapOrGeoModel);
    });
  };
  MapDraw2.prototype.resetForLabelLayout = function() {
    this.group.traverse(function(el) {
      var label = el.getTextContent();
      if (label) {
        label.ignore = mapLabelRaw(label).ignore;
      }
    });
  };
  MapDraw2.prototype._updateMapSelectHandler = function(mapOrGeoModel, regionsGroup, api, fromView) {
    var mapDraw = this;
    regionsGroup.off("mousedown");
    regionsGroup.off("click");
    if (mapOrGeoModel.get("selectedMode")) {
      regionsGroup.on("mousedown", function() {
        mapDraw._mouseDownFlag = true;
      });
      regionsGroup.on("click", function(e2) {
        if (!mapDraw._mouseDownFlag) {
          return;
        }
        mapDraw._mouseDownFlag = false;
      });
    }
  };
  return MapDraw2;
}();
function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
  var normalStyleModel = regionModel.getModel("itemStyle");
  var emphasisStyleModel = regionModel.getModel(["emphasis", "itemStyle"]);
  var blurStyleModel = regionModel.getModel(["blur", "itemStyle"]);
  var selectStyleModel = regionModel.getModel(["select", "itemStyle"]);
  var normalStyle = getFixedItemStyle(normalStyleModel);
  var emphasisStyle = getFixedItemStyle(emphasisStyleModel);
  var selectStyle = getFixedItemStyle(selectStyleModel);
  var blurStyle = getFixedItemStyle(blurStyleModel);
  var data = viewBuildCtx.data;
  if (data) {
    var style = data.getItemVisual(dataIndex, "style");
    var decal = data.getItemVisual(dataIndex, "decal");
    if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
      normalStyle.fill = style.fill;
    }
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
    }
  }
  el.setStyle(normalStyle);
  el.style.strokeNoScale = true;
  el.ensureState("emphasis").style = emphasisStyle;
  el.ensureState("select").style = selectStyle;
  el.ensureState("blur").style = blurStyle;
  setDefaultStateProxy(el);
}
function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, labelXY) {
  var data = viewBuildCtx.data;
  var isGeo = viewBuildCtx.isGeo;
  var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
  var itemLayout = data && data.getItemLayout(dataIdx);
  if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
    var query = !isGeo ? dataIdx : regionName;
    var labelFetcher = void 0;
    if (!data || dataIdx >= 0) {
      labelFetcher = mapOrGeoModel;
    }
    var specifiedTextOpt = labelXY ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    setLabelStyle(el, getLabelStatesModels(regionModel), {
      labelFetcher,
      labelDataIndex: query,
      defaultText: regionName
    }, specifiedTextOpt);
    var textEl = el.getTextContent();
    if (textEl) {
      mapLabelRaw(textEl).ignore = textEl.ignore;
      if (el.textConfig && labelXY) {
        var rect = el.getBoundingRect().clone();
        el.textConfig.layoutRect = rect;
        el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + "%", (labelXY[1] - rect.y) / rect.height * 100 + "%"];
      }
    }
    el.disableLabelAnimation = true;
  } else {
    el.removeTextContent();
    el.removeTextConfig();
    el.disableLabelAnimation = null;
  }
}
function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, dataIdx) {
  if (viewBuildCtx.data) {
    viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
  } else {
    getECData(eventTrigger).eventData = {
      componentType: "geo",
      componentIndex: mapOrGeoModel.componentIndex,
      geoIndex: mapOrGeoModel.componentIndex,
      name: regionName,
      region: regionModel && regionModel.option || {}
    };
  }
}
function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  if (!viewBuildCtx.data) {
    setTooltipConfig({
      el,
      componentModel: mapOrGeoModel,
      itemName: regionName,
      itemTooltipOption: regionModel.get("tooltip")
    });
  }
}
function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  el.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
  var emphasisModel = regionModel.getModel("emphasis");
  var focus = emphasisModel.get("focus");
  toggleHoverEmphasis(el, focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  if (viewBuildCtx.isGeo) {
    enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
  }
  return focus;
}
function projectPolys(rings, createStream, isLine) {
  var polygons = [];
  var curPoly;
  function startPolygon() {
    curPoly = [];
  }
  function endPolygon() {
    if (curPoly.length) {
      polygons.push(curPoly);
      curPoly = [];
    }
  }
  var stream = createStream({
    polygonStart: startPolygon,
    polygonEnd: endPolygon,
    lineStart: startPolygon,
    lineEnd: endPolygon,
    point: function(x2, y) {
      if (isFinite(x2) && isFinite(y)) {
        curPoly.push([x2, y]);
      }
    },
    sphere: function() {
    }
  });
  !isLine && stream.polygonStart();
  each$e(rings, function(ring) {
    stream.lineStart();
    for (var i = 0; i < ring.length; i++) {
      stream.point(ring[i][0], ring[i][1]);
    }
    stream.lineEnd();
  });
  !isLine && stream.polygonEnd();
  return polygons;
}
var MapDraw$1 = MapDraw;
var MapView = function(_super) {
  __extends(MapView2, _super);
  function MapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MapView2.type;
    return _this;
  }
  MapView2.prototype.render = function(mapModel, ecModel, api, payload) {
    if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
      return;
    }
    var group = this.group;
    group.removeAll();
    if (mapModel.getHostGeoModel()) {
      return;
    }
    if (this._mapDraw && payload && payload.type === "geoRoam") {
      this._mapDraw.resetForLabelLayout();
    }
    if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
      if (mapModel.needsDrawMap) {
        var mapDraw = this._mapDraw || new MapDraw$1(api);
        group.add(mapDraw.group);
        mapDraw.draw(mapModel, ecModel, api, this, payload);
        this._mapDraw = mapDraw;
      } else {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      }
    } else {
      var mapDraw = this._mapDraw;
      mapDraw && group.add(mapDraw.group);
    }
    mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
  };
  MapView2.prototype.remove = function() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
    this.group.removeAll();
  };
  MapView2.prototype.dispose = function() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
  };
  MapView2.prototype._renderSymbols = function(mapModel, ecModel, api) {
    var originalData = mapModel.originalData;
    var group = this.group;
    originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
      if (isNaN(value)) {
        return;
      }
      var layout2 = originalData.getItemLayout(originalDataIndex);
      if (!layout2 || !layout2.point) {
        return;
      }
      var point = layout2.point;
      var offset2 = layout2.offset;
      var circle = new Circle$1({
        style: {
          fill: mapModel.getData().getVisual("style").fill
        },
        shape: {
          cx: point[0] + offset2 * 9,
          cy: point[1],
          r: 3
        },
        silent: true,
        z2: 8 + (!offset2 ? Z2_EMPHASIS_LIFT + 1 : 0)
      });
      if (!offset2) {
        var fullData = mapModel.mainSeries.getData();
        var name_1 = originalData.getName(originalDataIndex);
        var fullIndex_1 = fullData.indexOfName(name_1);
        var itemModel = originalData.getItemModel(originalDataIndex);
        var labelModel = itemModel.getModel("label");
        var regionGroup = fullData.getItemGraphicEl(fullIndex_1);
        setLabelStyle(circle, getLabelStatesModels(itemModel), {
          labelFetcher: {
            getFormattedLabel: function(idx, state) {
              return mapModel.getFormattedLabel(fullIndex_1, state);
            }
          },
          defaultText: name_1
        });
        circle.disableLabelAnimation = true;
        if (!labelModel.get("position")) {
          circle.setTextConfig({
            position: "bottom"
          });
        }
        regionGroup.onHoverStateChange = function(toState) {
          setStatesFlag(circle, toState);
        };
      }
      group.add(circle);
    });
  };
  MapView2.type = "map";
  return MapView2;
}(ChartView$1);
var MapView$1 = MapView;
var MapSeries = function(_super) {
  __extends(MapSeries2, _super);
  function MapSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MapSeries2.type;
    _this.needsDrawMap = false;
    _this.seriesGroup = [];
    _this.getTooltipPosition = function(dataIndex) {
      if (dataIndex != null) {
        var name_1 = this.getData().getName(dataIndex);
        var geo = this.coordinateSystem;
        var region = geo.getRegion(name_1);
        return region && geo.dataToPoint(region.getCenter());
      }
    };
    return _this;
  }
  MapSeries2.prototype.getInitialData = function(option) {
    var data = createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
    var dataNameMap = createHashMap();
    var toAppendNames = [];
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      var name_2 = data.getName(i);
      dataNameMap.set(name_2, true);
    }
    var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
    each$e(geoSource.regions, function(region) {
      var name = region.name;
      if (!dataNameMap.get(name)) {
        toAppendNames.push(name);
      }
    });
    data.appendValues([], toAppendNames);
    return data;
  };
  MapSeries2.prototype.getHostGeoModel = function() {
    var geoIndex = this.option.geoIndex;
    return geoIndex != null ? this.ecModel.getComponent("geo", geoIndex) : null;
  };
  MapSeries2.prototype.getMapType = function() {
    return (this.getHostGeoModel() || this).option.map;
  };
  MapSeries2.prototype.getRawValue = function(dataIndex) {
    var data = this.getData();
    return data.get(data.mapDimension("value"), dataIndex);
  };
  MapSeries2.prototype.getRegionModel = function(regionName) {
    var data = this.getData();
    return data.getItemModel(data.indexOfName(regionName));
  };
  MapSeries2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name = data.getName(dataIndex);
    var seriesGroup = this.seriesGroup;
    var seriesNames = [];
    for (var i = 0; i < seriesGroup.length; i++) {
      var otherIndex = seriesGroup[i].originalData.indexOfName(name);
      var valueDim = data.mapDimension("value");
      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
        seriesNames.push(seriesGroup[i].name);
      }
    }
    return createTooltipMarkup("section", {
      header: seriesNames.join(", "),
      noHeader: !seriesNames.length,
      blocks: [createTooltipMarkup("nameValue", {
        name,
        value
      })]
    });
  };
  MapSeries2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  MapSeries2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  MapSeries2.prototype.getLegendIcon = function(opt) {
    var iconType = opt.icon || "roundRect";
    var icon = createSymbol(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
    icon.setStyle(opt.itemStyle);
    icon.style.stroke = "none";
    if (iconType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = "#fff";
      icon.style.lineWidth = 2;
    }
    return icon;
  };
  MapSeries2.type = "series.map";
  MapSeries2.dependencies = ["geo"];
  MapSeries2.layoutMode = "box";
  MapSeries2.defaultOption = {
    z: 2,
    coordinateSystem: "geo",
    map: "",
    left: "center",
    top: "center",
    aspectScale: null,
    showLegendSymbol: true,
    boundingCoords: null,
    center: null,
    zoom: 1,
    scaleLimit: null,
    selectedMode: true,
    label: {
      show: false,
      color: "#000"
    },
    itemStyle: {
      borderWidth: 0.5,
      borderColor: "#444",
      areaColor: "#eee"
    },
    emphasis: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        areaColor: "rgba(255,215,0,0.8)"
      }
    },
    select: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    nameProperty: "name"
  };
  return MapSeries2;
}(SeriesModel$1);
var MapSeries$1 = MapSeries;
function dataStatistics(datas, statisticType) {
  var dataNameMap = {};
  each$e(datas, function(data) {
    data.each(data.mapDimension("value"), function(value, idx) {
      var mapKey = "ec-" + data.getName(idx);
      dataNameMap[mapKey] = dataNameMap[mapKey] || [];
      if (!isNaN(value)) {
        dataNameMap[mapKey].push(value);
      }
    });
  });
  return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
    var mapKey = "ec-" + datas[0].getName(idx);
    var sum = 0;
    var min3 = Infinity;
    var max3 = -Infinity;
    var len2 = dataNameMap[mapKey].length;
    for (var i = 0; i < len2; i++) {
      min3 = Math.min(min3, dataNameMap[mapKey][i]);
      max3 = Math.max(max3, dataNameMap[mapKey][i]);
      sum += dataNameMap[mapKey][i];
    }
    var result;
    if (statisticType === "min") {
      result = min3;
    } else if (statisticType === "max") {
      result = max3;
    } else if (statisticType === "average") {
      result = sum / len2;
    } else {
      result = sum;
    }
    return len2 === 0 ? NaN : result;
  });
}
function mapDataStatistic(ecModel) {
  var seriesGroups = {};
  ecModel.eachSeriesByType("map", function(seriesModel) {
    var hostGeoModel = seriesModel.getHostGeoModel();
    var key2 = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
    (seriesGroups[key2] = seriesGroups[key2] || []).push(seriesModel);
  });
  each$e(seriesGroups, function(seriesList, key2) {
    var data = dataStatistics(map$1(seriesList, function(seriesModel) {
      return seriesModel.getData();
    }), seriesList[0].get("mapValueCalculation"));
    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].originalData = seriesList[i].getData();
    }
    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].seriesGroup = seriesList;
      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
      seriesList[i].setData(data.cloneShallow());
      seriesList[i].mainSeries = seriesList[0];
    }
  });
}
function mapSymbolLayout(ecModel) {
  var processedMapType = {};
  ecModel.eachSeriesByType("map", function(mapSeries) {
    var mapType = mapSeries.getMapType();
    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
      return;
    }
    var mapSymbolOffsets = {};
    each$e(mapSeries.seriesGroup, function(subMapSeries) {
      var geo = subMapSeries.coordinateSystem;
      var data2 = subMapSeries.originalData;
      if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
        data2.each(data2.mapDimension("value"), function(value, idx) {
          var name = data2.getName(idx);
          var region = geo.getRegion(name);
          if (!region || isNaN(value)) {
            return;
          }
          var offset2 = mapSymbolOffsets[name] || 0;
          var point = geo.dataToPoint(region.getCenter());
          mapSymbolOffsets[name] = offset2 + 1;
          data2.setItemLayout(idx, {
            point,
            offset: offset2
          });
        });
      }
    });
    var data = mapSeries.getData();
    data.each(function(idx) {
      var name = data.getName(idx);
      var layout2 = data.getItemLayout(idx) || {};
      layout2.showLabel = !mapSymbolOffsets[name];
      data.setItemLayout(idx, layout2);
    });
    processedMapType[mapType] = true;
  });
}
var v2ApplyTransform = applyTransform$1;
var View = function(_super) {
  __extends(View2, _super);
  function View2(name) {
    var _this = _super.call(this) || this;
    _this.type = "view";
    _this.dimensions = ["x", "y"];
    _this._roamTransformable = new Transformable$1();
    _this._rawTransformable = new Transformable$1();
    _this.name = name;
    return _this;
  }
  View2.prototype.setBoundingRect = function(x2, y, width, height) {
    this._rect = new BoundingRect$1(x2, y, width, height);
    return this._rect;
  };
  View2.prototype.getBoundingRect = function() {
    return this._rect;
  };
  View2.prototype.setViewRect = function(x2, y, width, height) {
    this._transformTo(x2, y, width, height);
    this._viewRect = new BoundingRect$1(x2, y, width, height);
  };
  View2.prototype._transformTo = function(x2, y, width, height) {
    var rect = this.getBoundingRect();
    var rawTransform = this._rawTransformable;
    rawTransform.transform = rect.calculateTransform(new BoundingRect$1(x2, y, width, height));
    var rawParent = rawTransform.parent;
    rawTransform.parent = null;
    rawTransform.decomposeTransform();
    rawTransform.parent = rawParent;
    this._updateTransform();
  };
  View2.prototype.setCenter = function(centerCoord) {
    if (!centerCoord) {
      return;
    }
    this._center = centerCoord;
    this._updateCenterAndZoom();
  };
  View2.prototype.setZoom = function(zoom) {
    zoom = zoom || 1;
    var zoomLimit = this.zoomLimit;
    if (zoomLimit) {
      if (zoomLimit.max != null) {
        zoom = Math.min(zoomLimit.max, zoom);
      }
      if (zoomLimit.min != null) {
        zoom = Math.max(zoomLimit.min, zoom);
      }
    }
    this._zoom = zoom;
    this._updateCenterAndZoom();
  };
  View2.prototype.getDefaultCenter = function() {
    var rawRect = this.getBoundingRect();
    var cx = rawRect.x + rawRect.width / 2;
    var cy = rawRect.y + rawRect.height / 2;
    return [cx, cy];
  };
  View2.prototype.getCenter = function() {
    return this._center || this.getDefaultCenter();
  };
  View2.prototype.getZoom = function() {
    return this._zoom || 1;
  };
  View2.prototype.getRoamTransform = function() {
    return this._roamTransformable.getLocalTransform();
  };
  View2.prototype._updateCenterAndZoom = function() {
    var rawTransformMatrix = this._rawTransformable.getLocalTransform();
    var roamTransform = this._roamTransformable;
    var defaultCenter = this.getDefaultCenter();
    var center2 = this.getCenter();
    var zoom = this.getZoom();
    center2 = applyTransform$1([], center2, rawTransformMatrix);
    defaultCenter = applyTransform$1([], defaultCenter, rawTransformMatrix);
    roamTransform.originX = center2[0];
    roamTransform.originY = center2[1];
    roamTransform.x = defaultCenter[0] - center2[0];
    roamTransform.y = defaultCenter[1] - center2[1];
    roamTransform.scaleX = roamTransform.scaleY = zoom;
    this._updateTransform();
  };
  View2.prototype._updateTransform = function() {
    var roamTransformable = this._roamTransformable;
    var rawTransformable = this._rawTransformable;
    rawTransformable.parent = roamTransformable;
    roamTransformable.updateTransform();
    rawTransformable.updateTransform();
    copy(this.transform || (this.transform = []), rawTransformable.transform || create());
    this._rawTransform = rawTransformable.getLocalTransform();
    this.invTransform = this.invTransform || [];
    invert(this.invTransform, this.transform);
    this.decomposeTransform();
  };
  View2.prototype.getTransformInfo = function() {
    var rawTransformable = this._rawTransformable;
    var roamTransformable = this._roamTransformable;
    var dummyTransformable = new Transformable$1();
    dummyTransformable.transform = roamTransformable.transform;
    dummyTransformable.decomposeTransform();
    return {
      roam: {
        x: dummyTransformable.x,
        y: dummyTransformable.y,
        scaleX: dummyTransformable.scaleX,
        scaleY: dummyTransformable.scaleY
      },
      raw: {
        x: rawTransformable.x,
        y: rawTransformable.y,
        scaleX: rawTransformable.scaleX,
        scaleY: rawTransformable.scaleY
      }
    };
  };
  View2.prototype.getViewRect = function() {
    return this._viewRect;
  };
  View2.prototype.getViewRectAfterRoam = function() {
    var rect = this.getBoundingRect().clone();
    rect.applyTransform(this.transform);
    return rect;
  };
  View2.prototype.dataToPoint = function(data, noRoam, out2) {
    var transform2 = noRoam ? this._rawTransform : this.transform;
    out2 = out2 || [];
    return transform2 ? v2ApplyTransform(out2, data, transform2) : copy$1(out2, data);
  };
  View2.prototype.pointToData = function(point) {
    var invTransform = this.invTransform;
    return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
  };
  View2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$3(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  View2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$3(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  View2.prototype.containPoint = function(point) {
    return this.getViewRectAfterRoam().contain(point[0], point[1]);
  };
  View2.dimensions = ["x", "y"];
  return View2;
}(Transformable$1);
function getCoordSys$3(finder) {
  var seriesModel = finder.seriesModel;
  return seriesModel ? seriesModel.coordinateSystem : null;
}
var View$1 = View;
var GEO_DEFAULT_PARAMS = {
  "geoJSON": {
    aspectScale: 0.75,
    invertLongitute: true
  },
  "geoSVG": {
    aspectScale: 1,
    invertLongitute: false
  }
};
var geo2DDimensions = ["lng", "lat"];
var Geo = function(_super) {
  __extends(Geo2, _super);
  function Geo2(name, map2, opt) {
    var _this = _super.call(this, name) || this;
    _this.dimensions = geo2DDimensions;
    _this.type = "geo";
    _this._nameCoordMap = createHashMap();
    _this.map = map2;
    var projection = opt.projection;
    var source = geoSourceManager.load(map2, opt.nameMap, opt.nameProperty);
    var resource = geoSourceManager.getGeoResource(map2);
    _this.resourceType = resource ? resource.type : null;
    var regions = _this.regions = source.regions;
    var defaultParams = GEO_DEFAULT_PARAMS[resource.type];
    _this._regionsMap = source.regionsMap;
    _this.regions = source.regions;
    _this.projection = projection;
    var boundingRect;
    if (projection) {
      for (var i = 0; i < regions.length; i++) {
        var regionRect = regions[i].getBoundingRect(projection);
        boundingRect = boundingRect || regionRect.clone();
        boundingRect.union(regionRect);
      }
    } else {
      boundingRect = source.boundingRect;
    }
    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);
    _this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale);
    _this._invertLongitute = projection ? false : defaultParams.invertLongitute;
    return _this;
  }
  Geo2.prototype._transformTo = function(x2, y, width, height) {
    var rect = this.getBoundingRect();
    var invertLongitute = this._invertLongitute;
    rect = rect.clone();
    if (invertLongitute) {
      rect.y = -rect.y - rect.height;
    }
    var rawTransformable = this._rawTransformable;
    rawTransformable.transform = rect.calculateTransform(new BoundingRect$1(x2, y, width, height));
    var rawParent = rawTransformable.parent;
    rawTransformable.parent = null;
    rawTransformable.decomposeTransform();
    rawTransformable.parent = rawParent;
    if (invertLongitute) {
      rawTransformable.scaleY = -rawTransformable.scaleY;
    }
    this._updateTransform();
  };
  Geo2.prototype.getRegion = function(name) {
    return this._regionsMap.get(name);
  };
  Geo2.prototype.getRegionByCoord = function(coord) {
    var regions = this.regions;
    for (var i = 0; i < regions.length; i++) {
      var region = regions[i];
      if (region.type === "geoJSON" && region.contain(coord)) {
        return regions[i];
      }
    }
  };
  Geo2.prototype.addGeoCoord = function(name, geoCoord2) {
    this._nameCoordMap.set(name, geoCoord2);
  };
  Geo2.prototype.getGeoCoord = function(name) {
    var region = this._regionsMap.get(name);
    return this._nameCoordMap.get(name) || region && region.getCenter();
  };
  Geo2.prototype.dataToPoint = function(data, noRoam, out2) {
    if (isString$2(data)) {
      data = this.getGeoCoord(data);
    }
    if (data) {
      var projection = this.projection;
      if (projection) {
        data = projection.project(data);
      }
      return data && this.projectedToPoint(data);
    }
  };
  Geo2.prototype.pointToData = function(point) {
    var projection = this.projection;
    if (projection) {
      point = projection.unproject(point);
    }
    return point && this.pointToProjected(point);
  };
  Geo2.prototype.pointToProjected = function(point) {
    return _super.prototype.pointToData.call(this, point);
  };
  Geo2.prototype.projectedToPoint = function(projected, noRoam, out2) {
    return _super.prototype.dataToPoint.call(this, projected, noRoam, out2);
  };
  Geo2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$2(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  Geo2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$2(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  return Geo2;
}(View$1);
mixin(Geo, View$1);
function getCoordSys$2(finder) {
  var geoModel = finder.geoModel;
  var seriesModel = finder.seriesModel;
  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
var Geo$1 = Geo;
function resizeGeo(geoModel, api) {
  var boundingCoords = geoModel.get("boundingCoords");
  if (boundingCoords != null) {
    var leftTop_1 = boundingCoords[0];
    var rightBottom_1 = boundingCoords[1];
    if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1])))
      ;
    else {
      var projection_1 = this.projection;
      if (projection_1) {
        var xMin = leftTop_1[0];
        var yMin = leftTop_1[1];
        var xMax = rightBottom_1[0];
        var yMax = rightBottom_1[1];
        leftTop_1 = [Infinity, Infinity];
        rightBottom_1 = [-Infinity, -Infinity];
        var sampleLine = function(x0, y0, x1, y1) {
          var dx = x1 - x0;
          var dy = y1 - y0;
          for (var i = 0; i <= 100; i++) {
            var p2 = i / 100;
            var pt = projection_1.project([x0 + dx * p2, y0 + dy * p2]);
            min$2(leftTop_1, leftTop_1, pt);
            max$2(rightBottom_1, rightBottom_1, pt);
          }
        };
        sampleLine(xMin, yMin, xMax, yMin);
        sampleLine(xMax, yMin, xMax, yMax);
        sampleLine(xMax, yMax, xMin, yMax);
        sampleLine(xMin, yMax, xMax, yMin);
      }
      this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1]);
    }
  }
  var rect = this.getBoundingRect();
  var centerOption = geoModel.get("layoutCenter");
  var sizeOption = geoModel.get("layoutSize");
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  var aspect = rect.width / rect.height * this.aspectScale;
  var useCenterAndSize = false;
  var center2;
  var size;
  if (centerOption && sizeOption) {
    center2 = [parsePercent(centerOption[0], viewWidth), parsePercent(centerOption[1], viewHeight)];
    size = parsePercent(sizeOption, Math.min(viewWidth, viewHeight));
    if (!isNaN(center2[0]) && !isNaN(center2[1]) && !isNaN(size)) {
      useCenterAndSize = true;
    }
  }
  var viewRect2;
  if (useCenterAndSize) {
    viewRect2 = {};
    if (aspect > 1) {
      viewRect2.width = size;
      viewRect2.height = size / aspect;
    } else {
      viewRect2.height = size;
      viewRect2.width = size * aspect;
    }
    viewRect2.y = center2[1] - viewRect2.height / 2;
    viewRect2.x = center2[0] - viewRect2.width / 2;
  } else {
    var boxLayoutOption = geoModel.getBoxLayoutParams();
    boxLayoutOption.aspect = aspect;
    viewRect2 = getLayoutRect$1(boxLayoutOption, {
      width: viewWidth,
      height: viewHeight
    });
  }
  this.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
  this.setCenter(geoModel.get("center"));
  this.setZoom(geoModel.get("zoom"));
}
function setGeoCoords(geo, model) {
  each$e(model.get("geoCoord"), function(geoCoord2, name) {
    geo.addGeoCoord(name, geoCoord2);
  });
}
var GeoCreator = function() {
  function GeoCreator2() {
    this.dimensions = geo2DDimensions;
  }
  GeoCreator2.prototype.create = function(ecModel, api) {
    var geoList = [];
    function getCommonGeoProperties(model) {
      return {
        nameProperty: model.get("nameProperty"),
        aspectScale: model.get("aspectScale"),
        projection: model.get("projection")
      };
    }
    ecModel.eachComponent("geo", function(geoModel, idx) {
      var mapName = geoModel.get("map");
      var geo = new Geo$1(mapName + idx, mapName, extend$3({
        nameMap: geoModel.get("nameMap")
      }, getCommonGeoProperties(geoModel)));
      geo.zoomLimit = geoModel.get("scaleLimit");
      geoList.push(geo);
      geoModel.coordinateSystem = geo;
      geo.model = geoModel;
      geo.resize = resizeGeo;
      geo.resize(geoModel, api);
    });
    ecModel.eachSeries(function(seriesModel) {
      var coordSys = seriesModel.get("coordinateSystem");
      if (coordSys === "geo") {
        var geoIndex = seriesModel.get("geoIndex") || 0;
        seriesModel.coordinateSystem = geoList[geoIndex];
      }
    });
    var mapModelGroupBySeries = {};
    ecModel.eachSeriesByType("map", function(seriesModel) {
      if (!seriesModel.getHostGeoModel()) {
        var mapType = seriesModel.getMapType();
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      }
    });
    each$e(mapModelGroupBySeries, function(mapSeries, mapType) {
      var nameMapList = map$1(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("nameMap");
      });
      var geo = new Geo$1(mapType, mapType, extend$3({
        nameMap: mergeAll(nameMapList)
      }, getCommonGeoProperties(mapSeries[0])));
      geo.zoomLimit = retrieve.apply(null, map$1(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("scaleLimit");
      }));
      geoList.push(geo);
      geo.resize = resizeGeo;
      geo.resize(mapSeries[0], api);
      each$e(mapSeries, function(singleMapSeries) {
        singleMapSeries.coordinateSystem = geo;
        setGeoCoords(geo, singleMapSeries);
      });
    });
    return geoList;
  };
  GeoCreator2.prototype.getFilledRegions = function(originRegionArr, mapName, nameMap, nameProperty) {
    var regionsArr = (originRegionArr || []).slice();
    var dataNameMap = createHashMap();
    for (var i = 0; i < regionsArr.length; i++) {
      dataNameMap.set(regionsArr[i].name, regionsArr[i]);
    }
    var source = geoSourceManager.load(mapName, nameMap, nameProperty);
    each$e(source.regions, function(region) {
      var name = region.name;
      !dataNameMap.get(name) && regionsArr.push({
        name
      });
    });
    return regionsArr;
  };
  return GeoCreator2;
}();
var geoCreator = new GeoCreator();
var geoCreator$1 = geoCreator;
var GeoModel = function(_super) {
  __extends(GeoModel2, _super);
  function GeoModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GeoModel2.type;
    return _this;
  }
  GeoModel2.prototype.init = function(option, parentModel, ecModel) {
    var source = geoSourceManager.getGeoResource(option.map);
    if (source && source.type === "geoJSON") {
      var itemStyle = option.itemStyle = option.itemStyle || {};
      if (!("color" in itemStyle)) {
        itemStyle.color = "#eee";
      }
    }
    this.mergeDefaultAndTheme(option, ecModel);
    defaultEmphasis(option, "label", ["show"]);
  };
  GeoModel2.prototype.optionUpdated = function() {
    var _this = this;
    var option = this.option;
    option.regions = geoCreator$1.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
    var selectedMap = {};
    this._optionModelMap = reduce(option.regions || [], function(optionModelMap, regionOpt) {
      var regionName = regionOpt.name;
      if (regionName) {
        optionModelMap.set(regionName, new Model$1(regionOpt, _this, _this.ecModel));
        if (regionOpt.selected) {
          selectedMap[regionName] = true;
        }
      }
      return optionModelMap;
    }, createHashMap());
    if (!option.selectedMap) {
      option.selectedMap = selectedMap;
    }
  };
  GeoModel2.prototype.getRegionModel = function(name) {
    return this._optionModelMap.get(name) || new Model$1(null, this, this.ecModel);
  };
  GeoModel2.prototype.getFormattedLabel = function(name, status) {
    var regionModel = this.getRegionModel(name);
    var formatter2 = status === "normal" ? regionModel.get(["label", "formatter"]) : regionModel.get(["emphasis", "label", "formatter"]);
    var params = {
      name
    };
    if (isFunction$2(formatter2)) {
      params.status = status;
      return formatter2(params);
    } else if (isString$2(formatter2)) {
      return formatter2.replace("{a}", name != null ? name : "");
    }
  };
  GeoModel2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  GeoModel2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  GeoModel2.prototype.select = function(name) {
    var option = this.option;
    var selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    if (selectedMode !== "multiple") {
      option.selectedMap = null;
    }
    var selectedMap = option.selectedMap || (option.selectedMap = {});
    selectedMap[name] = true;
  };
  GeoModel2.prototype.unSelect = function(name) {
    var selectedMap = this.option.selectedMap;
    if (selectedMap) {
      selectedMap[name] = false;
    }
  };
  GeoModel2.prototype.toggleSelected = function(name) {
    this[this.isSelected(name) ? "unSelect" : "select"](name);
  };
  GeoModel2.prototype.isSelected = function(name) {
    var selectedMap = this.option.selectedMap;
    return !!(selectedMap && selectedMap[name]);
  };
  GeoModel2.type = "geo";
  GeoModel2.layoutMode = "box";
  GeoModel2.defaultOption = {
    z: 0,
    show: true,
    left: "center",
    top: "center",
    aspectScale: null,
    silent: false,
    map: "",
    boundingCoords: null,
    center: null,
    zoom: 1,
    scaleLimit: null,
    label: {
      show: false,
      color: "#000"
    },
    itemStyle: {
      borderWidth: 0.5,
      borderColor: "#444"
    },
    emphasis: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    select: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    regions: []
  };
  return GeoModel2;
}(ComponentModel$1);
var GeoModel$1 = GeoModel;
function getCenterCoord(view2, point) {
  return view2.pointToProjected ? view2.pointToProjected(point) : view2.pointToData(point);
}
function updateCenterAndZoom(view2, payload, zoomLimit) {
  var previousZoom = view2.getZoom();
  var center2 = view2.getCenter();
  var zoom = payload.zoom;
  var point = view2.projectedToPoint ? view2.projectedToPoint(center2) : view2.dataToPoint(center2);
  if (payload.dx != null && payload.dy != null) {
    point[0] -= payload.dx;
    point[1] -= payload.dy;
    view2.setCenter(getCenterCoord(view2, point));
  }
  if (zoom != null) {
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
    }
    view2.scaleX *= zoom;
    view2.scaleY *= zoom;
    var fixX = (payload.originX - view2.x) * (zoom - 1);
    var fixY = (payload.originY - view2.y) * (zoom - 1);
    view2.x -= fixX;
    view2.y -= fixY;
    view2.updateTransform();
    view2.setCenter(getCenterCoord(view2, point));
    view2.setZoom(zoom * previousZoom);
  }
  return {
    center: view2.getCenter(),
    zoom: view2.getZoom()
  };
}
var GeoView = function(_super) {
  __extends(GeoView2, _super);
  function GeoView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GeoView2.type;
    _this.focusBlurEnabled = true;
    return _this;
  }
  GeoView2.prototype.init = function(ecModel, api) {
    this._api = api;
  };
  GeoView2.prototype.render = function(geoModel, ecModel, api, payload) {
    this._model = geoModel;
    if (!geoModel.get("show")) {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      return;
    }
    if (!this._mapDraw) {
      this._mapDraw = new MapDraw$1(api);
    }
    var mapDraw = this._mapDraw;
    mapDraw.draw(geoModel, ecModel, api, this, payload);
    mapDraw.group.on("click", this._handleRegionClick, this);
    mapDraw.group.silent = geoModel.get("silent");
    this.group.add(mapDraw.group);
    this.updateSelectStatus(geoModel, ecModel, api);
  };
  GeoView2.prototype._handleRegionClick = function(e2) {
    var eventData;
    findEventDispatcher(e2.target, function(current) {
      return (eventData = getECData(current).eventData) != null;
    }, true);
    if (eventData) {
      this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: eventData.name
      });
    }
  };
  GeoView2.prototype.updateSelectStatus = function(model, ecModel, api) {
    var _this = this;
    this._mapDraw.group.traverse(function(node) {
      var eventData = getECData(node).eventData;
      if (eventData) {
        _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node);
        return true;
      }
    });
  };
  GeoView2.prototype.findHighDownDispatchers = function(name) {
    return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);
  };
  GeoView2.prototype.dispose = function() {
    this._mapDraw && this._mapDraw.remove();
  };
  GeoView2.type = "geo";
  return GeoView2;
}(ComponentView$1);
var GeoView$1 = GeoView;
function registerMap(mapName, geoJson, specialAreas) {
  geoSourceManager.registerMap(mapName, geoJson, specialAreas);
}
function install$o(registers) {
  registers.registerCoordinateSystem("geo", geoCreator$1);
  registers.registerComponentModel(GeoModel$1);
  registers.registerComponentView(GeoView$1);
  registers.registerImpl("registerMap", registerMap);
  registers.registerImpl("getMap", function(mapName) {
    return geoSourceManager.getMapForUser(mapName);
  });
  function makeAction(method, actionInfo2) {
    actionInfo2.update = "geo:updateSelectStatus";
    registers.registerAction(actionInfo2, function(payload, ecModel) {
      var selected = {};
      var allSelected = [];
      ecModel.eachComponent({
        mainType: "geo",
        query: payload
      }, function(geoModel) {
        geoModel[method](payload.name);
        var geo = geoModel.coordinateSystem;
        each$e(geo.regions, function(region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
        var names2 = [];
        each$e(selected, function(v2, name) {
          selected[name] && names2.push(name);
        });
        allSelected.push({
          geoIndex: geoModel.componentIndex,
          name: names2
        });
      });
      return {
        selected,
        allSelected,
        name: payload.name
      };
    });
  }
  makeAction("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  });
  makeAction("select", {
    type: "geoSelect",
    event: "geoselected"
  });
  makeAction("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  });
  registers.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      var geo = componentModel.coordinateSystem;
      if (geo.type !== "geo") {
        return;
      }
      var res = updateCenterAndZoom(geo, payload, componentModel.get("scaleLimit"));
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom);
      if (componentType === "series") {
        each$e(componentModel.seriesGroup, function(seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
}
function install$n(registers) {
  use(install$o);
  registers.registerChartView(MapView$1);
  registers.registerSeriesModel(MapSeries$1);
  registers.registerLayout(mapSymbolLayout);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
  createLegacyDataSelectAction("map", registers.registerAction);
}
var each$b = each$e;
var isObject$6 = isObject$9;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
var VisualMapping = function() {
  function VisualMapping2(option) {
    var mappingMethod = option.mappingMethod;
    var visualType = option.type;
    var thisOption = this.option = clone$3(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    var visualHandler = VisualMapping2.visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];
    if (mappingMethod === "piecewise") {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === "category") {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
    } else {
      assert(mappingMethod !== "linear" || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  }
  VisualMapping2.prototype.mapValueToVisual = function(value) {
    var normalized = this._normalizeData(value);
    return this._normalizedToVisual(normalized, value);
  };
  VisualMapping2.prototype.getNormalizer = function() {
    return bind$1(this._normalizeData, this);
  };
  VisualMapping2.listVisualTypes = function() {
    return keys$1(VisualMapping2.visualHandlers);
  };
  VisualMapping2.isValidType = function(visualType) {
    return VisualMapping2.visualHandlers.hasOwnProperty(visualType);
  };
  VisualMapping2.eachVisual = function(visual, callback, context) {
    if (isObject$9(visual)) {
      each$e(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  };
  VisualMapping2.mapVisual = function(visual, callback, context) {
    var isPrimary;
    var newVisual = isArray$4(visual) ? [] : isObject$9(visual) ? {} : (isPrimary = true, null);
    VisualMapping2.eachVisual(visual, function(v2, key2) {
      var newVal = callback.call(context, v2, key2);
      isPrimary ? newVisual = newVal : newVisual[key2] = newVal;
    });
    return newVisual;
  };
  VisualMapping2.retrieveVisuals = function(obj) {
    var ret = {};
    var hasVisual;
    obj && each$b(VisualMapping2.visualHandlers, function(h2, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  };
  VisualMapping2.prepareVisualTypes = function(visualTypes) {
    if (isArray$4(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else if (isObject$6(visualTypes)) {
      var types_1 = [];
      each$b(visualTypes, function(item, type) {
        types_1.push(type);
      });
      visualTypes = types_1;
    } else {
      return [];
    }
    visualTypes.sort(function(type1, type2) {
      return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
    });
    return visualTypes;
  };
  VisualMapping2.dependsOn = function(visualType1, visualType2) {
    return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  };
  VisualMapping2.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
    var possibleI;
    var abs2 = Infinity;
    for (var i = 0, len2 = pieceList.length; i < len2; i++) {
      var pieceValue = pieceList[i].value;
      if (pieceValue != null) {
        if (pieceValue === value || isString$2(pieceValue) && pieceValue === value + "") {
          return i;
        }
        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }
    for (var i = 0, len2 = pieceList.length; i < len2; i++) {
      var piece = pieceList[i];
      var interval = piece.interval;
      var close_1 = piece.close;
      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close_1[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close_1[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {
          return i;
        }
        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }
    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }
    function updatePossible(val, index2) {
      var newAbs = Math.abs(val - value);
      if (newAbs < abs2) {
        abs2 = newAbs;
        possibleI = index2;
      }
    }
  };
  VisualMapping2.visualHandlers = {
    color: {
      applyVisual: makeApplyVisual("color"),
      getColorMapper: function() {
        var thisOption = this.option;
        return bind$1(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
          !isNormalized && (value = this._normalizeData(value));
          return doMapCategory.call(this, value);
        } : function(value, isNormalized, out2) {
          var returnRGBArray = !!out2;
          !isNormalized && (value = this._normalizeData(value));
          out2 = fastLerp(value, thisOption.parsedVisual, out2);
          return returnRGBArray ? out2 : stringify(out2, "rgba");
        }, this);
      },
      _normalizedToVisual: {
        linear: function(normalized) {
          return stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
        },
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    colorHue: makePartialColorVisualHandler(function(color$1, value) {
      return modifyHSL(color$1, value);
    }),
    colorSaturation: makePartialColorVisualHandler(function(color$1, value) {
      return modifyHSL(color$1, null, value);
    }),
    colorLightness: makePartialColorVisualHandler(function(color$1, value) {
      return modifyHSL(color$1, null, null, value);
    }),
    colorAlpha: makePartialColorVisualHandler(function(color$1, value) {
      return modifyAlpha(color$1, value);
    }),
    decal: {
      applyVisual: makeApplyVisual("decal"),
      _normalizedToVisual: {
        linear: null,
        category: doMapCategory,
        piecewise: null,
        fixed: null
      }
    },
    opacity: {
      applyVisual: makeApplyVisual("opacity"),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    },
    liftZ: {
      applyVisual: makeApplyVisual("liftZ"),
      _normalizedToVisual: {
        linear: doMapFixed,
        category: doMapFixed,
        piecewise: doMapFixed,
        fixed: doMapFixed
      }
    },
    symbol: {
      applyVisual: function(value, getter, setter) {
        var symbolCfg = this.mapValueToVisual(value);
        setter("symbol", symbolCfg);
      },
      _normalizedToVisual: {
        linear: doMapToArray,
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = doMapToArray.call(this, normalized);
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    symbolSize: {
      applyVisual: makeApplyVisual("symbolSize"),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    }
  };
  return VisualMapping2;
}();
function preprocessForPiecewise(thisOption) {
  var pieceList = thisOption.pieceList;
  thisOption.hasSpecialVisual = false;
  each$e(pieceList, function(piece, index2) {
    piece.originIndex = index2;
    if (piece.visual != null) {
      thisOption.hasSpecialVisual = true;
    }
  });
}
function preprocessForSpecifiedCategory(thisOption) {
  var categories = thisOption.categories;
  var categoryMap = thisOption.categoryMap = {};
  var visual = thisOption.visual;
  each$b(categories, function(cate, index2) {
    categoryMap[cate] = index2;
  });
  if (!isArray$4(visual)) {
    var visualArr_1 = [];
    if (isObject$9(visual)) {
      each$b(visual, function(v2, cate) {
        var index2 = categoryMap[cate];
        visualArr_1[index2 != null ? index2 : CATEGORY_DEFAULT_VISUAL_INDEX] = v2;
      });
    } else {
      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
    }
    visual = setVisualToOption(thisOption, visualArr_1);
  }
  for (var i = categories.length - 1; i >= 0; i--) {
    if (visual[i] == null) {
      delete categoryMap[categories[i]];
      categories.pop();
    }
  }
}
function normalizeVisualRange(thisOption, isCategory2) {
  var visual = thisOption.visual;
  var visualArr = [];
  if (isObject$9(visual)) {
    each$b(visual, function(v2) {
      visualArr.push(v2);
    });
  } else if (visual != null) {
    visualArr.push(visual);
  }
  var doNotNeedPair = {
    color: 1,
    symbol: 1
  };
  if (!isCategory2 && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
    visualArr[1] = visualArr[0];
  }
  setVisualToOption(thisOption, visualArr);
}
function makePartialColorVisualHandler(applyValue) {
  return {
    applyVisual: function(value, getter, setter) {
      var colorChannel = this.mapValueToVisual(value);
      setter("color", applyValue(getter("color"), colorChannel));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}
function doMapToArray(normalized) {
  var visual = this.option.visual;
  return visual[Math.round(linearMap$2(normalized, [0, 1], [0, visual.length - 1], true))] || {};
}
function makeApplyVisual(visualType) {
  return function(value, getter, setter) {
    setter(visualType, this.mapValueToVisual(value));
  };
}
function doMapCategory(normalized) {
  var visual = this.option.visual;
  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}
function doMapFixed() {
  return this.option.visual[0];
}
function createNormalizedToNumericVisual(sourceExtent) {
  return {
    linear: function(normalized) {
      return linearMap$2(normalized, sourceExtent, this.option.visual, true);
    },
    category: doMapCategory,
    piecewise: function(normalized, value) {
      var result = getSpecifiedVisual.call(this, value);
      if (result == null) {
        result = linearMap$2(normalized, sourceExtent, this.option.visual, true);
      }
      return result;
    },
    fixed: doMapFixed
  };
}
function getSpecifiedVisual(value) {
  var thisOption = this.option;
  var pieceList = thisOption.pieceList;
  if (thisOption.hasSpecialVisual) {
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
    var piece = pieceList[pieceIndex];
    if (piece && piece.visual) {
      return piece.visual[this.type];
    }
  }
}
function setVisualToOption(thisOption, visualArr) {
  thisOption.visual = visualArr;
  if (thisOption.type === "color") {
    thisOption.parsedVisual = map$1(visualArr, function(item) {
      var color$1 = parse(item);
      if (!color$1 && false) {
        warn("'" + item + "' is an illegal color, fallback to '#000000'", true);
      }
      return color$1 || [0, 0, 0, 1];
    });
  }
  return visualArr;
}
var normalizers = {
  linear: function(value) {
    return linearMap$2(value, this.option.dataExtent, [0, 1], true);
  },
  piecewise: function(value) {
    var pieceList = this.option.pieceList;
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
    if (pieceIndex != null) {
      return linearMap$2(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
    }
  },
  category: function(value) {
    var index2 = this.option.categories ? this.option.categoryMap[value] : value;
    return index2 == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index2;
  },
  fixed: noop$2
};
function littleThan(close2, a2, b2) {
  return close2 ? a2 <= b2 : a2 < b2;
}
var VisualMapping$1 = VisualMapping;
function parallelPreprocessor(option) {
  createParallelIfNeeded(option);
  mergeAxisOptionFromParallel(option);
}
function createParallelIfNeeded(option) {
  if (option.parallel) {
    return;
  }
  var hasParallelSeries = false;
  each$e(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "parallel") {
      hasParallelSeries = true;
    }
  });
  if (hasParallelSeries) {
    option.parallel = [{}];
  }
}
function mergeAxisOptionFromParallel(option) {
  var axes = normalizeToArray(option.parallelAxis);
  each$e(axes, function(axisOption) {
    if (!isObject$9(axisOption)) {
      return;
    }
    var parallelIndex = axisOption.parallelIndex || 0;
    var parallelOption = normalizeToArray(option.parallel)[parallelIndex];
    if (parallelOption && parallelOption.parallelAxisDefault) {
      merge(axisOption, parallelOption.parallelAxisDefault, false);
    }
  });
}
var CLICK_THRESHOLD = 5;
var ParallelView = function(_super) {
  __extends(ParallelView2, _super);
  function ParallelView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelView2.type;
    return _this;
  }
  ParallelView2.prototype.render = function(parallelModel, ecModel, api) {
    this._model = parallelModel;
    this._api = api;
    if (!this._handlers) {
      this._handlers = {};
      each$e(handlers$1, function(handler, eventName) {
        api.getZr().on(eventName, this._handlers[eventName] = bind$1(handler, this));
      }, this);
    }
    createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
  };
  ParallelView2.prototype.dispose = function(ecModel, api) {
    clear$1(this, "_throttledDispatchExpand");
    each$e(this._handlers, function(handler, eventName) {
      api.getZr().off(eventName, handler);
    });
    this._handlers = null;
  };
  ParallelView2.prototype._throttledDispatchExpand = function(opt) {
    this._dispatchExpand(opt);
  };
  ParallelView2.prototype._dispatchExpand = function(opt) {
    opt && this._api.dispatchAction(extend$3({
      type: "parallelAxisExpand"
    }, opt));
  };
  ParallelView2.type = "parallel";
  return ParallelView2;
}(ComponentView$1);
var handlers$1 = {
  mousedown: function(e2) {
    if (checkTrigger(this, "click")) {
      this._mouseDownPoint = [e2.offsetX, e2.offsetY];
    }
  },
  mouseup: function(e2) {
    var mouseDownPoint = this._mouseDownPoint;
    if (checkTrigger(this, "click") && mouseDownPoint) {
      var point = [e2.offsetX, e2.offsetY];
      var dist2 = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
      if (dist2 > CLICK_THRESHOLD) {
        return;
      }
      var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
      result.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: result.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(e2) {
    if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
      return;
    }
    var model = this._model;
    var result = model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
    var behavior = result.behavior;
    behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
    this._throttledDispatchExpand(behavior === "none" ? null : {
      axisExpandWindow: result.axisExpandWindow,
      animation: behavior === "jump" ? null : {
        duration: 0
      }
    });
  }
};
function checkTrigger(view2, triggerOn) {
  var model = view2._model;
  return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
}
var ParallelView$1 = ParallelView;
var ParallelModel = function(_super) {
  __extends(ParallelModel2, _super);
  function ParallelModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelModel2.type;
    return _this;
  }
  ParallelModel2.prototype.init = function() {
    _super.prototype.init.apply(this, arguments);
    this.mergeOption({});
  };
  ParallelModel2.prototype.mergeOption = function(newOption) {
    var thisOption = this.option;
    newOption && merge(thisOption, newOption, true);
    this._initDimensions();
  };
  ParallelModel2.prototype.contains = function(model, ecModel) {
    var parallelIndex = model.get("parallelIndex");
    return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
  };
  ParallelModel2.prototype.setAxisExpand = function(opt) {
    each$e(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(name) {
      if (opt.hasOwnProperty(name)) {
        this.option[name] = opt[name];
      }
    }, this);
  };
  ParallelModel2.prototype._initDimensions = function() {
    var dimensions = this.dimensions = [];
    var parallelAxisIndex = this.parallelAxisIndex = [];
    var axisModels = filter$2(this.ecModel.queryComponents({
      mainType: "parallelAxis"
    }), function(axisModel) {
      return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
    }, this);
    each$e(axisModels, function(axisModel) {
      dimensions.push("dim" + axisModel.get("dim"));
      parallelAxisIndex.push(axisModel.componentIndex);
    });
  };
  ParallelModel2.type = "parallel";
  ParallelModel2.dependencies = ["parallelAxis"];
  ParallelModel2.layoutMode = "box";
  ParallelModel2.defaultOption = {
    z: 0,
    left: 80,
    top: 60,
    right: 80,
    bottom: 60,
    layout: "horizontal",
    axisExpandable: false,
    axisExpandCenter: null,
    axisExpandCount: 0,
    axisExpandWidth: 50,
    axisExpandRate: 17,
    axisExpandDebounce: 50,
    axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
    axisExpandTriggerOn: "click",
    parallelAxisDefault: null
  };
  return ParallelModel2;
}(ComponentModel$1);
var ParallelModel$1 = ParallelModel;
var ParallelAxis = function(_super) {
  __extends(ParallelAxis2, _super);
  function ParallelAxis2(dim, scale2, coordExtent, axisType, axisIndex) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.type = axisType || "value";
    _this.axisIndex = axisIndex;
    return _this;
  }
  ParallelAxis2.prototype.isHorizontal = function() {
    return this.coordinateSystem.getModel().get("layout") !== "horizontal";
  };
  return ParallelAxis2;
}(Axis$1);
var ParallelAxis$1 = ParallelAxis;
function sliderMove(delta, handleEnds, extent3, handleIndex, minSpan, maxSpan) {
  delta = delta || 0;
  var extentSpan = extent3[1] - extent3[0];
  if (minSpan != null) {
    minSpan = restrict$1(minSpan, [0, extentSpan]);
  }
  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }
  if (handleIndex === "all") {
    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict$1(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict$1(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }
  handleEnds[0] = restrict$1(handleEnds[0], extent3);
  handleEnds[1] = restrict$1(handleEnds[1], extent3);
  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta;
  var extentMinSpan = minSpan || 0;
  var realExtent = extent3.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict$1(handleEnds[handleIndex], realExtent);
  var currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  }
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }
  return handleEnds;
}
function getSpanSign(handleEnds, handleIndex) {
  var dist2 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
  return {
    span: Math.abs(dist2),
    sign: dist2 > 0 ? -1 : dist2 < 0 ? 1 : handleIndex ? -1 : 1
  };
}
function restrict$1(value, extend2) {
  return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
}
var each$a = each$e;
var mathMin$2 = Math.min;
var mathMax$2 = Math.max;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var round$2 = round$4;
var PI$2 = Math.PI;
var Parallel = function() {
  function Parallel2(parallelModel, ecModel, api) {
    this.type = "parallel";
    this._axesMap = createHashMap();
    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._model = parallelModel;
    this._init(parallelModel, ecModel, api);
  }
  Parallel2.prototype._init = function(parallelModel, ecModel, api) {
    var dimensions = parallelModel.dimensions;
    var parallelAxisIndex = parallelModel.parallelAxisIndex;
    each$a(dimensions, function(dim, idx) {
      var axisIndex = parallelAxisIndex[idx];
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axis = this._axesMap.set(dim, new ParallelAxis$1(dim, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisIndex));
      var isCategory2 = axis.type === "category";
      axis.onBand = isCategory2 && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.coordinateSystem = axisModel.coordinateSystem = this;
    }, this);
  };
  Parallel2.prototype.update = function(ecModel, api) {
    this._updateAxesFromSeries(this._model, ecModel);
  };
  Parallel2.prototype.containPoint = function(point) {
    var layoutInfo = this._makeLayoutInfo();
    var axisBase = layoutInfo.axisBase;
    var layoutBase = layoutInfo.layoutBase;
    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var pAxis = point[1 - pixelDimIndex];
    var pLayout = point[pixelDimIndex];
    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
  };
  Parallel2.prototype.getModel = function() {
    return this._model;
  };
  Parallel2.prototype._updateAxesFromSeries = function(parallelModel, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      if (!parallelModel.contains(seriesModel, ecModel)) {
        return;
      }
      var data = seriesModel.getData();
      each$a(this.dimensions, function(dim) {
        var axis = this._axesMap.get(dim);
        axis.scale.unionExtentFromData(data, data.mapDimension(dim));
        niceScaleExtent(axis.scale, axis.model);
      }, this);
    }, this);
  };
  Parallel2.prototype.resize = function(parallelModel, api) {
    this._rect = getLayoutRect$1(parallelModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._layoutAxes();
  };
  Parallel2.prototype.getRect = function() {
    return this._rect;
  };
  Parallel2.prototype._makeLayoutInfo = function() {
    var parallelModel = this._model;
    var rect = this._rect;
    var xy = ["x", "y"];
    var wh = ["width", "height"];
    var layout2 = parallelModel.get("layout");
    var pixelDimIndex = layout2 === "horizontal" ? 0 : 1;
    var layoutLength = rect[wh[pixelDimIndex]];
    var layoutExtent = [0, layoutLength];
    var axisCount = this.dimensions.length;
    var axisExpandWidth = restrict(parallelModel.get("axisExpandWidth"), layoutExtent);
    var axisExpandCount = restrict(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
    var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
    var axisExpandWindow = parallelModel.get("axisExpandWindow");
    var winSize;
    if (!axisExpandWindow) {
      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
      var axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor(axisCount / 2);
      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    } else {
      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    }
    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
    axisCollapseWidth < 3 && (axisCollapseWidth = 0);
    var winInnerIndices = [mathFloor(round$2(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round$2(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
    return {
      layout: layout2,
      pixelDimIndex,
      layoutBase: rect[xy[pixelDimIndex]],
      layoutLength,
      axisBase: rect[xy[1 - pixelDimIndex]],
      axisLength: rect[wh[1 - pixelDimIndex]],
      axisExpandable,
      axisExpandWidth,
      axisCollapseWidth,
      axisExpandWindow,
      axisCount,
      winInnerIndices,
      axisExpandWindow0Pos
    };
  };
  Parallel2.prototype._layoutAxes = function() {
    var rect = this._rect;
    var axes = this._axesMap;
    var dimensions = this.dimensions;
    var layoutInfo = this._makeLayoutInfo();
    var layout2 = layoutInfo.layout;
    axes.each(function(axis) {
      var axisExtent = [0, layoutInfo.axisLength];
      var idx = axis.inverse ? 1 : 0;
      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
    });
    each$a(dimensions, function(dim, idx) {
      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
      var positionTable = {
        horizontal: {
          x: posInfo.position,
          y: layoutInfo.axisLength
        },
        vertical: {
          x: 0,
          y: posInfo.position
        }
      };
      var rotationTable = {
        horizontal: PI$2 / 2,
        vertical: 0
      };
      var position2 = [positionTable[layout2].x + rect.x, positionTable[layout2].y + rect.y];
      var rotation = rotationTable[layout2];
      var transform2 = create();
      rotate(transform2, transform2, rotation);
      translate$2(transform2, transform2, position2);
      this._axesLayout[dim] = {
        position: position2,
        rotation,
        transform: transform2,
        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
        axisLabelShow: posInfo.axisLabelShow,
        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
        tickDirection: 1,
        labelDirection: 1
      };
    }, this);
  };
  Parallel2.prototype.getAxis = function(dim) {
    return this._axesMap.get(dim);
  };
  Parallel2.prototype.dataToPoint = function(value, dim) {
    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
  };
  Parallel2.prototype.eachActiveState = function(data, callback, start2, end2) {
    start2 == null && (start2 = 0);
    end2 == null && (end2 = data.count());
    var axesMap = this._axesMap;
    var dimensions = this.dimensions;
    var dataDimensions = [];
    var axisModels = [];
    each$e(dimensions, function(axisDim) {
      dataDimensions.push(data.mapDimension(axisDim));
      axisModels.push(axesMap.get(axisDim).model);
    });
    var hasActiveSet = this.hasAxisBrushed();
    for (var dataIndex = start2; dataIndex < end2; dataIndex++) {
      var activeState = void 0;
      if (!hasActiveSet) {
        activeState = "normal";
      } else {
        activeState = "active";
        var values = data.getValues(dataDimensions, dataIndex);
        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
          var state = axisModels[j].getActiveState(values[j]);
          if (state === "inactive") {
            activeState = "inactive";
            break;
          }
        }
      }
      callback(activeState, dataIndex);
    }
  };
  Parallel2.prototype.hasAxisBrushed = function() {
    var dimensions = this.dimensions;
    var axesMap = this._axesMap;
    var hasActiveSet = false;
    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
      if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
        hasActiveSet = true;
      }
    }
    return hasActiveSet;
  };
  Parallel2.prototype.axisCoordToPoint = function(coord, dim) {
    var axisLayout = this._axesLayout[dim];
    return applyTransform([coord, 0], axisLayout.transform);
  };
  Parallel2.prototype.getAxisLayout = function(dim) {
    return clone$3(this._axesLayout[dim]);
  };
  Parallel2.prototype.getSlidedAxisExpandWindow = function(point) {
    var layoutInfo = this._makeLayoutInfo();
    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
    var winSize = axisExpandWindow[1] - axisExpandWindow[0];
    var extent3 = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
    if (!this.containPoint(point)) {
      return {
        behavior: "none",
        axisExpandWindow
      };
    }
    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
    var delta;
    var behavior = "slide";
    var axisCollapseWidth = layoutInfo.axisCollapseWidth;
    var triggerArea = this._model.get("axisExpandSlideTriggerArea");
    var useJump = triggerArea[0] != null;
    if (axisCollapseWidth) {
      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
        behavior = "jump";
        delta = pointCoord - winSize * triggerArea[2];
      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
        behavior = "jump";
        delta = pointCoord - winSize * (1 - triggerArea[2]);
      } else {
        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
      }
      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
      delta ? sliderMove(delta, axisExpandWindow, extent3, "all") : behavior = "none";
    } else {
      var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
      var pos = extent3[1] * pointCoord / winSize2;
      axisExpandWindow = [mathMax$2(0, pos - winSize2 / 2)];
      axisExpandWindow[1] = mathMin$2(extent3[1], axisExpandWindow[0] + winSize2);
      axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
    }
    return {
      axisExpandWindow,
      behavior
    };
  };
  return Parallel2;
}();
function restrict(len2, extent3) {
  return mathMin$2(mathMax$2(len2, extent3[0]), extent3[1]);
}
function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
  return {
    position: step * axisIndex,
    axisNameAvailableWidth: step,
    axisLabelShow: true
  };
}
function layoutAxisWithExpand(axisIndex, layoutInfo) {
  var layoutLength = layoutInfo.layoutLength;
  var axisExpandWidth = layoutInfo.axisExpandWidth;
  var axisCount = layoutInfo.axisCount;
  var axisCollapseWidth = layoutInfo.axisCollapseWidth;
  var winInnerIndices = layoutInfo.winInnerIndices;
  var position2;
  var axisNameAvailableWidth = axisCollapseWidth;
  var axisLabelShow = false;
  var nameTruncateMaxWidth;
  if (axisIndex < winInnerIndices[0]) {
    position2 = axisIndex * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  } else if (axisIndex <= winInnerIndices[1]) {
    position2 = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
    axisNameAvailableWidth = axisExpandWidth;
    axisLabelShow = true;
  } else {
    position2 = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  }
  return {
    position: position2,
    axisNameAvailableWidth,
    axisLabelShow,
    nameTruncateMaxWidth
  };
}
var Parallel$1 = Parallel;
function createParallelCoordSys(ecModel, api) {
  var coordSysList = [];
  ecModel.eachComponent("parallel", function(parallelModel, idx) {
    var coordSys = new Parallel$1(parallelModel, ecModel, api);
    coordSys.name = "parallel_" + idx;
    coordSys.resize(parallelModel, api);
    parallelModel.coordinateSystem = coordSys;
    coordSys.model = parallelModel;
    coordSysList.push(coordSys);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "parallel") {
      var parallelModel = seriesModel.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = parallelModel.coordinateSystem;
    }
  });
  return coordSysList;
}
var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
var parallelCoordSysCreator$1 = parallelCoordSysCreator;
var ParallelAxisModel = function(_super) {
  __extends(ParallelAxisModel2, _super);
  function ParallelAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelAxisModel2.type;
    _this.activeIntervals = [];
    return _this;
  }
  ParallelAxisModel2.prototype.getAreaSelectStyle = function() {
    return makeStyleMapper([
      ["fill", "color"],
      ["lineWidth", "borderWidth"],
      ["stroke", "borderColor"],
      ["width", "width"],
      ["opacity", "opacity"]
    ])(this.getModel("areaSelectStyle"));
  };
  ParallelAxisModel2.prototype.setActiveIntervals = function(intervals) {
    var activeIntervals = this.activeIntervals = clone$3(intervals);
    if (activeIntervals) {
      for (var i = activeIntervals.length - 1; i >= 0; i--) {
        asc$2(activeIntervals[i]);
      }
    }
  };
  ParallelAxisModel2.prototype.getActiveState = function(value) {
    var activeIntervals = this.activeIntervals;
    if (!activeIntervals.length) {
      return "normal";
    }
    if (value == null || isNaN(+value)) {
      return "inactive";
    }
    if (activeIntervals.length === 1) {
      var interval = activeIntervals[0];
      if (interval[0] <= value && value <= interval[1]) {
        return "active";
      }
    } else {
      for (var i = 0, len2 = activeIntervals.length; i < len2; i++) {
        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
          return "active";
        }
      }
    }
    return "inactive";
  };
  return ParallelAxisModel2;
}(ComponentModel$1);
mixin(ParallelAxisModel, AxisModelCommonMixin);
var ParallelAxisModel$1 = ParallelAxisModel;
var BRUSH_PANEL_GLOBAL = true;
var mathMin$1 = Math.min;
var mathMax$1 = Math.max;
var mathPow = Math.pow;
var COVER_Z = 1e4;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = "globalPan";
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: true,
  brushMode: "single",
  removeOnClick: false
};
var baseUID = 0;
var BrushController = function(_super) {
  __extends(BrushController2, _super);
  function BrushController2(zr) {
    var _this = _super.call(this) || this;
    _this._track = [];
    _this._covers = [];
    _this._handlers = {};
    _this._zr = zr;
    _this.group = new Group$3();
    _this._uid = "brushController_" + baseUID++;
    each$e(pointerHandlers, function(handler, eventName) {
      this._handlers[eventName] = bind$1(handler, this);
    }, _this);
    return _this;
  }
  BrushController2.prototype.enableBrush = function(brushOption) {
    this._brushType && this._doDisableBrush();
    brushOption.brushType && this._doEnableBrush(brushOption);
    return this;
  };
  BrushController2.prototype._doEnableBrush = function(brushOption) {
    var zr = this._zr;
    if (!this._enableGlobalPan) {
      take(zr, MUTEX_RESOURCE_KEY, this._uid);
    }
    each$e(this._handlers, function(handler, eventName) {
      zr.on(eventName, handler);
    });
    this._brushType = brushOption.brushType;
    this._brushOption = merge(clone$3(DEFAULT_BRUSH_OPT), brushOption, true);
  };
  BrushController2.prototype._doDisableBrush = function() {
    var zr = this._zr;
    release(zr, MUTEX_RESOURCE_KEY, this._uid);
    each$e(this._handlers, function(handler, eventName) {
      zr.off(eventName, handler);
    });
    this._brushType = this._brushOption = null;
  };
  BrushController2.prototype.setPanels = function(panelOpts) {
    if (panelOpts && panelOpts.length) {
      var panels_1 = this._panels = {};
      each$e(panelOpts, function(panelOpts2) {
        panels_1[panelOpts2.panelId] = clone$3(panelOpts2);
      });
    } else {
      this._panels = null;
    }
    return this;
  };
  BrushController2.prototype.mount = function(opt) {
    opt = opt || {};
    this._enableGlobalPan = opt.enableGlobalPan;
    var thisGroup = this.group;
    this._zr.add(thisGroup);
    thisGroup.attr({
      x: opt.x || 0,
      y: opt.y || 0,
      rotation: opt.rotation || 0,
      scaleX: opt.scaleX || 1,
      scaleY: opt.scaleY || 1
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  };
  BrushController2.prototype.updateCovers = function(coverConfigList) {
    coverConfigList = map$1(coverConfigList, function(coverConfig) {
      return merge(clone$3(DEFAULT_BRUSH_OPT), coverConfig, true);
    });
    var tmpIdPrefix = "\0-brush-index-";
    var oldCovers = this._covers;
    var newCovers = this._covers = [];
    var controller = this;
    var creatingCover = this._creatingCover;
    new DataDiffer$1(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove2).execute();
    return this;
    function getKey(brushOption, index2) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index2) + "-" + brushOption.brushType;
    }
    function oldGetKey(cover, index2) {
      return getKey(cover.__brushOption, index2);
    }
    function addOrUpdate(newIndex, oldIndex) {
      var newBrushInternal = coverConfigList[newIndex];
      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));
        updateCoverAfterCreation(controller, cover);
      }
    }
    function remove2(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  };
  BrushController2.prototype.unmount = function() {
    this.enableBrush(false);
    clearCovers(this);
    this._zr.remove(this.group);
    return this;
  };
  BrushController2.prototype.dispose = function() {
    this.unmount();
    this.off();
  };
  return BrushController2;
}(Eventful$1);
function createCover(controller, brushOption) {
  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ(cover, brushOption);
  controller.group.add(cover);
  return cover;
}
function endCreating(controller, creatingCover) {
  var coverRenderer = getCoverRenderer(creatingCover);
  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ(creatingCover, creatingCover.__brushOption);
  }
  return creatingCover;
}
function updateCoverShape(controller, cover) {
  var brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}
function updateZ(cover, brushOption) {
  var z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function(el) {
    el.z = z;
    el.z2 = z;
  });
}
function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}
function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
}
function getPanelByPoint(controller, e2, localCursorPoint) {
  var panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  var panel;
  var transform2 = controller._transform;
  each$e(panels, function(pn) {
    pn.isTargetByCursor(e2, localCursorPoint, transform2) && (panel = pn);
  });
  return panel;
}
function getPanelByCover(controller, cover) {
  var panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  var panelId = cover.__brushOption.panelId;
  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(controller) {
  var covers = controller._covers;
  var originalLength = covers.length;
  each$e(covers, function(cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}
function trigger$1(controller, opt) {
  var areas = map$1(controller._covers, function(cover) {
    var brushOption = cover.__brushOption;
    var range = clone$3(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range
    };
  });
  controller.trigger("brush", {
    areas,
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}
function shouldShowCover(controller) {
  var track = controller._track;
  if (!track.length) {
    return false;
  }
  var p2 = track[track.length - 1];
  var p1 = track[0];
  var dx = p2[0] - p1[0];
  var dy = p2[1] - p1[1];
  var dist2 = mathPow(dx * dx + dy * dy, 0.5);
  return dist2 > UNSELECT_THRESHOLD;
}
function getTrackEnds(track) {
  var tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}
function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
  var cover = new Group$3();
  cover.add(new Rect$2({
    name: "main",
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: "move",
    drift: curry$1(driftRect, rectRangeConverter, controller, cover, ["n", "s", "w", "e"]),
    ondragend: curry$1(trigger$1, controller, {
      isEnd: true
    })
  }));
  each$e(edgeNameSequences, function(nameSequence) {
    cover.add(new Rect$2({
      name: nameSequence.join(""),
      style: {
        opacity: 0
      },
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry$1(driftRect, rectRangeConverter, controller, cover, nameSequence),
      ondragend: curry$1(trigger$1, controller, {
        isEnd: true
      })
    }));
  });
  return cover;
}
function updateBaseRect(controller, cover, localRange, brushOption) {
  var lineWidth = brushOption.brushStyle.lineWidth || 0;
  var handleSize = mathMax$1(lineWidth, MIN_RESIZE_LINE_WIDTH);
  var x2 = localRange[0][0];
  var y = localRange[1][0];
  var xa = x2 - lineWidth / 2;
  var ya = y - lineWidth / 2;
  var x22 = localRange[0][1];
  var y2 = localRange[1][1];
  var x2a = x22 - handleSize + lineWidth / 2;
  var y2a = y2 - handleSize + lineWidth / 2;
  var width = x22 - x2;
  var height = y2 - y;
  var widtha = width + lineWidth;
  var heighta = height + lineWidth;
  updateRectShape(controller, cover, "main", x2, y, width, height);
  if (brushOption.transformable) {
    updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
  }
}
function updateCommon$1(controller, cover) {
  var brushOption = cover.__brushOption;
  var transformable = brushOption.transformable;
  var mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? "move" : "default"
  });
  each$e([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(nameSequence) {
    var el = cover.childOfName(nameSequence.join(""));
    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
    });
  });
}
function updateRectShape(controller, cover, name, x2, y, w2, h2) {
  var el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x2, y], [x2 + w2, y + h2]])));
}
function makeStyle(brushOption) {
  return defaults$1({
    strokeNoScale: true
  }, brushOption.brushStyle);
}
function formatRectRange(x2, y, x22, y2) {
  var min3 = [mathMin$1(x2, x22), mathMin$1(y, y2)];
  var max3 = [mathMax$1(x2, x22), mathMax$1(y, y2)];
  return [
    [min3[0], max3[0]],
    [min3[1], max3[1]]
  ];
}
function getTransform(controller) {
  return getTransform$1(controller.group);
}
function getGlobalDirection1(controller, localDirName) {
  var map2 = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  };
  var inverseMap = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  };
  var dir3 = transformDirection(map2[localDirName], getTransform(controller));
  return inverseMap[dir3];
}
function getGlobalDirection2(controller, localDirNameSeq) {
  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];
  (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
  return globalDir.join("");
}
function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
  var brushOption = cover.__brushOption;
  var rectRange = rectRangeConverter.toRectRange(brushOption.range);
  var localDelta = toLocalDelta(controller, dx, dy);
  each$e(dirNameSequence, function(dirName) {
    var ind = DIRECTION_MAP[dirName];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger$1(controller, {
    isEnd: false
  });
}
function driftPolygon(controller, cover, dx, dy) {
  var range = cover.__brushOption.range;
  var localDelta = toLocalDelta(controller, dx, dy);
  each$e(range, function(point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger$1(controller, {
    isEnd: false
  });
}
function toLocalDelta(controller, dx, dy) {
  var thisGroup = controller.group;
  var localD = thisGroup.transformCoordToLocal(dx, dy);
  var localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}
function clipByPanel(controller, cover, data) {
  var panel = getPanelByCover(controller, cover);
  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone$3(data);
}
function pointsToRect(points2) {
  var xmin = mathMin$1(points2[0][0], points2[1][0]);
  var ymin = mathMin$1(points2[0][1], points2[1][1]);
  var xmax = mathMax$1(points2[0][0], points2[1][0]);
  var ymax = mathMax$1(points2[0][1], points2[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}
function resetCursor(controller, e2, localCursorPoint) {
  if (!controller._brushType || isOutsideZrArea(controller, e2.offsetX, e2.offsetY)) {
    return;
  }
  var zr = controller._zr;
  var covers = controller._covers;
  var currPanel = getPanelByPoint(controller, e2, localCursorPoint);
  if (!controller._dragging) {
    for (var i = 0; i < covers.length; i++) {
      var brushOption = covers[i].__brushOption;
      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        return;
      }
    }
  }
  currPanel && zr.setCursorStyle("crosshair");
}
function preventDefault(e2) {
  var rawE = e2.event;
  rawE.preventDefault && rawE.preventDefault();
}
function mainShapeContain(cover, x2, y) {
  return cover.childOfName("main").contain(x2, y);
}
function updateCoverByMouse(controller, e2, localCursorPoint, isEnd) {
  var creatingCover = controller._creatingCover;
  var panel = controller._creatingPanel;
  var thisBrushOption = controller._brushOption;
  var eventParams;
  controller._track.push(localCursorPoint.slice());
  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === "single" && clearCovers(controller);
      var brushOption = clone$3(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);
      controller._covers.push(creatingCover);
    }
    if (creatingCover) {
      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      var coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }
      updateCoverShape(controller, creatingCover);
      eventParams = {
        isEnd
      };
    }
  } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
    if (getPanelByPoint(controller, e2, localCursorPoint) && clearCovers(controller)) {
      eventParams = {
        isEnd,
        removeOnClick: true
      };
    }
  }
  return eventParams;
}
function determineBrushType(brushType, panel) {
  if (brushType === "auto") {
    return panel.defaultBrushType;
  }
  return brushType;
}
var pointerHandlers = {
  mousedown: function(e2) {
    if (this._dragging) {
      handleDragEnd(this, e2);
    } else if (!e2.target || !e2.target.draggable) {
      preventDefault(e2);
      var localCursorPoint = this.group.transformCoordToLocal(e2.offsetX, e2.offsetY);
      this._creatingCover = null;
      var panel = this._creatingPanel = getPanelByPoint(this, e2, localCursorPoint);
      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function(e2) {
    var x2 = e2.offsetX;
    var y = e2.offsetY;
    var localCursorPoint = this.group.transformCoordToLocal(x2, y);
    resetCursor(this, e2, localCursorPoint);
    if (this._dragging) {
      preventDefault(e2);
      var eventParams = updateCoverByMouse(this, e2, localCursorPoint, false);
      eventParams && trigger$1(this, eventParams);
    }
  },
  mouseup: function(e2) {
    handleDragEnd(this, e2);
  }
};
function handleDragEnd(controller, e2) {
  if (controller._dragging) {
    preventDefault(e2);
    var x2 = e2.offsetX;
    var y = e2.offsetY;
    var localCursorPoint = controller.group.transformCoordToLocal(x2, y);
    var eventParams = updateCoverByMouse(controller, e2, localCursorPoint, true);
    controller._dragging = false;
    controller._track = [];
    controller._creatingCover = null;
    eventParams && trigger$1(controller, eventParams);
  }
}
function isOutsideZrArea(controller, x2, y) {
  var zr = controller._zr;
  return x2 < 0 || x2 > zr.getWidth() || y < 0 || y > zr.getHeight();
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function(controller, brushOption) {
      function returnInput(range) {
        return range;
      }
      return createBaseRectCover({
        toRectRange: returnInput,
        fromRectRange: returnInput
      }, controller, brushOption, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(localTrack) {
      var ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function(controller, brushOption) {
      var cover = new Group$3();
      cover.add(new Polyline$1({
        name: "main",
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function(localTrack) {
      return localTrack;
    },
    endCreating: function(controller, cover) {
      cover.remove(cover.childAt(0));
      cover.add(new Polygon$1({
        name: "main",
        draggable: true,
        drift: curry$1(driftPolygon, controller, cover),
        ondragend: curry$1(trigger$1, controller, {
          isEnd: true
        })
      }));
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  }
};
function getLineRenderer(xyIndex) {
  return {
    createCover: function(controller, brushOption) {
      return createBaseRectCover({
        toRectRange: function(range) {
          var rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        },
        fromRectRange: function(rectRange) {
          return rectRange[xyIndex];
        }
      }, controller, brushOption, [[["w"], ["e"]], [["n"], ["s"]]][xyIndex]);
    },
    getCreatingRange: function(localTrack) {
      var ends = getTrackEnds(localTrack);
      var min3 = mathMin$1(ends[0][xyIndex], ends[1][xyIndex]);
      var max3 = mathMax$1(ends[0][xyIndex], ends[1][xyIndex]);
      return [min3, max3];
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      var otherExtent;
      var panel = getPanelByCover(controller, cover);
      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
      } else {
        var zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }
      var rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  };
}
var BrushController$1 = BrushController;
function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function(localPoints) {
    return clipPointsByRect(localPoints, rect);
  };
}
function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function(xyIndex) {
    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    var brushWidth = idx ? rect.width : rect.height;
    var base2 = idx ? rect.x : rect.y;
    return [base2, base2 + (brushWidth || 0)];
  };
}
function makeRectIsTargetByCursor(rect, api, targetModel) {
  var boundingRect = normalizeRect(rect);
  return function(e2, localCursorPoint) {
    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e2, api, targetModel);
  };
}
function normalizeRect(rect) {
  return BoundingRect$1.create(rect);
}
var elementList$1 = ["axisLine", "axisTickLabel", "axisName"];
var ParallelAxisView = function(_super) {
  __extends(ParallelAxisView2, _super);
  function ParallelAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelAxisView2.type;
    return _this;
  }
  ParallelAxisView2.prototype.init = function(ecModel, api) {
    _super.prototype.init.apply(this, arguments);
    (this._brushController = new BrushController$1(api.getZr())).on("brush", bind$1(this._onBrush, this));
  };
  ParallelAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
      return;
    }
    this.axisModel = axisModel;
    this.api = api;
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$3();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var coordSysModel = getCoordSysModel(axisModel, ecModel);
    var coordSys = coordSysModel.coordinateSystem;
    var areaSelectStyle = axisModel.getAreaSelectStyle();
    var areaWidth = areaSelectStyle.width;
    var dim = axisModel.axis.dim;
    var axisLayout = coordSys.getAxisLayout(dim);
    var builderOpt = extend$3({
      strokeContainThreshold: areaWidth
    }, axisLayout);
    var axisBuilder = new AxisBuilder$1(axisModel, builderOpt);
    each$e(elementList$1, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
  };
  ParallelAxisView2.prototype._refreshBrushController = function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
    var extent3 = axisModel.axis.getExtent();
    var extentLen = extent3[1] - extent3[0];
    var extra = Math.min(30, Math.abs(extentLen) * 0.1);
    var rect = BoundingRect$1.create({
      x: extent3[0],
      y: -areaWidth / 2,
      width: extentLen,
      height: areaWidth
    });
    rect.x -= extra;
    rect.width += 2 * extra;
    this._brushController.mount({
      enableGlobalPan: true,
      rotation: builderOpt.rotation,
      x: builderOpt.position[0],
      y: builderOpt.position[1]
    }).setPanels([{
      panelId: "pl",
      clipPath: makeRectPanelClipPath(rect),
      isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),
      getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
    }]).enableBrush({
      brushType: "lineX",
      brushStyle: areaSelectStyle,
      removeOnClick: true
    }).updateCovers(getCoverInfoList(axisModel));
  };
  ParallelAxisView2.prototype._onBrush = function(eventParam) {
    var coverInfoList = eventParam.areas;
    var axisModel = this.axisModel;
    var axis = axisModel.axis;
    var intervals = map$1(coverInfoList, function(coverInfo) {
      return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
    });
    if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
      this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: axisModel.id,
        intervals
      });
    }
  };
  ParallelAxisView2.prototype.dispose = function() {
    this._brushController.dispose();
  };
  ParallelAxisView2.type = "parallelAxis";
  return ParallelAxisView2;
}(ComponentView$1);
function fromAxisAreaSelect(axisModel, ecModel, payload) {
  return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
    mainType: "parallelAxis",
    query: payload
  })[0] === axisModel;
}
function getCoverInfoList(axisModel) {
  var axis = axisModel.axis;
  return map$1(axisModel.activeIntervals, function(interval) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
    };
  });
}
function getCoordSysModel(axisModel, ecModel) {
  return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
}
var ParallelAxisView$1 = ParallelAxisView;
var actionInfo = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
};
function installParallelActions(registers) {
  registers.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallelAxis",
      query: payload
    }, function(parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  registers.registerAction("parallelAxisExpand", function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallel",
      query: payload
    }, function(parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
}
var defaultAxisOption = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: true,
  z: 10
};
function install$m(registers) {
  registers.registerComponentView(ParallelView$1);
  registers.registerComponentModel(ParallelModel$1);
  registers.registerCoordinateSystem("parallel", parallelCoordSysCreator$1);
  registers.registerPreprocessor(parallelPreprocessor);
  registers.registerComponentModel(ParallelAxisModel$1);
  registers.registerComponentView(ParallelAxisView$1);
  axisModelCreator(registers, "parallel", ParallelAxisModel$1, defaultAxisOption);
  installParallelActions(registers);
}
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
var LAYOUT_ATTRS = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}];
var pathForLineWidth = new Circle$1();
var PictorialBarView = function(_super) {
  __extends(PictorialBarView2, _super);
  function PictorialBarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PictorialBarView2.type;
    return _this;
  }
  PictorialBarView2.prototype.render = function(seriesModel, ecModel, api) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var coordSysRect = cartesian.master.getRect();
    var opt = {
      ecSize: {
        width: api.getWidth(),
        height: api.getHeight()
      },
      seriesModel,
      coordSys: cartesian,
      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
      isHorizontal,
      valueDim: LAYOUT_ATTRS[+isHorizontal],
      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
    };
    data.diff(oldData).add(function(dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }
      var itemModel = getItemModel(data, dataIndex);
      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
      var bar = createBar(data, opt, symbolMeta);
      data.setItemGraphicEl(dataIndex, bar);
      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).update(function(newIndex, oldIndex) {
      var bar = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex)) {
        group.remove(bar);
        return;
      }
      var itemModel = getItemModel(data, newIndex);
      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
      var pictorialShapeStr = getShapeStr(data, symbolMeta);
      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
        group.remove(bar);
        data.setItemGraphicEl(newIndex, null);
        bar = null;
      }
      if (bar) {
        updateBar(bar, opt, symbolMeta);
      } else {
        bar = createBar(data, opt, symbolMeta, true);
      }
      data.setItemGraphicEl(newIndex, bar);
      bar.__pictorialSymbolMeta = symbolMeta;
      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).remove(function(dataIndex) {
      var bar = oldData.getItemGraphicEl(dataIndex);
      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
    }).execute();
    this._data = data;
    return this.group;
  };
  PictorialBarView2.prototype.remove = function(ecModel, api) {
    var group = this.group;
    var data = this._data;
    if (ecModel.get("animation")) {
      if (data) {
        data.eachItemGraphicEl(function(bar) {
          removeBar(data, getECData(bar).dataIndex, ecModel, bar);
        });
      }
    } else {
      group.removeAll();
    }
  };
  PictorialBarView2.type = "pictorialBar";
  return PictorialBarView2;
}(ChartView$1);
function getSymbolMeta(data, dataIndex, itemModel, opt) {
  var layout2 = data.getItemLayout(dataIndex);
  var symbolRepeat = itemModel.get("symbolRepeat");
  var symbolClip = itemModel.get("symbolClip");
  var symbolPosition = itemModel.get("symbolPosition") || "start";
  var symbolRotate = itemModel.get("symbolRotate");
  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
  var isAnimationEnabled2 = itemModel.isAnimationEnabled();
  var symbolMeta = {
    dataIndex,
    layout: layout2,
    itemModel,
    symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
    style: data.getItemVisual(dataIndex, "style"),
    symbolClip,
    symbolRepeat,
    symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
    symbolPatternSize,
    rotation,
    animationModel: isAnimationEnabled2 ? itemModel : null,
    hoverScale: isAnimationEnabled2 && itemModel.get(["emphasis", "scale"]),
    z2: itemModel.getShallow("z", true) || 0
  };
  prepareBarLength(itemModel, symbolRepeat, layout2, opt, symbolMeta);
  prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
  var symbolSize = symbolMeta.symbolSize;
  var symbolOffset = normalizeSymbolOffset(itemModel.get("symbolOffset"), symbolSize);
  prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
  return symbolMeta;
}
function prepareBarLength(itemModel, symbolRepeat, layout2, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var symbolBoundingData = itemModel.get("symbolBoundingData");
  var valueAxis2 = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
  var zeroPx = valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(0));
  var pxSignIdx = 1 - +(layout2[valueDim.wh] <= 0);
  var boundingLength;
  if (isArray$4(symbolBoundingData)) {
    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis2, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis2, symbolBoundingData[1]) - zeroPx];
    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
    boundingLength = symbolBoundingExtent[pxSignIdx];
  } else if (symbolBoundingData != null) {
    boundingLength = convertToCoordOnAxis(valueAxis2, symbolBoundingData) - zeroPx;
  } else if (symbolRepeat) {
    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
  } else {
    boundingLength = layout2[valueDim.wh];
  }
  outputSymbolMeta.boundingLength = boundingLength;
  if (symbolRepeat) {
    outputSymbolMeta.repeatCutLength = layout2[valueDim.wh];
  }
  outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : -1;
}
function convertToCoordOnAxis(axis, value) {
  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
}
function prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var categoryDim = opt.categoryDim;
  var categorySize = Math.abs(layout2[categoryDim.wh]);
  var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
  var parsedSymbolSize;
  if (isArray$4(symbolSize)) {
    parsedSymbolSize = symbolSize.slice();
  } else {
    if (symbolSize == null) {
      parsedSymbolSize = ["100%", "100%"];
    } else {
      parsedSymbolSize = [symbolSize, symbolSize];
    }
  }
  parsedSymbolSize[categoryDim.index] = parsePercent(parsedSymbolSize[categoryDim.index], categorySize);
  parsedSymbolSize[valueDim.index] = parsePercent(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
  outputSymbolMeta.symbolSize = parsedSymbolSize;
  var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize];
  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
}
function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  if (valueLineWidth) {
    pathForLineWidth.attr({
      scaleX: symbolScale[0],
      scaleY: symbolScale[1],
      rotation
    });
    pathForLineWidth.updateTransform();
    valueLineWidth /= pathForLineWidth.getLineScale();
    valueLineWidth *= symbolScale[opt.valueDim.index];
  }
  outputSymbolMeta.valueLineWidth = valueLineWidth || 0;
}
function prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
  var categoryDim = opt.categoryDim;
  var valueDim = opt.valueDim;
  var pxSign = outputSymbolMeta.pxSign;
  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
  var pathLen = unitLength;
  if (symbolRepeat) {
    var absBoundingLength = Math.abs(boundingLength);
    var symbolMargin = retrieve(itemModel.get("symbolMargin"), "15%") + "";
    var hasEndGap = false;
    if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
      hasEndGap = true;
      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
    }
    var symbolMarginNumeric = parsePercent(symbolMargin, symbolSize[valueDim.index]);
    var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);
    var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    var repeatSpecified = isNumeric(symbolRepeat);
    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
    var mDiff = absBoundingLength - repeatTimes * unitLength;
    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));
    uLenWithMargin = unitLength + symbolMarginNumeric * 2;
    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    if (!repeatSpecified && symbolRepeat !== "fixed") {
      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
    }
    pathLen = repeatTimes * uLenWithMargin - endFix;
    outputSymbolMeta.repeatTimes = repeatTimes;
    outputSymbolMeta.symbolMargin = symbolMarginNumeric;
  }
  var sizeFix = pxSign * (pathLen / 2);
  var pathPosition = outputSymbolMeta.pathPosition = [];
  pathPosition[categoryDim.index] = layout2[categoryDim.wh] / 2;
  pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
  if (symbolOffset) {
    pathPosition[0] += symbolOffset[0];
    pathPosition[1] += symbolOffset[1];
  }
  var bundlePosition = outputSymbolMeta.bundlePosition = [];
  bundlePosition[categoryDim.index] = layout2[categoryDim.xy];
  bundlePosition[valueDim.index] = layout2[valueDim.xy];
  var barRectShape = outputSymbolMeta.barRectShape = extend$3({}, layout2);
  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout2[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
  barRectShape[categoryDim.wh] = layout2[categoryDim.wh];
  var clipShape = outputSymbolMeta.clipShape = {};
  clipShape[categoryDim.xy] = -layout2[categoryDim.xy];
  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
  clipShape[valueDim.xy] = 0;
  clipShape[valueDim.wh] = layout2[valueDim.wh];
}
function createPath(symbolMeta) {
  var symbolPatternSize = symbolMeta.symbolPatternSize;
  var path = createSymbol(symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);
  path.attr({
    culling: true
  });
  path.type !== "image" && path.setStyle({
    strokeNoScale: true
  });
  return path;
}
function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var symbolSize = symbolMeta.symbolSize;
  var valueLineWidth = symbolMeta.valueLineWidth;
  var pathPosition = symbolMeta.pathPosition;
  var valueDim = opt.valueDim;
  var repeatTimes = symbolMeta.repeatTimes || 0;
  var index2 = 0;
  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
  eachPath(bar, function(path2) {
    path2.__pictorialAnimationIndex = index2;
    path2.__pictorialRepeatTimes = repeatTimes;
    if (index2 < repeatTimes) {
      updateAttr(path2, null, makeTarget(index2), symbolMeta, isUpdate);
    } else {
      updateAttr(path2, null, {
        scaleX: 0,
        scaleY: 0
      }, symbolMeta, isUpdate, function() {
        bundle.remove(path2);
      });
    }
    index2++;
  });
  for (; index2 < repeatTimes; index2++) {
    var path = createPath(symbolMeta);
    path.__pictorialAnimationIndex = index2;
    path.__pictorialRepeatTimes = repeatTimes;
    bundle.add(path);
    var target = makeTarget(index2);
    updateAttr(path, {
      x: target.x,
      y: target.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: target.scaleX,
      scaleY: target.scaleY,
      rotation: target.rotation
    }, symbolMeta, isUpdate);
  }
  function makeTarget(index3) {
    var position2 = pathPosition.slice();
    var pxSign = symbolMeta.pxSign;
    var i = index3;
    if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
      i = repeatTimes - 1 - index3;
    }
    position2[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
    return {
      x: position2[0],
      y: position2[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    };
  }
}
function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var mainPath = bar.__pictorialMainPath;
  if (!mainPath) {
    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
    bundle.add(mainPath);
    updateAttr(mainPath, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: symbolMeta.rotation
    }, {
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1]
    }, symbolMeta, isUpdate);
  } else {
    updateAttr(mainPath, null, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
  var rectShape = extend$3({}, symbolMeta.barRectShape);
  var barRect = bar.__pictorialBarRect;
  if (!barRect) {
    barRect = bar.__pictorialBarRect = new Rect$2({
      z2: 2,
      shape: rectShape,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    });
    barRect.disableMorphing = true;
    bar.add(barRect);
  } else {
    updateAttr(barRect, null, {
      shape: rectShape
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
  if (symbolMeta.symbolClip) {
    var clipPath = bar.__pictorialClipPath;
    var clipShape = extend$3({}, symbolMeta.clipShape);
    var valueDim = opt.valueDim;
    var animationModel = symbolMeta.animationModel;
    var dataIndex = symbolMeta.dataIndex;
    if (clipPath) {
      updateProps$1(clipPath, {
        shape: clipShape
      }, animationModel, dataIndex);
    } else {
      clipShape[valueDim.wh] = 0;
      clipPath = new Rect$2({
        shape: clipShape
      });
      bar.__pictorialBundle.setClipPath(clipPath);
      bar.__pictorialClipPath = clipPath;
      var target = {};
      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
      graphic$1[isUpdate ? "updateProps" : "initProps"](clipPath, {
        shape: target
      }, animationModel, dataIndex);
    }
  }
}
function getItemModel(data, dataIndex) {
  var itemModel = data.getItemModel(dataIndex);
  itemModel.getAnimationDelayParams = getAnimationDelayParams;
  itemModel.isAnimationEnabled = isAnimationEnabled;
  return itemModel;
}
function getAnimationDelayParams(path) {
  return {
    index: path.__pictorialAnimationIndex,
    count: path.__pictorialRepeatTimes
  };
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(data, opt, symbolMeta, isUpdate) {
  var bar = new Group$3();
  var bundle = new Group$3();
  bar.add(bundle);
  bar.__pictorialBundle = bundle;
  bundle.x = symbolMeta.bundlePosition[0];
  bundle.y = symbolMeta.bundlePosition[1];
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta);
  }
  createOrUpdateBarRect(bar, symbolMeta, isUpdate);
  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
  bar.__pictorialSymbolMeta = symbolMeta;
  return bar;
}
function updateBar(bar, opt, symbolMeta) {
  var animationModel = symbolMeta.animationModel;
  var dataIndex = symbolMeta.dataIndex;
  var bundle = bar.__pictorialBundle;
  updateProps$1(bundle, {
    x: symbolMeta.bundlePosition[0],
    y: symbolMeta.bundlePosition[1]
  }, animationModel, dataIndex);
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
  }
  createOrUpdateBarRect(bar, symbolMeta, true);
  createOrUpdateClip(bar, opt, symbolMeta, true);
}
function removeBar(data, dataIndex, animationModel, bar) {
  var labelRect = bar.__pictorialBarRect;
  labelRect && labelRect.removeTextContent();
  var pathes = [];
  eachPath(bar, function(path) {
    pathes.push(path);
  });
  bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath);
  bar.__pictorialClipPath && (animationModel = null);
  each$e(pathes, function(path) {
    removeElement(path, {
      scaleX: 0,
      scaleY: 0
    }, animationModel, dataIndex, function() {
      bar.parent && bar.parent.remove(bar);
    });
  });
  data.setItemGraphicEl(dataIndex, null);
}
function getShapeStr(data, symbolMeta) {
  return [data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none", !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(":");
}
function eachPath(bar, cb, context) {
  each$e(bar.__pictorialBundle.children(), function(el) {
    el !== bar.__pictorialBarRect && cb.call(context, el);
  });
}
function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
  immediateAttrs && el.attr(immediateAttrs);
  if (symbolMeta.symbolClip && !isUpdate) {
    animationAttrs && el.attr(animationAttrs);
  } else {
    animationAttrs && graphic$1[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
  }
}
function updateCommon(bar, opt, symbolMeta) {
  var dataIndex = symbolMeta.dataIndex;
  var itemModel = symbolMeta.itemModel;
  var emphasisModel = itemModel.getModel("emphasis");
  var emphasisStyle = emphasisModel.getModel("itemStyle").getItemStyle();
  var blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
  var selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
  var cursorStyle = itemModel.getShallow("cursor");
  var focus = emphasisModel.get("focus");
  var blurScope = emphasisModel.get("blurScope");
  var hoverScale = emphasisModel.get("scale");
  eachPath(bar, function(path) {
    if (path instanceof ZRImage$1) {
      var pathStyle = path.style;
      path.useStyle(extend$3({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolMeta.style));
    } else {
      path.useStyle(symbolMeta.style);
    }
    var emphasisState = path.ensureState("emphasis");
    emphasisState.style = emphasisStyle;
    if (hoverScale) {
      emphasisState.scaleX = path.scaleX * 1.1;
      emphasisState.scaleY = path.scaleY * 1.1;
    }
    path.ensureState("blur").style = blurStyle;
    path.ensureState("select").style = selectStyle;
    cursorStyle && (path.cursor = cursorStyle);
    path.z2 = symbolMeta.z2;
  });
  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
  var barRect = bar.__pictorialBarRect;
  setLabelStyle(barRect, getLabelStatesModels(itemModel), {
    labelFetcher: opt.seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
    inheritColor: symbolMeta.style.fill,
    defaultOpacity: symbolMeta.style.opacity,
    defaultOutsidePosition: barPositionOutside
  });
  toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get("disabled"));
}
function toIntTimes(times) {
  var roundedTimes = Math.round(times);
  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
}
var PictorialBarView$1 = PictorialBarView;
var PictorialBarSeriesModel = function(_super) {
  __extends(PictorialBarSeriesModel2, _super);
  function PictorialBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PictorialBarSeriesModel2.type;
    _this.hasSymbolVisual = true;
    _this.defaultSymbol = "roundRect";
    return _this;
  }
  PictorialBarSeriesModel2.prototype.getInitialData = function(option) {
    option.stack = null;
    return _super.prototype.getInitialData.apply(this, arguments);
  };
  PictorialBarSeriesModel2.type = "series.pictorialBar";
  PictorialBarSeriesModel2.dependencies = ["grid"];
  PictorialBarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    symbol: "circle",
    symbolSize: null,
    symbolRotate: null,
    symbolPosition: null,
    symbolOffset: null,
    symbolMargin: null,
    symbolRepeat: false,
    symbolRepeatDirection: "end",
    symbolClip: false,
    symbolBoundingData: null,
    symbolPatternSize: 400,
    barGap: "-100%",
    progressive: 0,
    emphasis: {
      scale: false
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  });
  return PictorialBarSeriesModel2;
}(BaseBarSeriesModel$1);
var PictorialBarSeriesModel$1 = PictorialBarSeriesModel;
function install$l(registers) {
  registers.registerChartView(PictorialBarView$1);
  registers.registerSeriesModel(PictorialBarSeriesModel$1);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$2, "pictorialBar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}
function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
  return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn$1(style, "text")));
}
function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
  var srcStyle = hostStyle;
  var textConfig;
  var textContent;
  var textContentStyle;
  if (elType === "text") {
    textContentStyle = srcStyle;
  } else {
    textContentStyle = {};
    hasOwn$1(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
    hasOwn$1(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
    hasOwn$1(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
    hasOwn$1(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
    hasOwn$1(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
    hasOwn$1(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
    hasOwn$1(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
    hasOwn$1(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
    textContent = {
      type: "text",
      style: textContentStyle,
      silent: true
    };
    textConfig = {};
    var hasOwnPos = hasOwn$1(srcStyle, "textPosition");
    if (isNormal) {
      textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
    } else {
      hasOwnPos && (textConfig.position = srcStyle.textPosition);
    }
    hasOwn$1(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
    hasOwn$1(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
    hasOwn$1(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
    hasOwn$1(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
  }
  convertEC4CompatibleRichItem(textContentStyle, hostStyle);
  each$e(textContentStyle.rich, function(richItem) {
    convertEC4CompatibleRichItem(richItem, richItem);
  });
  return {
    textConfig,
    textContent
  };
}
function convertEC4CompatibleRichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  richItem.font = richItem.textFont || richItem.font;
  hasOwn$1(richItem, "textStrokeWidth") && (out2.lineWidth = richItem.textStrokeWidth);
  hasOwn$1(richItem, "textAlign") && (out2.align = richItem.textAlign);
  hasOwn$1(richItem, "textVerticalAlign") && (out2.verticalAlign = richItem.textVerticalAlign);
  hasOwn$1(richItem, "textLineHeight") && (out2.lineHeight = richItem.textLineHeight);
  hasOwn$1(richItem, "textWidth") && (out2.width = richItem.textWidth);
  hasOwn$1(richItem, "textHeight") && (out2.height = richItem.textHeight);
  hasOwn$1(richItem, "textBackgroundColor") && (out2.backgroundColor = richItem.textBackgroundColor);
  hasOwn$1(richItem, "textPadding") && (out2.padding = richItem.textPadding);
  hasOwn$1(richItem, "textBorderColor") && (out2.borderColor = richItem.textBorderColor);
  hasOwn$1(richItem, "textBorderWidth") && (out2.borderWidth = richItem.textBorderWidth);
  hasOwn$1(richItem, "textBorderRadius") && (out2.borderRadius = richItem.textBorderRadius);
  hasOwn$1(richItem, "textBoxShadowColor") && (out2.shadowColor = richItem.textBoxShadowColor);
  hasOwn$1(richItem, "textBoxShadowBlur") && (out2.shadowBlur = richItem.textBoxShadowBlur);
  hasOwn$1(richItem, "textBoxShadowOffsetX") && (out2.shadowOffsetX = richItem.textBoxShadowOffsetX);
  hasOwn$1(richItem, "textBoxShadowOffsetY") && (out2.shadowOffsetY = richItem.textBoxShadowOffsetY);
}
var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
};
var LEGACY_TRANSFORM_PROPS = keys$1(LEGACY_TRANSFORM_PROPS_MAP);
reduce(TRANSFORMABLE_PROPS, function(obj, key2) {
  obj[key2] = 1;
  return obj;
}, {});
TRANSFORMABLE_PROPS.join(", ");
var ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"];
var transitionInnerStore = makeInner();
function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
  var animationProp = animationType + "Animation";
  var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
  var userDuring = transitionInnerStore(el).userDuring;
  if (config.duration > 0) {
    config.during = userDuring ? bind$1(duringCall, {
      el,
      userDuring
    }) : null;
    config.setToFinal = true;
    config.scope = animationType;
  }
  extend$3(config, elOption[animationProp]);
  return config;
}
function applyUpdateTransition(el, elOption, animatableModel, opts) {
  opts = opts || {};
  var dataIndex = opts.dataIndex, isInit = opts.isInit, clearStyle = opts.clearStyle;
  var hasAnimation = animatableModel.isAnimationEnabled();
  var store = transitionInnerStore(el);
  var styleOpt = elOption.style;
  store.userDuring = elOption.during;
  var transFromProps = {};
  var propsToSet = {};
  prepareTransformAllPropsFinal(el, elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
  if (!isInit && hasAnimation) {
    prepareTransformTransitionFrom(el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
  }
  propsToSet.style = styleOpt;
  applyPropsDirectly(el, propsToSet, clearStyle);
  applyMiscProps(el, elOption);
  if (hasAnimation) {
    if (isInit) {
      var enterFromProps_1 = {};
      each$e(ELEMENT_ANIMATABLE_PROPS, function(propName) {
        var prop = propName ? elOption[propName] : elOption;
        if (prop && prop.enterFrom) {
          if (propName) {
            enterFromProps_1[propName] = enterFromProps_1[propName] || {};
          }
          extend$3(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);
        }
      });
      var config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
      if (config.duration > 0) {
        el.animateFrom(enterFromProps_1, config);
      }
    } else {
      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
    }
  }
  updateLeaveTo(el, elOption);
  styleOpt ? el.dirty() : el.markRedraw();
}
function updateLeaveTo(el, elOption) {
  var leaveToProps = transitionInnerStore(el).leaveToProps;
  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
    var propName = ELEMENT_ANIMATABLE_PROPS[i];
    var prop = propName ? elOption[propName] : elOption;
    if (prop && prop.leaveTo) {
      if (!leaveToProps) {
        leaveToProps = transitionInnerStore(el).leaveToProps = {};
      }
      if (propName) {
        leaveToProps[propName] = leaveToProps[propName] || {};
      }
      extend$3(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
    }
  }
}
function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
  if (el) {
    var parent_1 = el.parent;
    var leaveToProps = transitionInnerStore(el).leaveToProps;
    if (leaveToProps) {
      var config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
      config.done = function() {
        parent_1.remove(el);
        onRemove && onRemove();
      };
      el.animateTo(leaveToProps, config);
    } else {
      parent_1.remove(el);
      onRemove && onRemove();
    }
  }
}
function isTransitionAll(transition2) {
  return transition2 === "all";
}
function applyPropsDirectly(el, allPropsFinal, clearStyle) {
  var styleOpt = allPropsFinal.style;
  if (!el.isGroup && styleOpt) {
    if (clearStyle) {
      el.useStyle({});
      var animators = el.animators;
      for (var i = 0; i < animators.length; i++) {
        var animator = animators[i];
        if (animator.targetName === "style") {
          animator.changeTarget(el.style);
        }
      }
    }
    el.setStyle(styleOpt);
  }
  if (allPropsFinal) {
    allPropsFinal.style = null;
    allPropsFinal && el.attr(allPropsFinal);
    allPropsFinal.style = styleOpt;
  }
}
function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
  if (transFromProps) {
    var config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
    if (config.duration > 0) {
      el.animateFrom(transFromProps, config);
    }
  }
}
function applyMiscProps(el, elOption) {
  hasOwn$1(elOption, "silent") && (el.silent = elOption.silent);
  hasOwn$1(elOption, "ignore") && (el.ignore = elOption.ignore);
  if (el instanceof Displayable$1) {
    hasOwn$1(elOption, "invisible") && (el.invisible = elOption.invisible);
  }
  if (el instanceof Path$1) {
    hasOwn$1(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
  }
}
var tmpDuringScope = {};
var transitionDuringAPI = {
  setTransform: function(key2, val) {
    tmpDuringScope.el[key2] = val;
    return this;
  },
  getTransform: function(key2) {
    return tmpDuringScope.el[key2];
  },
  setShape: function(key2, val) {
    var el = tmpDuringScope.el;
    var shape = el.shape || (el.shape = {});
    shape[key2] = val;
    el.dirtyShape && el.dirtyShape();
    return this;
  },
  getShape: function(key2) {
    var shape = tmpDuringScope.el.shape;
    if (shape) {
      return shape[key2];
    }
  },
  setStyle: function(key2, val) {
    var el = tmpDuringScope.el;
    var style = el.style;
    if (style) {
      style[key2] = val;
      el.dirtyStyle && el.dirtyStyle();
    }
    return this;
  },
  getStyle: function(key2) {
    var style = tmpDuringScope.el.style;
    if (style) {
      return style[key2];
    }
  },
  setExtra: function(key2, val) {
    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    extra[key2] = val;
    return this;
  },
  getExtra: function(key2) {
    var extra = tmpDuringScope.el.extra;
    if (extra) {
      return extra[key2];
    }
  }
};
function duringCall() {
  var scope = this;
  var el = scope.el;
  if (!el) {
    return;
  }
  var latestUserDuring = transitionInnerStore(el).userDuring;
  var scopeUserDuring = scope.userDuring;
  if (latestUserDuring !== scopeUserDuring) {
    scope.el = scope.userDuring = null;
    return;
  }
  tmpDuringScope.el = el;
  scopeUserDuring(transitionDuringAPI);
}
function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
  var attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  var elPropsInAttr = fromEl[mainAttr];
  var transFromPropsInAttr;
  if (elPropsInAttr) {
    var transition2 = elOption.transition;
    var attrTransition = attrOpt.transition;
    if (attrTransition) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      if (isTransitionAll(attrTransition)) {
        extend$3(transFromPropsInAttr, elPropsInAttr);
      } else {
        var transitionKeys = normalizeToArray(attrTransition);
        for (var i = 0; i < transitionKeys.length; i++) {
          var key2 = transitionKeys[i];
          var elVal = elPropsInAttr[key2];
          transFromPropsInAttr[key2] = elVal;
        }
      }
    } else if (isTransitionAll(transition2) || indexOf(transition2, mainAttr) >= 0) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      var elPropsInAttrKeys = keys$1(elPropsInAttr);
      for (var i = 0; i < elPropsInAttrKeys.length; i++) {
        var key2 = elPropsInAttrKeys[i];
        var elVal = elPropsInAttr[key2];
        if (isNonStyleTransitionEnabled(attrOpt[key2], elVal)) {
          transFromPropsInAttr[key2] = elVal;
        }
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
  var attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  var allPropsInAttr = allProps[mainAttr] = {};
  var keysInAttr = keys$1(attrOpt);
  for (var i = 0; i < keysInAttr.length; i++) {
    var key2 = keysInAttr[i];
    allPropsInAttr[key2] = cloneValue(attrOpt[key2]);
  }
}
function prepareTransformTransitionFrom(el, elOption, transFromProps) {
  var transition2 = elOption.transition;
  var transitionKeys = isTransitionAll(transition2) ? TRANSFORMABLE_PROPS : normalizeToArray(transition2 || []);
  for (var i = 0; i < transitionKeys.length; i++) {
    var key2 = transitionKeys[i];
    if (key2 === "style" || key2 === "shape" || key2 === "extra") {
      continue;
    }
    var elVal = el[key2];
    transFromProps[key2] = elVal;
  }
}
function prepareTransformAllPropsFinal(el, elOption, allProps) {
  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
    var legacyName = LEGACY_TRANSFORM_PROPS[i];
    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
    var legacyArr = elOption[legacyName];
    if (legacyArr) {
      allProps[xyName[0]] = legacyArr[0];
      allProps[xyName[1]] = legacyArr[1];
    }
  }
  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    var key2 = TRANSFORMABLE_PROPS[i];
    if (elOption[key2] != null) {
      allProps[key2] = elOption[key2];
    }
  }
}
function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
  if (!styleOpt) {
    return;
  }
  var fromElStyle = fromEl.style;
  var transFromStyleProps;
  if (fromElStyle) {
    var styleTransition = styleOpt.transition;
    var elTransition = elOption.transition;
    if (styleTransition && !isTransitionAll(styleTransition)) {
      var transitionKeys = normalizeToArray(styleTransition);
      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
      for (var i = 0; i < transitionKeys.length; i++) {
        var key2 = transitionKeys[i];
        var elVal = fromElStyle[key2];
        transFromStyleProps[key2] = elVal;
      }
    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, "style") >= 0)) {
      var animationProps = fromEl.getAnimationStyleProps();
      var animationStyleProps = animationProps ? animationProps.style : null;
      if (animationStyleProps) {
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        var styleKeys = keys$1(styleOpt);
        for (var i = 0; i < styleKeys.length; i++) {
          var key2 = styleKeys[i];
          if (animationStyleProps[key2]) {
            var elVal = fromElStyle[key2];
            transFromStyleProps[key2] = elVal;
          }
        }
      }
    }
  }
}
function isNonStyleTransitionEnabled(optVal, elVal) {
  return !isArrayLike$1(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}
var getStateToRestore = makeInner();
var KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
function stopPreviousKeyframeAnimationAndRestore(el) {
  el.stopAnimation("keyframe");
  el.attr(getStateToRestore(el));
}
function applyKeyframeAnimation(el, animationOpts, animatableModel) {
  if (!animatableModel.isAnimationEnabled() || !animationOpts) {
    return;
  }
  if (isArray$4(animationOpts)) {
    each$e(animationOpts, function(singleAnimationOpts) {
      applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
    });
    return;
  }
  var keyframes = animationOpts.keyframes;
  var duration = animationOpts.duration;
  if (animatableModel && duration == null) {
    var config = getAnimationConfig("enter", animatableModel, 0);
    duration = config && config.duration;
  }
  if (!keyframes || !duration) {
    return;
  }
  var stateToRestore = getStateToRestore(el);
  each$e(ELEMENT_ANIMATABLE_PROPS, function(targetPropName) {
    if (targetPropName && !el[targetPropName]) {
      return;
    }
    var animator;
    keyframes.sort(function(a2, b2) {
      return a2.percent - b2.percent;
    });
    each$e(keyframes, function(kf) {
      var animators = el.animators;
      var kfValues = targetPropName ? kf[targetPropName] : kf;
      if (!kfValues) {
        return;
      }
      var propKeys = keys$1(kfValues);
      if (!targetPropName) {
        propKeys = filter$2(propKeys, function(key2) {
          return indexOf(KEYFRAME_EXCLUDE_KEYS, key2) < 0;
        });
      }
      if (!propKeys.length) {
        return;
      }
      if (!animator) {
        animator = el.animate(targetPropName, animationOpts.loop, true);
        animator.scope = "keyframe";
      }
      for (var i = 0; i < animators.length; i++) {
        if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
          animators[i].stopTracks(propKeys);
        }
      }
      targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
      var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
      each$e(propKeys, function(key2) {
        savedTarget[key2] = ((targetPropName ? el[targetPropName] : el) || {})[key2];
      });
      animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
    });
    if (!animator) {
      return;
    }
    animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
  });
}
var inner$7 = makeInner();
var clone = clone$3;
var bind = bind$1;
var BaseAxisPointer = function() {
  function BaseAxisPointer2() {
    this._dragging = false;
    this.animationThreshold = 15;
  }
  BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get("value");
    var status = axisPointerModel.get("status");
    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api;
    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }
    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;
    if (!status || status === "hide") {
      group && group.hide();
      handle && handle.hide();
      return;
    }
    group && group.show();
    handle && handle.show();
    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
    var graphicKey = elOption.graphicKey;
    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }
    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
    if (!group) {
      group = this._group = new Group$3();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = curry$1(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }
    updateMandatoryProps(group, axisPointerModel, true);
    this._renderHandle(value);
  };
  BaseAxisPointer2.prototype.remove = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.dispose = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
    var animation = axisPointerModel.get("animation");
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === "category";
    var useSnap = axisPointerModel.get("snap");
    if (!useSnap && !isCategoryAxis) {
      return false;
    }
    if (animation === "auto" || animation == null) {
      var animationThreshold = this.animationThreshold;
      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      }
      if (useSnap) {
        var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent();
        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }
      return false;
    }
    return animation === true;
  };
  BaseAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
  };
  BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;
    if (pointerOption) {
      var pointerEl = inner$7(group).pointerEl = new graphic$1[pointerOption.type](clone(elOption.pointer));
      group.add(pointerEl);
    }
  };
  BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner$7(group).labelEl = new ZRText$1(clone(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps2) {
    var pointerEl = inner$7(group).pointerEl;
    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps2(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  };
  BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps2, axisPointerModel) {
    var labelEl = inner$7(group).labelEl;
    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps2(labelEl, {
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype._renderHandle = function(value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }
    var axisPointerModel = this._axisPointerModel;
    var zr = this._api.getZr();
    var handle = this._handle;
    var handleModel = axisPointerModel.getModel("handle");
    var status = axisPointerModel.get("status");
    if (!handleModel.get("show") || !status || status === "hide") {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }
    var isInit;
    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get("icon"), {
        cursor: "move",
        draggable: true,
        onmousemove: function(e2) {
          stop(e2.event);
        },
        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
        drift: bind(this._onHandleDragMove, this),
        ondragend: bind(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }
    updateMandatoryProps(handle, axisPointerModel, false);
    handle.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
    var handleSize = handleModel.get("size");
    if (!isArray$4(handleSize)) {
      handleSize = [handleSize, handleSize];
    }
    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
    this._moveHandleToValue(value, isInit);
  };
  BaseAxisPointer2.prototype._moveHandleToValue = function(value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  };
  BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    this._dragging = true;
    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner$7(handle).lastProp = null;
    this._doDispatchAxisPointer();
  };
  BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;
    this._api.dispatchAction({
      type: "updateAxisPointer",
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  };
  BaseAxisPointer2.prototype._onHandleDragEnd = function() {
    this._dragging = false;
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var value = this._axisPointerModel.get("value");
    this._moveHandleToValue(value);
    this._api.dispatchAction({
      type: "hideTip"
    });
  };
  BaseAxisPointer2.prototype.clear = function(api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;
    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
    clear$1(this, "_doDispatchAxisPointer");
  };
  BaseAxisPointer2.prototype.doClear = function() {
  };
  BaseAxisPointer2.prototype.buildLabel = function(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  };
  return BaseAxisPointer2;
}();
function updateProps(animationModel, moveAnimation, el, props2) {
  if (!propsEqual(inner$7(el).lastProp, props2)) {
    inner$7(el).lastProp = props2;
    moveAnimation ? updateProps$1(el, props2, animationModel) : (el.stopAnimation(), el.attr(props2));
  }
}
function propsEqual(lastProps, newProps) {
  if (isObject$9(lastProps) && isObject$9(newProps)) {
    var equals_1 = true;
    each$e(newProps, function(item, key2) {
      equals_1 = equals_1 && propsEqual(lastProps[key2], item);
    });
    return !!equals_1;
  } else {
    return lastProps === newProps;
  }
}
function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}
function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get("z");
  var zlevel = axisPointerModel.get("zlevel");
  group && group.traverse(function(el) {
    if (el.type !== "group") {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}
var BaseAxisPointer$1 = BaseAxisPointer;
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get("type");
  var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
  var style;
  if (axisPointerType === "line") {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === "shadow") {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }
  return style;
}
function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get("value");
  var text2 = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
    precision: axisPointerModel.get(["label", "precision"]),
    formatter: axisPointerModel.get(["label", "formatter"])
  });
  var labelModel = axisPointerModel.getModel("label");
  var paddings = normalizeCssArray(labelModel.get("padding") || 0);
  var font = labelModel.getFont();
  var textRect = getBoundingRect(text2, font);
  var position2 = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2];
  var align = labelPos.align;
  align === "right" && (position2[0] -= width);
  align === "center" && (position2[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === "bottom" && (position2[1] -= height);
  verticalAlign === "middle" && (position2[1] -= height / 2);
  confineInContainer(position2, width, height, api);
  var bgColor = labelModel.get("backgroundColor");
  if (!bgColor || bgColor === "auto") {
    bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
  }
  elOption.label = {
    x: position2[0],
    y: position2[1],
    style: createTextStyle$1(labelModel, {
      text: text2,
      font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    z2: 10
  };
}
function confineInContainer(position2, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position2[0] = Math.min(position2[0] + width, viewWidth) - width;
  position2[1] = Math.min(position2[1] + height, viewHeight) - height;
  position2[0] = Math.max(position2[0], 0);
  position2[1] = Math.max(position2[1], 0);
}
function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  var text2 = axis.scale.getLabel({
    value
  }, {
    precision: opt.precision
  });
  var formatter2 = opt.formatter;
  if (formatter2) {
    var params_1 = {
      value: getAxisRawValue(axis, {
        value
      }),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each$e(seriesDataIndices, function(idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params_1.seriesData.push(dataParams);
    });
    if (isString$2(formatter2)) {
      text2 = formatter2.replace("{value}", text2);
    } else if (isFunction$2(formatter2)) {
      text2 = formatter2(params_1);
    }
  }
  return text2;
}
function getTransformedPosition(axis, value, layoutInfo) {
  var transform2 = create();
  rotate(transform2, transform2, layoutInfo.rotation);
  translate$2(transform2, transform2, layoutInfo.position);
  return applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform2);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder$1.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}
function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx,
    cy,
    r0,
    r,
    startAngle,
    endAngle,
    clockwise: true
  };
}
var CartesianAxisPointer = function(_super) {
  __extends(CartesianAxisPointer2, _super);
  function CartesianAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid2 = axis.grid;
    var axisPointerType = axisPointerModel.get("type");
    var otherExtent = getCartesian(grid2, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder$1[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var layoutInfo = layout$1(grid2.model, axisModel);
    buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  };
  CartesianAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
    var layoutInfo = layout$1(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  CartesianAxisPointer2.prototype.updateHandleTransform = function(transform2, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid2 = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid2, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === "x" ? 0 : 1;
    var currPosition = [transform2.x, transform2.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    var tooltipOptions = [{
      verticalAlign: "middle"
    }, {
      align: "center"
    }];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform2.rotation,
      cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  };
  return CartesianAxisPointer2;
}(BaseAxisPointer$1);
function getCartesian(grid2, axis) {
  var opt = {};
  opt[axis.dim + "AxisIndex"] = axis.index;
  return grid2.getCartesian(opt);
}
var pointerShapeBuilder$1 = {
  line: function(axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};
function getAxisDimIndex(axis) {
  return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer$1 = CartesianAxisPointer;
var AxisPointerModel = function(_super) {
  __extends(AxisPointerModel2, _super);
  function AxisPointerModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerModel2.type;
    return _this;
  }
  AxisPointerModel2.type = "axisPointer";
  AxisPointerModel2.defaultOption = {
    show: "auto",
    z: 50,
    type: "line",
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    link: [],
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: "#B9BEC9",
      width: 1,
      type: "dashed"
    },
    shadowStyle: {
      color: "rgba(210,219,238,0.2)"
    },
    label: {
      show: true,
      formatter: null,
      precision: "auto",
      margin: 3,
      color: "#fff",
      padding: [5, 7, 5, 7],
      backgroundColor: "auto",
      borderColor: null,
      borderWidth: 0,
      borderRadius: 3
    },
    handle: {
      show: false,
      icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
      size: 45,
      margin: 50,
      color: "#333",
      shadowBlur: 3,
      shadowColor: "#aaa",
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      throttle: 40
    }
  };
  return AxisPointerModel2;
}(ComponentModel$1);
var AxisPointerModel$1 = AxisPointerModel;
var inner$6 = makeInner();
var each$9 = each$e;
function register(key2, api, handler) {
  if (env$1.node) {
    return;
  }
  var zr = api.getZr();
  inner$6(zr).records || (inner$6(zr).records = {});
  initGlobalListeners(zr, api);
  var record = inner$6(zr).records[key2] || (inner$6(zr).records[key2] = {});
  record.handler = handler;
}
function initGlobalListeners(zr, api) {
  if (inner$6(zr).initialized) {
    return;
  }
  inner$6(zr).initialized = true;
  useHandler("click", curry$1(doEnter, "click"));
  useHandler("mousemove", curry$1(doEnter, "mousemove"));
  useHandler("globalout", onLeave);
  function useHandler(eventType, cb) {
    zr.on(eventType, function(e2) {
      var dis = makeDispatchAction$1(api);
      each$9(inner$6(zr).records, function(record) {
        record && cb(record, e2, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}
function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;
  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }
  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}
function onLeave(record, e2, dispatchAction2) {
  record.handler("leave", null, dispatchAction2);
}
function doEnter(currTrigger, record, e2, dispatchAction2) {
  record.handler(currTrigger, e2, dispatchAction2);
}
function makeDispatchAction$1(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  };
  var dispatchAction2 = function(payload) {
    var pendingList = pendings[payload.type];
    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction2;
      api.dispatchAction(payload);
    }
  };
  return {
    dispatchAction: dispatchAction2,
    pendings
  };
}
function unregister(key2, api) {
  if (env$1.node) {
    return;
  }
  var zr = api.getZr();
  var record = (inner$6(zr).records || {})[key2];
  if (record) {
    inner$6(zr).records[key2] = null;
  }
}
var AxisPointerView = function(_super) {
  __extends(AxisPointerView2, _super);
  function AxisPointerView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerView2.type;
    return _this;
  }
  AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
    register("axisPointer", api, function(currTrigger, e2, dispatchAction2) {
      if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction2({
          type: "updateAxisPointer",
          currTrigger,
          x: e2 && e2.offsetX,
          y: e2 && e2.offsetY
        });
      }
    });
  };
  AxisPointerView2.prototype.remove = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.prototype.dispose = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.type = "axisPointer";
  return AxisPointerView2;
}(ComponentView$1);
var AxisPointerView$1 = AxisPointerView;
function findPointFromSeries(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;
  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }
  var data = seriesModel.getData();
  var dataIndex = queryDataIndex(data, finder);
  if (dataIndex == null || dataIndex < 0 || isArray$4(dataIndex)) {
    return {
      point: []
    };
  }
  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;
  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis2 = coordSys.getOtherAxis(baseAxis);
      var valueAxisDim = valueAxis2.dim;
      var baseAxisDim = baseAxis.dim;
      var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      var baseDim = data.mapDimension(baseAxisDim);
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data.getValues(map$1(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
  return {
    point,
    el
  };
}
var inner$5 = makeInner();
function axisTrigger(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction2 = payload.dispatchAction || bind$1(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
  if (!coordSysAxesInfo) {
    return;
  }
  if (illegalPoint(point)) {
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }
  var isIllegalPoint = illegalPoint(point);
  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === "leave" || illegalPoint(point);
  var outputPayload = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry$1(showPointer, showValueMap),
    showTooltip: curry$1(showTooltip, dataByCoordSys)
  };
  each$e(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each$e(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key2) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;
        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }
        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  });
  var linkTriggers = {};
  each$e(axesInfo, function(tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup;
    if (linkGroup && !showValueMap[tarKey]) {
      each$e(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey];
        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each$e(linkTriggers, function(val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2);
  dispatchHighDownActually(axesInfo, dispatchAction2, api);
  return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  var axis = axisInfo.axis;
  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }
  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  }
  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue;
  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend$3(outputFinder, payloadBatch[0]);
  }
  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }
  updaters.showPointer(axisInfo, newValue, payloadBatch);
  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each$e(axisInfo.seriesModels, function(series, idx) {
    var dataDim = series.getData().mapDimensionsAll(dim);
    var seriesNestestValue;
    var dataIndices;
    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, axis.type === "category" ? 0.5 : null);
      if (!dataIndices.length) {
        return;
      }
      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }
    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }
    var diff = value - seriesNestestValue;
    var dist2 = Math.abs(diff);
    if (dist2 <= minDist) {
      if (dist2 < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist2;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }
      each$e(dataIndices, function(dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch,
    snapToValue
  };
}
function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value,
    payloadBatch
  };
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel;
  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }
  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];
  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }
  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value,
    valueLabelOpt: {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
  var outputAxesInfo = outputPayload.axesInfo = [];
  each$e(axesInfo, function(axisInfo, key2) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key2];
    if (valItem) {
      !axisInfo.useHandle && (option.status = "show");
      option.value = valItem.value;
      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } else {
      !axisInfo.useHandle && (option.status = "hide");
    }
    option.status === "show" && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}
function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2) {
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction2({
      type: "hideTip"
    });
    return;
  }
  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction2({
    type: "showTip",
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}
function dispatchHighDownActually(axesInfo, dispatchAction2, api) {
  var zr = api.getZr();
  var highDownKey = "axisPointerLastHighlights";
  var lastHighlights = inner$5(zr)[highDownKey] || {};
  var newHighlights = inner$5(zr)[highDownKey] = {};
  each$e(axesInfo, function(axisInfo, key2) {
    var option = axisInfo.axisPointerModel.option;
    option.status === "show" && each$e(option.seriesDataIndices, function(batchItem) {
      var key3 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
      newHighlights[key3] = batchItem;
    });
  });
  var toHighlight = [];
  var toDownplay = [];
  each$e(lastHighlights, function(batchItem, key2) {
    !newHighlights[key2] && toDownplay.push(batchItem);
  });
  each$e(newHighlights, function(batchItem, key2) {
    !lastHighlights[key2] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: "downplay",
    escapeConnect: true,
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: "highlight",
    escapeConnect: true,
    notBlur: true,
    batch: toHighlight
  });
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];
    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}
function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
  item.axisName = item[dim + "AxisName"] = axisModel.name;
  item.axisId = item[dim + "AxisId"] = axisModel.id;
  return item;
}
function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}
function install$k(registers) {
  AxisView$1.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer$1);
  registers.registerComponentModel(AxisPointerModel$1);
  registers.registerComponentView(AxisPointerView$1);
  registers.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link2 = option.axisPointer.link;
      if (link2 && !isArray$4(link2)) {
        option.axisPointer.link = [link2];
      }
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
  });
  registers.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}
function install$j(registers) {
  use(install$r);
  use(install$k);
}
var PolarAxisPointer = function(_super) {
  __extends(PolarAxisPointer2, _super);
  function PolarAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    if (axis.dim === "angle") {
      this.animationThreshold = Math.PI / 18;
    }
    var polar = axis.polar;
    var otherAxis = polar.getOtherAxis(axis);
    var otherExtent = otherAxis.getExtent();
    var coordValue = axis.dataToCoord(value);
    var axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, polar, coordValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var labelMargin = axisPointerModel.get(["label", "margin"]);
    var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
  };
  return PolarAxisPointer2;
}(BaseAxisPointer$1);
function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
  var axis = axisModel.axis;
  var coord = axis.dataToCoord(value);
  var axisAngle = polar.getAngleAxis().getExtent()[0];
  axisAngle = axisAngle / 180 * Math.PI;
  var radiusExtent = polar.getRadiusAxis().getExtent();
  var position2;
  var align;
  var verticalAlign;
  if (axis.dim === "radius") {
    var transform2 = create();
    rotate(transform2, transform2, axisAngle);
    translate$2(transform2, transform2, [polar.cx, polar.cy]);
    position2 = applyTransform([coord, -labelMargin], transform2);
    var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
    var labelLayout = AxisBuilder$1.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
    align = labelLayout.textAlign;
    verticalAlign = labelLayout.textVerticalAlign;
  } else {
    var r = radiusExtent[1];
    position2 = polar.coordToPoint([r + labelMargin, coord]);
    var cx = polar.cx;
    var cy = polar.cy;
    align = Math.abs(position2[0] - cx) / r < 0.3 ? "center" : position2[0] > cx ? "left" : "right";
    verticalAlign = Math.abs(position2[1] - cy) / r < 0.3 ? "middle" : position2[1] > cy ? "top" : "bottom";
  }
  return {
    position: position2,
    align,
    verticalAlign
  };
}
var pointerShapeBuilder = {
  line: function(axis, polar, coordValue, otherExtent) {
    return axis.dim === "angle" ? {
      type: "Line",
      shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
    } : {
      type: "Circle",
      shape: {
        cx: polar.cx,
        cy: polar.cy,
        r: coordValue
      }
    };
  },
  shadow: function(axis, polar, coordValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var radian = Math.PI / 180;
    return axis.dim === "angle" ? {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
    } : {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
    };
  }
};
var PolarAxisPointer$1 = PolarAxisPointer;
var PolarModel = function(_super) {
  __extends(PolarModel2, _super);
  function PolarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PolarModel2.type;
    return _this;
  }
  PolarModel2.prototype.findAxisModel = function(axisType) {
    var foundAxisModel;
    var ecModel = this.ecModel;
    ecModel.eachComponent(axisType, function(axisModel) {
      if (axisModel.getCoordSysModel() === this) {
        foundAxisModel = axisModel;
      }
    }, this);
    return foundAxisModel;
  };
  PolarModel2.type = "polar";
  PolarModel2.dependencies = ["radiusAxis", "angleAxis"];
  PolarModel2.defaultOption = {
    z: 0,
    center: ["50%", "50%"],
    radius: "80%"
  };
  return PolarModel2;
}(ComponentModel$1);
var PolarModel$1 = PolarModel;
var PolarAxisModel = function(_super) {
  __extends(PolarAxisModel2, _super);
  function PolarAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
  };
  PolarAxisModel2.type = "polarAxis";
  return PolarAxisModel2;
}(ComponentModel$1);
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel = function(_super) {
  __extends(AngleAxisModel2, _super);
  function AngleAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AngleAxisModel2.type;
    return _this;
  }
  AngleAxisModel2.type = "angleAxis";
  return AngleAxisModel2;
}(PolarAxisModel);
var RadiusAxisModel = function(_super) {
  __extends(RadiusAxisModel2, _super);
  function RadiusAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadiusAxisModel2.type;
    return _this;
  }
  RadiusAxisModel2.type = "radiusAxis";
  return RadiusAxisModel2;
}(PolarAxisModel);
var RadiusAxis = function(_super) {
  __extends(RadiusAxis2, _super);
  function RadiusAxis2(scale2, radiusExtent) {
    return _super.call(this, "radius", scale2, radiusExtent) || this;
  }
  RadiusAxis2.prototype.pointToData = function(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  };
  return RadiusAxis2;
}(Axis$1);
RadiusAxis.prototype.dataToRadius = Axis$1.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis$1.prototype.coordToData;
var RadiusAxis$1 = RadiusAxis;
var inner$4 = makeInner();
var AngleAxis = function(_super) {
  __extends(AngleAxis2, _super);
  function AngleAxis2(scale2, angleExtent) {
    return _super.call(this, "angle", scale2, angleExtent || [0, 360]) || this;
  }
  AngleAxis2.prototype.pointToData = function(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  };
  AngleAxis2.prototype.calculateCategoryInterval = function() {
    var axis = this;
    var labelModel = axis.getLabelModel();
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitH = Math.abs(unitSpan);
    var rect = getBoundingRect(tickValue == null ? "" : tickValue + "", labelModel.getFont(), "center", "top");
    var maxH = Math.max(rect.height, 7);
    var dh = maxH / unitH;
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(dh));
    var cache = inner$4(axis.model);
    var lastAutoInterval = cache.lastAutoInterval;
    var lastTickCount = cache.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
      interval = lastAutoInterval;
    } else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
    }
    return interval;
  };
  return AngleAxis2;
}(Axis$1);
AngleAxis.prototype.dataToAngle = Axis$1.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis$1.prototype.coordToData;
var AngleAxis$1 = AngleAxis;
var polarDimensions = ["radius", "angle"];
var Polar = function() {
  function Polar2(name) {
    this.dimensions = polarDimensions;
    this.type = "polar";
    this.cx = 0;
    this.cy = 0;
    this._radiusAxis = new RadiusAxis$1();
    this._angleAxis = new AngleAxis$1();
    this.axisPointerEnabled = true;
    this.name = name || "";
    this._radiusAxis.polar = this._angleAxis.polar = this;
  }
  Polar2.prototype.containPoint = function(point) {
    var coord = this.pointToCoord(point);
    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
  };
  Polar2.prototype.containData = function(data) {
    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
  };
  Polar2.prototype.getAxis = function(dim) {
    var key2 = "_" + dim + "Axis";
    return this[key2];
  };
  Polar2.prototype.getAxes = function() {
    return [this._radiusAxis, this._angleAxis];
  };
  Polar2.prototype.getAxesByScale = function(scaleType) {
    var axes = [];
    var angleAxis = this._angleAxis;
    var radiusAxis = this._radiusAxis;
    angleAxis.scale.type === scaleType && axes.push(angleAxis);
    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
    return axes;
  };
  Polar2.prototype.getAngleAxis = function() {
    return this._angleAxis;
  };
  Polar2.prototype.getRadiusAxis = function() {
    return this._radiusAxis;
  };
  Polar2.prototype.getOtherAxis = function(axis) {
    var angleAxis = this._angleAxis;
    return axis === angleAxis ? this._radiusAxis : angleAxis;
  };
  Polar2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
  };
  Polar2.prototype.getTooltipAxes = function(dim) {
    var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
    return {
      baseAxes: [baseAxis],
      otherAxes: [this.getOtherAxis(baseAxis)]
    };
  };
  Polar2.prototype.dataToPoint = function(data, clamp2) {
    return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp2), this._angleAxis.dataToAngle(data[1], clamp2)]);
  };
  Polar2.prototype.pointToData = function(point, clamp2) {
    var coord = this.pointToCoord(point);
    return [this._radiusAxis.radiusToData(coord[0], clamp2), this._angleAxis.angleToData(coord[1], clamp2)];
  };
  Polar2.prototype.pointToCoord = function(point) {
    var dx = point[0] - this.cx;
    var dy = point[1] - this.cy;
    var angleAxis = this.getAngleAxis();
    var extent3 = angleAxis.getExtent();
    var minAngle = Math.min(extent3[0], extent3[1]);
    var maxAngle = Math.max(extent3[0], extent3[1]);
    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx) / Math.PI * 180;
    var dir3 = radian < minAngle ? 1 : -1;
    while (radian < minAngle || radian > maxAngle) {
      radian += dir3 * 360;
    }
    return [radius, radian];
  };
  Polar2.prototype.coordToPoint = function(coord) {
    var radius = coord[0];
    var radian = coord[1] / 180 * Math.PI;
    var x2 = Math.cos(radian) * radius + this.cx;
    var y = -Math.sin(radian) * radius + this.cy;
    return [x2, y];
  };
  Polar2.prototype.getArea = function() {
    var angleAxis = this.getAngleAxis();
    var radiusAxis = this.getRadiusAxis();
    var radiusExtent = radiusAxis.getExtent().slice();
    radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
    var angleExtent = angleAxis.getExtent();
    var RADIAN2 = Math.PI / 180;
    return {
      cx: this.cx,
      cy: this.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN2,
      endAngle: -angleExtent[1] * RADIAN2,
      clockwise: angleAxis.inverse,
      contain: function(x2, y) {
        var dx = x2 - this.cx;
        var dy = y - this.cy;
        var d2 = dx * dx + dy * dy - 1e-4;
        var r = this.r;
        var r0 = this.r0;
        return d2 <= r * r && d2 >= r0 * r0;
      }
    };
  };
  Polar2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  };
  Polar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  };
  return Polar2;
}();
function getCoordSys$1(finder) {
  var seriesModel = finder.seriesModel;
  var polarModel = finder.polarModel;
  return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Polar$1 = Polar;
function resizePolar(polar, polarModel, api) {
  var center2 = polarModel.get("center");
  var width = api.getWidth();
  var height = api.getHeight();
  polar.cx = parsePercent(center2[0], width);
  polar.cy = parsePercent(center2[1], height);
  var radiusAxis = polar.getRadiusAxis();
  var size = Math.min(width, height) / 2;
  var radius = polarModel.get("radius");
  if (radius == null) {
    radius = [0, "100%"];
  } else if (!isArray$4(radius)) {
    radius = [0, radius];
  }
  var parsedRadius = [parsePercent(radius[0], size), parsePercent(radius[1], size)];
  radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
}
function updatePolarScale(ecModel, api) {
  var polar = this;
  var angleAxis = polar.getAngleAxis();
  var radiusAxis = polar.getRadiusAxis();
  angleAxis.scale.setExtent(Infinity, -Infinity);
  radiusAxis.scale.setExtent(Infinity, -Infinity);
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem === polar) {
      var data_1 = seriesModel.getData();
      each$e(getDataDimensionsOnAxis(data_1, "radius"), function(dim) {
        radiusAxis.scale.unionExtentFromData(data_1, dim);
      });
      each$e(getDataDimensionsOnAxis(data_1, "angle"), function(dim) {
        angleAxis.scale.unionExtentFromData(data_1, dim);
      });
    }
  });
  niceScaleExtent(angleAxis.scale, angleAxis.model);
  niceScaleExtent(radiusAxis.scale, radiusAxis.model);
  if (angleAxis.type === "category" && !angleAxis.onBand) {
    var extent3 = angleAxis.getExtent();
    var diff = 360 / angleAxis.scale.count();
    angleAxis.inverse ? extent3[1] += diff : extent3[1] -= diff;
    angleAxis.setExtent(extent3[0], extent3[1]);
  }
}
function isAngleAxisModel(axisModel) {
  return axisModel.mainType === "angleAxis";
}
function setAxis(axis, axisModel) {
  axis.type = axisModel.get("type");
  axis.scale = createScaleByModel$1(axisModel);
  axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
  axis.inverse = axisModel.get("inverse");
  if (isAngleAxisModel(axisModel)) {
    axis.inverse = axis.inverse !== axisModel.get("clockwise");
    var startAngle = axisModel.get("startAngle");
    axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
  }
  axisModel.axis = axis;
  axis.model = axisModel;
}
var polarCreator = {
  dimensions: polarDimensions,
  create: function(ecModel, api) {
    var polarList = [];
    ecModel.eachComponent("polar", function(polarModel, idx) {
      var polar = new Polar$1(idx + "");
      polar.update = updatePolarScale;
      var radiusAxis = polar.getRadiusAxis();
      var angleAxis = polar.getAngleAxis();
      var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      var angleAxisModel = polarModel.findAxisModel("angleAxis");
      setAxis(radiusAxis, radiusAxisModel);
      setAxis(angleAxis, angleAxisModel);
      resizePolar(polar, polarModel, api);
      polarList.push(polar);
      polarModel.coordinateSystem = polar;
      polar.model = polarModel;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "polar") {
        var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
        seriesModel.coordinateSystem = polarModel.coordinateSystem;
      }
    });
    return polarList;
  }
};
var polarCreator$1 = polarCreator;
var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function getAxisLineShape(polar, rExtent, angle) {
  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
  var start2 = polar.coordToPoint([rExtent[0], angle]);
  var end2 = polar.coordToPoint([rExtent[1], angle]);
  return {
    x1: start2[0],
    y1: start2[1],
    x2: end2[0],
    y2: end2[1]
  };
}
function getRadiusIdx(polar) {
  var radiusAxis = polar.getRadiusAxis();
  return radiusAxis.inverse ? 0 : 1;
}
function fixAngleOverlap(list2) {
  var firstItem = list2[0];
  var lastItem = list2[list2.length - 1];
  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
    list2.pop();
  }
}
var AngleAxisView = function(_super) {
  __extends(AngleAxisView2, _super);
  function AngleAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AngleAxisView2.type;
    _this.axisPointerClass = "PolarAxisPointer";
    return _this;
  }
  AngleAxisView2.prototype.render = function(angleAxisModel, ecModel) {
    this.group.removeAll();
    if (!angleAxisModel.get("show")) {
      return;
    }
    var angleAxis = angleAxisModel.axis;
    var polar = angleAxis.polar;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var ticksAngles = angleAxis.getTicksCoords();
    var minorTickAngles = angleAxis.getMinorTicksCoords();
    var labels = map$1(angleAxis.getViewLabels(), function(labelItem) {
      labelItem = clone$3(labelItem);
      var scale2 = angleAxis.scale;
      var tickValue = scale2.type === "ordinal" ? scale2.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      labelItem.coord = angleAxis.dataToCoord(tickValue);
      return labelItem;
    });
    fixAngleOverlap(labels);
    fixAngleOverlap(ticksAngles);
    each$e(elementList, function(name) {
      if (angleAxisModel.get([name, "show"]) && (!angleAxis.scale.isBlank() || name === "axisLine")) {
        angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
      }
    }, this);
  };
  AngleAxisView2.type = "angleAxis";
  return AngleAxisView2;
}(AxisView$1);
var angelAxisElementsBuilders = {
  axisLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var lineStyleModel = angleAxisModel.getModel(["axisLine", "lineStyle"]);
    var rId = getRadiusIdx(polar);
    var r0Id = rId ? 0 : 1;
    var shape;
    if (radiusExtent[r0Id] === 0) {
      shape = new Circle$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    } else {
      shape = new Ring$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          r0: radiusExtent[r0Id]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    }
    shape.style.fill = null;
    group.add(shape);
  },
  axisTick: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var tickModel = angleAxisModel.getModel("axisTick");
    var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = map$1(ticksAngles, function(tickAngleItem) {
      return new Line$1({
        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
      });
    });
    group.add(mergePath(lines, {
      style: defaults$1(tickModel.getModel("lineStyle").getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    var tickModel = angleAxisModel.getModel("axisTick");
    var minorTickModel = angleAxisModel.getModel("minorTick");
    var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = [];
    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line$1({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath(lines, {
      style: defaults$1(minorTickModel.getModel("lineStyle").getLineStyle(), defaults$1(tickModel.getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      }))
    }));
  },
  axisLabel: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
    var rawCategoryData = angleAxisModel.getCategories(true);
    var commonLabelModel = angleAxisModel.getModel("axisLabel");
    var labelMargin = commonLabelModel.get("margin");
    var triggerEvent = angleAxisModel.get("triggerEvent");
    each$e(labels, function(labelItem, idx) {
      var labelModel = commonLabelModel;
      var tickValue = labelItem.tickValue;
      var r = radiusExtent[getRadiusIdx(polar)];
      var p2 = polar.coordToPoint([r + labelMargin, labelItem.coord]);
      var cx = polar.cx;
      var cy = polar.cy;
      var labelTextAlign = Math.abs(p2[0] - cx) / r < 0.3 ? "center" : p2[0] > cx ? "left" : "right";
      var labelTextVerticalAlign = Math.abs(p2[1] - cy) / r < 0.3 ? "middle" : p2[1] > cy ? "top" : "bottom";
      if (rawCategoryData && rawCategoryData[tickValue]) {
        var rawCategoryItem = rawCategoryData[tickValue];
        if (isObject$9(rawCategoryItem) && rawCategoryItem.textStyle) {
          labelModel = new Model$1(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
        }
      }
      var textEl = new ZRText$1({
        silent: AxisBuilder$1.isLabelSilent(angleAxisModel),
        style: createTextStyle$1(labelModel, {
          x: p2[0],
          y: p2[1],
          fill: labelModel.getTextColor() || angleAxisModel.get(["axisLine", "lineStyle", "color"]),
          text: labelItem.formattedLabel,
          align: labelTextAlign,
          verticalAlign: labelTextVerticalAlign
        })
      });
      group.add(textEl);
      if (triggerEvent) {
        var eventData = AxisBuilder$1.makeAxisEventDataBase(angleAxisModel);
        eventData.targetType = "axisLabel";
        eventData.value = labelItem.rawLabel;
        getECData(textEl).eventData = eventData;
      }
    }, this);
  },
  splitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var splitLineModel = angleAxisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];
    for (var i = 0; i < ticksAngles.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Line$1({
        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
      }));
    }
    for (var i = 0; i < splitLines.length; i++) {
      group.add(mergePath(splitLines[i], {
        style: defaults$1({
          stroke: lineColors[i % lineColors.length]
        }, lineStyleModel.getLineStyle()),
        silent: true,
        z: angleAxisModel.get("z")
      }));
    }
  },
  minorSplitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    var minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var lines = [];
    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line$1({
          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath(lines, {
      style: lineStyleModel.getLineStyle(),
      silent: true,
      z: angleAxisModel.get("z")
    }));
  },
  splitArea: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!ticksAngles.length) {
      return;
    }
    var splitAreaModel = angleAxisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var RADIAN2 = Math.PI / 180;
    var prevAngle = -ticksAngles[0].coord * RADIAN2;
    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
    var clockwise = angleAxisModel.get("clockwise");
    for (var i = 1, len2 = ticksAngles.length; i <= len2; i++) {
      var coord = i === len2 ? ticksAngles[0].coord : ticksAngles[i].coord;
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0,
          r: r1,
          startAngle: prevAngle,
          endAngle: -coord * RADIAN2,
          clockwise
        },
        silent: true
      }));
      prevAngle = -coord * RADIAN2;
    }
    for (var i = 0; i < splitAreas.length; i++) {
      group.add(mergePath(splitAreas[i], {
        style: defaults$1({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
var AngleAxisView$1 = AngleAxisView;
var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs = ["splitLine", "splitArea", "minorSplitLine"];
var RadiusAxisView = function(_super) {
  __extends(RadiusAxisView2, _super);
  function RadiusAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadiusAxisView2.type;
    _this.axisPointerClass = "PolarAxisPointer";
    return _this;
  }
  RadiusAxisView2.prototype.render = function(radiusAxisModel, ecModel) {
    this.group.removeAll();
    if (!radiusAxisModel.get("show")) {
      return;
    }
    var oldAxisGroup = this._axisGroup;
    var newAxisGroup = this._axisGroup = new Group$3();
    this.group.add(newAxisGroup);
    var radiusAxis = radiusAxisModel.axis;
    var polar = radiusAxis.polar;
    var angleAxis = polar.getAngleAxis();
    var ticksCoords = radiusAxis.getTicksCoords();
    var minorTicksCoords = radiusAxis.getMinorTicksCoords();
    var axisAngle = angleAxis.getExtent()[0];
    var radiusExtent = radiusAxis.getExtent();
    var layout2 = layoutAxis(polar, radiusAxisModel, axisAngle);
    var axisBuilder = new AxisBuilder$1(radiusAxisModel, layout2);
    each$e(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    newAxisGroup.add(axisBuilder.getGroup());
    groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
    each$e(selfBuilderAttrs, function(name) {
      if (radiusAxisModel.get([name, "show"]) && !radiusAxis.scale.isBlank()) {
        axisElementBuilders[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
      }
    }, this);
  };
  RadiusAxisView2.type = "radiusAxis";
  return RadiusAxisView2;
}(AxisView$1);
var axisElementBuilders = {
  splitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    var splitLineModel = radiusAxisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];
    for (var i = 0; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Circle$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: Math.max(ticksCoords[i].coord, 0)
        }
      }));
    }
    for (var i = 0; i < splitLines.length; i++) {
      group.add(mergePath(splitLines[i], {
        style: defaults$1({
          stroke: lineColors[i % lineColors.length],
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    }
  },
  minorSplitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
    if (!minorTicksCoords.length) {
      return;
    }
    var minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var lines = [];
    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        lines.push(new Circle$1({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: minorTicksCoords[i][k].coord
          }
        }));
      }
    }
    group.add(mergePath(lines, {
      style: defaults$1({
        fill: null
      }, lineStyleModel.getLineStyle()),
      silent: true
    }));
  },
  splitArea: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    if (!ticksCoords.length) {
      return;
    }
    var splitAreaModel = radiusAxisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var prevRadius = ticksCoords[0].coord;
    for (var i = 1; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0: prevRadius,
          r: ticksCoords[i].coord,
          startAngle: 0,
          endAngle: Math.PI * 2
        },
        silent: true
      }));
      prevRadius = ticksCoords[i].coord;
    }
    for (var i = 0; i < splitAreas.length; i++) {
      group.add(mergePath(splitAreas[i], {
        style: defaults$1({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
function layoutAxis(polar, radiusAxisModel, axisAngle) {
  return {
    position: [polar.cx, polar.cy],
    rotation: axisAngle / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
    z2: 1
  };
}
var RadiusAxisView$1 = RadiusAxisView;
function getSeriesStackId(seriesModel) {
  return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
}
function getAxisKey(polar, axis) {
  return axis.dim + polar.model.componentIndex;
}
function barLayoutPolar(seriesType2, ecModel, api) {
  var lastStackCoords = {};
  var barWidthAndOffset = calRadialBar(filter$2(ecModel.getSeriesByType(seriesType2), function(seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
  }));
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (seriesModel.coordinateSystem.type !== "polar") {
      return;
    }
    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    var valueAxis2 = polar.getOtherAxis(baseAxis);
    var cx = seriesModel.coordinateSystem.cx;
    var cy = seriesModel.coordinateSystem.cy;
    var barMinHeight = seriesModel.get("barMinHeight") || 0;
    var barMinAngle = seriesModel.get("barMinAngle") || 0;
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    var valueDim = data.mapDimension(valueAxis2.dim);
    var baseDim = data.mapDimension(baseAxis.dim);
    var stacked = isDimensionStacked(data, valueDim);
    var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
    var valueAxisStart = valueAxis2.dataToCoord(0);
    for (var idx = 0, len2 = data.count(); idx < len2; idx++) {
      var value = data.get(valueDim, idx);
      var baseValue = data.get(baseDim, idx);
      var sign = value >= 0 ? "p" : "n";
      var baseCoord = valueAxisStart;
      if (stacked) {
        if (!lastStackCoords[stackId][baseValue]) {
          lastStackCoords[stackId][baseValue] = {
            p: valueAxisStart,
            n: valueAxisStart
          };
        }
        baseCoord = lastStackCoords[stackId][baseValue][sign];
      }
      var r0 = void 0;
      var r = void 0;
      var startAngle = void 0;
      var endAngle = void 0;
      if (valueAxis2.dim === "radius") {
        var radiusSpan = valueAxis2.dataToCoord(value) - valueAxisStart;
        var angle = baseAxis.dataToCoord(baseValue);
        if (Math.abs(radiusSpan) < barMinHeight) {
          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
        }
        r0 = baseCoord;
        r = baseCoord + radiusSpan;
        startAngle = angle - columnOffset;
        endAngle = startAngle - columnWidth;
        stacked && (lastStackCoords[stackId][baseValue][sign] = r);
      } else {
        var angleSpan = valueAxis2.dataToCoord(value, clampLayout) - valueAxisStart;
        var radius = baseAxis.dataToCoord(baseValue);
        if (Math.abs(angleSpan) < barMinAngle) {
          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
        }
        r0 = radius + columnOffset;
        r = r0 + columnWidth;
        startAngle = baseCoord;
        endAngle = baseCoord + angleSpan;
        stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
      }
      data.setItemLayout(idx, {
        cx,
        cy,
        r0,
        r,
        startAngle: -startAngle * Math.PI / 180,
        endAngle: -endAngle * Math.PI / 180,
        clockwise: startAngle >= endAngle
      });
    }
  });
}
function calRadialBar(barSeries) {
  var columnsMap = {};
  each$e(barSeries, function(seriesModel, idx) {
    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var axisExtent = baseAxis.getExtent();
    var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = getSeriesStackId(seriesModel);
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    if (barWidth && !stacks[stackId].width) {
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      stacks[stackId].width = barWidth;
      columnsOnAxis.remainedWidth -= barWidth;
    }
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    barGap != null && (columnsOnAxis.gap = barGap);
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$e(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each$e(stacks, function(column, stack) {
      var maxWidth = column.maxWidth;
      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);
        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }
        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$e(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset2 = -widthSum / 2;
    each$e(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset: offset2,
        width: column.width
      };
      offset2 += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: true,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
};
var radiusAxisExtraOption = {
  splitNumber: 5
};
var PolarView = function(_super) {
  __extends(PolarView2, _super);
  function PolarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PolarView2.type;
    return _this;
  }
  PolarView2.type = "polar";
  return PolarView2;
}(ComponentView$1);
function install$i(registers) {
  use(install$k);
  AxisView$1.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer$1);
  registers.registerCoordinateSystem("polar", polarCreator$1);
  registers.registerComponentModel(PolarModel$1);
  registers.registerComponentView(PolarView);
  axisModelCreator(registers, "angle", AngleAxisModel, angleAxisExtraOption);
  axisModelCreator(registers, "radius", RadiusAxisModel, radiusAxisExtraOption);
  registers.registerComponentView(AngleAxisView$1);
  registers.registerComponentView(RadiusAxisView$1);
  registers.registerLayout(curry$1(barLayoutPolar, "bar"));
}
var CalendarModel = function(_super) {
  __extends(CalendarModel2, _super);
  function CalendarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CalendarModel2.type;
    return _this;
  }
  CalendarModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.apply(this, arguments);
    mergeAndNormalizeLayoutParams$1(option, inputPositionParams);
  };
  CalendarModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    mergeAndNormalizeLayoutParams$1(this.option, option);
  };
  CalendarModel2.prototype.getCellSize = function() {
    return this.option.cellSize;
  };
  CalendarModel2.type = "calendar";
  CalendarModel2.defaultOption = {
    z: 2,
    left: 80,
    top: 60,
    cellSize: 20,
    orient: "horizontal",
    splitLine: {
      show: true,
      lineStyle: {
        color: "#000",
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      color: "#fff",
      borderWidth: 1,
      borderColor: "#ccc"
    },
    dayLabel: {
      show: true,
      firstDay: 0,
      position: "start",
      margin: "50%",
      color: "#000"
    },
    monthLabel: {
      show: true,
      position: "start",
      margin: 5,
      align: "center",
      formatter: null,
      color: "#000"
    },
    yearLabel: {
      show: true,
      position: null,
      margin: 30,
      formatter: null,
      color: "#ccc",
      fontFamily: "sans-serif",
      fontWeight: "bolder",
      fontSize: 20
    }
  };
  return CalendarModel2;
}(ComponentModel$1);
function mergeAndNormalizeLayoutParams$1(target, raw) {
  var cellSize = target.cellSize;
  var cellSizeArr;
  if (!isArray$4(cellSize)) {
    cellSizeArr = target.cellSize = [cellSize, cellSize];
  } else {
    cellSizeArr = cellSize;
  }
  if (cellSizeArr.length === 1) {
    cellSizeArr[1] = cellSizeArr[0];
  }
  var ignoreSize = map$1([0, 1], function(hvIdx) {
    if (sizeCalculable(raw, hvIdx)) {
      cellSizeArr[hvIdx] = "auto";
    }
    return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
  });
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize
  });
}
var CalendarModel$1 = CalendarModel;
var CalendarView = function(_super) {
  __extends(CalendarView2, _super);
  function CalendarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CalendarView2.type;
    return _this;
  }
  CalendarView2.prototype.render = function(calendarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    var coordSys = calendarModel.coordinateSystem;
    var rangeData = coordSys.getRangeInfo();
    var orient = coordSys.getOrient();
    var localeModel = ecModel.getLocaleModel();
    this._renderDayRect(calendarModel, rangeData, group);
    this._renderLines(calendarModel, rangeData, orient, group);
    this._renderYearText(calendarModel, rangeData, orient, group);
    this._renderMonthText(calendarModel, localeModel, orient, group);
    this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);
  };
  CalendarView2.prototype._renderDayRect = function(calendarModel, rangeData, group) {
    var coordSys = calendarModel.coordinateSystem;
    var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
    var sw = coordSys.getCellWidth();
    var sh = coordSys.getCellHeight();
    for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
      var point = coordSys.dataToRect([i], false).tl;
      var rect = new Rect$2({
        shape: {
          x: point[0],
          y: point[1],
          width: sw,
          height: sh
        },
        cursor: "default",
        style: itemRectStyleModel
      });
      group.add(rect);
    }
  };
  CalendarView2.prototype._renderLines = function(calendarModel, rangeData, orient, group) {
    var self2 = this;
    var coordSys = calendarModel.coordinateSystem;
    var lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
    var show = calendarModel.get(["splitLine", "show"]);
    var lineWidth = lineStyleModel.lineWidth;
    this._tlpoints = [];
    this._blpoints = [];
    this._firstDayOfMonth = [];
    this._firstDayPoints = [];
    var firstDay = rangeData.start;
    for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
      addPoints(firstDay.formatedDate);
      if (i === 0) {
        firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
      }
      var date = firstDay.date;
      date.setMonth(date.getMonth() + 1);
      firstDay = coordSys.getDateInfo(date);
    }
    addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
    function addPoints(date2) {
      self2._firstDayOfMonth.push(coordSys.getDateInfo(date2));
      self2._firstDayPoints.push(coordSys.dataToRect([date2], false).tl);
      var points2 = self2._getLinePointsOfOneWeek(calendarModel, date2, orient);
      self2._tlpoints.push(points2[0]);
      self2._blpoints.push(points2[points2.length - 1]);
      show && self2._drawSplitline(points2, lineStyleModel, group);
    }
    show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
    show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
  };
  CalendarView2.prototype._getEdgesPoints = function(points2, lineWidth, orient) {
    var rs = [points2[0].slice(), points2[points2.length - 1].slice()];
    var idx = orient === "horizontal" ? 0 : 1;
    rs[0][idx] = rs[0][idx] - lineWidth / 2;
    rs[1][idx] = rs[1][idx] + lineWidth / 2;
    return rs;
  };
  CalendarView2.prototype._drawSplitline = function(points2, lineStyle, group) {
    var poyline = new Polyline$1({
      z2: 20,
      shape: {
        points: points2
      },
      style: lineStyle
    });
    group.add(poyline);
  };
  CalendarView2.prototype._getLinePointsOfOneWeek = function(calendarModel, date, orient) {
    var coordSys = calendarModel.coordinateSystem;
    var parsedDate = coordSys.getDateInfo(date);
    var points2 = [];
    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(parsedDate.time, i);
      var point = coordSys.dataToRect([tmpD.time], false);
      points2[2 * tmpD.day] = point.tl;
      points2[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
    }
    return points2;
  };
  CalendarView2.prototype._formatterLabel = function(formatter2, params) {
    if (isString$2(formatter2) && formatter2) {
      return formatTplSimple(formatter2, params);
    }
    if (isFunction$2(formatter2)) {
      return formatter2(params);
    }
    return params.nameMap;
  };
  CalendarView2.prototype._yearTextPositionControl = function(textEl, point, orient, position2, margin) {
    var x2 = point[0];
    var y = point[1];
    var aligns = ["center", "bottom"];
    if (position2 === "bottom") {
      y += margin;
      aligns = ["center", "top"];
    } else if (position2 === "left") {
      x2 -= margin;
    } else if (position2 === "right") {
      x2 += margin;
      aligns = ["center", "top"];
    } else {
      y -= margin;
    }
    var rotate2 = 0;
    if (position2 === "left" || position2 === "right") {
      rotate2 = Math.PI / 2;
    }
    return {
      rotation: rotate2,
      x: x2,
      y,
      style: {
        align: aligns[0],
        verticalAlign: aligns[1]
      }
    };
  };
  CalendarView2.prototype._renderYearText = function(calendarModel, rangeData, orient, group) {
    var yearLabel = calendarModel.getModel("yearLabel");
    if (!yearLabel.get("show")) {
      return;
    }
    var margin = yearLabel.get("margin");
    var pos = yearLabel.get("position");
    if (!pos) {
      pos = orient !== "horizontal" ? "top" : "left";
    }
    var points2 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
    var xc = (points2[0][0] + points2[1][0]) / 2;
    var yc = (points2[0][1] + points2[1][1]) / 2;
    var idx = orient === "horizontal" ? 0 : 1;
    var posPoints = {
      top: [xc, points2[idx][1]],
      bottom: [xc, points2[1 - idx][1]],
      left: [points2[1 - idx][0], yc],
      right: [points2[idx][0], yc]
    };
    var name = rangeData.start.y;
    if (+rangeData.end.y > +rangeData.start.y) {
      name = name + "-" + rangeData.end.y;
    }
    var formatter2 = yearLabel.get("formatter");
    var params = {
      start: rangeData.start.y,
      end: rangeData.end.y,
      nameMap: name
    };
    var content = this._formatterLabel(formatter2, params);
    var yearText = new ZRText$1({
      z2: 30,
      style: createTextStyle$1(yearLabel, {
        text: content
      })
    });
    yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
    group.add(yearText);
  };
  CalendarView2.prototype._monthTextPositionControl = function(point, isCenter, orient, position2, margin) {
    var align = "left";
    var vAlign = "top";
    var x2 = point[0];
    var y = point[1];
    if (orient === "horizontal") {
      y = y + margin;
      if (isCenter) {
        align = "center";
      }
      if (position2 === "start") {
        vAlign = "bottom";
      }
    } else {
      x2 = x2 + margin;
      if (isCenter) {
        vAlign = "middle";
      }
      if (position2 === "start") {
        align = "right";
      }
    }
    return {
      x: x2,
      y,
      align,
      verticalAlign: vAlign
    };
  };
  CalendarView2.prototype._renderMonthText = function(calendarModel, localeModel, orient, group) {
    var monthLabel = calendarModel.getModel("monthLabel");
    if (!monthLabel.get("show")) {
      return;
    }
    var nameMap = monthLabel.get("nameMap");
    var margin = monthLabel.get("margin");
    var pos = monthLabel.get("position");
    var align = monthLabel.get("align");
    var termPoints = [this._tlpoints, this._blpoints];
    if (!nameMap || isString$2(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      nameMap = localeModel.get(["time", "monthAbbr"]) || [];
    }
    var idx = pos === "start" ? 0 : 1;
    var axis = orient === "horizontal" ? 0 : 1;
    margin = pos === "start" ? -margin : margin;
    var isCenter = align === "center";
    for (var i = 0; i < termPoints[idx].length - 1; i++) {
      var tmp = termPoints[idx][i].slice();
      var firstDay = this._firstDayOfMonth[i];
      if (isCenter) {
        var firstDayPoints = this._firstDayPoints[i];
        tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
      }
      var formatter2 = monthLabel.get("formatter");
      var name_1 = nameMap[+firstDay.m - 1];
      var params = {
        yyyy: firstDay.y,
        yy: (firstDay.y + "").slice(2),
        MM: firstDay.m,
        M: +firstDay.m,
        nameMap: name_1
      };
      var content = this._formatterLabel(formatter2, params);
      var monthText = new ZRText$1({
        z2: 30,
        style: extend$3(createTextStyle$1(monthLabel, {
          text: content
        }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin))
      });
      group.add(monthText);
    }
  };
  CalendarView2.prototype._weekTextPositionControl = function(point, orient, position2, margin, cellSize) {
    var align = "center";
    var vAlign = "middle";
    var x2 = point[0];
    var y = point[1];
    var isStart = position2 === "start";
    if (orient === "horizontal") {
      x2 = x2 + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
      align = isStart ? "right" : "left";
    } else {
      y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
      vAlign = isStart ? "bottom" : "top";
    }
    return {
      x: x2,
      y,
      align,
      verticalAlign: vAlign
    };
  };
  CalendarView2.prototype._renderWeekText = function(calendarModel, localeModel, rangeData, orient, group) {
    var dayLabel = calendarModel.getModel("dayLabel");
    if (!dayLabel.get("show")) {
      return;
    }
    var coordSys = calendarModel.coordinateSystem;
    var pos = dayLabel.get("position");
    var nameMap = dayLabel.get("nameMap");
    var margin = dayLabel.get("margin");
    var firstDayOfWeek = coordSys.getFirstDayOfWeek();
    if (!nameMap || isString$2(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      var dayOfWeekShort = localeModel.get(["time", "dayOfWeekShort"]);
      nameMap = dayOfWeekShort || map$1(localeModel.get(["time", "dayOfWeekAbbr"]), function(val) {
        return val[0];
      });
    }
    var start2 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
    var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
    margin = parsePercent(margin, Math.min(cellSize[1], cellSize[0]));
    if (pos === "start") {
      start2 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
      margin = -margin;
    }
    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(start2, i);
      var point = coordSys.dataToRect([tmpD.time], false).center;
      var day = i;
      day = Math.abs((i + firstDayOfWeek) % 7);
      var weekText = new ZRText$1({
        z2: 30,
        style: extend$3(createTextStyle$1(dayLabel, {
          text: nameMap[day]
        }), this._weekTextPositionControl(point, orient, pos, margin, cellSize))
      });
      group.add(weekText);
    }
  };
  CalendarView2.type = "calendar";
  return CalendarView2;
}(ComponentView$1);
var CalendarView$1 = CalendarView;
var PROXIMATE_ONE_DAY = 864e5;
var Calendar = function() {
  function Calendar2(calendarModel, ecModel, api) {
    this.type = "calendar";
    this.dimensions = Calendar2.dimensions;
    this.getDimensionsInfo = Calendar2.getDimensionsInfo;
    this._model = calendarModel;
  }
  Calendar2.getDimensionsInfo = function() {
    return [{
      name: "time",
      type: "time"
    }, "value"];
  };
  Calendar2.prototype.getRangeInfo = function() {
    return this._rangeInfo;
  };
  Calendar2.prototype.getModel = function() {
    return this._model;
  };
  Calendar2.prototype.getRect = function() {
    return this._rect;
  };
  Calendar2.prototype.getCellWidth = function() {
    return this._sw;
  };
  Calendar2.prototype.getCellHeight = function() {
    return this._sh;
  };
  Calendar2.prototype.getOrient = function() {
    return this._orient;
  };
  Calendar2.prototype.getFirstDayOfWeek = function() {
    return this._firstDayOfWeek;
  };
  Calendar2.prototype.getDateInfo = function(date) {
    date = parseDate(date);
    var y = date.getFullYear();
    var m2 = date.getMonth() + 1;
    var mStr = m2 < 10 ? "0" + m2 : "" + m2;
    var d2 = date.getDate();
    var dStr = d2 < 10 ? "0" + d2 : "" + d2;
    var day = date.getDay();
    day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
    return {
      y: y + "",
      m: mStr,
      d: dStr,
      day,
      time: date.getTime(),
      formatedDate: y + "-" + mStr + "-" + dStr,
      date
    };
  };
  Calendar2.prototype.getNextNDay = function(date, n) {
    n = n || 0;
    if (n === 0) {
      return this.getDateInfo(date);
    }
    date = new Date(this.getDateInfo(date).time);
    date.setDate(date.getDate() + n);
    return this.getDateInfo(date);
  };
  Calendar2.prototype.update = function(ecModel, api) {
    this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
    this._orient = this._model.get("orient");
    this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
    this._rangeInfo = this._getRangeInfo(this._initRangeOption());
    var weeks = this._rangeInfo.weeks || 1;
    var whNames = ["width", "height"];
    var cellSize = this._model.getCellSize().slice();
    var layoutParams = this._model.getBoxLayoutParams();
    var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
    each$e([0, 1], function(idx) {
      if (cellSizeSpecified(cellSize, idx)) {
        layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
      }
    });
    var whGlobal = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var calendarRect = this._rect = getLayoutRect$1(layoutParams, whGlobal);
    each$e([0, 1], function(idx) {
      if (!cellSizeSpecified(cellSize, idx)) {
        cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
      }
    });
    function cellSizeSpecified(cellSize2, idx) {
      return cellSize2[idx] != null && cellSize2[idx] !== "auto";
    }
    this._sw = cellSize[0];
    this._sh = cellSize[1];
  };
  Calendar2.prototype.dataToPoint = function(data, clamp2) {
    isArray$4(data) && (data = data[0]);
    clamp2 == null && (clamp2 = true);
    var dayInfo = this.getDateInfo(data);
    var range = this._rangeInfo;
    var date = dayInfo.formatedDate;
    if (clamp2 && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
      return [NaN, NaN];
    }
    var week = dayInfo.day;
    var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
    if (this._orient === "vertical") {
      return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
    }
    return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
  };
  Calendar2.prototype.pointToData = function(point) {
    var date = this.pointToDate(point);
    return date && date.time;
  };
  Calendar2.prototype.dataToRect = function(data, clamp2) {
    var point = this.dataToPoint(data, clamp2);
    return {
      contentShape: {
        x: point[0] - (this._sw - this._lineWidth) / 2,
        y: point[1] - (this._sh - this._lineWidth) / 2,
        width: this._sw - this._lineWidth,
        height: this._sh - this._lineWidth
      },
      center: point,
      tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
      tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
      br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
      bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
    };
  };
  Calendar2.prototype.pointToDate = function(point) {
    var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
    var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
    var range = this._rangeInfo.range;
    if (this._orient === "vertical") {
      return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
    }
    return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
  };
  Calendar2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  Calendar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  Calendar2.prototype.containPoint = function(point) {
    console.warn("Not implemented.");
    return false;
  };
  Calendar2.prototype._initRangeOption = function() {
    var range = this._model.get("range");
    var normalizedRange;
    if (isArray$4(range) && range.length === 1) {
      range = range[0];
    }
    if (!isArray$4(range)) {
      var rangeStr = range.toString();
      if (/^\d{4}$/.test(rangeStr)) {
        normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
      }
      if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
        var start2 = this.getDateInfo(rangeStr);
        var firstDay = start2.date;
        firstDay.setMonth(firstDay.getMonth() + 1);
        var end2 = this.getNextNDay(firstDay, -1);
        normalizedRange = [start2.formatedDate, end2.formatedDate];
      }
      if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
        normalizedRange = [rangeStr, rangeStr];
      }
    } else {
      normalizedRange = range;
    }
    if (!normalizedRange) {
      return range;
    }
    var tmp = this._getRangeInfo(normalizedRange);
    if (tmp.start.time > tmp.end.time) {
      normalizedRange.reverse();
    }
    return normalizedRange;
  };
  Calendar2.prototype._getRangeInfo = function(range) {
    var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
    var reversed;
    if (parsedRange[0].time > parsedRange[1].time) {
      reversed = true;
      parsedRange.reverse();
    }
    var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
    var date = new Date(parsedRange[0].time);
    var startDateNum = date.getDate();
    var endDateNum = parsedRange[1].date.getDate();
    date.setDate(startDateNum + allDay - 1);
    var dateNum = date.getDate();
    if (dateNum !== endDateNum) {
      var sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
      while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
        allDay -= sign;
        date.setDate(dateNum - sign);
      }
    }
    var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
    var nthWeek = reversed ? -weeks + 1 : weeks - 1;
    reversed && parsedRange.reverse();
    return {
      range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
      start: parsedRange[0],
      end: parsedRange[1],
      allDay,
      weeks,
      nthWeek,
      fweek: parsedRange[0].day,
      lweek: parsedRange[1].day
    };
  };
  Calendar2.prototype._getDateByWeeksAndDay = function(nthWeek, day, range) {
    var rangeInfo = this._getRangeInfo(range);
    if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
      return null;
    }
    var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
    var date = new Date(rangeInfo.start.time);
    date.setDate(+rangeInfo.start.d + nthDay);
    return this.getDateInfo(date);
  };
  Calendar2.create = function(ecModel, api) {
    var calendarList = [];
    ecModel.eachComponent("calendar", function(calendarModel) {
      var calendar2 = new Calendar2(calendarModel, ecModel, api);
      calendarList.push(calendar2);
      calendarModel.coordinateSystem = calendar2;
    });
    ecModel.eachSeries(function(calendarSeries) {
      if (calendarSeries.get("coordinateSystem") === "calendar") {
        calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
      }
    });
    return calendarList;
  };
  Calendar2.dimensions = ["time", "value"];
  return Calendar2;
}();
function getCoordSys(finder) {
  var calendarModel = finder.calendarModel;
  var seriesModel = finder.seriesModel;
  var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
  return coordSys;
}
var Calendar$1 = Calendar;
function install$h(registers) {
  registers.registerComponentModel(CalendarModel$1);
  registers.registerComponentView(CalendarView$1);
  registers.registerCoordinateSystem("calendar", Calendar$1);
}
function setKeyInfoToNewElOption(resultItem, newElOption) {
  var existElOption = resultItem.existing;
  newElOption.id = resultItem.keyInfo.id;
  !newElOption.type && existElOption && (newElOption.type = existElOption.type);
  if (newElOption.parentId == null) {
    var newElParentOption = newElOption.parentOption;
    if (newElParentOption) {
      newElOption.parentId = newElParentOption.id;
    } else if (existElOption) {
      newElOption.parentId = existElOption.parentId;
    }
  }
  newElOption.parentOption = null;
}
function isSetLoc(obj, props2) {
  var isSet;
  each$e(props2, function(prop) {
    obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
  });
  return isSet;
}
function mergeNewElOptionToExist(existList, index2, newElOption) {
  var newElOptCopy = extend$3({}, newElOption);
  var existElOption = existList[index2];
  var $action = newElOption.$action || "merge";
  if ($action === "merge") {
    if (existElOption) {
      merge(existElOption, newElOptCopy, true);
      mergeLayoutParam(existElOption, newElOptCopy, {
        ignoreSize: true
      });
      copyLayoutParams(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption, "shape");
      copyTransitionInfo(newElOption, existElOption, "style");
      copyTransitionInfo(newElOption, existElOption, "extra");
      newElOption.clipPath = existElOption.clipPath;
    } else {
      existList[index2] = newElOptCopy;
    }
  } else if ($action === "replace") {
    existList[index2] = newElOptCopy;
  } else if ($action === "remove") {
    existElOption && (existList[index2] = null);
  }
}
var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"];
var ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function copyTransitionInfo(target, source, targetProp) {
  if (targetProp) {
    if (!target[targetProp] && source[targetProp]) {
      target[targetProp] = {};
    }
    target = target[targetProp];
    source = source[targetProp];
  }
  if (!target || !source) {
    return;
  }
  var props2 = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;
  for (var i = 0; i < props2.length; i++) {
    var prop = props2[i];
    if (target[prop] == null && source[prop] != null) {
      target[prop] = source[prop];
    }
  }
}
function setLayoutInfoToExist(existItem, newElOption) {
  if (!existItem) {
    return;
  }
  existItem.hv = newElOption.hv = [
    isSetLoc(newElOption, ["left", "right"]),
    isSetLoc(newElOption, ["top", "bottom"])
  ];
  if (existItem.type === "group") {
    var existingGroupOpt = existItem;
    var newGroupOpt = newElOption;
    existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);
    existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);
  }
}
var GraphicComponentModel = function(_super) {
  __extends(GraphicComponentModel2, _super);
  function GraphicComponentModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphicComponentModel2.type;
    _this.preventAutoZ = true;
    return _this;
  }
  GraphicComponentModel2.prototype.mergeOption = function(option, ecModel) {
    var elements = this.option.elements;
    this.option.elements = null;
    _super.prototype.mergeOption.call(this, option, ecModel);
    this.option.elements = elements;
  };
  GraphicComponentModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    var newList = (isInit ? thisOption : newOption).elements;
    var existList = thisOption.elements = isInit ? [] : thisOption.elements;
    var flattenedList = [];
    this._flatten(newList, flattenedList, null);
    var mappingResult = mappingToExists(existList, flattenedList, "normalMerge");
    var elOptionsToUpdate = this._elOptionsToUpdate = [];
    each$e(mappingResult, function(resultItem, index2) {
      var newElOption = resultItem.newOption;
      if (!newElOption) {
        return;
      }
      elOptionsToUpdate.push(newElOption);
      setKeyInfoToNewElOption(resultItem, newElOption);
      mergeNewElOptionToExist(existList, index2, newElOption);
      setLayoutInfoToExist(existList[index2], newElOption);
    }, this);
    thisOption.elements = filter$2(existList, function(item) {
      item && delete item.$action;
      return item != null;
    });
  };
  GraphicComponentModel2.prototype._flatten = function(optionList, result, parentOption) {
    each$e(optionList, function(option) {
      if (!option) {
        return;
      }
      if (parentOption) {
        option.parentOption = parentOption;
      }
      result.push(option);
      var children2 = option.children;
      if (option.type === "group" && children2) {
        this._flatten(children2, result, option);
      }
      delete option.children;
    }, this);
  };
  GraphicComponentModel2.prototype.useElOptionsToUpdate = function() {
    var els = this._elOptionsToUpdate;
    this._elOptionsToUpdate = null;
    return els;
  };
  GraphicComponentModel2.type = "graphic";
  GraphicComponentModel2.defaultOption = {
    elements: []
  };
  return GraphicComponentModel2;
}(ComponentModel$1);
var nonShapeGraphicElements = {
  path: null,
  compoundPath: null,
  group: Group$3,
  image: ZRImage$1,
  text: ZRText$1
};
var inner$3 = makeInner();
var GraphicComponentView = function(_super) {
  __extends(GraphicComponentView2, _super);
  function GraphicComponentView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphicComponentView2.type;
    return _this;
  }
  GraphicComponentView2.prototype.init = function() {
    this._elMap = createHashMap();
  };
  GraphicComponentView2.prototype.render = function(graphicModel, ecModel, api) {
    if (graphicModel !== this._lastGraphicModel) {
      this._clear();
    }
    this._lastGraphicModel = graphicModel;
    this._updateElements(graphicModel);
    this._relocate(graphicModel, api);
  };
  GraphicComponentView2.prototype._updateElements = function(graphicModel) {
    var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
    if (!elOptionsToUpdate) {
      return;
    }
    var elMap = this._elMap;
    var rootGroup = this.group;
    var globalZ = graphicModel.get("z");
    var globalZLevel = graphicModel.get("zlevel");
    each$e(elOptionsToUpdate, function(elOption) {
      var id = convertOptionIdName(elOption.id, null);
      var elExisting = id != null ? elMap.get(id) : null;
      var parentId = convertOptionIdName(elOption.parentId, null);
      var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
      var elType = elOption.type;
      var elOptionStyle = elOption.style;
      if (elType === "text" && elOptionStyle) {
        if (elOption.hv && elOption.hv[1]) {
          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
        }
      }
      var textContentOption = elOption.textContent;
      var textConfig = elOption.textConfig;
      if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
        var convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);
        if (!textConfig && convertResult.textConfig) {
          textConfig = elOption.textConfig = convertResult.textConfig;
        }
        if (!textContentOption && convertResult.textContent) {
          textContentOption = convertResult.textContent;
        }
      }
      var elOptionCleaned = getCleanedElOption(elOption);
      var $action = elOption.$action || "merge";
      var isMerge = $action === "merge";
      var isReplace = $action === "replace";
      if (isMerge) {
        var isInit = !elExisting;
        var el_1 = elExisting;
        if (isInit) {
          el_1 = createEl(id, targetElParent, elOption.type, elMap);
        } else {
          el_1 && (inner$3(el_1).isNew = false);
          stopPreviousKeyframeAnimationAndRestore(el_1);
        }
        if (el_1) {
          applyUpdateTransition(el_1, elOptionCleaned, graphicModel, {
            isInit
          });
          updateCommonAttrs(el_1, elOption, globalZ, globalZLevel);
        }
      } else if (isReplace) {
        removeEl(elExisting, elOption, elMap, graphicModel);
        var el_2 = createEl(id, targetElParent, elOption.type, elMap);
        if (el_2) {
          applyUpdateTransition(el_2, elOptionCleaned, graphicModel, {
            isInit: true
          });
          updateCommonAttrs(el_2, elOption, globalZ, globalZLevel);
        }
      } else if ($action === "remove") {
        updateLeaveTo(elExisting, elOption);
        removeEl(elExisting, elOption, elMap, graphicModel);
      }
      var el = elMap.get(id);
      if (el && textContentOption) {
        if (isMerge) {
          var textContentExisting = el.getTextContent();
          textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new ZRText$1(textContentOption));
        } else if (isReplace) {
          el.setTextContent(new ZRText$1(textContentOption));
        }
      }
      if (el) {
        var clipPathOption = elOption.clipPath;
        if (clipPathOption) {
          var clipPathType = clipPathOption.type;
          var clipPath = void 0;
          var isInit = false;
          if (isMerge) {
            var oldClipPath = el.getClipPath();
            isInit = !oldClipPath || inner$3(oldClipPath).type !== clipPathType;
            clipPath = isInit ? newEl(clipPathType) : oldClipPath;
          } else if (isReplace) {
            isInit = true;
            clipPath = newEl(clipPathType);
          }
          el.setClipPath(clipPath);
          applyUpdateTransition(clipPath, clipPathOption, graphicModel, {
            isInit
          });
          applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel);
        }
        var elInner = inner$3(el);
        el.setTextConfig(textConfig);
        elInner.option = elOption;
        setEventData(el, graphicModel, elOption);
        setTooltipConfig({
          el,
          componentModel: graphicModel,
          itemName: el.name,
          itemTooltipOption: elOption.tooltip
        });
        applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel);
      }
    });
  };
  GraphicComponentView2.prototype._relocate = function(graphicModel, api) {
    var elOptions = graphicModel.option.elements;
    var rootGroup = this.group;
    var elMap = this._elMap;
    var apiWidth = api.getWidth();
    var apiHeight = api.getHeight();
    var xy = ["x", "y"];
    for (var i = 0; i < elOptions.length; i++) {
      var elOption = elOptions[i];
      var id = convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;
      if (!el || !el.isGroup) {
        continue;
      }
      var parentEl = el.parent;
      var isParentRoot = parentEl === rootGroup;
      var elInner = inner$3(el);
      var parentElInner = inner$3(parentEl);
      elInner.width = parsePercent(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;
      elInner.height = parsePercent(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;
    }
    for (var i = elOptions.length - 1; i >= 0; i--) {
      var elOption = elOptions[i];
      var id = convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;
      if (!el) {
        continue;
      }
      var parentEl = el.parent;
      var parentElInner = inner$3(parentEl);
      var containerInfo = parentEl === rootGroup ? {
        width: apiWidth,
        height: apiHeight
      } : {
        width: parentElInner.width,
        height: parentElInner.height
      };
      var layoutPos = {};
      var layouted = positionElement(el, elOption, containerInfo, null, {
        hv: elOption.hv,
        boundingMode: elOption.bounding
      }, layoutPos);
      if (!inner$3(el).isNew && layouted) {
        var transition2 = elOption.transition;
        var animatePos = {};
        for (var k = 0; k < xy.length; k++) {
          var key2 = xy[k];
          var val = layoutPos[key2];
          if (transition2 && (isTransitionAll(transition2) || indexOf(transition2, key2) >= 0)) {
            animatePos[key2] = val;
          } else {
            el[key2] = val;
          }
        }
        updateProps$1(el, animatePos, graphicModel, 0);
      } else {
        el.attr(layoutPos);
      }
    }
  };
  GraphicComponentView2.prototype._clear = function() {
    var _this = this;
    var elMap = this._elMap;
    elMap.each(function(el) {
      removeEl(el, inner$3(el).option, elMap, _this._lastGraphicModel);
    });
    this._elMap = createHashMap();
  };
  GraphicComponentView2.prototype.dispose = function() {
    this._clear();
  };
  GraphicComponentView2.type = "graphic";
  return GraphicComponentView2;
}(ComponentView$1);
function newEl(graphicType) {
  var Clz = hasOwn$1(nonShapeGraphicElements, graphicType) ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);
  var el = new Clz({});
  inner$3(el).type = graphicType;
  return el;
}
function createEl(id, targetElParent, graphicType, elMap) {
  var el = newEl(graphicType);
  targetElParent.add(el);
  elMap.set(id, el);
  inner$3(el).id = id;
  inner$3(el).isNew = true;
  return el;
}
function removeEl(elExisting, elOption, elMap, graphicModel) {
  var existElParent = elExisting && elExisting.parent;
  if (existElParent) {
    elExisting.type === "group" && elExisting.traverse(function(el) {
      removeEl(el, elOption, elMap, graphicModel);
    });
    applyLeaveTransition(elExisting, elOption, graphicModel);
    elMap.removeKey(inner$3(elExisting).id);
  }
}
function updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {
  if (!el.isGroup) {
    var elDisplayable = el;
    elDisplayable.cursor = retrieve2(elOption.cursor, Displayable$1.prototype.cursor);
    elDisplayable.z = retrieve2(elOption.z, defaultZ || 0);
    elDisplayable.zlevel = retrieve2(elOption.zlevel, defaultZlevel || 0);
    var optZ2 = elOption.z2;
    optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
  }
  each$e(keys$1(elOption), function(key2) {
    var val = elOption[key2];
    if (key2.indexOf("on") === 0 && isFunction$2(val)) {
      el[key2] = val;
    }
  });
  el.draggable = elOption.draggable;
  elOption.name != null && (el.name = elOption.name);
  elOption.id != null && (el.id = elOption.id);
}
function getCleanedElOption(elOption) {
  elOption = extend$3({}, elOption);
  each$e(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(name) {
    delete elOption[name];
  });
  return elOption;
}
function setEventData(el, graphicModel, elOption) {
  var eventData = getECData(el).eventData;
  if (!el.silent && !el.ignore && !eventData) {
    eventData = getECData(el).eventData = {
      componentType: "graphic",
      componentIndex: graphicModel.componentIndex,
      name: el.name
    };
  }
  if (eventData) {
    eventData.info = elOption.info;
  }
}
function install$g(registers) {
  registers.registerComponentModel(GraphicComponentModel);
  registers.registerComponentView(GraphicComponentView);
  registers.registerPreprocessor(function(option) {
    var graphicOption = option.graphic;
    if (isArray$4(graphicOption)) {
      if (!graphicOption[0] || !graphicOption[0].elements) {
        option.graphic = [{
          elements: graphicOption
        }];
      } else {
        option.graphic = [option.graphic[0]];
      }
    } else if (graphicOption && !graphicOption.elements) {
      option.graphic = [{
        elements: [graphicOption]
      }];
    }
  });
}
var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"];
var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(seriesModel) {
  var coordType = seriesModel.get("coordinateSystem");
  return indexOf(SERIES_COORDS, coordType) >= 0;
}
function getAxisMainType(axisDim) {
  return axisDim + "Axis";
}
function findEffectedDataZooms(ecModel, payload) {
  var axisRecords = createHashMap();
  var effectedModels = [];
  var effectedModelMap = createHashMap();
  ecModel.eachComponent({
    mainType: "dataZoom",
    query: payload
  }, function(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid)) {
      addToEffected(dataZoomModel);
    }
  });
  var foundNewLink;
  do {
    foundNewLink = false;
    ecModel.eachComponent("dataZoom", processSingle);
  } while (foundNewLink);
  function processSingle(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
      addToEffected(dataZoomModel);
      foundNewLink = true;
    }
  }
  function addToEffected(dataZoom) {
    effectedModelMap.set(dataZoom.uid, true);
    effectedModels.push(dataZoom);
    markAxisControlled(dataZoom);
  }
  function isLinked(dataZoomModel) {
    var isLink = false;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var axisIdxArr = axisRecords.get(axisDim);
      if (axisIdxArr && axisIdxArr[axisIndex]) {
        isLink = true;
      }
    });
    return isLink;
  }
  function markAxisControlled(dataZoomModel) {
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
    });
  }
  return effectedModels;
}
function collectReferCoordSysModelInfo(dataZoomModel) {
  var ecModel = dataZoomModel.ecModel;
  var coordSysInfoWrap = {
    infoList: [],
    infoMap: createHashMap()
  };
  dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    if (!axisModel) {
      return;
    }
    var coordSysModel = axisModel.getCoordSysModel();
    if (!coordSysModel) {
      return;
    }
    var coordSysUid = coordSysModel.uid;
    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
    if (!coordSysInfo) {
      coordSysInfo = {
        model: coordSysModel,
        axisModels: []
      };
      coordSysInfoWrap.infoList.push(coordSysInfo);
      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
    }
    coordSysInfo.axisModels.push(axisModel);
  });
  return coordSysInfoWrap;
}
var DataZoomAxisInfo = function() {
  function DataZoomAxisInfo2() {
    this.indexList = [];
    this.indexMap = [];
  }
  DataZoomAxisInfo2.prototype.add = function(axisCmptIdx) {
    if (!this.indexMap[axisCmptIdx]) {
      this.indexList.push(axisCmptIdx);
      this.indexMap[axisCmptIdx] = true;
    }
  };
  return DataZoomAxisInfo2;
}();
var DataZoomModel = function(_super) {
  __extends(DataZoomModel2, _super);
  function DataZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomModel2.type;
    _this._autoThrottle = true;
    _this._noTarget = true;
    _this._rangePropMode = ["percent", "percent"];
    return _this;
  }
  DataZoomModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputRawOption = retrieveRawOption(option);
    this.settledOption = inputRawOption;
    this.mergeDefaultAndTheme(option, ecModel);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype.mergeOption = function(newOption) {
    var inputRawOption = retrieveRawOption(newOption);
    merge(this.option, newOption, true);
    merge(this.settledOption, inputRawOption, true);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype._doInit = function(inputRawOption) {
    var thisOption = this.option;
    this._setDefaultThrottle(inputRawOption);
    this._updateRangeUse(inputRawOption);
    var settledOption = this.settledOption;
    each$e([["start", "startValue"], ["end", "endValue"]], function(names2, index2) {
      if (this._rangePropMode[index2] === "value") {
        thisOption[names2[0]] = settledOption[names2[0]] = null;
      }
    }, this);
    this._resetTarget();
  };
  DataZoomModel2.prototype._resetTarget = function() {
    var optionOrient = this.get("orient", true);
    var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
    if (hasAxisSpecified) {
      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
    } else {
      this._orient = optionOrient || "horizontal";
      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
    }
    this._noTarget = true;
    targetAxisIndexMap.each(function(axisInfo) {
      if (axisInfo.indexList.length) {
        this._noTarget = false;
      }
    }, this);
  };
  DataZoomModel2.prototype._fillSpecifiedTargetAxis = function(targetAxisIndexMap) {
    var hasAxisSpecified = false;
    each$e(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
      var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
      if (!refering.specified) {
        return;
      }
      hasAxisSpecified = true;
      var axisInfo = new DataZoomAxisInfo();
      each$e(refering.models, function(axisModel) {
        axisInfo.add(axisModel.componentIndex);
      });
      targetAxisIndexMap.set(axisDim, axisInfo);
    }, this);
    return hasAxisSpecified;
  };
  DataZoomModel2.prototype._fillAutoTargetAxisByOrient = function(targetAxisIndexMap, orient) {
    var ecModel = this.ecModel;
    var needAuto = true;
    if (needAuto) {
      var axisDim = orient === "vertical" ? "y" : "x";
      var axisModels = ecModel.findComponents({
        mainType: axisDim + "Axis"
      });
      setParallelAxis(axisModels, axisDim);
    }
    if (needAuto) {
      var axisModels = ecModel.findComponents({
        mainType: "singleAxis",
        filter: function(axisModel) {
          return axisModel.get("orient", true) === orient;
        }
      });
      setParallelAxis(axisModels, "single");
    }
    function setParallelAxis(axisModels2, axisDim2) {
      var axisModel = axisModels2[0];
      if (!axisModel) {
        return;
      }
      var axisInfo = new DataZoomAxisInfo();
      axisInfo.add(axisModel.componentIndex);
      targetAxisIndexMap.set(axisDim2, axisInfo);
      needAuto = false;
      if (axisDim2 === "x" || axisDim2 === "y") {
        var gridModel_1 = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
        gridModel_1 && each$e(axisModels2, function(axModel) {
          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
            axisInfo.add(axModel.componentIndex);
          }
        });
      }
    }
    if (needAuto) {
      each$e(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim2) {
        if (!needAuto) {
          return;
        }
        var axisModels2 = ecModel.findComponents({
          mainType: getAxisMainType(axisDim2),
          filter: function(axisModel) {
            return axisModel.get("type", true) === "category";
          }
        });
        if (axisModels2[0]) {
          var axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModels2[0].componentIndex);
          targetAxisIndexMap.set(axisDim2, axisInfo);
          needAuto = false;
        }
      }, this);
    }
  };
  DataZoomModel2.prototype._makeAutoOrientByTargetAxis = function() {
    var dim;
    this.eachTargetAxis(function(axisDim) {
      !dim && (dim = axisDim);
    }, this);
    return dim === "y" ? "vertical" : "horizontal";
  };
  DataZoomModel2.prototype._setDefaultThrottle = function(inputRawOption) {
    if (inputRawOption.hasOwnProperty("throttle")) {
      this._autoThrottle = false;
    }
    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  };
  DataZoomModel2.prototype._updateRangeUse = function(inputRawOption) {
    var rangePropMode = this._rangePropMode;
    var rangeModeInOption = this.get("rangeMode");
    each$e([["start", "startValue"], ["end", "endValue"]], function(names2, index2) {
      var percentSpecified = inputRawOption[names2[0]] != null;
      var valueSpecified = inputRawOption[names2[1]] != null;
      if (percentSpecified && !valueSpecified) {
        rangePropMode[index2] = "percent";
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index2] = "value";
      } else if (rangeModeInOption) {
        rangePropMode[index2] = rangeModeInOption[index2];
      } else if (percentSpecified) {
        rangePropMode[index2] = "percent";
      }
    });
  };
  DataZoomModel2.prototype.noTarget = function() {
    return this._noTarget;
  };
  DataZoomModel2.prototype.getFirstTargetAxisModel = function() {
    var firstAxisModel;
    this.eachTargetAxis(function(axisDim, axisIndex) {
      if (firstAxisModel == null) {
        firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      }
    }, this);
    return firstAxisModel;
  };
  DataZoomModel2.prototype.eachTargetAxis = function(callback, context) {
    this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
      each$e(axisInfo.indexList, function(axisIndex) {
        callback.call(context, axisDim, axisIndex);
      });
    });
  };
  DataZoomModel2.prototype.getAxisProxy = function(axisDim, axisIndex) {
    var axisModel = this.getAxisModel(axisDim, axisIndex);
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
  };
  DataZoomModel2.prototype.getAxisModel = function(axisDim, axisIndex) {
    var axisInfo = this._targetAxisInfoMap.get(axisDim);
    if (axisInfo && axisInfo.indexMap[axisIndex]) {
      return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    }
  };
  DataZoomModel2.prototype.setRawRange = function(opt) {
    var thisOption = this.option;
    var settledOption = this.settledOption;
    each$e([["start", "startValue"], ["end", "endValue"]], function(names2) {
      if (opt[names2[0]] != null || opt[names2[1]] != null) {
        thisOption[names2[0]] = settledOption[names2[0]] = opt[names2[0]];
        thisOption[names2[1]] = settledOption[names2[1]] = opt[names2[1]];
      }
    }, this);
    this._updateRangeUse(opt);
  };
  DataZoomModel2.prototype.setCalculatedRange = function(opt) {
    var option = this.option;
    each$e(["start", "startValue", "end", "endValue"], function(name) {
      option[name] = opt[name];
    });
  };
  DataZoomModel2.prototype.getPercentRange = function() {
    var axisProxy = this.findRepresentativeAxisProxy();
    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  };
  DataZoomModel2.prototype.getValueRange = function(axisDim, axisIndex) {
    if (axisDim == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
    }
  };
  DataZoomModel2.prototype.findRepresentativeAxisProxy = function(axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
    var firstProxy;
    var axisDimList = this._targetAxisInfoMap.keys();
    for (var i = 0; i < axisDimList.length; i++) {
      var axisDim = axisDimList[i];
      var axisInfo = this._targetAxisInfoMap.get(axisDim);
      for (var j = 0; j < axisInfo.indexList.length; j++) {
        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
        if (proxy.hostedBy(this)) {
          return proxy;
        }
        if (!firstProxy) {
          firstProxy = proxy;
        }
      }
    }
    return firstProxy;
  };
  DataZoomModel2.prototype.getRangePropMode = function() {
    return this._rangePropMode.slice();
  };
  DataZoomModel2.prototype.getOrient = function() {
    return this._orient;
  };
  DataZoomModel2.type = "dataZoom";
  DataZoomModel2.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"];
  DataZoomModel2.defaultOption = {
    z: 4,
    filterMode: "filter",
    start: 0,
    end: 100
  };
  return DataZoomModel2;
}(ComponentModel$1);
function retrieveRawOption(option) {
  var ret = {};
  each$e(["start", "end", "startValue", "endValue", "throttle"], function(name) {
    option.hasOwnProperty(name) && (ret[name] = option[name]);
  });
  return ret;
}
var DataZoomModel$1 = DataZoomModel;
var SelectDataZoomModel = function(_super) {
  __extends(SelectDataZoomModel2, _super);
  function SelectDataZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SelectDataZoomModel2.type;
    return _this;
  }
  SelectDataZoomModel2.type = "dataZoom.select";
  return SelectDataZoomModel2;
}(DataZoomModel$1);
var SelectZoomModel = SelectDataZoomModel;
var DataZoomView = function(_super) {
  __extends(DataZoomView2, _super);
  function DataZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomView2.type;
    return _this;
  }
  DataZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  };
  DataZoomView2.type = "dataZoom";
  return DataZoomView2;
}(ComponentView$1);
var DataZoomView$1 = DataZoomView;
var SelectDataZoomView = function(_super) {
  __extends(SelectDataZoomView2, _super);
  function SelectDataZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SelectDataZoomView2.type;
    return _this;
  }
  SelectDataZoomView2.type = "dataZoom.select";
  return SelectDataZoomView2;
}(DataZoomView$1);
var SelectZoomView = SelectDataZoomView;
var each$8 = each$e;
var asc$1 = asc$2;
var AxisProxy = function() {
  function AxisProxy2(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  }
  AxisProxy2.prototype.hostedBy = function(dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  };
  AxisProxy2.prototype.getDataValueWindow = function() {
    return this._valueWindow.slice();
  };
  AxisProxy2.prototype.getDataPercentWindow = function() {
    return this._percentWindow.slice();
  };
  AxisProxy2.prototype.getTargetSeriesModels = function() {
    var seriesModels = [];
    this.ecModel.eachSeries(function(seriesModel) {
      if (isCoordSupported(seriesModel)) {
        var axisMainType = getAxisMainType(this._dimName);
        var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
        if (axisModel && this._axisIndex === axisModel.componentIndex) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  };
  AxisProxy2.prototype.getAxisModel = function() {
    return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
  };
  AxisProxy2.prototype.getMinMaxSpan = function() {
    return clone$3(this._minMaxSpan);
  };
  AxisProxy2.prototype.calculateDataWindow = function(opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale2 = axisModel.axis.scale;
    var rangePropMode = this._dataZoomModel.getRangePropMode();
    var percentExtent = [0, 100];
    var percentWindow = [];
    var valueWindow = [];
    var hasPropModeValue;
    each$8(["start", "end"], function(prop, idx) {
      var boundPercent = opt[prop];
      var boundValue = opt[prop + "Value"];
      if (rangePropMode[idx] === "percent") {
        boundPercent == null && (boundPercent = percentExtent[idx]);
        boundValue = scale2.parse(linearMap$2(boundPercent, percentExtent, dataExtent));
      } else {
        hasPropModeValue = true;
        boundValue = boundValue == null ? dataExtent[idx] : scale2.parse(boundValue);
        boundPercent = linearMap$2(boundValue, dataExtent, percentExtent);
      }
      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    asc$1(valueWindow);
    asc$1(percentWindow);
    var spans = this._minMaxSpan;
    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
      var suffix = toValue ? "Span" : "ValueSpan";
      sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
      for (var i = 0; i < 2; i++) {
        toWindow[i] = linearMap$2(fromWindow[i], fromExtent, toExtent, true);
        toValue && (toWindow[i] = scale2.parse(toWindow[i]));
      }
    }
    return {
      valueWindow,
      percentWindow
    };
  };
  AxisProxy2.prototype.reset = function(dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var targetSeries = this.getTargetSeriesModels();
    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
    this._updateMinMaxSpan();
    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    this._setAxisModel();
  };
  AxisProxy2.prototype.filterData = function(dataZoomModel, api) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get("filterMode");
    var valueWindow = this._valueWindow;
    if (filterMode === "none") {
      return;
    }
    each$8(seriesModels, function(seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesData.mapDimensionsAll(axisDim);
      if (!dataDims.length) {
        return;
      }
      if (filterMode === "weakFilter") {
        var store_1 = seriesData.getStore();
        var dataDimIndices_1 = map$1(dataDims, function(dim) {
          return seriesData.getDimensionIndex(dim);
        }, seriesData);
        seriesData.filterSelf(function(dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;
          for (var i = 0; i < dataDims.length; i++) {
            var value = store_1.get(dataDimIndices_1[i], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];
            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }
            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          }
          return hasValue && leftOut && rightOut;
        });
      } else {
        each$8(dataDims, function(dim) {
          if (filterMode === "empty") {
            seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            var range = {};
            range[dim] = valueWindow;
            seriesData.selectRange(range);
          }
        });
      }
      each$8(dataDims, function(dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });
    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  };
  AxisProxy2.prototype._updateMinMaxSpan = function() {
    var minMaxSpan = this._minMaxSpan = {};
    var dataZoomModel = this._dataZoomModel;
    var dataExtent = this._dataExtent;
    each$8(["min", "max"], function(minMax) {
      var percentSpan = dataZoomModel.get(minMax + "Span");
      var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
      if (valueSpan != null) {
        percentSpan = linearMap$2(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = linearMap$2(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }
      minMaxSpan[minMax + "Span"] = percentSpan;
      minMaxSpan[minMax + "ValueSpan"] = valueSpan;
    }, this);
  };
  AxisProxy2.prototype._setAxisModel = function() {
    var axisModel = this.getAxisModel();
    var percentWindow = this._percentWindow;
    var valueWindow = this._valueWindow;
    if (!percentWindow) {
      return;
    }
    var precision = getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20);
    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
    if (percentWindow[0] !== 0) {
      rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
    }
    if (percentWindow[1] !== 100) {
      rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
    }
    rawExtentInfo.freeze();
  };
  return AxisProxy2;
}();
function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each$8(seriesModels, function(seriesModel) {
    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
  });
  var axisModel = axisProxy.getAxisModel();
  var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
  return [rawExtentResult.min, rawExtentResult.max];
}
var AxisProxy$1 = AxisProxy;
var dataZoomProcessor = {
  getTargetSeries: function(ecModel) {
    function eachAxisModel(cb) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
          cb(axisDim, axisIndex, axisModel, dataZoomModel);
        });
      });
    }
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      axisModel.__dzAxisProxy = null;
    });
    var proxyList = [];
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      if (!axisModel.__dzAxisProxy) {
        axisModel.__dzAxisProxy = new AxisProxy$1(axisDim, axisIndex, dataZoomModel, ecModel);
        proxyList.push(axisModel.__dzAxisProxy);
      }
    });
    var seriesModelMap = createHashMap();
    each$e(proxyList, function(axisProxy) {
      each$e(axisProxy.getTargetSeriesModels(), function(seriesModel) {
        seriesModelMap.set(seriesModel.uid, seriesModel);
      });
    });
    return seriesModelMap;
  },
  overallReset: function(ecModel, api) {
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
      });
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
      });
    });
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var percentRange = axisProxy.getDataPercentWindow();
        var valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      }
    });
  }
};
var dataZoomProcessor$1 = dataZoomProcessor;
function installDataZoomAction(registers) {
  registers.registerAction("dataZoom", function(payload, ecModel) {
    var effectedModels = findEffectedDataZooms(ecModel, payload);
    each$e(effectedModels, function(dataZoomModel) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
}
var installed$1 = false;
function installCommon$1(registers) {
  if (installed$1) {
    return;
  }
  installed$1 = true;
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor$1);
  installDataZoomAction(registers);
  registers.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  });
}
function install$f(registers) {
  registers.registerComponentModel(SelectZoomModel);
  registers.registerComponentView(SelectZoomView);
  installCommon$1(registers);
}
var ToolboxFeature = function() {
  function ToolboxFeature2() {
  }
  return ToolboxFeature2;
}();
var features = {};
function registerFeature(name, ctor) {
  features[name] = ctor;
}
function getFeature(name) {
  return features[name];
}
var ToolboxModel = function(_super) {
  __extends(ToolboxModel2, _super);
  function ToolboxModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ToolboxModel2.type;
    return _this;
  }
  ToolboxModel2.prototype.optionUpdated = function() {
    _super.prototype.optionUpdated.apply(this, arguments);
    var ecModel = this.ecModel;
    each$e(this.option.feature, function(featureOpt, featureName) {
      var Feature = getFeature(featureName);
      if (Feature) {
        if (Feature.getDefaultOption) {
          Feature.defaultOption = Feature.getDefaultOption(ecModel);
        }
        merge(featureOpt, Feature.defaultOption);
      }
    });
  };
  ToolboxModel2.type = "toolbox";
  ToolboxModel2.layoutMode = {
    type: "box",
    ignoreSize: true
  };
  ToolboxModel2.defaultOption = {
    show: true,
    z: 6,
    orient: "horizontal",
    left: "right",
    top: "top",
    backgroundColor: "transparent",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemSize: 15,
    itemGap: 8,
    showTitle: true,
    iconStyle: {
      borderColor: "#666",
      color: "none"
    },
    emphasis: {
      iconStyle: {
        borderColor: "#3E98C5"
      }
    },
    tooltip: {
      show: false,
      position: "bottom"
    }
  };
  return ToolboxModel2;
}(ComponentModel$1);
var ToolboxModel$1 = ToolboxModel;
function layout(group, componentModel, api) {
  var boxLayoutParams = componentModel.getBoxLayoutParams();
  var padding = componentModel.get("padding");
  var viewportSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var rect = getLayoutRect$1(boxLayoutParams, viewportSize, padding);
  box$1(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
  positionElement(group, boxLayoutParams, viewportSize, padding);
}
function makeBackground(rect, componentModel) {
  var padding = normalizeCssArray(componentModel.get("padding"));
  var style = componentModel.getItemStyle(["color", "opacity"]);
  style.fill = componentModel.get("backgroundColor");
  rect = new Rect$2({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get("borderRadius")
    },
    style,
    silent: true,
    z2: -1
  });
  return rect;
}
var ToolboxView = function(_super) {
  __extends(ToolboxView2, _super);
  function ToolboxView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ToolboxView2.prototype.render = function(toolboxModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();
    if (!toolboxModel.get("show")) {
      return;
    }
    var itemSize = +toolboxModel.get("itemSize");
    var isVertical = toolboxModel.get("orient") === "vertical";
    var featureOpts = toolboxModel.get("feature") || {};
    var features2 = this._features || (this._features = {});
    var featureNames = [];
    each$e(featureOpts, function(opt, name) {
      featureNames.push(name);
    });
    new DataDiffer$1(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry$1(processFeature, null)).execute();
    this._featureNames = featureNames;
    function processFeature(newIndex, oldIndex) {
      var featureName = featureNames[newIndex];
      var oldName = featureNames[oldIndex];
      var featureOpt = featureOpts[featureName];
      var featureModel = new Model$1(featureOpt, toolboxModel, toolboxModel.ecModel);
      var feature;
      if (payload && payload.newTitle != null && payload.featureName === featureName) {
        featureOpt.title = payload.newTitle;
      }
      if (featureName && !oldName) {
        if (isUserFeatureName(featureName)) {
          feature = {
            onclick: featureModel.option.onclick,
            featureName
          };
        } else {
          var Feature = getFeature(featureName);
          if (!Feature) {
            return;
          }
          feature = new Feature();
        }
        features2[featureName] = feature;
      } else {
        feature = features2[oldName];
        if (!feature) {
          return;
        }
      }
      feature.uid = getUID("toolbox-feature");
      feature.model = featureModel;
      feature.ecModel = ecModel;
      feature.api = api;
      var isToolboxFeature = feature instanceof ToolboxFeature;
      if (!featureName && oldName) {
        isToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
        return;
      }
      if (!featureModel.get("show") || isToolboxFeature && feature.unusable) {
        isToolboxFeature && feature.remove && feature.remove(ecModel, api);
        return;
      }
      createIconPaths(featureModel, feature, featureName);
      featureModel.setIconStatus = function(iconName, status) {
        var option = this.option;
        var iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status;
        if (iconPaths[iconName]) {
          (status === "emphasis" ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);
        }
      };
      if (feature instanceof ToolboxFeature) {
        if (feature.render) {
          feature.render(featureModel, ecModel, api, payload);
        }
      }
    }
    function createIconPaths(featureModel, feature, featureName) {
      var iconStyleModel = featureModel.getModel("iconStyle");
      var iconStyleEmphasisModel = featureModel.getModel(["emphasis", "iconStyle"]);
      var icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get("icon");
      var titles = featureModel.get("title") || {};
      var iconsMap;
      var titlesMap;
      if (isString$2(icons)) {
        iconsMap = {};
        iconsMap[featureName] = icons;
      } else {
        iconsMap = icons;
      }
      if (isString$2(titles)) {
        titlesMap = {};
        titlesMap[featureName] = titles;
      } else {
        titlesMap = titles;
      }
      var iconPaths = featureModel.iconPaths = {};
      each$e(iconsMap, function(iconStr, iconName) {
        var path = createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getItemStyle());
        var pathEmphasisState = path.ensureState("emphasis");
        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();
        var textContent = new ZRText$1({
          style: {
            text: titlesMap[iconName],
            align: iconStyleEmphasisModel.get("textAlign"),
            borderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
            padding: iconStyleEmphasisModel.get("textPadding"),
            fill: null
          },
          ignore: true
        });
        path.setTextContent(textContent);
        setTooltipConfig({
          el: path,
          componentModel: toolboxModel,
          itemName: iconName,
          formatterParamsExtra: {
            title: titlesMap[iconName]
          }
        });
        path.__title = titlesMap[iconName];
        path.on("mouseover", function() {
          var hoverStyle = iconStyleEmphasisModel.getItemStyle();
          var defaultTextPosition = isVertical ? toolboxModel.get("right") == null && toolboxModel.get("left") !== "right" ? "right" : "left" : toolboxModel.get("bottom") == null && toolboxModel.get("top") !== "bottom" ? "bottom" : "top";
          textContent.setStyle({
            fill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
            backgroundColor: iconStyleEmphasisModel.get("textBackgroundColor")
          });
          path.setTextConfig({
            position: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
          });
          textContent.ignore = !toolboxModel.get("showTitle");
          api.enterEmphasis(this);
        }).on("mouseout", function() {
          if (featureModel.get(["iconStatus", iconName]) !== "emphasis") {
            api.leaveEmphasis(this);
          }
          textContent.hide();
        });
        (featureModel.get(["iconStatus", iconName]) === "emphasis" ? enterEmphasis : leaveEmphasis)(path);
        group.add(path);
        path.on("click", bind$1(feature.onclick, feature, ecModel, api, iconName));
        iconPaths[iconName] = path;
      });
    }
    layout(group, toolboxModel, api);
    group.add(makeBackground(group.getBoundingRect(), toolboxModel));
    isVertical || group.eachChild(function(icon) {
      var titleText = icon.__title;
      var emphasisState = icon.ensureState("emphasis");
      var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
      var textContent = icon.getTextContent();
      var emphasisTextState = textContent && textContent.ensureState("emphasis");
      if (emphasisTextState && !isFunction$2(emphasisTextState) && titleText) {
        var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
        var rect = getBoundingRect(titleText, ZRText$1.makeFont(emphasisTextStyle));
        var offsetX = icon.x + group.x;
        var offsetY = icon.y + group.y + itemSize;
        var needPutOnTop = false;
        if (offsetY + rect.height > api.getHeight()) {
          emphasisTextConfig.position = "top";
          needPutOnTop = true;
        }
        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10;
        if (offsetX + rect.width / 2 > api.getWidth()) {
          emphasisTextConfig.position = ["100%", topOffset];
          emphasisTextStyle.align = "right";
        } else if (offsetX - rect.width / 2 < 0) {
          emphasisTextConfig.position = [0, topOffset];
          emphasisTextStyle.align = "left";
        }
      }
    });
  };
  ToolboxView2.prototype.updateView = function(toolboxModel, ecModel, api, payload) {
    each$e(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
    });
  };
  ToolboxView2.prototype.remove = function(ecModel, api) {
    each$e(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api);
    });
    this.group.removeAll();
  };
  ToolboxView2.prototype.dispose = function(ecModel, api) {
    each$e(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
    });
  };
  ToolboxView2.type = "toolbox";
  return ToolboxView2;
}(ComponentView$1);
function isUserFeatureName(featureName) {
  return featureName.indexOf("my") === 0;
}
var ToolboxView$1 = ToolboxView;
var SaveAsImage = function(_super) {
  __extends(SaveAsImage2, _super);
  function SaveAsImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SaveAsImage2.prototype.onclick = function(ecModel, api) {
    var model = this.model;
    var title = model.get("name") || ecModel.get("title.0.text") || "echarts";
    var isSvg = api.getZr().painter.getType() === "svg";
    var type = isSvg ? "svg" : model.get("type", true) || "png";
    var url = api.getConnectedDataURL({
      type,
      backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
      connectedBackgroundColor: model.get("connectedBackgroundColor"),
      excludeComponents: model.get("excludeComponents"),
      pixelRatio: model.get("pixelRatio")
    });
    var browser2 = env$1.browser;
    if (isFunction$2(MouseEvent) && (browser2.newEdge || !browser2.ie && !browser2.edge)) {
      var $a = document.createElement("a");
      $a.download = title + "." + type;
      $a.target = "_blank";
      $a.href = url;
      var evt = new MouseEvent("click", {
        view: document.defaultView,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } else {
      if (window.navigator.msSaveOrOpenBlob || isSvg) {
        var parts = url.split(",");
        var base64Encoded = parts[0].indexOf("base64") > -1;
        var bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];
        base64Encoded && (bstr = window.atob(bstr));
        var filename = title + "." + type;
        if (window.navigator.msSaveOrOpenBlob) {
          var n = bstr.length;
          var u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          var blob = new Blob([u8arr]);
          window.navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          var frame = document.createElement("iframe");
          document.body.appendChild(frame);
          var cw = frame.contentWindow;
          var doc = cw.document;
          doc.open("image/svg+xml", "replace");
          doc.write(bstr);
          doc.close();
          cw.focus();
          doc.execCommand("SaveAs", true, filename);
          document.body.removeChild(frame);
        }
      } else {
        var lang = model.get("lang");
        var html2 = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || "") + '" /></body>';
        var tab = window.open();
        tab.document.write(html2);
        tab.document.title = title;
      }
    }
  };
  SaveAsImage2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
      title: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
      type: "png",
      connectedBackgroundColor: "#fff",
      name: "",
      excludeComponents: ["toolbox"],
      lang: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
    };
    return defaultOption2;
  };
  return SaveAsImage2;
}(ToolboxFeature);
var SaveAsImage$1 = SaveAsImage;
var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
var radioTypes = [["line", "bar"], ["stack"]];
var MagicType = function(_super) {
  __extends(MagicType2, _super);
  function MagicType2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MagicType2.prototype.getIcons = function() {
    var model = this.model;
    var availableIcons = model.get("icon");
    var icons = {};
    each$e(model.get("type"), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  MagicType2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      type: [],
      icon: {
        line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
        bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
        stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "magicType", "title"]),
      option: {},
      seriesIndex: {}
    };
    return defaultOption2;
  };
  MagicType2.prototype.onclick = function(ecModel, api, type) {
    var model = this.model;
    var seriesIndex = model.get(["seriesIndex", type]);
    if (!seriesOptGenreator[type]) {
      return;
    }
    var newOption = {
      series: []
    };
    var generateNewSeriesTypes = function(seriesModel) {
      var seriesType2 = seriesModel.subType;
      var seriesId = seriesModel.id;
      var newSeriesOpt = seriesOptGenreator[type](seriesType2, seriesId, seriesModel, model);
      if (newSeriesOpt) {
        defaults$1(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      }
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
        var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
        if (categoryAxis2) {
          var axisDim = categoryAxis2.dim;
          var axisType = axisDim + "Axis";
          var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
          var axisIndex = axisModel.componentIndex;
          newOption[axisType] = newOption[axisType] || [];
          for (var i = 0; i <= axisIndex; i++) {
            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
          }
          newOption[axisType][axisIndex].boundaryGap = type === "bar";
        }
      }
    };
    each$e(radioTypes, function(radio) {
      if (indexOf(radio, type) >= 0) {
        each$e(radio, function(item) {
          model.setIconStatus(item, "normal");
        });
      }
    });
    model.setIconStatus(type, "emphasis");
    ecModel.eachComponent({
      mainType: "series",
      query: seriesIndex == null ? null : {
        seriesIndex
      }
    }, generateNewSeriesTypes);
    var newTitle;
    var currentType = type;
    if (type === "stack") {
      newTitle = merge({
        stack: model.option.title.tiled,
        tiled: model.option.title.stack
      }, model.option.title);
      if (model.get(["iconStatus", type]) !== "emphasis") {
        currentType = "tiled";
      }
    }
    api.dispatchAction({
      type: "changeMagicType",
      currentType,
      newOption,
      newTitle,
      featureName: "magicType"
    });
  };
  return MagicType2;
}(ToolboxFeature);
var seriesOptGenreator = {
  "line": function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "bar") {
      return merge({
        id: seriesId,
        type: "line",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "line"]) || {}, true);
    }
  },
  "bar": function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "line") {
      return merge({
        id: seriesId,
        type: "bar",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "bar"]) || {}, true);
    }
  },
  "stack": function(seriesType2, seriesId, seriesModel, model) {
    var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
    if (seriesType2 === "line" || seriesType2 === "bar") {
      model.setIconStatus("stack", isStack ? "normal" : "emphasis");
      return merge({
        id: seriesId,
        stack: isStack ? "" : INNER_STACK_KEYWORD
      }, model.get(["option", "stack"]) || {}, true);
    }
  }
};
registerAction({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
var MagicType$1 = MagicType;
var BLOCK_SPLITER = new Array(60).join("-");
var ITEM_SPLITER = "	";
function groupSeries(ecModel) {
  var seriesGroupByCategoryAxis = {};
  var otherSeries = [];
  var meta = [];
  ecModel.eachRawSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
      var baseAxis = coordSys.getBaseAxis();
      if (baseAxis.type === "category") {
        var key2 = baseAxis.dim + "_" + baseAxis.index;
        if (!seriesGroupByCategoryAxis[key2]) {
          seriesGroupByCategoryAxis[key2] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }
        seriesGroupByCategoryAxis[key2].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis,
    other: otherSeries,
    meta
  };
}
function assembleSeriesWithCategoryAxis(groups) {
  var tables = [];
  each$e(groups, function(group, key2) {
    var categoryAxis2 = group.categoryAxis;
    var valueAxis2 = group.valueAxis;
    var valueAxisDim = valueAxis2.dim;
    var headers = [" "].concat(map$1(group.series, function(series) {
      return series.name;
    }));
    var columns = [categoryAxis2.model.getCategories()];
    each$e(group.series, function(series) {
      var rawData = series.getRawData();
      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
        return val;
      }));
    });
    var lines = [headers.join(ITEM_SPLITER)];
    for (var i = 0; i < columns[0].length; i++) {
      var items = [];
      for (var j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }
      lines.push(items.join(ITEM_SPLITER));
    }
    tables.push(lines.join("\n"));
  });
  return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function assembleOtherSeries(series) {
  return map$1(series, function(series2) {
    var data = series2.getRawData();
    var lines = [series2.name];
    var vals = [];
    data.each(data.dimensions, function() {
      var argLen = arguments.length;
      var dataIndex = arguments[argLen - 1];
      var name = data.getName(dataIndex);
      for (var i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }
      lines.push((name ? name + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
    });
    return lines.join("\n");
  }).join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function getContentFromModel(ecModel) {
  var result = groupSeries(ecModel);
  return {
    value: filter$2([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
      return !!str.replace(/[\n\t\s]/g, "");
    }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
    meta: result.meta
  };
}
function trim(str) {
  return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(block) {
  var firstLine = block.slice(0, block.indexOf("\n"));
  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(tsv) {
  var tsvLines = tsv.split(/\n+/g);
  var headers = trim(tsvLines.shift()).split(itemSplitRegex);
  var categories = [];
  var series = map$1(headers, function(header) {
    return {
      name: header,
      data: []
    };
  });
  for (var i = 0; i < tsvLines.length; i++) {
    var items = trim(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());
    for (var j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }
  return {
    series,
    categories
  };
}
function parseListContents(str) {
  var lines = str.split(/\n+/g);
  var seriesName = trim(lines.shift());
  var data = [];
  for (var i = 0; i < lines.length; i++) {
    var line = trim(lines[i]);
    if (!line) {
      continue;
    }
    var items = line.split(itemSplitRegex);
    var name_1 = "";
    var value = void 0;
    var hasName = false;
    if (isNaN(items[0])) {
      hasName = true;
      name_1 = items[0];
      items = items.slice(1);
      data[i] = {
        name: name_1,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }
    for (var j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }
    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }
  return {
    name: seriesName,
    data
  };
}
function parseContents(str, blockMetaList) {
  var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
  var newOption = {
    series: []
  };
  each$e(blocks, function(block, idx) {
    if (isTSVFormat(block)) {
      var result = parseTSVContents(block);
      var blockMeta = blockMetaList[idx];
      var axisKey = blockMeta.axisDim + "Axis";
      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      var result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
var DataView$2 = function(_super) {
  __extends(DataView2, _super);
  function DataView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataView2.prototype.onclick = function(ecModel, api) {
    setTimeout(function() {
      api.dispatchAction({
        type: "hideTip"
      });
    });
    var container = api.getDom();
    var model = this.model;
    if (this._dom) {
      container.removeChild(this._dom);
    }
    var root2 = document.createElement("div");
    root2.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px";
    root2.style.backgroundColor = model.get("backgroundColor") || "#fff";
    var header = document.createElement("h4");
    var lang = model.get("lang") || [];
    header.innerHTML = lang[0] || model.get("title");
    header.style.cssText = "margin:10px 20px";
    header.style.color = model.get("textColor");
    var viewMain = document.createElement("div");
    var textarea = document.createElement("textarea");
    viewMain.style.cssText = "overflow:auto";
    var optionToContent = model.get("optionToContent");
    var contentToOption = model.get("contentToOption");
    var result = getContentFromModel(ecModel);
    if (isFunction$2(optionToContent)) {
      var htmlOrDom = optionToContent(api.getOption());
      if (isString$2(htmlOrDom)) {
        viewMain.innerHTML = htmlOrDom;
      } else if (isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      textarea.readOnly = model.get("readOnly");
      var style = textarea.style;
      style.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none";
      style.color = model.get("textColor");
      style.borderColor = model.get("textareaBorderColor");
      style.backgroundColor = model.get("textareaColor");
      textarea.value = result.value;
      viewMain.appendChild(textarea);
    }
    var blockMetaList = result.meta;
    var buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
    var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
    var closeButton = document.createElement("div");
    var refreshButton = document.createElement("div");
    buttonStyle += ";background-color:" + model.get("buttonColor");
    buttonStyle += ";color:" + model.get("buttonTextColor");
    var self2 = this;
    function close2() {
      container.removeChild(root2);
      self2._dom = null;
    }
    addEventListener(closeButton, "click", close2);
    addEventListener(refreshButton, "click", function() {
      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
        close2();
        return;
      }
      var newOption;
      try {
        if (isFunction$2(contentToOption)) {
          newOption = contentToOption(viewMain, api.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e2) {
        close2();
        throw new Error("Data view format error " + e2);
      }
      if (newOption) {
        api.dispatchAction({
          type: "changeDataView",
          newOption
        });
      }
      close2();
    });
    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;
    !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    root2.appendChild(header);
    root2.appendChild(viewMain);
    root2.appendChild(buttonContainer);
    viewMain.style.height = container.clientHeight - 80 + "px";
    container.appendChild(root2);
    this._dom = root2;
  };
  DataView2.prototype.remove = function(ecModel, api) {
    this._dom && api.getDom().removeChild(this._dom);
  };
  DataView2.prototype.dispose = function(ecModel, api) {
    this.remove(ecModel, api);
  };
  DataView2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
      title: ecModel.getLocaleModel().get(["toolbox", "dataView", "title"]),
      lang: ecModel.getLocaleModel().get(["toolbox", "dataView", "lang"]),
      backgroundColor: "#fff",
      textColor: "#000",
      textareaColor: "#fff",
      textareaBorderColor: "#333",
      buttonColor: "#c23531",
      buttonTextColor: "#fff"
    };
    return defaultOption2;
  };
  return DataView2;
}(ToolboxFeature);
function tryMergeDataOption(newData, originalData) {
  return map$1(newData, function(newVal, idx) {
    var original = originalData && originalData[idx];
    if (isObject$9(original) && !isArray$4(original)) {
      var newValIsObject = isObject$9(newVal) && !isArray$4(newVal);
      if (!newValIsObject) {
        newVal = {
          value: newVal
        };
      }
      var shouldDeleteName = original.name != null && newVal.name == null;
      newVal = defaults$1(newVal, original);
      shouldDeleteName && delete newVal.name;
      return newVal;
    } else {
      return newVal;
    }
  });
}
registerAction({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  var newSeriesOptList = [];
  each$e(payload.newOption.series, function(seriesOpt) {
    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
    if (!seriesModel) {
      newSeriesOptList.push(extend$3({
        type: "scatter"
      }, seriesOpt));
    } else {
      var originalData = seriesModel.get("data");
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(defaults$1({
    series: newSeriesOptList
  }, payload.newOption));
});
var DataView$3 = DataView$2;
var each$7 = each$e;
var inner$2 = makeInner();
function push(ecModel, newSnapshot) {
  var storedSnapshots = getStoreSnapshots(ecModel);
  each$7(newSnapshot, function(batchItem, dataZoomId) {
    var i = storedSnapshots.length - 1;
    for (; i >= 0; i--) {
      var snapshot = storedSnapshots[i];
      if (snapshot[dataZoomId]) {
        break;
      }
    }
    if (i < 0) {
      var dataZoomModel = ecModel.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: dataZoomId
      })[0];
      if (dataZoomModel) {
        var percentRange = dataZoomModel.getPercentRange();
        storedSnapshots[0][dataZoomId] = {
          dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  storedSnapshots.push(newSnapshot);
}
function pop(ecModel) {
  var storedSnapshots = getStoreSnapshots(ecModel);
  var head = storedSnapshots[storedSnapshots.length - 1];
  storedSnapshots.length > 1 && storedSnapshots.pop();
  var snapshot = {};
  each$7(head, function(batchItem, dataZoomId) {
    for (var i = storedSnapshots.length - 1; i >= 0; i--) {
      batchItem = storedSnapshots[i][dataZoomId];
      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
function clear(ecModel) {
  inner$2(ecModel).snapshots = null;
}
function count(ecModel) {
  return getStoreSnapshots(ecModel).length;
}
function getStoreSnapshots(ecModel) {
  var store = inner$2(ecModel);
  if (!store.snapshots) {
    store.snapshots = [{}];
  }
  return store.snapshots;
}
var RestoreOption = function(_super) {
  __extends(RestoreOption2, _super);
  function RestoreOption2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RestoreOption2.prototype.onclick = function(ecModel, api) {
    clear(ecModel);
    api.dispatchAction({
      type: "restore",
      from: this.uid
    });
  };
  RestoreOption2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
      title: ecModel.getLocaleModel().get(["toolbox", "restore", "title"])
    };
    return defaultOption2;
  };
  return RestoreOption2;
}(ToolboxFeature);
registerAction({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.resetOption("recreate");
});
var Restore = RestoreOption;
var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
var BrushTargetManager = function() {
  function BrushTargetManager2(finder, ecModel, opt) {
    var _this = this;
    this._targetInfoList = [];
    var foundCpts = parseFinder(ecModel, finder);
    each$e(targetInfoBuilders, function(builder, type) {
      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
        builder(foundCpts, _this._targetInfoList);
      }
    });
  }
  BrushTargetManager2.prototype.setOutputRanges = function(areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      (area.coordRanges || (area.coordRanges = [])).push(coordRange);
      if (!area.coordRange) {
        area.coordRange = coordRange;
        var result = coordConvert[area.brushType](0, coordSys, coordRange);
        area.__rangeOffset = {
          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
          xyMinMax: result.xyMinMax
        };
      }
    });
    return areas;
  };
  BrushTargetManager2.prototype.matchOutputRanges = function(areas, ecModel, cb) {
    each$e(areas, function(area) {
      var targetInfo = this.findTargetInfo(area, ecModel);
      if (targetInfo && targetInfo !== true) {
        each$e(targetInfo.coordSyses, function(coordSys) {
          var result = coordConvert[area.brushType](1, coordSys, area.range, true);
          cb(area, result.values, coordSys, ecModel);
        });
      }
    }, this);
  };
  BrushTargetManager2.prototype.setInputRanges = function(areas, ecModel) {
    each$e(areas, function(area) {
      var targetInfo = this.findTargetInfo(area, ecModel);
      area.range = area.range || [];
      if (targetInfo && targetInfo !== true) {
        area.panelId = targetInfo.panelId;
        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
        var rangeOffset = area.__rangeOffset;
        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
      }
    }, this);
  };
  BrushTargetManager2.prototype.makePanelOpts = function(api, getDefaultBrushType) {
    return map$1(this._targetInfoList, function(targetInfo) {
      var rect = targetInfo.getPanelRect();
      return {
        panelId: targetInfo.panelId,
        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
        clipPath: makeRectPanelClipPath(rect),
        isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
      };
    });
  };
  BrushTargetManager2.prototype.controlSeries = function(area, seriesModel, ecModel) {
    var targetInfo = this.findTargetInfo(area, ecModel);
    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
  };
  BrushTargetManager2.prototype.findTargetInfo = function(area, ecModel) {
    var targetInfoList = this._targetInfoList;
    var foundCpts = parseFinder(ecModel, area);
    for (var i = 0; i < targetInfoList.length; i++) {
      var targetInfo = targetInfoList[i];
      var areaPanelId = area.panelId;
      if (areaPanelId) {
        if (targetInfo.panelId === areaPanelId) {
          return targetInfo;
        }
      } else {
        for (var j = 0; j < targetInfoMatchers.length; j++) {
          if (targetInfoMatchers[j](foundCpts, targetInfo)) {
            return targetInfo;
          }
        }
      }
    }
    return true;
  };
  return BrushTargetManager2;
}();
function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}
function parseFinder(ecModel, finder) {
  return parseFinder$1(ecModel, finder, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}
var targetInfoBuilders = {
  grid: function(foundCpts, targetInfoList) {
    var xAxisModels = foundCpts.xAxisModels;
    var yAxisModels = foundCpts.yAxisModels;
    var gridModels = foundCpts.gridModels;
    var gridModelMap = createHashMap();
    var xAxesHas = {};
    var yAxesHas = {};
    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }
    each$e(xAxisModels, function(axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each$e(yAxisModels, function(axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each$e(gridModels, function(gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function(gridModel) {
      var grid2 = gridModel.coordinateSystem;
      var cartesians = [];
      each$e(grid2.getCartesians(), function(cartesian, index2) {
        if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: "grid--" + gridModel.id,
        gridModel,
        coordSysModel: gridModel,
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function(foundCpts, targetInfoList) {
    each$e(foundCpts.geoModels, function(geoModel) {
      var coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: "geo--" + geoModel.id,
        geoModel,
        coordSysModel: geoModel,
        coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
};
var targetInfoMatchers = [
  function(foundCpts, targetInfo) {
    var xAxisModel = foundCpts.xAxisModel;
    var yAxisModel = foundCpts.yAxisModel;
    var gridModel = foundCpts.gridModel;
    !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
    !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
    return gridModel && gridModel === targetInfo.gridModel;
  },
  function(foundCpts, targetInfo) {
    var geoModel = foundCpts.geoModel;
    return geoModel && geoModel === targetInfo.geoModel;
  }
];
var panelRectBuilders = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var coordSys = this.coordSys;
    var rect = coordSys.getBoundingRect().clone();
    rect.applyTransform(getTransform$1(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry$1(axisConvert, 0),
  lineY: curry$1(axisConvert, 1),
  rect: function(to, coordSys, rangeOrCoordRange, clamp2) {
    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2);
    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2);
    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    return {
      values,
      xyMinMax: values
    };
  },
  polygon: function(to, coordSys, rangeOrCoordRange, clamp2) {
    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    var values = map$1(rangeOrCoordRange, function(item) {
      var p2 = to ? coordSys.pointToData(item, clamp2) : coordSys.dataToPoint(item, clamp2);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p2[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p2[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p2[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p2[1]);
      return p2;
    });
    return {
      values,
      xyMinMax
    };
  }
};
function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  var axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
  var values = formatMinMax(map$1([0, 1], function(i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  var xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {
    values,
    xyMinMax
  };
}
var diffProcessor = {
  lineX: curry$1(axisDiffProcessor, 0),
  lineY: curry$1(axisDiffProcessor, 1),
  rect: function(values, refer, scales) {
    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
  },
  polygon: function(values, refer, scales) {
    return map$1(values, function(item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};
function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
}
function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  var sizeCurr = getSize(xyMinMaxCurr);
  var sizeOrigin = getSize(xyMinMaxOrigin);
  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}
function getSize(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}
var BrushTargetManager$1 = BrushTargetManager;
var each$6 = each$e;
var DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_");
var DataZoomFeature = function(_super) {
  __extends(DataZoomFeature2, _super);
  function DataZoomFeature2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataZoomFeature2.prototype.render = function(featureModel, ecModel, api, payload) {
    if (!this._brushController) {
      this._brushController = new BrushController$1(api.getZr());
      this._brushController.on("brush", bind$1(this._onBrush, this)).mount();
    }
    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
    updateBackBtnStatus(featureModel, ecModel);
  };
  DataZoomFeature2.prototype.onclick = function(ecModel, api, type) {
    handlers[type].call(this);
  };
  DataZoomFeature2.prototype.remove = function(ecModel, api) {
    this._brushController && this._brushController.unmount();
  };
  DataZoomFeature2.prototype.dispose = function(ecModel, api) {
    this._brushController && this._brushController.dispose();
  };
  DataZoomFeature2.prototype._onBrush = function(eventParam) {
    var areas = eventParam.areas;
    if (!eventParam.isEnd || !areas.length) {
      return;
    }
    var snapshot = {};
    var ecModel = this.ecModel;
    this._brushController.updateCovers([]);
    var brushTargetManager = new BrushTargetManager$1(makeAxisFinder(this.model), ecModel, {
      include: ["grid"]
    });
    brushTargetManager.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      var brushType = area.brushType;
      if (brushType === "rect") {
        setBatch("x", coordSys, coordRange[0]);
        setBatch("y", coordSys, coordRange[1]);
      } else {
        setBatch({
          lineX: "x",
          lineY: "y"
        }[brushType], coordSys, coordRange);
      }
    });
    push(ecModel, snapshot);
    this._dispatchZoomAction(snapshot);
    function setBatch(dimName, coordSys, minMax) {
      var axis = coordSys.getAxis(dimName);
      var axisModel = axis.model;
      var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
        minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
      }
      dataZoomModel && (snapshot[dataZoomModel.id] = {
        dataZoomId: dataZoomModel.id,
        startValue: minMax[0],
        endValue: minMax[1]
      });
    }
    function findDataZoom(dimName, axisModel, ecModel2) {
      var found;
      ecModel2.eachComponent({
        mainType: "dataZoom",
        subType: "select"
      }, function(dzModel) {
        var has2 = dzModel.getAxisModel(dimName, axisModel.componentIndex);
        has2 && (found = dzModel);
      });
      return found;
    }
  };
  DataZoomFeature2.prototype._dispatchZoomAction = function(snapshot) {
    var batch = [];
    each$6(snapshot, function(batchItem, dataZoomId) {
      batch.push(clone$3(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      batch
    });
  };
  DataZoomFeature2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      filterMode: "filter",
      icon: {
        zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
        back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
      brushStyle: {
        borderWidth: 0,
        color: "rgba(210,219,238,0.2)"
      }
    };
    return defaultOption2;
  };
  return DataZoomFeature2;
}(ToolboxFeature);
var handlers = {
  zoom: function() {
    var nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: nextActive
    });
  },
  back: function() {
    this._dispatchZoomAction(pop(this.ecModel));
  }
};
function makeAxisFinder(dzFeatureModel) {
  var setting2 = {
    xAxisIndex: dzFeatureModel.get("xAxisIndex", true),
    yAxisIndex: dzFeatureModel.get("yAxisIndex", true),
    xAxisId: dzFeatureModel.get("xAxisId", true),
    yAxisId: dzFeatureModel.get("yAxisId", true)
  };
  if (setting2.xAxisIndex == null && setting2.xAxisId == null) {
    setting2.xAxisIndex = "all";
  }
  if (setting2.yAxisIndex == null && setting2.yAxisId == null) {
    setting2.yAxisIndex = "all";
  }
  return setting2;
}
function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus("back", count(ecModel) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(featureModel, ecModel, view2, payload, api) {
  var zoomActive = view2._isZoomActive;
  if (payload && payload.type === "takeGlobalCursor") {
    zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
  }
  view2._isZoomActive = zoomActive;
  featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
  var brushTargetManager = new BrushTargetManager$1(makeAxisFinder(featureModel), ecModel, {
    include: ["grid"]
  });
  var panels = brushTargetManager.makePanelOpts(api, function(targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
  });
  view2._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
    brushType: "auto",
    brushStyle: featureModel.getModel("brushStyle").getItemStyle()
  } : false);
}
registerInternalOptionCreator("dataZoom", function(ecModel) {
  var toolboxModel = ecModel.getComponent("toolbox", 0);
  var featureDataZoomPath = ["feature", "dataZoom"];
  if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {
    return;
  }
  var dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);
  var dzOptions = [];
  var finder = makeAxisFinder(dzFeatureModel);
  var finderResult = parseFinder$1(ecModel, finder);
  each$6(finderResult.xAxisModels, function(axisModel) {
    return buildInternalOptions(axisModel, "xAxis", "xAxisIndex");
  });
  each$6(finderResult.yAxisModels, function(axisModel) {
    return buildInternalOptions(axisModel, "yAxis", "yAxisIndex");
  });
  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
    var axisIndex = axisModel.componentIndex;
    var newOpt = {
      type: "select",
      $fromToolbox: true,
      filterMode: dzFeatureModel.get("filterMode", true) || "filter",
      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
    };
    newOpt[axisIndexPropName] = axisIndex;
    dzOptions.push(newOpt);
  }
  return dzOptions;
});
var DataZoom = DataZoomFeature;
function install$e(registers) {
  registers.registerComponentModel(ToolboxModel$1);
  registers.registerComponentView(ToolboxView$1);
  registerFeature("saveAsImage", SaveAsImage$1);
  registerFeature("magicType", MagicType$1);
  registerFeature("dataView", DataView$3);
  registerFeature("dataZoom", DataZoom);
  registerFeature("restore", Restore);
  use(install$f);
}
var TooltipModel = function(_super) {
  __extends(TooltipModel2, _super);
  function TooltipModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipModel2.type;
    return _this;
  }
  TooltipModel2.type = "tooltip";
  TooltipModel2.dependencies = ["axisPointer"];
  TooltipModel2.defaultOption = {
    z: 60,
    show: true,
    showContent: true,
    trigger: "item",
    triggerOn: "mousemove|click",
    alwaysShowContent: false,
    displayMode: "single",
    renderMode: "auto",
    confine: null,
    showDelay: 0,
    hideDelay: 100,
    transitionDuration: 0.4,
    enterable: false,
    backgroundColor: "#fff",
    shadowBlur: 10,
    shadowColor: "rgba(0, 0, 0, .2)",
    shadowOffsetX: 1,
    shadowOffsetY: 2,
    borderRadius: 4,
    borderWidth: 1,
    padding: null,
    extraCssText: "",
    axisPointer: {
      type: "line",
      axis: "auto",
      animation: "auto",
      animationDurationUpdate: 200,
      animationEasingUpdate: "exponentialOut",
      crossStyle: {
        color: "#999",
        width: 1,
        type: "dashed",
        textStyle: {}
      }
    },
    textStyle: {
      color: "#666",
      fontSize: 14
    }
  };
  return TooltipModel2;
}(ComponentModel$1);
var TooltipModel$1 = TooltipModel;
function shouldTooltipConfine(tooltipModel) {
  var confineOption = tooltipModel.get("confine");
  return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
  if (!env$1.domSupported) {
    return;
  }
  var style = document.documentElement.style;
  for (var i = 0, len2 = styleProps.length; i < len2; i++) {
    if (styleProps[i] in style) {
      return styleProps[i];
    }
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }
  styleProp = toCamelCase(styleProp, true);
  var idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
  return styleVendor.toLowerCase();
}
function getComputedStyle$3(el, style) {
  var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
  return stl ? style ? stl[style] : stl : null;
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env$1.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(pos) {
  pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
  return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString$2(arrowPosition) || arrowPosition === "inside") {
    return "";
  }
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var borderWidth = tooltipModel.get("borderWidth");
  borderColor = convertToColorString(borderColor);
  var arrowPos = mirrorPos(arrowPosition);
  var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  var positionStyle = "";
  var transformStyle = CSS_TRANSFORM_VENDOR + ":";
  var rotateDeg;
  if (indexOf(["left", "right"], arrowPos) > -1) {
    positionStyle += "top:50%";
    transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
  } else {
    positionStyle += "left:50%";
    transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
  }
  var rotateRadian = rotateDeg * Math.PI / 180;
  var arrowWH = arrowSize + borderWidth;
  var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
  var borderStyle = borderColor + " solid " + borderWidth + "px;";
  var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
  return '<div style="' + styleCss.join("") + '"></div>';
}
function assembleTransition(duration, onlyFade) {
  var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
  var transitionOption = " " + duration / 2 + "s " + transitionCurve;
  var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
  if (!onlyFade) {
    transitionOption = " " + duration + "s " + transitionCurve;
    transitionText += env$1.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
  }
  return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x2, y, toString2) {
  var x0 = x2.toFixed(0) + "px";
  var y0 = y.toFixed(0) + "px";
  if (!env$1.transformSupported) {
    return toString2 ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
  }
  var is3d = env$1.transform3dSupported;
  var translate2 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
  return toString2 ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
}
function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get("fontSize");
  var color2 = textStyleModel.getTextColor();
  color2 && cssText.push("color:" + color2);
  cssText.push("font:" + textStyleModel.getFont());
  fontSize && cssText.push("line-height:" + Math.round(fontSize * 3 / 2) + "px");
  var shadowColor = textStyleModel.get("textShadowColor");
  var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
  var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
  var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
  shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
  each$e(["decoration", "align"], function(name) {
    var val = textStyleModel.get(name);
    val && cssText.push("text-" + name + ":" + val);
  });
  return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  var cssText = [];
  var transitionDuration = tooltipModel.get("transitionDuration");
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var shadowBlur = tooltipModel.get("shadowBlur");
  var shadowColor = tooltipModel.get("shadowColor");
  var shadowOffsetX = tooltipModel.get("shadowOffsetX");
  var shadowOffsetY = tooltipModel.get("shadowOffsetY");
  var textStyleModel = tooltipModel.getModel("textStyle");
  var padding = getPaddingFromTooltipModel(tooltipModel, "html");
  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
  cssText.push("box-shadow:" + boxShadow);
  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
  if (backgroundColor2) {
    cssText.push("background-color:" + backgroundColor2);
  }
  each$e(["width", "color", "radius"], function(name) {
    var borderName = "border-" + name;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
  });
  cssText.push(assembleFont(textStyleModel));
  if (padding != null) {
    cssText.push("padding:" + normalizeCssArray(padding).join("px ") + "px");
  }
  return cssText.join(";") + ";";
}
function makeStyleCoord$1(out2, zr, appendToBody, zrX, zrY) {
  var zrPainter = zr && zr.painter;
  if (appendToBody) {
    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
    if (zrViewportRoot) {
      transformLocalCoord(out2, zrViewportRoot, document.body, zrX, zrY);
    }
  } else {
    out2[0] = zrX;
    out2[1] = zrY;
    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
    if (viewportRootOffset) {
      out2[0] += viewportRootOffset.offsetLeft;
      out2[1] += viewportRootOffset.offsetTop;
    }
  }
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipHTMLContent = function() {
  function TooltipHTMLContent2(container, api, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._firstShow = true;
    this._longHide = true;
    if (env$1.wxa) {
      return null;
    }
    var el = document.createElement("div");
    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    makeStyleCoord$1(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
    if (appendToBody) {
      document.body.appendChild(el);
    } else {
      container.appendChild(el);
    }
    this._container = container;
    var self2 = this;
    el.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el.onmousemove = function(e2) {
      e2 = e2 || window.event;
      if (!self2._enterable) {
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e2, true);
        handler.dispatch("mousemove", e2);
      }
    };
    el.onmouseleave = function() {
      self2._inContent = false;
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
    };
  }
  TooltipHTMLContent2.prototype.update = function(tooltipModel) {
    var container = this._container;
    var position2 = getComputedStyle$3(container, "position");
    var domStyle = container.style;
    if (domStyle.position !== "absolute" && position2 !== "absolute") {
      domStyle.position = "relative";
    }
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this.el.className = tooltipModel.get("className") || "";
  };
  TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var el = this.el;
    var style = el.style;
    var styleCoord = this._styleCoord;
    if (!el.innerHTML) {
      style.display = "none";
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
    }
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  };
  TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
    var el = this.el;
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    var arrow2 = "";
    if (isString$2(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
      arrow2 = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }
    if (isString$2(content)) {
      el.innerHTML = content + arrow2;
    } else if (content) {
      el.innerHTML = "";
      if (!isArray$4(content)) {
        content = [content];
      }
      for (var i = 0; i < content.length; i++) {
        if (isDom(content[i]) && content[i].parentNode !== el) {
          el.appendChild(content[i]);
        }
      }
      if (arrow2 && el.childNodes.length) {
        var arrowEl = document.createElement("div");
        arrowEl.innerHTML = arrow2;
        el.appendChild(arrowEl);
      }
    }
  };
  TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipHTMLContent2.prototype.getSize = function() {
    var el = this.el;
    return [el.offsetWidth, el.offsetHeight];
  };
  TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
    var styleCoord = this._styleCoord;
    makeStyleCoord$1(styleCoord, this._zr, this._appendToBody, zrX, zrY);
    if (styleCoord[0] != null && styleCoord[1] != null) {
      var style_1 = this.el.style;
      var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each$e(transforms, function(transform2) {
        style_1[transform2[0]] = transform2[1];
      });
    }
  };
  TooltipHTMLContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipHTMLContent2.prototype.hide = function() {
    var _this = this;
    var style = this.el.style;
    style.visibility = "hidden";
    style.opacity = "0";
    env$1.transform3dSupported && (style.willChange = "");
    this._show = false;
    this._longHideTimeout = setTimeout(function() {
      return _this._longHide = true;
    }, 500);
  };
  TooltipHTMLContent2.prototype.hideLater = function(time2) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time2) {
        this._hideDelay = time2;
        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time2);
      } else {
        this.hide();
      }
    }
  };
  TooltipHTMLContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipHTMLContent2.prototype.dispose = function() {
    this.el.parentNode.removeChild(this.el);
  };
  return TooltipHTMLContent2;
}();
var TooltipHTMLContent$1 = TooltipHTMLContent;
var TooltipRichContent = function() {
  function TooltipRichContent2(api) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._zr = api.getZr();
    makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
  }
  TooltipRichContent2.prototype.update = function(tooltipModel) {
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
  };
  TooltipRichContent2.prototype.show = function() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    this.el.show();
    this._show = true;
  };
  TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    var _this = this;
    if (isObject$9(content)) {
      throwError$1("");
    }
    if (this.el) {
      this._zr.remove(this.el);
    }
    var textStyleModel = tooltipModel.getModel("textStyle");
    this.el = new ZRText$1({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor,
        textShadowColor: textStyleModel.get("textShadowColor"),
        fill: tooltipModel.get(["textStyle", "color"]),
        padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
        verticalAlign: "top",
        align: "left"
      },
      z: tooltipModel.get("z")
    });
    each$e(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
      _this.el.style[propName] = tooltipModel.get(propName);
    });
    each$e(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
      _this.el.style[propName] = textStyleModel.get(propName) || 0;
    });
    this._zr.add(this.el);
    var self2 = this;
    this.el.on("mouseover", function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    });
    this.el.on("mouseout", function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    });
  };
  TooltipRichContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipRichContent2.prototype.getSize = function() {
    var el = this.el;
    var bounding = this.el.getBoundingRect();
    var shadowOuterSize = calcShadowOuterSize(el.style);
    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
  };
  TooltipRichContent2.prototype.moveTo = function(x2, y) {
    var el = this.el;
    if (el) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, x2, y);
      x2 = styleCoord[0];
      y = styleCoord[1];
      var style = el.style;
      var borderWidth = mathMaxWith0(style.borderWidth || 0);
      var shadowOuterSize = calcShadowOuterSize(style);
      el.x = x2 + borderWidth + shadowOuterSize.left;
      el.y = y + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  };
  TooltipRichContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipRichContent2.prototype.hide = function() {
    if (this.el) {
      this.el.hide();
    }
    this._show = false;
  };
  TooltipRichContent2.prototype.hideLater = function(time2) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time2) {
        this._hideDelay = time2;
        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time2);
      } else {
        this.hide();
      }
    }
  };
  TooltipRichContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipRichContent2.prototype.dispose = function() {
    this._zr.remove(this.el);
  };
  return TooltipRichContent2;
}();
function mathMaxWith0(val) {
  return Math.max(0, val);
}
function calcShadowOuterSize(style) {
  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}
function makeStyleCoord(out2, zr, zrX, zrY) {
  out2[0] = zrX;
  out2[1] = zrY;
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipRichContent$1 = TooltipRichContent;
var proxyRect = new Rect$2({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});
var TooltipView = function(_super) {
  __extends(TooltipView2, _super);
  function TooltipView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipView2.type;
    return _this;
  }
  TooltipView2.prototype.init = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    var tooltipModel = ecModel.getComponent("tooltip");
    var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
    this._tooltipContent = renderMode === "richText" ? new TooltipRichContent$1(api) : new TooltipHTMLContent$1(api.getDom(), api, {
      appendToBody: tooltipModel.get("appendToBody", true)
    });
  };
  TooltipView2.prototype.render = function(tooltipModel, ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api;
    this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
    var tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    this._initGlobalListener();
    this._keepShow();
    if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
      createOrUpdate(this, "_updatePosition", 50, "fixRate");
    } else {
      clear$1(this, "_updatePosition");
    }
  };
  TooltipView2.prototype._initGlobalListener = function() {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get("triggerOn");
    register("itemTooltip", this._api, bind$1(function(currTrigger, e2, dispatchAction2) {
      if (triggerOn !== "none") {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e2, dispatchAction2);
        } else if (currTrigger === "leave") {
          this._hide(dispatchAction2);
        }
      }
    }, this));
  };
  TooltipView2.prototype._keepShow = function() {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api;
    if (this._lastX != null && this._lastY != null && tooltipModel.get("triggerOn") !== "none") {
      var self_1 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function() {
        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self_1._lastX,
          y: self_1._lastY,
          dataByCoordSys: self_1._lastDataByCoordSys
        });
      });
    }
  };
  TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env$1.node || !api.getDom()) {
      return;
    }
    var dispatchAction2 = makeDispatchAction(payload, api);
    this._ticket = "";
    var dataByCoordSys = payload.dataByCoordSys;
    var cmptRef = findComponentReference(payload, ecModel, api);
    if (cmptRef) {
      var rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);
      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        positionDefault: "bottom"
      }, dispatchAction2);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      getECData(el).tooltipConfig = {
        name: null,
        option: payload.tooltip
      };
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction2);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction2);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }
      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];
      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction2);
      }
    } else if (payload.x != null && payload.y != null) {
      api.dispatchAction({
        type: "updateAxisPointer",
        x: payload.x,
        y: payload.y
      });
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction2);
    }
  };
  TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;
    if (!this._alwaysShowContent && this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
    }
    this._lastX = this._lastY = this._lastDataByCoordSys = null;
    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  };
  TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (!seriesModel) {
      return;
    }
    var data = seriesModel.getData();
    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
    if (tooltipCascadedModel.get("trigger") !== "axis") {
      return;
    }
    api.dispatchAction({
      type: "updateAxisPointer",
      seriesIndex,
      dataIndex,
      position: payload.position
    });
    return true;
  };
  TooltipView2.prototype._tryShow = function(e2, dispatchAction2) {
    var el = e2.target;
    var tooltipModel = this._tooltipModel;
    if (!tooltipModel) {
      return;
    }
    this._lastX = e2.offsetX;
    this._lastY = e2.offsetY;
    var dataByCoordSys = e2.dataByCoordSys;
    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e2);
    } else if (el) {
      this._lastDataByCoordSys = null;
      var seriesDispatcher_1;
      var cmptDispatcher_1;
      findEventDispatcher(el, function(target) {
        if (getECData(target).dataIndex != null) {
          seriesDispatcher_1 = target;
          return true;
        }
        if (getECData(target).tooltipConfig != null) {
          cmptDispatcher_1 = target;
          return true;
        }
      }, true);
      if (seriesDispatcher_1) {
        this._showSeriesItemTooltip(e2, seriesDispatcher_1, dispatchAction2);
      } else if (cmptDispatcher_1) {
        this._showComponentItemTooltip(e2, cmptDispatcher_1, dispatchAction2);
      } else {
        this._hide(dispatchAction2);
      }
    } else {
      this._lastDataByCoordSys = null;
      this._hide(dispatchAction2);
    }
  };
  TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
    var delay = tooltipModel.get("showDelay");
    cb = bind$1(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  };
  TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e2) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e2.offsetX, e2.offsetY];
    var singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
    var renderMode = this._renderMode;
    var cbParamsList = [];
    var articleMarkup = createTooltipMarkup("section", {
      blocks: [],
      noHeader: true
    });
    var markupTextArrLegacy = [];
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    each$e(dataByCoordSys, function(itemCoordSys) {
      each$e(itemCoordSys.dataByAxis, function(axisItem) {
        var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
        var axisValue = axisItem.value;
        if (!axisModel || axisValue == null) {
          return;
        }
        var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        var axisSectionMarkup = createTooltipMarkup("section", {
          header: axisValueLabel,
          noHeader: !trim$1(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each$e(axisItem.seriesDataIndices, function(idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var cbParams = series.getDataParams(dataIndex);
          if (cbParams.dataIndex < 0) {
            return;
          }
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {
            value: axisValue
          });
          cbParams.axisValueLabel = axisValueLabel;
          cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
          var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          var frag = seriesTooltipResult.frag;
          if (frag) {
            var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
            axisSectionMarkup.blocks.push(valueFormatter ? extend$3({
              valueFormatter
            }, frag) : frag);
          }
          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }
          cbParamsList.push(cbParams);
        });
      });
    });
    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    var positionExpr = e2.position;
    var orderMode = singleTooltipModel.get("order");
    var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
    var allMarkupText = markupTextArrLegacy.join(blockBreak);
    this._showOrMove(singleTooltipModel, function() {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    });
  };
  TooltipView2.prototype._showSeriesItemTooltip = function(e2, dispatcher, dispatchAction2) {
    var ecModel = this._ecModel;
    var ecData = getECData(dispatcher);
    var seriesIndex = ecData.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    var dataModel = ecData.dataModel || seriesModel;
    var dataIndex = ecData.dataIndex;
    var dataType = ecData.dataType;
    var data = dataModel.getData(dataType);
    var renderMode = this._renderMode;
    var positionDefault = e2.positionDefault;
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var tooltipTrigger = tooltipModel.get("trigger");
    if (tooltipTrigger != null && tooltipTrigger !== "item") {
      return;
    }
    var params = dataModel.getDataParams(dataIndex, dataType);
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
    var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    var orderMode = tooltipModel.get("order");
    var valueFormatter = tooltipModel.get("valueFormatter");
    var frag = seriesTooltipResult.frag;
    var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend$3({
      valueFormatter
    }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
    var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
    this._showOrMove(tooltipModel, function() {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex,
      from: this.uid
    });
  };
  TooltipView2.prototype._showComponentItemTooltip = function(e2, el, dispatchAction2) {
    var ecData = getECData(el);
    var tooltipConfig = ecData.tooltipConfig;
    var tooltipOpt = tooltipConfig.option || {};
    if (isString$2(tooltipOpt)) {
      var content = tooltipOpt;
      tooltipOpt = {
        content,
        formatter: content
      };
    }
    var tooltipModelCascade = [tooltipOpt];
    var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    }
    tooltipModelCascade.push({
      formatter: tooltipOpt.content
    });
    var positionDefault = e2.positionDefault;
    var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var defaultHtml = subTooltipModel.get("content");
    var asyncTicket = Math.random() + "";
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    this._showOrMove(subTooltipModel, function() {
      var formatterParams = clone$3(subTooltipModel.get("formatterParams") || {});
      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      from: this.uid
    });
  };
  TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x2, y, positionExpr, el, markupStyleCreator) {
    this._ticket = "";
    if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
      return;
    }
    var tooltipContent = this._tooltipContent;
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    var formatter2 = tooltipModel.get("formatter");
    positionExpr = positionExpr || tooltipModel.get("position");
    var html2 = defaultHtml;
    var nearPoint = this._getNearestPoint([x2, y], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
    var nearPointColor = nearPoint.color;
    if (formatter2) {
      if (isString$2(formatter2)) {
        var useUTC = tooltipModel.ecModel.get("useUTC");
        var params0 = isArray$4(params) ? params[0] : params;
        var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
        html2 = formatter2;
        if (isTimeAxis) {
          html2 = format$1(params0.axisValue, html2, useUTC);
        }
        html2 = formatTpl(html2, params, true);
      } else if (isFunction$2(formatter2)) {
        var callback = bind$1(function(cbTicket, html3) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html3, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
            this._updatePosition(tooltipModel, positionExpr, x2, y, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html2 = formatter2(params, asyncTicket, callback);
      } else {
        html2 = formatter2;
      }
    }
    tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);
    this._updatePosition(tooltipModel, positionExpr, x2, y, tooltipContent, params, el);
  };
  TooltipView2.prototype._getNearestPoint = function(point, tooltipDataParams, trigger2, borderColor) {
    if (trigger2 === "axis" || isArray$4(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
      };
    }
    if (!isArray$4(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  };
  TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x2, y, content, params, el) {
    var viewWidth = this._api.getWidth();
    var viewHeight = this._api.getHeight();
    positionExpr = positionExpr || tooltipModel.get("position");
    var contentSize = content.getSize();
    var align = tooltipModel.get("align");
    var vAlign = tooltipModel.get("verticalAlign");
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);
    if (isFunction$2(positionExpr)) {
      positionExpr = positionExpr([x2, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }
    if (isArray$4(positionExpr)) {
      x2 = parsePercent(positionExpr[0], viewWidth);
      y = parsePercent(positionExpr[1], viewHeight);
    } else if (isObject$9(positionExpr)) {
      var boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      var layoutRect = getLayoutRect$1(boxLayoutPosition, {
        width: viewWidth,
        height: viewHeight
      });
      x2 = layoutRect.x;
      y = layoutRect.y;
      align = null;
      vAlign = null;
    } else if (isString$2(positionExpr) && el) {
      var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
      x2 = pos[0];
      y = pos[1];
    } else {
      var pos = refixTooltipPosition(x2, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
      x2 = pos[0];
      y = pos[1];
    }
    align && (x2 -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
    if (shouldTooltipConfine(tooltipModel)) {
      var pos = confineTooltipPosition(x2, y, content, viewWidth, viewHeight);
      x2 = pos[0];
      y = pos[1];
    }
    content.moveTo(x2, y);
  };
  TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
    var lastCoordSys = this._lastDataByCoordSys;
    var lastCbParamsList = this._cbParamsList;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each$e(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each$e(lastDataByAxis, function(lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each$e(lastIndices, function(lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
        lastCbParamsList && each$e(lastItem.seriesDataIndices, function(idxItem) {
          var seriesIdx = idxItem.seriesIndex;
          var cbParams = cbParamsList[seriesIdx];
          var lastCbParams = lastCbParamsList[seriesIdx];
          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  };
  TooltipView2.prototype._hide = function(dispatchAction2) {
    this._lastDataByCoordSys = null;
    dispatchAction2({
      type: "hideTip",
      from: this.uid
    });
  };
  TooltipView2.prototype.dispose = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    clear$1(this, "_updatePosition");
    this._tooltipContent.dispose();
    unregister("itemTooltip", api);
  };
  TooltipView2.type = "tooltip";
  return TooltipView2;
}(ComponentView$1);
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  var ecModel = globalTooltipModel.ecModel;
  var resultModel;
  if (defaultTooltipOption) {
    resultModel = new Model$1(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model$1(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }
  for (var i = modelCascade.length - 1; i >= 0; i--) {
    var tooltipOpt = modelCascade[i];
    if (tooltipOpt) {
      if (tooltipOpt instanceof Model$1) {
        tooltipOpt = tooltipOpt.get("tooltip", true);
      }
      if (isString$2(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }
      if (tooltipOpt) {
        resultModel = new Model$1(tooltipOpt, resultModel, ecModel);
      }
    }
  }
  return resultModel;
}
function makeDispatchAction(payload, api) {
  return payload.dispatchAction || bind$1(api.dispatchAction, api);
}
function refixTooltipPosition(x2, y, content, viewWidth, viewHeight, gapH, gapV) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];
  if (gapH != null) {
    if (x2 + width + gapH + 2 > viewWidth) {
      x2 -= width + gapH;
    } else {
      x2 += gapH;
    }
  }
  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }
  return [x2, y];
}
function confineTooltipPosition(x2, y, content, viewWidth, viewHeight) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];
  x2 = Math.min(x2 + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x2 = Math.max(x2, 0);
  y = Math.max(y, 0);
  return [x2, y];
}
function calcTooltipPosition(position2, rect, contentSize, borderWidth) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var offset2 = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  var x2 = 0;
  var y = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  switch (position2) {
    case "inside":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "top":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - offset2;
      break;
    case "bottom":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + offset2;
      break;
    case "left":
      x2 = rect.x - domWidth - offset2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "right":
      x2 = rect.x + rectWidth + offset2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }
  return [x2, y];
}
function isCenterAlign(align) {
  return align === "center" || align === "middle";
}
function findComponentReference(payload, ecModel, api) {
  var queryOptionMap = preParseFinder(payload).queryOptionMap;
  var componentMainType = queryOptionMap.keys()[0];
  if (!componentMainType || componentMainType === "series") {
    return;
  }
  var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
    useDefault: false,
    enableAll: false,
    enableNone: false
  });
  var model = queryResult.models[0];
  if (!model) {
    return;
  }
  var view2 = api.getViewOfComponentModel(model);
  var el;
  view2.group.traverse(function(subEl) {
    var tooltipConfig = getECData(subEl).tooltipConfig;
    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el = subEl;
      return true;
    }
  });
  if (el) {
    return {
      componentMainType,
      componentIndex: model.componentIndex,
      el
    };
  }
}
var TooltipView$1 = TooltipView;
function install$d(registers) {
  use(install$k);
  registers.registerComponentModel(TooltipModel$1);
  registers.registerComponentView(TooltipView$1);
  registers.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop$2);
  registers.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop$2);
}
var each$5 = each$e;
function hasKeys(obj) {
  if (obj) {
    for (var name_1 in obj) {
      if (obj.hasOwnProperty(name_1)) {
        return true;
      }
    }
  }
}
function createVisualMappings(option, stateList, supplementVisualOption) {
  var visualMappings = {};
  each$5(stateList, function(state) {
    var mappings = visualMappings[state] = createMappings();
    each$5(option[state], function(visualData, visualType) {
      if (!VisualMapping$1.isValidType(visualType)) {
        return;
      }
      var mappingOption = {
        type: visualType,
        visual: visualData
      };
      supplementVisualOption && supplementVisualOption(mappingOption, state);
      mappings[visualType] = new VisualMapping$1(mappingOption);
      if (visualType === "opacity") {
        mappingOption = clone$3(mappingOption);
        mappingOption.type = "colorAlpha";
        mappings.__hidden.__alphaForOpacity = new VisualMapping$1(mappingOption);
      }
    });
  });
  return visualMappings;
  function createMappings() {
    var Creater = function() {
    };
    Creater.prototype.__hidden = Creater.prototype;
    var obj = new Creater();
    return obj;
  }
}
function replaceVisualOption(thisOption, newOption, keys2) {
  var has2;
  each$e(keys2, function(key2) {
    if (newOption.hasOwnProperty(key2) && hasKeys(newOption[key2])) {
      has2 = true;
    }
  });
  has2 && each$e(keys2, function(key2) {
    if (newOption.hasOwnProperty(key2) && hasKeys(newOption[key2])) {
      thisOption[key2] = clone$3(newOption[key2]);
    } else {
      delete thisOption[key2];
    }
  });
}
function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
  var visualTypesMap = {};
  each$e(stateList, function(state) {
    var visualTypes = VisualMapping$1.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  return {
    progress: function progress(params, data) {
      var dimIndex;
      if (dim != null) {
        dimIndex = data.getDimensionIndex(dim);
      }
      function getVisual(key2) {
        return getItemVisualFromData(data, dataIndex, key2);
      }
      function setVisual(key2, value2) {
        setItemVisualFromData(data, dataIndex, key2, value2);
      }
      var dataIndex;
      var store = data.getStore();
      while ((dataIndex = params.next()) != null) {
        var rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }
        var value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
        var valueState = getValueState(value);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];
        for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
  };
}
var TitleModel = function(_super) {
  __extends(TitleModel2, _super);
  function TitleModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  TitleModel2.type = "title";
  TitleModel2.defaultOption = {
    z: 6,
    show: true,
    text: "",
    target: "blank",
    subtext: "",
    subtarget: "blank",
    left: 0,
    top: 0,
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: "bold",
      color: "#464646"
    },
    subtextStyle: {
      fontSize: 12,
      color: "#6E7079"
    }
  };
  return TitleModel2;
}(ComponentModel$1);
var TitleView = function(_super) {
  __extends(TitleView2, _super);
  function TitleView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleView2.type;
    return _this;
  }
  TitleView2.prototype.render = function(titleModel, ecModel, api) {
    this.group.removeAll();
    if (!titleModel.get("show")) {
      return;
    }
    var group = this.group;
    var textStyleModel = titleModel.getModel("textStyle");
    var subtextStyleModel = titleModel.getModel("subtextStyle");
    var textAlign = titleModel.get("textAlign");
    var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
    var textEl = new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: titleModel.get("text"),
        fill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get("subtext");
    var subTextEl = new ZRText$1({
      style: createTextStyle$1(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get("itemGap"),
        verticalAlign: "top"
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link2 = titleModel.get("link");
    var sublink = titleModel.get("sublink");
    var triggerEvent = titleModel.get("triggerEvent", true);
    textEl.silent = !link2 && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;
    if (link2) {
      textEl.on("click", function() {
        windowOpen(link2, "_" + titleModel.get("target"));
      });
    }
    if (sublink) {
      subTextEl.on("click", function() {
        windowOpen(sublink, "_" + titleModel.get("subtarget"));
      });
    }
    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
      componentType: "title",
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl);
    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect$1(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get("padding"));
    if (!textAlign) {
      textAlign = titleModel.get("left") || titleModel.get("right");
      if (textAlign === "middle") {
        textAlign = "center";
      }
      if (textAlign === "right") {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === "center") {
        layoutRect.x += layoutRect.width / 2;
      }
    }
    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
      if (textVerticalAlign === "center") {
        textVerticalAlign = "middle";
      }
      if (textVerticalAlign === "bottom") {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === "middle") {
        layoutRect.y += layoutRect.height / 2;
      }
      textVerticalAlign = textVerticalAlign || "top";
    }
    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    var alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle);
    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(["color", "opacity"]);
    style.fill = titleModel.get("backgroundColor");
    var rect = new Rect$2({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get("borderRadius")
      },
      style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  };
  TitleView2.type = "title";
  return TitleView2;
}(ComponentView$1);
function install$c(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}
var TimelineModel = function(_super) {
  __extends(TimelineModel2, _super);
  function TimelineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TimelineModel2.type;
    _this.layoutMode = "box";
    return _this;
  }
  TimelineModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    this._initData();
  };
  TimelineModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    this._initData();
  };
  TimelineModel2.prototype.setCurrentIndex = function(currentIndex) {
    if (currentIndex == null) {
      currentIndex = this.option.currentIndex;
    }
    var count2 = this._data.count();
    if (this.option.loop) {
      currentIndex = (currentIndex % count2 + count2) % count2;
    } else {
      currentIndex >= count2 && (currentIndex = count2 - 1);
      currentIndex < 0 && (currentIndex = 0);
    }
    this.option.currentIndex = currentIndex;
  };
  TimelineModel2.prototype.getCurrentIndex = function() {
    return this.option.currentIndex;
  };
  TimelineModel2.prototype.isIndexMax = function() {
    return this.getCurrentIndex() >= this._data.count() - 1;
  };
  TimelineModel2.prototype.setPlayState = function(state) {
    this.option.autoPlay = !!state;
  };
  TimelineModel2.prototype.getPlayState = function() {
    return !!this.option.autoPlay;
  };
  TimelineModel2.prototype._initData = function() {
    var thisOption = this.option;
    var dataArr = thisOption.data || [];
    var axisType = thisOption.axisType;
    var names2 = this._names = [];
    var processedDataArr;
    if (axisType === "category") {
      processedDataArr = [];
      each$e(dataArr, function(item, index2) {
        var value = convertOptionIdName(getDataItemValue(item), "");
        var newItem;
        if (isObject$9(item)) {
          newItem = clone$3(item);
          newItem.value = index2;
        } else {
          newItem = index2;
        }
        processedDataArr.push(newItem);
        names2.push(value);
      });
    } else {
      processedDataArr = dataArr;
    }
    var dimType = {
      category: "ordinal",
      time: "time",
      value: "number"
    }[axisType] || "number";
    var data = this._data = new SeriesData$1([{
      name: "value",
      type: dimType
    }], this);
    data.initData(processedDataArr, names2);
  };
  TimelineModel2.prototype.getData = function() {
    return this._data;
  };
  TimelineModel2.prototype.getCategories = function() {
    if (this.get("axisType") === "category") {
      return this._names.slice();
    }
  };
  TimelineModel2.type = "timeline";
  TimelineModel2.defaultOption = {
    z: 4,
    show: true,
    axisType: "time",
    realtime: true,
    left: "20%",
    top: null,
    right: "20%",
    bottom: 0,
    width: null,
    height: 40,
    padding: 5,
    controlPosition: "left",
    autoPlay: false,
    rewind: false,
    loop: true,
    playInterval: 2e3,
    currentIndex: 0,
    itemStyle: {},
    label: {
      color: "#000"
    },
    data: []
  };
  return TimelineModel2;
}(ComponentModel$1);
var TimelineModel$1 = TimelineModel;
var SliderTimelineModel = function(_super) {
  __extends(SliderTimelineModel2, _super);
  function SliderTimelineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderTimelineModel2.type;
    return _this;
  }
  SliderTimelineModel2.type = "timeline.slider";
  SliderTimelineModel2.defaultOption = inheritDefaultOption(TimelineModel$1.defaultOption, {
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    orient: "horizontal",
    inverse: false,
    tooltip: {
      trigger: "item"
    },
    symbol: "circle",
    symbolSize: 12,
    lineStyle: {
      show: true,
      width: 2,
      color: "#DAE1F5"
    },
    label: {
      position: "auto",
      show: true,
      interval: "auto",
      rotate: 0,
      color: "#A4B1D7"
    },
    itemStyle: {
      color: "#A4B1D7",
      borderWidth: 1
    },
    checkpointStyle: {
      symbol: "circle",
      symbolSize: 15,
      color: "#316bf3",
      borderColor: "#fff",
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: "rgba(0, 0, 0, 0.3)",
      animation: true,
      animationDuration: 300,
      animationEasing: "quinticInOut"
    },
    controlStyle: {
      show: true,
      showPlayBtn: true,
      showPrevBtn: true,
      showNextBtn: true,
      itemSize: 24,
      itemGap: 12,
      position: "left",
      playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
      stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
      nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
      prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
      prevBtnSize: 18,
      nextBtnSize: 18,
      color: "#A4B1D7",
      borderColor: "#A4B1D7",
      borderWidth: 1
    },
    emphasis: {
      label: {
        show: true,
        color: "#6f778d"
      },
      itemStyle: {
        color: "#316BF3"
      },
      controlStyle: {
        color: "#316BF3",
        borderColor: "#316BF3",
        borderWidth: 2
      }
    },
    progress: {
      lineStyle: {
        color: "#316BF3"
      },
      itemStyle: {
        color: "#316BF3"
      },
      label: {
        color: "#6f778d"
      }
    },
    data: []
  });
  return SliderTimelineModel2;
}(TimelineModel$1);
mixin(SliderTimelineModel, DataFormatMixin.prototype);
var SliderTimelineModel$1 = SliderTimelineModel;
var TimelineView = function(_super) {
  __extends(TimelineView2, _super);
  function TimelineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TimelineView2.type;
    return _this;
  }
  TimelineView2.type = "timeline";
  return TimelineView2;
}(ComponentView$1);
var TimelineView$1 = TimelineView;
var TimelineAxis = function(_super) {
  __extends(TimelineAxis2, _super);
  function TimelineAxis2(dim, scale2, coordExtent, axisType) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.type = axisType || "value";
    return _this;
  }
  TimelineAxis2.prototype.getLabelModel = function() {
    return this.model.getModel("label");
  };
  TimelineAxis2.prototype.isHorizontal = function() {
    return this.model.get("orient") === "horizontal";
  };
  return TimelineAxis2;
}(Axis$1);
var TimelineAxis$1 = TimelineAxis;
var PI$1 = Math.PI;
var labelDataIndexStore = makeInner();
var SliderTimelineView = function(_super) {
  __extends(SliderTimelineView2, _super);
  function SliderTimelineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderTimelineView2.type;
    return _this;
  }
  SliderTimelineView2.prototype.init = function(ecModel, api) {
    this.api = api;
  };
  SliderTimelineView2.prototype.render = function(timelineModel, ecModel, api) {
    this.model = timelineModel;
    this.api = api;
    this.ecModel = ecModel;
    this.group.removeAll();
    if (timelineModel.get("show", true)) {
      var layoutInfo_1 = this._layout(timelineModel, api);
      var mainGroup_1 = this._createGroup("_mainGroup");
      var labelGroup = this._createGroup("_labelGroup");
      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);
      timelineModel.formatTooltip = function(dataIndex) {
        var name = axis_1.scale.getLabel({
          value: dataIndex
        });
        return createTooltipMarkup("nameValue", {
          noName: true,
          value: name
        });
      };
      each$e(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name) {
        this["_render" + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);
      }, this);
      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);
      this._position(layoutInfo_1, timelineModel);
    }
    this._doPlayStop();
    this._updateTicksStatus();
  };
  SliderTimelineView2.prototype.remove = function() {
    this._clearTimer();
    this.group.removeAll();
  };
  SliderTimelineView2.prototype.dispose = function() {
    this._clearTimer();
  };
  SliderTimelineView2.prototype._layout = function(timelineModel, api) {
    var labelPosOpt = timelineModel.get(["label", "position"]);
    var orient = timelineModel.get("orient");
    var viewRect2 = getViewRect(timelineModel, api);
    var parsedLabelPos;
    if (labelPosOpt == null || labelPosOpt === "auto") {
      parsedLabelPos = orient === "horizontal" ? viewRect2.y + viewRect2.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect2.x + viewRect2.width / 2 < api.getWidth() / 2 ? "+" : "-";
    } else if (isString$2(labelPosOpt)) {
      parsedLabelPos = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[orient][labelPosOpt];
    } else {
      parsedLabelPos = labelPosOpt;
    }
    var labelAlignMap = {
      horizontal: "center",
      vertical: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "left" : "right"
    };
    var labelBaselineMap = {
      horizontal: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "top" : "bottom",
      vertical: "middle"
    };
    var rotationMap = {
      horizontal: 0,
      vertical: PI$1 / 2
    };
    var mainLength = orient === "vertical" ? viewRect2.height : viewRect2.width;
    var controlModel = timelineModel.getModel("controlStyle");
    var showControl = controlModel.get("show", true);
    var controlSize = showControl ? controlModel.get("itemSize") : 0;
    var controlGap = showControl ? controlModel.get("itemGap") : 0;
    var sizePlusGap = controlSize + controlGap;
    var labelRotation = timelineModel.get(["label", "rotate"]) || 0;
    labelRotation = labelRotation * PI$1 / 180;
    var playPosition;
    var prevBtnPosition;
    var nextBtnPosition;
    var controlPosition = controlModel.get("position", true);
    var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
    var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
    var showNextBtn = showControl && controlModel.get("showNextBtn", true);
    var xLeft = 0;
    var xRight = mainLength;
    if (controlPosition === "left" || controlPosition === "bottom") {
      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    } else {
      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    }
    var axisExtent = [xLeft, xRight];
    if (timelineModel.get("inverse")) {
      axisExtent.reverse();
    }
    return {
      viewRect: viewRect2,
      mainLength,
      orient,
      rotation: rotationMap[orient],
      labelRotation,
      labelPosOpt: parsedLabelPos,
      labelAlign: timelineModel.get(["label", "align"]) || labelAlignMap[orient],
      labelBaseline: timelineModel.get(["label", "verticalAlign"]) || timelineModel.get(["label", "baseline"]) || labelBaselineMap[orient],
      playPosition,
      prevBtnPosition,
      nextBtnPosition,
      axisExtent,
      controlSize,
      controlGap
    };
  };
  SliderTimelineView2.prototype._position = function(layoutInfo, timelineModel) {
    var mainGroup = this._mainGroup;
    var labelGroup = this._labelGroup;
    var viewRect2 = layoutInfo.viewRect;
    if (layoutInfo.orient === "vertical") {
      var m2 = create();
      var rotateOriginX = viewRect2.x;
      var rotateOriginY = viewRect2.y + viewRect2.height;
      translate$2(m2, m2, [-rotateOriginX, -rotateOriginY]);
      rotate(m2, m2, -PI$1 / 2);
      translate$2(m2, m2, [rotateOriginX, rotateOriginY]);
      viewRect2 = viewRect2.clone();
      viewRect2.applyTransform(m2);
    }
    var viewBound = getBound(viewRect2);
    var mainBound = getBound(mainGroup.getBoundingRect());
    var labelBound = getBound(labelGroup.getBoundingRect());
    var mainPosition = [mainGroup.x, mainGroup.y];
    var labelsPosition = [labelGroup.x, labelGroup.y];
    labelsPosition[0] = mainPosition[0] = viewBound[0][0];
    var labelPosOpt = layoutInfo.labelPosOpt;
    if (labelPosOpt == null || isString$2(labelPosOpt)) {
      var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
    } else {
      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      labelsPosition[1] = mainPosition[1] + labelPosOpt;
    }
    mainGroup.setPosition(mainPosition);
    labelGroup.setPosition(labelsPosition);
    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
    setOrigin(mainGroup);
    setOrigin(labelGroup);
    function setOrigin(targetGroup) {
      targetGroup.originX = viewBound[0][0] - targetGroup.x;
      targetGroup.originY = viewBound[1][0] - targetGroup.y;
    }
    function getBound(rect) {
      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
    }
    function toBound(fromPos, from, to, dimIdx, boundIdx) {
      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
    }
  };
  SliderTimelineView2.prototype._createAxis = function(layoutInfo, timelineModel) {
    var data = timelineModel.getData();
    var axisType = timelineModel.get("axisType");
    var scale2 = createScaleByModel(timelineModel, axisType);
    scale2.getTicks = function() {
      return data.mapArray(["value"], function(value) {
        return {
          value
        };
      });
    };
    var dataExtent = data.getDataExtent("value");
    scale2.setExtent(dataExtent[0], dataExtent[1]);
    scale2.calcNiceTicks();
    var axis = new TimelineAxis$1("value", scale2, layoutInfo.axisExtent, axisType);
    axis.model = timelineModel;
    return axis;
  };
  SliderTimelineView2.prototype._createGroup = function(key2) {
    var newGroup = this[key2] = new Group$3();
    this.group.add(newGroup);
    return newGroup;
  };
  SliderTimelineView2.prototype._renderAxisLine = function(layoutInfo, group, axis, timelineModel) {
    var axisExtent = axis.getExtent();
    if (!timelineModel.get(["lineStyle", "show"])) {
      return;
    }
    var line = new Line$1({
      shape: {
        x1: axisExtent[0],
        y1: 0,
        x2: axisExtent[1],
        y2: 0
      },
      style: extend$3({
        lineCap: "round"
      }, timelineModel.getModel("lineStyle").getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(line);
    var progressLine = this._progressLine = new Line$1({
      shape: {
        x1: axisExtent[0],
        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
        y1: 0,
        y2: 0
      },
      style: defaults$1({
        lineCap: "round",
        lineWidth: line.style.lineWidth
      }, timelineModel.getModel(["progress", "lineStyle"]).getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(progressLine);
  };
  SliderTimelineView2.prototype._renderAxisTick = function(layoutInfo, group, axis, timelineModel) {
    var _this = this;
    var data = timelineModel.getData();
    var ticks = axis.scale.getTicks();
    this._tickSymbols = [];
    each$e(ticks, function(tick) {
      var tickCoord = axis.dataToCoord(tick.value);
      var itemModel = data.getItemModel(tick.value);
      var itemStyleModel = itemModel.getModel("itemStyle");
      var hoverStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
      var progressStyleModel = itemModel.getModel(["progress", "itemStyle"]);
      var symbolOpt = {
        x: tickCoord,
        y: 0,
        onclick: bind$1(_this._changeTimeline, _this, tick.value)
      };
      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
      el.ensureState("emphasis").style = hoverStyleModel.getItemStyle();
      el.ensureState("progress").style = progressStyleModel.getItemStyle();
      enableHoverEmphasis(el);
      var ecData = getECData(el);
      if (itemModel.get("tooltip")) {
        ecData.dataIndex = tick.value;
        ecData.dataModel = timelineModel;
      } else {
        ecData.dataIndex = ecData.dataModel = null;
      }
      _this._tickSymbols.push(el);
    });
  };
  SliderTimelineView2.prototype._renderAxisLabel = function(layoutInfo, group, axis, timelineModel) {
    var _this = this;
    var labelModel = axis.getLabelModel();
    if (!labelModel.get("show")) {
      return;
    }
    var data = timelineModel.getData();
    var labels = axis.getViewLabels();
    this._tickLabels = [];
    each$e(labels, function(labelItem) {
      var dataIndex = labelItem.tickValue;
      var itemModel = data.getItemModel(dataIndex);
      var normalLabelModel = itemModel.getModel("label");
      var hoverLabelModel = itemModel.getModel(["emphasis", "label"]);
      var progressLabelModel = itemModel.getModel(["progress", "label"]);
      var tickCoord = axis.dataToCoord(labelItem.tickValue);
      var textEl = new ZRText$1({
        x: tickCoord,
        y: 0,
        rotation: layoutInfo.labelRotation - layoutInfo.rotation,
        onclick: bind$1(_this._changeTimeline, _this, dataIndex),
        silent: false,
        style: createTextStyle$1(normalLabelModel, {
          text: labelItem.formattedLabel,
          align: layoutInfo.labelAlign,
          verticalAlign: layoutInfo.labelBaseline
        })
      });
      textEl.ensureState("emphasis").style = createTextStyle$1(hoverLabelModel);
      textEl.ensureState("progress").style = createTextStyle$1(progressLabelModel);
      group.add(textEl);
      enableHoverEmphasis(textEl);
      labelDataIndexStore(textEl).dataIndex = dataIndex;
      _this._tickLabels.push(textEl);
    });
  };
  SliderTimelineView2.prototype._renderControl = function(layoutInfo, group, axis, timelineModel) {
    var controlSize = layoutInfo.controlSize;
    var rotation = layoutInfo.rotation;
    var itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
    var hoverStyle = timelineModel.getModel(["emphasis", "controlStyle"]).getItemStyle();
    var playState = timelineModel.getPlayState();
    var inverse = timelineModel.get("inverse", true);
    makeBtn(layoutInfo.nextBtnPosition, "next", bind$1(this._changeTimeline, this, inverse ? "-" : "+"));
    makeBtn(layoutInfo.prevBtnPosition, "prev", bind$1(this._changeTimeline, this, inverse ? "+" : "-"));
    makeBtn(layoutInfo.playPosition, playState ? "stop" : "play", bind$1(this._handlePlayClick, this, !playState), true);
    function makeBtn(position2, iconName, onclick, willRotate) {
      if (!position2) {
        return;
      }
      var iconSize = parsePercent$1(retrieve2(timelineModel.get(["controlStyle", iconName + "BtnSize"]), controlSize), controlSize);
      var rect = [0, -iconSize / 2, iconSize, iconSize];
      var btn = makeControlIcon(timelineModel, iconName + "Icon", rect, {
        x: position2[0],
        y: position2[1],
        originX: controlSize / 2,
        originY: 0,
        rotation: willRotate ? -rotation : 0,
        rectHover: true,
        style: itemStyle,
        onclick
      });
      btn.ensureState("emphasis").style = hoverStyle;
      group.add(btn);
      enableHoverEmphasis(btn);
    }
  };
  SliderTimelineView2.prototype._renderCurrentPointer = function(layoutInfo, group, axis, timelineModel) {
    var data = timelineModel.getData();
    var currentIndex = timelineModel.getCurrentIndex();
    var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
    var me = this;
    var callback = {
      onCreate: function(pointer2) {
        pointer2.draggable = true;
        pointer2.drift = bind$1(me._handlePointerDrag, me);
        pointer2.ondragend = bind$1(me._handlePointerDragend, me);
        pointerMoveTo(pointer2, me._progressLine, currentIndex, axis, timelineModel, true);
      },
      onUpdate: function(pointer2) {
        pointerMoveTo(pointer2, me._progressLine, currentIndex, axis, timelineModel);
      }
    };
    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
  };
  SliderTimelineView2.prototype._handlePlayClick = function(nextState) {
    this._clearTimer();
    this.api.dispatchAction({
      type: "timelinePlayChange",
      playState: nextState,
      from: this.uid
    });
  };
  SliderTimelineView2.prototype._handlePointerDrag = function(dx, dy, e2) {
    this._clearTimer();
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY]);
  };
  SliderTimelineView2.prototype._handlePointerDragend = function(e2) {
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY], true);
  };
  SliderTimelineView2.prototype._pointerChangeTimeline = function(mousePos, trigger2) {
    var toCoord = this._toAxisCoord(mousePos)[0];
    var axis = this._axis;
    var axisExtent = asc$2(axis.getExtent().slice());
    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
    this._currentPointer.x = toCoord;
    this._currentPointer.markRedraw();
    this._progressLine.shape.x2 = toCoord;
    this._progressLine.dirty();
    var targetDataIndex = this._findNearestTick(toCoord);
    var timelineModel = this.model;
    if (trigger2 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
      this._changeTimeline(targetDataIndex);
    }
  };
  SliderTimelineView2.prototype._doPlayStop = function() {
    var _this = this;
    this._clearTimer();
    if (this.model.getPlayState()) {
      this._timer = setTimeout(function() {
        var timelineModel = _this.model;
        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval"));
    }
  };
  SliderTimelineView2.prototype._toAxisCoord = function(vertex) {
    var trans = this._mainGroup.getLocalTransform();
    return applyTransform(vertex, trans, true);
  };
  SliderTimelineView2.prototype._findNearestTick = function(axisCoord) {
    var data = this.model.getData();
    var dist2 = Infinity;
    var targetDataIndex;
    var axis = this._axis;
    data.each(["value"], function(value, dataIndex) {
      var coord = axis.dataToCoord(value);
      var d2 = Math.abs(coord - axisCoord);
      if (d2 < dist2) {
        dist2 = d2;
        targetDataIndex = dataIndex;
      }
    });
    return targetDataIndex;
  };
  SliderTimelineView2.prototype._clearTimer = function() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  };
  SliderTimelineView2.prototype._changeTimeline = function(nextIndex) {
    var currentIndex = this.model.getCurrentIndex();
    if (nextIndex === "+") {
      nextIndex = currentIndex + 1;
    } else if (nextIndex === "-") {
      nextIndex = currentIndex - 1;
    }
    this.api.dispatchAction({
      type: "timelineChange",
      currentIndex: nextIndex,
      from: this.uid
    });
  };
  SliderTimelineView2.prototype._updateTicksStatus = function() {
    var currentIndex = this.model.getCurrentIndex();
    var tickSymbols = this._tickSymbols;
    var tickLabels = this._tickLabels;
    if (tickSymbols) {
      for (var i = 0; i < tickSymbols.length; i++) {
        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState("progress", i < currentIndex);
      }
    }
    if (tickLabels) {
      for (var i = 0; i < tickLabels.length; i++) {
        tickLabels && tickLabels[i] && tickLabels[i].toggleState("progress", labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);
      }
    }
  };
  SliderTimelineView2.type = "timeline.slider";
  return SliderTimelineView2;
}(TimelineView$1);
function createScaleByModel(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new IntervalScale$1();
    }
  }
}
function getViewRect(model, api) {
  return getLayoutRect$1(model.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  }, model.get("padding"));
}
function makeControlIcon(timelineModel, objPath, rect, opts) {
  var style = opts.style;
  var icon = createIcon(timelineModel.get(["controlStyle", objPath]), opts || {}, new BoundingRect$1(rect[0], rect[1], rect[2], rect[3]));
  if (style) {
    icon.setStyle(style);
  }
  return icon;
}
function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
  var color2 = itemStyleModel.get("color");
  if (!symbol) {
    var symbolType = hostModel.get("symbol");
    symbol = createSymbol(symbolType, -1, -1, 2, 2, color2);
    symbol.setStyle("strokeNoScale", true);
    group.add(symbol);
    callback && callback.onCreate(symbol);
  } else {
    symbol.setColor(color2);
    group.add(symbol);
    callback && callback.onUpdate(symbol);
  }
  var itemStyle = itemStyleModel.getItemStyle(["color"]);
  symbol.setStyle(itemStyle);
  opt = merge({
    rectHover: true,
    z2: 100
  }, opt, true);
  var symbolSize = normalizeSymbolSize(hostModel.get("symbolSize"));
  opt.scaleX = symbolSize[0] / 2;
  opt.scaleY = symbolSize[1] / 2;
  var symbolOffset = normalizeSymbolOffset(hostModel.get("symbolOffset"), symbolSize);
  if (symbolOffset) {
    opt.x = (opt.x || 0) + symbolOffset[0];
    opt.y = (opt.y || 0) + symbolOffset[1];
  }
  var symbolRotate = hostModel.get("symbolRotate");
  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  symbol.attr(opt);
  symbol.updateTransform();
  return symbol;
}
function pointerMoveTo(pointer2, progressLine, dataIndex, axis, timelineModel, noAnimation) {
  if (pointer2.dragging) {
    return;
  }
  var pointerModel = timelineModel.getModel("checkpointStyle");
  var toCoord = axis.dataToCoord(timelineModel.getData().get("value", dataIndex));
  if (noAnimation || !pointerModel.get("animation", true)) {
    pointer2.attr({
      x: toCoord,
      y: 0
    });
    progressLine && progressLine.attr({
      shape: {
        x2: toCoord
      }
    });
  } else {
    var animationCfg = {
      duration: pointerModel.get("animationDuration", true),
      easing: pointerModel.get("animationEasing", true)
    };
    pointer2.stopAnimation(null, true);
    pointer2.animateTo({
      x: toCoord,
      y: 0
    }, animationCfg);
    progressLine && progressLine.animateTo({
      shape: {
        x2: toCoord
      }
    }, animationCfg);
  }
}
var SliderTimelineView$1 = SliderTimelineView;
function installTimelineAction(registers) {
  registers.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel, api) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);
      if (!timelineModel.get("loop", true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
        timelineModel.setPlayState(false);
        api.dispatchAction({
          type: "timelinePlayChange",
          playState: false,
          from: payload.from
        });
      }
    }
    ecModel.resetOption("timeline", {
      replaceMerge: timelineModel.get("replaceMerge", true)
    });
    return defaults$1({
      currentIndex: timelineModel.option.currentIndex
    }, payload);
  });
  registers.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(payload, ecModel) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
}
function timelinePreprocessor(option) {
  var timelineOpt = option && option.timeline;
  if (!isArray$4(timelineOpt)) {
    timelineOpt = timelineOpt ? [timelineOpt] : [];
  }
  each$e(timelineOpt, function(opt) {
    if (!opt) {
      return;
    }
    compatibleEC2(opt);
  });
}
function compatibleEC2(opt) {
  var type = opt.type;
  var ec2Types = {
    "number": "value",
    "time": "time"
  };
  if (ec2Types[type]) {
    opt.axisType = ec2Types[type];
    delete opt.type;
  }
  transferItem(opt);
  if (has$1(opt, "controlPosition")) {
    var controlStyle = opt.controlStyle || (opt.controlStyle = {});
    if (!has$1(controlStyle, "position")) {
      controlStyle.position = opt.controlPosition;
    }
    if (controlStyle.position === "none" && !has$1(controlStyle, "show")) {
      controlStyle.show = false;
      delete controlStyle.position;
    }
    delete opt.controlPosition;
  }
  each$e(opt.data || [], function(dataItem) {
    if (isObject$9(dataItem) && !isArray$4(dataItem)) {
      if (!has$1(dataItem, "value") && has$1(dataItem, "name")) {
        dataItem.value = dataItem.name;
      }
      transferItem(dataItem);
    }
  });
}
function transferItem(opt) {
  var itemStyle = opt.itemStyle || (opt.itemStyle = {});
  var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
  var label = opt.label || opt.label || {};
  var labelNormal = label.normal || (label.normal = {});
  var excludeLabelAttr = {
    normal: 1,
    emphasis: 1
  };
  each$e(label, function(value, name) {
    if (!excludeLabelAttr[name] && !has$1(labelNormal, name)) {
      labelNormal[name] = value;
    }
  });
  if (itemStyleEmphasis.label && !has$1(label, "emphasis")) {
    label.emphasis = itemStyleEmphasis.label;
    delete itemStyleEmphasis.label;
  }
}
function has$1(obj, attr2) {
  return obj.hasOwnProperty(attr2);
}
function install$b(registers) {
  registers.registerComponentModel(SliderTimelineModel$1);
  registers.registerComponentView(SliderTimelineView$1);
  registers.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  });
  installTimelineAction(registers);
  registers.registerPreprocessor(timelinePreprocessor);
}
var getDefaultSelectorOptions = function(ecModel, type) {
  if (type === "all") {
    return {
      type: "all",
      title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
    };
  } else if (type === "inverse") {
    return {
      type: "inverse",
      title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
    };
  }
};
var LegendModel = function(_super) {
  __extends(LegendModel2, _super);
  function LegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  LegendModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
    this._updateSelector(option);
  };
  LegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    this._updateSelector(option);
  };
  LegendModel2.prototype._updateSelector = function(option) {
    var selector = option.selector;
    var ecModel = this.ecModel;
    if (selector === true) {
      selector = option.selector = ["all", "inverse"];
    }
    if (isArray$4(selector)) {
      each$e(selector, function(item, index2) {
        isString$2(item) && (item = {
          type: item
        });
        selector[index2] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  };
  LegendModel2.prototype.optionUpdated = function() {
    this._updateData(this.ecModel);
    var legendData = this._data;
    if (legendData[0] && this.get("selectedMode") === "single") {
      var hasSelected = false;
      for (var i = 0; i < legendData.length; i++) {
        var name_1 = legendData[i].get("name");
        if (this.isSelected(name_1)) {
          this.select(name_1);
          hasSelected = true;
          break;
        }
      }
      !hasSelected && this.select(legendData[0].get("name"));
    }
  };
  LegendModel2.prototype._updateData = function(ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;
      if (seriesModel.legendVisualProvider) {
        var provider = seriesModel.legendVisualProvider;
        var names2 = provider.getAllNames();
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names2);
        }
        if (names2.length) {
          potentialData = potentialData.concat(names2);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }
      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    this._availableNames = availableNames;
    var rawData = this.get("data") || potentialData;
    var legendData = map$1(rawData, function(dataItem) {
      if (isString$2(dataItem) || isNumber$1(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }
      return new Model$1(dataItem, this, this.ecModel);
    }, this);
    this._data = legendData;
  };
  LegendModel2.prototype.getData = function() {
    return this._data;
  };
  LegendModel2.prototype.select = function(name) {
    var selected = this.option.selected;
    var selectedMode = this.get("selectedMode");
    if (selectedMode === "single") {
      var data = this._data;
      each$e(data, function(dataItem) {
        selected[dataItem.get("name")] = false;
      });
    }
    selected[name] = true;
  };
  LegendModel2.prototype.unSelect = function(name) {
    if (this.get("selectedMode") !== "single") {
      this.option.selected[name] = false;
    }
  };
  LegendModel2.prototype.toggleSelected = function(name) {
    var selected = this.option.selected;
    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }
    this[selected[name] ? "unSelect" : "select"](name);
  };
  LegendModel2.prototype.allSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each$e(data, function(dataItem) {
      selected[dataItem.get("name", true)] = true;
    });
  };
  LegendModel2.prototype.inverseSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each$e(data, function(dataItem) {
      var name = dataItem.get("name", true);
      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }
      selected[name] = !selected[name];
    });
  };
  LegendModel2.prototype.isSelected = function(name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
  };
  LegendModel2.prototype.getOrient = function() {
    return this.get("orient") === "vertical" ? {
      index: 1,
      name: "vertical"
    } : {
      index: 0,
      name: "horizontal"
    };
  };
  LegendModel2.type = "legend.plain";
  LegendModel2.dependencies = ["series"];
  LegendModel2.defaultOption = {
    z: 4,
    show: true,
    orient: "horizontal",
    left: "center",
    top: 0,
    align: "auto",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    itemWidth: 25,
    itemHeight: 14,
    symbolRotate: "inherit",
    symbolKeepAspect: true,
    inactiveColor: "#ccc",
    inactiveBorderColor: "#ccc",
    inactiveBorderWidth: "auto",
    itemStyle: {
      color: "inherit",
      opacity: "inherit",
      borderColor: "inherit",
      borderWidth: "auto",
      borderCap: "inherit",
      borderJoin: "inherit",
      borderDashOffset: "inherit",
      borderMiterLimit: "inherit"
    },
    lineStyle: {
      width: "auto",
      color: "inherit",
      inactiveColor: "#ccc",
      inactiveWidth: 2,
      opacity: "inherit",
      type: "inherit",
      cap: "inherit",
      join: "inherit",
      dashOffset: "inherit",
      miterLimit: "inherit"
    },
    textStyle: {
      color: "#333"
    },
    selectedMode: true,
    selector: false,
    selectorLabel: {
      show: true,
      borderRadius: 10,
      padding: [3, 5, 3, 5],
      fontSize: 12,
      fontFamily: "sans-serif",
      color: "#666",
      borderWidth: 1,
      borderColor: "#666"
    },
    emphasis: {
      selectorLabel: {
        show: true,
        color: "#eee",
        backgroundColor: "#666"
      }
    },
    selectorPosition: "auto",
    selectorItemGap: 7,
    selectorButtonGap: 10,
    tooltip: {
      show: false
    }
  };
  return LegendModel2;
}(ComponentModel$1);
var LegendModel$1 = LegendModel;
var curry = curry$1;
var each$4 = each$e;
var Group$1 = Group$3;
var LegendView = function(_super) {
  __extends(LegendView2, _super);
  function LegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendView2.type;
    _this.newlineDisabled = false;
    return _this;
  }
  LegendView2.prototype.init = function() {
    this.group.add(this._contentGroup = new Group$1());
    this.group.add(this._selectorGroup = new Group$1());
    this._isFirstRender = true;
  };
  LegendView2.prototype.getContentGroup = function() {
    return this._contentGroup;
  };
  LegendView2.prototype.getSelectorGroup = function() {
    return this._selectorGroup;
  };
  LegendView2.prototype.render = function(legendModel, ecModel, api) {
    var isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();
    if (!legendModel.get("show", true)) {
      return;
    }
    var itemAlign = legendModel.get("align");
    var orient = legendModel.get("orient");
    if (!itemAlign || itemAlign === "auto") {
      itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
    }
    var selector = legendModel.get("selector", true);
    var selectorPosition = legendModel.get("selectorPosition", true);
    if (selector && (!selectorPosition || selectorPosition === "auto")) {
      selectorPosition = orient === "horizontal" ? "end" : "start";
    }
    this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get("padding");
    var maxSize = getLayoutRect$1(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
    var layoutRect = getLayoutRect$1(defaults$1({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw();
    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  };
  LegendView2.prototype.resetInner = function() {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  };
  LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = createHashMap();
    var selectMode = legendModel.get("selectedMode");
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function(seriesModel) {
      !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
    });
    each$4(legendModel.getData(), function(legendItemModel, dataIndex) {
      var name = legendItemModel.get("name");
      if (!this.newlineDisabled && (name === "" || name === "\n")) {
        var g = new Group$1();
        g.newline = true;
        contentGroup.add(g);
        return;
      }
      var seriesModel = ecModel.getSeriesByName(name)[0];
      if (legendDrawnMap.get(name)) {
        return;
      }
      if (seriesModel) {
        var data = seriesModel.getData();
        var lineVisualStyle = data.getVisual("legendLineStyle") || {};
        var legendIcon = data.getVisual("legendIcon");
        var style = data.getVisual("style");
        var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode);
        itemGroup.on("click", curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
        legendDrawnMap.set(name, true);
      } else {
        ecModel.eachRawSeries(function(seriesModel2) {
          if (legendDrawnMap.get(name)) {
            return;
          }
          if (seriesModel2.legendVisualProvider) {
            var provider = seriesModel2.legendVisualProvider;
            if (!provider.containName(name)) {
              return;
            }
            var idx = provider.indexOfName(name);
            var style2 = provider.getItemVisual(idx, "style");
            var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
            var colorArr = parse(style2.fill);
            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2;
              style2 = extend$3(extend$3({}, style2), {
                fill: stringify(colorArr, "rgba")
              });
            }
            var itemGroup2 = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode);
            itemGroup2.on("click", curry(dispatchSelectAction, null, name, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name, api, excludeSeriesId));
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
    }, this);
    if (selector) {
      this._createSelector(selector, legendModel, api, orient, selectorPosition);
    }
  };
  LegendView2.prototype._createSelector = function(selector, legendModel, api, orient, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    each$4(selector, function createSelectorButton(selectorItem) {
      var type = selectorItem.type;
      var labelText = new ZRText$1({
        style: {
          x: 0,
          y: 0,
          align: "center",
          verticalAlign: "middle"
        },
        onclick: function() {
          api.dispatchAction({
            type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
          });
        }
      });
      selectorGroup.add(labelText);
      var labelModel = legendModel.getModel("selectorLabel");
      var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
      setLabelStyle(labelText, {
        normal: labelModel,
        emphasis: emphasisLabelModel
      }, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  };
  LegendView2.prototype._createItem = function(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode) {
    var drawType = seriesModel.visualDrawType;
    var itemWidth = legendModel.get("itemWidth");
    var itemHeight = legendModel.get("itemHeight");
    var isSelected = legendModel.isSelected(name);
    var iconRotate = legendItemModel.get("symbolRotate");
    var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
    var legendIconType = legendItemModel.get("icon");
    legendIcon = legendIconType || legendIcon || "roundRect";
    var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected);
    var itemGroup = new Group$1();
    var textStyleModel = legendItemModel.getModel("textStyle");
    if (isFunction$2(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    } else {
      var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
      itemGroup.add(getDefaultLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate: rotate2,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    }
    var textX = itemAlign === "left" ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter2 = legendModel.get("formatter");
    var content = name;
    if (isString$2(formatter2) && formatter2) {
      content = formatter2.replace("{name}", name != null ? name : "");
    } else if (isFunction$2(formatter2)) {
      content = formatter2(name);
    }
    var inactiveColor = legendItemModel.get("inactiveColor");
    itemGroup.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        align: textAlign,
        verticalAlign: "middle"
      })
    }));
    var hitRect = new Rect$2({
      shape: itemGroup.getBoundingRect(),
      invisible: true
    });
    var tooltipModel = legendItemModel.getModel("tooltip");
    if (tooltipModel.get("show")) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name,
        itemTooltipOption: tooltipModel.option
      });
    }
    itemGroup.add(hitRect);
    itemGroup.eachChild(function(child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  };
  LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var selectorGroup = this.getSelectorGroup();
    box$1(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    var contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();
    if (selector) {
      box$1("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var selectorButtonGap = legendModel.get("selectorButtonGap", true);
      var orientIdx = legendModel.getOrient().index;
      var wh = orientIdx === 0 ? "width" : "height";
      var hw = orientIdx === 0 ? "height" : "width";
      var yx = orientIdx === 0 ? "y" : "x";
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      }
      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  };
  LegendView2.prototype.remove = function() {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  };
  LegendView2.type = "legend.plain";
  return LegendView2;
}(ComponentView$1);
function getLegendStyle(iconType, legendModel, lineVisualStyle, itemVisualStyle, drawType, isSelected) {
  function handleCommonProps(style, visualStyle) {
    if (style.lineWidth === "auto") {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }
    each$4(style, function(propVal, propName) {
      style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
    });
  }
  var legendItemModel = legendModel.getModel("itemStyle");
  var itemStyle = legendItemModel.getItemStyle();
  var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
  itemStyle.decal = itemVisualStyle.decal;
  if (itemStyle.fill === "inherit") {
    itemStyle.fill = itemVisualStyle[drawType];
  }
  if (itemStyle.stroke === "inherit") {
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }
  if (itemStyle.opacity === "inherit") {
    itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
  }
  handleCommonProps(itemStyle, itemVisualStyle);
  var legendLineModel = legendModel.getModel("lineStyle");
  var lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle);
  itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
  if (!isSelected) {
    var borderWidth = legendModel.get("inactiveBorderWidth");
    var visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendModel.get("inactiveColor");
    itemStyle.stroke = legendModel.get("inactiveBorderColor");
    lineStyle.stroke = legendLineModel.get("inactiveColor");
    lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
  }
  return {
    itemStyle,
    lineStyle
  };
}
function getDefaultLegendIcon(opt) {
  var symboType = opt.icon || "roundRect";
  var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
  if (symboType.indexOf("empty") > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = "#fff";
    icon.style.lineWidth = 2;
  }
  return icon;
}
function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
  api.dispatchAction({
    type: "legendToggleSelect",
    name: seriesName != null ? seriesName : dataName
  });
  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}
function isUseHoverLayer(api) {
  var list2 = api.getZr().storage.getDisplayList();
  var emphasisState;
  var i = 0;
  var len2 = list2.length;
  while (i < len2 && !(emphasisState = list2[i].states.emphasis)) {
    i++;
  }
  return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "highlight",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "downplay",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
var LegendView$1 = LegendView;
function legendFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function(series) {
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }
      return true;
    });
  }
}
function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === "toggleSelected";
  var isSelected;
  ecModel.eachComponent("legend", function(legendModel) {
    if (isToggleSelect && isSelected != null) {
      legendModel[isSelected ? "select" : "unSelect"](payload.name);
    } else if (methodName === "allSelect" || methodName === "inverseSelect") {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }
    var legendData = legendModel.getData();
    each$e(legendData, function(model) {
      var name = model.get("name");
      if (name === "\n" || name === "") {
        return;
      }
      var isItemSelected = legendModel.isSelected(name);
      if (selectedMap.hasOwnProperty(name)) {
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  });
  return methodName === "allSelect" || methodName === "inverseSelect" ? {
    selected: selectedMap
  } : {
    name: payload.name,
    selected: selectedMap
  };
}
function installLegendAction(registers) {
  registers.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected"));
  registers.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect"));
  registers.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect"));
  registers.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select"));
  registers.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
}
function install$a(registers) {
  registers.registerComponentModel(LegendModel$1);
  registers.registerComponentView(LegendView$1);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  installLegendAction(registers);
}
var ScrollableLegendModel = function(_super) {
  __extends(ScrollableLegendModel2, _super);
  function ScrollableLegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendModel2.type;
    return _this;
  }
  ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  };
  ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.call(this, option, parentModel, ecModel);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  };
  ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  };
  ScrollableLegendModel2.type = "legend.scroll";
  ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel$1.defaultOption, {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: "end",
    pageFormatter: "{current}/{total}",
    pageIcons: {
      horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
      vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
    },
    pageIconColor: "#2f4554",
    pageIconInactiveColor: "#aaa",
    pageIconSize: 15,
    pageTextStyle: {
      color: "#333"
    },
    animationDurationUpdate: 800
  });
  return ScrollableLegendModel2;
}(LegendModel$1);
function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize: !!ignoreSize
  });
}
var ScrollableLegendModel$1 = ScrollableLegendModel;
var Group = Group$3;
var WH = ["width", "height"];
var XY = ["x", "y"];
var ScrollableLegendView = function(_super) {
  __extends(ScrollableLegendView2, _super);
  function ScrollableLegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendView2.type;
    _this.newlineDisabled = true;
    _this._currentIndex = 0;
    return _this;
  }
  ScrollableLegendView2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.group.add(this._containerGroup = new Group());
    this._containerGroup.add(this.getContentGroup());
    this.group.add(this._controllerGroup = new Group());
  };
  ScrollableLegendView2.prototype.resetInner = function() {
    _super.prototype.resetInner.call(this);
    this._controllerGroup.removeAll();
    this._containerGroup.removeClipPath();
    this._containerGroup.__rectSize = null;
  };
  ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var self2 = this;
    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get("pageIconSize", true);
    var pageIconSizeArr = isArray$4(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton("pagePrev", 0);
    var pageTextStyleModel = legendModel.getModel("pageTextStyle");
    controllerGroup.add(new ZRText$1({
      name: "pageText",
      style: {
        text: "xx/xx",
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: "middle",
        align: "center"
      },
      silent: true
    }));
    createPageButton("pageNext", 1);
    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + "DataIndex";
      var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
        onclick: bind$1(self2._pageGo, self2, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  };
  ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx];
    selector && box$1("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
    var selectorButtonGap = legendModel.get("selectorButtonGap", true);
    var selectorRect = selectorGroup.getBoundingRect();
    var selectorPos = [-selectorRect.x, -selectorRect.y];
    var processMaxSize = clone$3(maxSize);
    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
    if (selector) {
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        var offset2 = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset2;
        mainRect[xy] -= offset2;
      }
      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }
    return mainRect;
  };
  ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    box$1(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box$1("horizontal", controllerGroup, legendModel.get("pageButtonItemGap", true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh];
    var contentPos = [-contentRect.x, -contentRect.y];
    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    }
    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
    if (showController) {
      var pageButtonPosition = legendModel.get("pageButtonPosition", true);
      if (pageButtonPosition === "end") {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } else {
        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
      }
    }
    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos);
    var mainRect = {
      x: 0,
      y: 0
    };
    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];
    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect$2({
        shape: clipShape
      }));
      containerGroup.__rectSize = clipShape[wh];
    } else {
      controllerGroup.eachChild(function(child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    }
    var pageInfo = this._getPageInfo(legendModel);
    pageInfo.pageIndex != null && updateProps$1(contentGroup, {
      x: pageInfo.contentPosition[0],
      y: pageInfo.contentPosition[1]
    }, showController ? legendModel : null);
    this._updatePageInfoView(legendModel, pageInfo);
    return mainRect;
  };
  ScrollableLegendView2.prototype._pageGo = function(to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];
    scrollDataIndex != null && api.dispatchAction({
      type: "legendScroll",
      scrollDataIndex,
      legendId: legendModel.id
    });
  };
  ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    each$e(["pagePrev", "pageNext"], function(name) {
      var key2 = name + "DataIndex";
      var canJump = pageInfo[key2] != null;
      var icon = controllerGroup.childOfName(name);
      if (icon) {
        icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
        icon.cursor = canJump ? "pointer" : "default";
      }
    });
    var pageText = controllerGroup.childOfName("pageText");
    var pageFormatter = legendModel.get("pageFormatter");
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle("text", isString$2(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
      current,
      total
    }));
  };
  ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
    var scrollDataIndex = legendModel.get("scrollDataIndex", true);
    var contentGroup = this.getContentGroup();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
    var children2 = contentGroup.children();
    var targetItem = children2[targetItemIndex];
    var itemCount = children2.length;
    var pCount = !itemCount ? 0 : 1;
    var result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };
    if (!targetItem) {
      return result;
    }
    var targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s;
    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
      currItemInfo = getItemInfo(children2[i]);
      if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          winStartItemInfo = currItemInfo;
        }
        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
        }
      }
      winEndItemInfo = currItemInfo;
    }
    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
      currItemInfo = getItemInfo(children2[i]);
      if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;
        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }
        ++result.pageCount;
        ++result.pageIndex;
      }
      winStartItemInfo = currItemInfo;
    }
    return result;
    function getItemInfo(el) {
      if (el) {
        var itemRect = el.getBoundingRect();
        var start2 = itemRect[xy] + el[xy];
        return {
          s: start2,
          e: start2 + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }
    function intersect2(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  };
  ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
    if (!this._showController) {
      return 0;
    }
    var index2;
    var contentGroup = this.getContentGroup();
    var defaultIndex;
    contentGroup.eachChild(function(child, idx) {
      var legendDataIdx = child.__legendDataIndex;
      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }
      if (legendDataIdx === targetDataIndex) {
        index2 = idx;
      }
    });
    return index2 != null ? index2 : defaultIndex;
  };
  ScrollableLegendView2.type = "legend.scroll";
  return ScrollableLegendView2;
}(LegendView$1);
var ScrollableLegendView$1 = ScrollableLegendView;
function installScrollableLegendAction(registers) {
  registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: payload
    }, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}
function install$9(registers) {
  use(install$a);
  registers.registerComponentModel(ScrollableLegendModel$1);
  registers.registerComponentView(ScrollableLegendView$1);
  installScrollableLegendAction(registers);
}
function install$8(registers) {
  use(install$a);
  use(install$9);
}
var InsideZoomModel = function(_super) {
  __extends(InsideZoomModel2, _super);
  function InsideZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = InsideZoomModel2.type;
    return _this;
  }
  InsideZoomModel2.type = "dataZoom.inside";
  InsideZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    disabled: false,
    zoomLock: false,
    zoomOnMouseWheel: true,
    moveOnMouseMove: true,
    moveOnMouseWheel: false,
    preventDefaultMouseMove: true
  });
  return InsideZoomModel2;
}(DataZoomModel$1);
var InsideZoomModel$1 = InsideZoomModel;
var inner$1 = makeInner();
function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
  inner$1(api).coordSysRecordMap.each(function(coordSysRecord) {
    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
    if (dzInfo) {
      dzInfo.getRange = getRange;
    }
  });
}
function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
  var coordSysRecordMap = inner$1(api).coordSysRecordMap;
  var coordSysKeyArr = coordSysRecordMap.keys();
  for (var i = 0; i < coordSysKeyArr.length; i++) {
    var coordSysKey = coordSysKeyArr[i];
    var coordSysRecord = coordSysRecordMap.get(coordSysKey);
    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
    if (dataZoomInfoMap) {
      var dzUid = dataZoomModel.uid;
      var dzInfo = dataZoomInfoMap.get(dzUid);
      if (dzInfo) {
        dataZoomInfoMap.removeKey(dzUid);
        if (!dataZoomInfoMap.keys().length) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        }
      }
    }
  }
}
function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
  if (coordSysRecord) {
    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
    var controller = coordSysRecord.controller;
    controller && controller.dispose();
  }
}
function createCoordSysRecord(api, coordSysModel) {
  var coordSysRecord = {
    model: coordSysModel,
    containsPoint: curry$1(containsPoint, coordSysModel),
    dispatchAction: curry$1(dispatchAction, api),
    dataZoomInfoMap: null,
    controller: null
  };
  var controller = coordSysRecord.controller = new RoamController$1(api.getZr());
  each$e(["pan", "zoom", "scrollMove"], function(eventName) {
    controller.on(eventName, function(event) {
      var batch = [];
      coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
        if (!event.isAvailableBehavior(dzInfo.model.option)) {
          return;
        }
        var method = (dzInfo.getRange || {})[eventName];
        var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
        !dzInfo.model.get("disabled", true) && range && batch.push({
          dataZoomId: dzInfo.model.id,
          start: range[0],
          end: range[1]
        });
      });
      batch.length && coordSysRecord.dispatchAction(batch);
    });
  });
  return coordSysRecord;
}
function dispatchAction(api, batch) {
  if (!api.isDisposed()) {
    api.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch
    });
  }
}
function containsPoint(coordSysModel, e2, x2, y) {
  return coordSysModel.coordinateSystem.containPoint([x2, y]);
}
function mergeControllerParams(dataZoomInfoMap) {
  var controlType;
  var prefix = "type_";
  var typePriority = {
    "type_true": 2,
    "type_move": 1,
    "type_false": 0,
    "type_undefined": -1
  };
  var preventDefaultMouseMove = true;
  dataZoomInfoMap.each(function(dataZoomInfo) {
    var dataZoomModel = dataZoomInfo.model;
    var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    }
    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
  });
  return {
    controlType,
    opt: {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: true,
      preventDefaultMouseMove: !!preventDefaultMouseMove
    }
  };
}
function installDataZoomRoamProcessor(registers) {
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api) {
    var apiInner = inner$1(api);
    var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
    coordSysRecordMap.each(function(coordSysRecord) {
      coordSysRecord.dataZoomInfoMap = null;
    });
    ecModel.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(dataZoomModel) {
      var dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
      each$e(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
        var coordSysUid = dzCoordSysInfo.model.uid;
        var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
        dataZoomInfoMap.set(dataZoomModel.uid, {
          dzReferCoordSysInfo: dzCoordSysInfo,
          model: dataZoomModel,
          getRange: null
        });
      });
    });
    coordSysRecordMap.each(function(coordSysRecord) {
      var controller = coordSysRecord.controller;
      var firstDzInfo;
      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        var firstDzKey = dataZoomInfoMap.keys()[0];
        if (firstDzKey != null) {
          firstDzInfo = dataZoomInfoMap.get(firstDzKey);
        }
      }
      if (!firstDzInfo) {
        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        return;
      }
      var controllerParams = mergeControllerParams(dataZoomInfoMap);
      controller.enable(controllerParams.controlType, controllerParams.opt);
      controller.setPointerChecker(coordSysRecord.containsPoint);
      createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
    });
  });
}
var InsideZoomView = function(_super) {
  __extends(InsideZoomView2, _super);
  function InsideZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataZoom.inside";
    return _this;
  }
  InsideZoomView2.prototype.render = function(dataZoomModel, ecModel, api) {
    _super.prototype.render.apply(this, arguments);
    if (dataZoomModel.noTarget()) {
      this._clear();
      return;
    }
    this.range = dataZoomModel.getPercentRange();
    setViewInfoToCoordSysRecord(api, dataZoomModel, {
      pan: bind$1(getRangeHandlers.pan, this),
      zoom: bind$1(getRangeHandlers.zoom, this),
      scrollMove: bind$1(getRangeHandlers.scrollMove, this)
    });
  };
  InsideZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  InsideZoomView2.prototype._clear = function() {
    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
    this.range = null;
  };
  InsideZoomView2.type = "dataZoom.inside";
  return InsideZoomView2;
}(DataZoomView$1);
var getRangeHandlers = {
  zoom: function(coordSysInfo, coordSysMainType, controller, e2) {
    var lastRange = this.range;
    var range = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var directionInfo = getDirectionInfo[coordSysMainType](null, [e2.originX, e2.originY], axisModel, controller, coordSysInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    var scale2 = Math.max(1 / e2.scale, 0);
    range[0] = (range[0] - percentPoint) * scale2 + percentPoint;
    range[1] = (range[1] - percentPoint) * scale2 + percentPoint;
    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  },
  pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    var directionInfo = getDirectionInfo[coordSysMainType]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
  }),
  scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
  })
};
function makeMover(getPercentDelta) {
  return function(coordSysInfo, coordSysMainType, controller, e2) {
    var lastRange = this.range;
    var range = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e2);
    sliderMove(percentDelta, range, [0, 100], "all");
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  };
}
var getDirectionInfo = {
  grid: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];
    if (axis.dim === "x") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  polar: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var polar = coordSysInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);
    if (axisModel.mainType === "radiusAxis") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  singleAxis: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    var ret = {};
    oldPoint = oldPoint || [0, 0];
    if (axis.orient === "horizontal") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  }
};
var InsideZoomView$1 = InsideZoomView;
function install$7(registers) {
  installCommon$1(registers);
  registers.registerComponentModel(InsideZoomModel$1);
  registers.registerComponentView(InsideZoomView$1);
  installDataZoomRoamProcessor(registers);
}
var SliderZoomModel = function(_super) {
  __extends(SliderZoomModel2, _super);
  function SliderZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomModel2.type;
    return _this;
  }
  SliderZoomModel2.type = "dataZoom.slider";
  SliderZoomModel2.layoutMode = "box";
  SliderZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    show: true,
    right: "ph",
    top: "ph",
    width: "ph",
    height: "ph",
    left: null,
    bottom: null,
    borderColor: "#d2dbee",
    borderRadius: 3,
    backgroundColor: "rgba(47,69,84,0)",
    dataBackground: {
      lineStyle: {
        color: "#d2dbee",
        width: 0.5
      },
      areaStyle: {
        color: "#d2dbee",
        opacity: 0.2
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#8fb0f7",
        width: 0.5
      },
      areaStyle: {
        color: "#8fb0f7",
        opacity: 0.2
      }
    },
    fillerColor: "rgba(135,175,274,0.2)",
    handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
    handleSize: "100%",
    handleStyle: {
      color: "#fff",
      borderColor: "#ACB8D1"
    },
    moveHandleSize: 7,
    moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
    moveHandleStyle: {
      color: "#D2DBEE",
      opacity: 0.7
    },
    showDetail: true,
    showDataShadow: "auto",
    realtime: true,
    zoomLock: false,
    textStyle: {
      color: "#6E7079"
    },
    brushSelect: true,
    brushStyle: {
      color: "rgba(135,175,274,0.15)"
    },
    emphasis: {
      handleStyle: {
        borderColor: "#8FB0F7"
      },
      moveHandleStyle: {
        color: "#8FB0F7"
      }
    }
  });
  return SliderZoomModel2;
}(DataZoomModel$1);
var SliderZoomModel$1 = SliderZoomModel;
var Rect = Rect$2;
var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
var REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
};
var SliderZoomView = function(_super) {
  __extends(SliderZoomView2, _super);
  function SliderZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomView2.type;
    _this._displayables = {};
    return _this;
  }
  SliderZoomView2.prototype.init = function(ecModel, api) {
    this.api = api;
    this._onBrush = bind$1(this._onBrush, this);
    this._onBrushEnd = bind$1(this._onBrushEnd, this);
  };
  SliderZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    _super.prototype.render.apply(this, arguments);
    createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
    this._orient = dataZoomModel.getOrient();
    if (dataZoomModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    if (dataZoomModel.noTarget()) {
      this._clear();
      this.group.removeAll();
      return;
    }
    if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
      this._buildView();
    }
    this._updateView();
  };
  SliderZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  SliderZoomView2.prototype._clear = function() {
    clear$1(this, "_dispatchZoomAction");
    var zr = this.api.getZr();
    zr.off("mousemove", this._onBrush);
    zr.off("mouseup", this._onBrushEnd);
  };
  SliderZoomView2.prototype._buildView = function() {
    var thisGroup = this.group;
    thisGroup.removeAll();
    this._brushing = false;
    this._displayables.brushRect = null;
    this._resetLocation();
    this._resetInterval();
    var barGroup = this._displayables.sliderGroup = new Group$3();
    this._renderBackground();
    this._renderHandle();
    this._renderDataShadow();
    thisGroup.add(barGroup);
    this._positionGroup();
  };
  SliderZoomView2.prototype._resetLocation = function() {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var showMoveHandle = dataZoomModel.get("brushSelect");
    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
    var coordRect = this._findCoordRect();
    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var positionInfo = this._orient === HORIZONTAL ? {
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    };
    var layoutParams = getLayoutParams(dataZoomModel.option);
    each$e(["right", "top", "width", "height"], function(name) {
      if (layoutParams[name] === "ph") {
        layoutParams[name] = positionInfo[name];
      }
    });
    var layoutRect = getLayoutRect$1(layoutParams, ecSize);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  };
  SliderZoomView2.prototype._positionGroup = function() {
    var thisGroup = this.group;
    var location2 = this._location;
    var orient = this._orient;
    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get("inverse");
    var sliderGroup = this._displayables.sliderGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: 1
    } : orient === HORIZONTAL && inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: -1
    } : orient === VERTICAL && !inverse ? {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: 1,
      rotation: Math.PI / 2
    } : {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: -1,
      rotation: Math.PI / 2
    });
    var rect = thisGroup.getBoundingRect([sliderGroup]);
    thisGroup.x = location2.x - rect.x;
    thisGroup.y = location2.y - rect.y;
    thisGroup.markRedraw();
  };
  SliderZoomView2.prototype._getViewExtent = function() {
    return [0, this._size[0]];
  };
  SliderZoomView2.prototype._renderBackground = function() {
    var dataZoomModel = this.dataZoomModel;
    var size = this._size;
    var barGroup = this._displayables.sliderGroup;
    var brushSelect = dataZoomModel.get("brushSelect");
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get("backgroundColor")
      },
      z2: -40
    }));
    var clickPanel = new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: "transparent"
      },
      z2: 0,
      onclick: bind$1(this._onClickPanel, this)
    });
    var zr = this.api.getZr();
    if (brushSelect) {
      clickPanel.on("mousedown", this._onBrushStart, this);
      clickPanel.cursor = "crosshair";
      zr.on("mousemove", this._onBrush);
      zr.on("mouseup", this._onBrushEnd);
    } else {
      zr.off("mousemove", this._onBrush);
      zr.off("mouseup", this._onBrushEnd);
    }
    barGroup.add(clickPanel);
  };
  SliderZoomView2.prototype._renderDataShadow = function() {
    var info = this._dataShadowInfo = this._prepareDataShadowInfo();
    this._displayables.dataShadowSegs = [];
    if (!info) {
      return;
    }
    var size = this._size;
    var oldSize = this._shadowSize || [];
    var seriesModel = info.series;
    var data = seriesModel.getRawData();
    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
    if (otherDim == null) {
      return;
    }
    var polygonPts = this._shadowPolygonPts;
    var polylinePts = this._shadowPolylinePts;
    if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      var otherDataExtent_1 = data.getDataExtent(otherDim);
      var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;
      otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];
      var otherShadowExtent_1 = [0, size[1]];
      var thisShadowExtent = [0, size[0]];
      var areaPoints_1 = [[size[0], 0], [0, 0]];
      var linePoints_1 = [];
      var step_1 = thisShadowExtent[1] / (data.count() - 1);
      var thisCoord_1 = 0;
      var stride_1 = Math.round(data.count() / size[0]);
      var lastIsEmpty_1;
      data.each([otherDim], function(value, index2) {
        if (stride_1 > 0 && index2 % stride_1) {
          thisCoord_1 += step_1;
          return;
        }
        var isEmpty2 = value == null || isNaN(value) || value === "";
        var otherCoord = isEmpty2 ? 0 : linearMap$2(value, otherDataExtent_1, otherShadowExtent_1, true);
        if (isEmpty2 && !lastIsEmpty_1 && index2) {
          areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);
          linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);
        } else if (!isEmpty2 && lastIsEmpty_1) {
          areaPoints_1.push([thisCoord_1, 0]);
          linePoints_1.push([thisCoord_1, 0]);
        }
        areaPoints_1.push([thisCoord_1, otherCoord]);
        linePoints_1.push([thisCoord_1, otherCoord]);
        thisCoord_1 += step_1;
        lastIsEmpty_1 = isEmpty2;
      });
      polygonPts = this._shadowPolygonPts = areaPoints_1;
      polylinePts = this._shadowPolylinePts = linePoints_1;
    }
    this._shadowData = data;
    this._shadowDim = otherDim;
    this._shadowSize = [size[0], size[1]];
    var dataZoomModel = this.dataZoomModel;
    function createDataShadowGroup(isSelectedArea) {
      var model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
      var group2 = new Group$3();
      var polygon = new Polygon$1({
        shape: {
          points: polygonPts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("areaStyle").getAreaStyle(),
        silent: true,
        z2: -20
      });
      var polyline = new Polyline$1({
        shape: {
          points: polylinePts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("lineStyle").getLineStyle(),
        silent: true,
        z2: -19
      });
      group2.add(polygon);
      group2.add(polyline);
      return group2;
    }
    for (var i = 0; i < 3; i++) {
      var group = createDataShadowGroup(i === 1);
      this._displayables.sliderGroup.add(group);
      this._displayables.dataShadowSegs.push(group);
    }
  };
  SliderZoomView2.prototype._prepareDataShadowInfo = function() {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get("showDataShadow");
    if (showDataShadow === false) {
      return;
    }
    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
      each$e(seriesModels, function(seriesModel) {
        if (result) {
          return;
        }
        if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
          return;
        }
        var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
        var otherDim = getOtherDim(axisDim);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;
        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }
        otherDim = seriesModel.getData().mapDimension(otherDim);
        result = {
          thisAxis,
          series: seriesModel,
          thisDim: axisDim,
          otherDim,
          otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  };
  SliderZoomView2.prototype._renderHandle = function() {
    var thisGroup = this.group;
    var displayables = this._displayables;
    var handles = displayables.handles = [null, null];
    var handleLabels = displayables.handleLabels = [null, null];
    var sliderGroup = this._displayables.sliderGroup;
    var size = this._size;
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var borderRadius = dataZoomModel.get("borderRadius") || 0;
    var brushSelect = dataZoomModel.get("brushSelect");
    var filler = displayables.filler = new Rect({
      silent: brushSelect,
      style: {
        fill: dataZoomModel.get("fillerColor")
      },
      textConfig: {
        position: "inside"
      }
    });
    sliderGroup.add(filler);
    sliderGroup.add(new Rect({
      silent: true,
      subPixelOptimize: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        r: borderRadius
      },
      style: {
        stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: "rgba(0,0,0,0)"
      }
    }));
    each$e([0, 1], function(handleIndex) {
      var iconStr = dataZoomModel.get("handleIcon");
      if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
        iconStr = "path://" + iconStr;
      }
      var path = createSymbol(iconStr, -1, 0, 2, 2, null, true);
      path.attr({
        cursor: getCursor$1(this._orient),
        draggable: true,
        drift: bind$1(this._onDragMove, this, handleIndex),
        ondragend: bind$1(this._onDragEnd, this),
        onmouseover: bind$1(this._showDataInfo, this, true),
        onmouseout: bind$1(this._showDataInfo, this, false),
        z2: 5
      });
      var bRect = path.getBoundingRect();
      var handleSize = dataZoomModel.get("handleSize");
      this._handleHeight = parsePercent(handleSize, this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
      path.style.strokeNoScale = true;
      path.rectHover = true;
      path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
      enableHoverEmphasis(path);
      var handleColor = dataZoomModel.get("handleColor");
      if (handleColor != null) {
        path.style.fill = handleColor;
      }
      sliderGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.getModel("textStyle");
      thisGroup.add(handleLabels[handleIndex] = new ZRText$1({
        silent: true,
        invisible: true,
        style: createTextStyle$1(textStyleModel, {
          x: 0,
          y: 0,
          text: "",
          verticalAlign: "middle",
          align: "center",
          fill: textStyleModel.getTextColor(),
          font: textStyleModel.getFont()
        }),
        z2: 10
      }));
    }, this);
    var actualMoveZone = filler;
    if (brushSelect) {
      var moveHandleHeight = parsePercent(dataZoomModel.get("moveHandleSize"), size[1]);
      var moveHandle_1 = displayables.moveHandle = new Rect$2({
        style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
        silent: true,
        shape: {
          r: [0, 0, 2, 2],
          y: size[1] - 0.5,
          height: moveHandleHeight
        }
      });
      var iconSize = moveHandleHeight * 0.8;
      var moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, "#fff", true);
      moveHandleIcon.silent = true;
      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
      moveHandle_1.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
      var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
      actualMoveZone = displayables.moveZone = new Rect$2({
        invisible: true,
        shape: {
          y: size[1] - moveZoneExpandSize,
          height: moveHandleHeight + moveZoneExpandSize
        }
      });
      actualMoveZone.on("mouseover", function() {
        api.enterEmphasis(moveHandle_1);
      }).on("mouseout", function() {
        api.leaveEmphasis(moveHandle_1);
      });
      sliderGroup.add(moveHandle_1);
      sliderGroup.add(moveHandleIcon);
      sliderGroup.add(actualMoveZone);
    }
    actualMoveZone.attr({
      draggable: true,
      cursor: getCursor$1(this._orient),
      drift: bind$1(this._onDragMove, this, "all"),
      ondragstart: bind$1(this._showDataInfo, this, true),
      ondragend: bind$1(this._onDragEnd, this),
      onmouseover: bind$1(this._showDataInfo, this, true),
      onmouseout: bind$1(this._showDataInfo, this, false)
    });
  };
  SliderZoomView2.prototype._resetInterval = function() {
    var range = this._range = this.dataZoomModel.getPercentRange();
    var viewExtent = this._getViewExtent();
    this._handleEnds = [linearMap$2(range[0], [0, 100], viewExtent, true), linearMap$2(range[1], [0, 100], viewExtent, true)];
  };
  SliderZoomView2.prototype._updateInterval = function(handleIndex, delta) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;
    var viewExtend = this._getViewExtent();
    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap$2(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap$2(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    var lastRange = this._range;
    var range = this._range = asc$2([linearMap$2(handleEnds[0], viewExtend, percentExtent, true), linearMap$2(handleEnds[1], viewExtend, percentExtent, true)]);
    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
  };
  SliderZoomView2.prototype._updateView = function(nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = asc$2(handleEnds.slice());
    var size = this._size;
    each$e([0, 1], function(handleIndex) {
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scaleX: handleHeight / 2,
        scaleY: handleHeight / 2,
        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
        y: size[1] / 2 - handleHeight / 2
      });
    }, this);
    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });
    var viewExtent = {
      x: handleInterval[0],
      width: handleInterval[1] - handleInterval[0]
    };
    if (displaybles.moveHandle) {
      displaybles.moveHandle.setShape(viewExtent);
      displaybles.moveZone.setShape(viewExtent);
      displaybles.moveZone.getBoundingRect();
      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
    }
    var dataShadowSegs = displaybles.dataShadowSegs;
    var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
    for (var i = 0; i < dataShadowSegs.length; i++) {
      var segGroup = dataShadowSegs[i];
      var clipPath = segGroup.getClipPath();
      if (!clipPath) {
        clipPath = new Rect$2();
        segGroup.setClipPath(clipPath);
      }
      clipPath.setShape({
        x: segIntervals[i],
        y: 0,
        width: segIntervals[i + 1] - segIntervals[i],
        height: size[1]
      });
    }
    this._updateDataInfo(nonRealtime);
  };
  SliderZoomView2.prototype._updateDataInfo = function(nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient = this._orient;
    var labelTexts = ["", ""];
    if (dataZoomModel.get("showDetail")) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range = this._range;
        var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }
    var orderedHandleEnds = asc$2(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);
    function setLabel(handleIndex) {
      var barTransform = getTransform$1(displaybles.handles[handleIndex].parent, this.group);
      var direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
      var offset2 = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset2 : offset2), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        verticalAlign: orient === HORIZONTAL ? "middle" : direction,
        align: orient === HORIZONTAL ? direction : "center",
        text: labelTexts[handleIndex]
      });
    }
  };
  SliderZoomView2.prototype._formatLabel = function(value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get("labelFormatter");
    var labelPrecision = dataZoomModel.get("labelPrecision");
    if (labelPrecision == null || labelPrecision === "auto") {
      labelPrecision = axis.getPixelPrecision();
    }
    var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
      value: Math.round(value)
    }) : value.toFixed(Math.min(labelPrecision, 20));
    return isFunction$2(labelFormatter) ? labelFormatter(value, valueStr) : isString$2(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
  };
  SliderZoomView2.prototype._showDataInfo = function(showOrHide) {
    showOrHide = this._dragging || showOrHide;
    var displayables = this._displayables;
    var handleLabels = displayables.handleLabels;
    handleLabels[0].attr("invisible", !showOrHide);
    handleLabels[1].attr("invisible", !showOrHide);
    displayables.moveHandle && this.api[showOrHide ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
  };
  SliderZoomView2.prototype._onDragMove = function(handleIndex, dx, dy, event) {
    this._dragging = true;
    stop(event.event);
    var barTransform = this._displayables.sliderGroup.getLocalTransform();
    var vertex = applyTransform([dx, dy], barTransform, true);
    var changed = this._updateInterval(handleIndex, vertex[0]);
    var realtime = this.dataZoomModel.get("realtime");
    this._updateView(!realtime);
    changed && realtime && this._dispatchZoomAction(true);
  };
  SliderZoomView2.prototype._onDragEnd = function() {
    this._dragging = false;
    this._showDataInfo(false);
    var realtime = this.dataZoomModel.get("realtime");
    !realtime && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onClickPanel = function(e2) {
    var size = this._size;
    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }
    var handleEnds = this._handleEnds;
    var center2 = (handleEnds[0] + handleEnds[1]) / 2;
    var changed = this._updateInterval("all", localPoint[0] - center2);
    this._updateView();
    changed && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrushStart = function(e2) {
    var x2 = e2.offsetX;
    var y = e2.offsetY;
    this._brushStart = new Point$1(x2, y);
    this._brushing = true;
    this._brushStartTime = +new Date();
  };
  SliderZoomView2.prototype._onBrushEnd = function(e2) {
    if (!this._brushing) {
      return;
    }
    var brushRect = this._displayables.brushRect;
    this._brushing = false;
    if (!brushRect) {
      return;
    }
    brushRect.attr("ignore", true);
    var brushShape = brushRect.shape;
    var brushEndTime = +new Date();
    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
      return;
    }
    var viewExtend = this._getViewExtent();
    var percentExtent = [0, 100];
    this._range = asc$2([linearMap$2(brushShape.x, viewExtend, percentExtent, true), linearMap$2(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);
    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
    this._updateView();
    this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrush = function(e2) {
    if (this._brushing) {
      stop(e2.event);
      this._updateBrushRect(e2.offsetX, e2.offsetY);
    }
  };
  SliderZoomView2.prototype._updateBrushRect = function(mouseX, mouseY) {
    var displayables = this._displayables;
    var dataZoomModel = this.dataZoomModel;
    var brushRect = displayables.brushRect;
    if (!brushRect) {
      brushRect = displayables.brushRect = new Rect({
        silent: true,
        style: dataZoomModel.getModel("brushStyle").getItemStyle()
      });
      displayables.sliderGroup.add(brushRect);
    }
    brushRect.attr("ignore", false);
    var brushStart = this._brushStart;
    var sliderGroup = this._displayables.sliderGroup;
    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
    var size = this._size;
    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
    brushRect.setShape({
      x: startPoint[0],
      y: 0,
      width: endPoint[0] - startPoint[0],
      height: size[1]
    });
  };
  SliderZoomView2.prototype._dispatchZoomAction = function(realtime) {
    var range = this._range;
    this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
      start: range[0],
      end: range[1]
    });
  };
  SliderZoomView2.prototype._findCoordRect = function() {
    var rect;
    var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
    if (!rect && coordSysInfoList.length) {
      var coordSys = coordSysInfoList[0].model.coordinateSystem;
      rect = coordSys.getRect && coordSys.getRect();
    }
    if (!rect) {
      var width = this.api.getWidth();
      var height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }
    return rect;
  };
  SliderZoomView2.type = "dataZoom.slider";
  return SliderZoomView2;
}(DataZoomView$1);
function getOtherDim(thisDim) {
  var map2 = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return map2[thisDim];
}
function getCursor$1(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView$1 = SliderZoomView;
function install$6(registers) {
  registers.registerComponentModel(SliderZoomModel$1);
  registers.registerComponentView(SliderZoomView$1);
  installCommon$1(registers);
}
function install$5(registers) {
  use(install$7);
  use(install$6);
}
var visualDefault = {
  get: function(visualType, key2, isCategory2) {
    var value = clone$3((defaultOption[visualType] || {})[key2]);
    return isCategory2 ? isArray$4(value) ? value[value.length - 1] : value : value;
  }
};
var defaultOption = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
var visualDefault$1 = visualDefault;
var mapVisual = VisualMapping$1.mapVisual;
var eachVisual = VisualMapping$1.eachVisual;
var isArray$3 = isArray$4;
var each$3 = each$e;
var asc = asc$2;
var linearMap$1 = linearMap$2;
var VisualMapModel = function(_super) {
  __extends(VisualMapModel2, _super);
  function VisualMapModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = VisualMapModel2.type;
    _this.stateList = ["inRange", "outOfRange"];
    _this.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"];
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    _this.dataBound = [-Infinity, Infinity];
    _this.targetVisuals = {};
    _this.controllerVisuals = {};
    return _this;
  }
  VisualMapModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  VisualMapModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
    this.textStyleModel = this.getModel("textStyle");
    this.resetItemSize();
    this.completeVisualOption();
  };
  VisualMapModel2.prototype.resetVisual = function(supplementVisualOption) {
    var stateList = this.stateList;
    supplementVisualOption = bind$1(supplementVisualOption, this);
    this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
    this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
  };
  VisualMapModel2.prototype.getItemSymbol = function() {
    return null;
  };
  VisualMapModel2.prototype.getTargetSeriesIndices = function() {
    var optionSeriesIndex = this.option.seriesIndex;
    var seriesIndices = [];
    if (optionSeriesIndex == null || optionSeriesIndex === "all") {
      this.ecModel.eachSeries(function(seriesModel, index2) {
        seriesIndices.push(index2);
      });
    } else {
      seriesIndices = normalizeToArray(optionSeriesIndex);
    }
    return seriesIndices;
  };
  VisualMapModel2.prototype.eachTargetSeries = function(callback, context) {
    each$e(this.getTargetSeriesIndices(), function(seriesIndex) {
      var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);
      if (seriesModel) {
        callback.call(context, seriesModel);
      }
    }, this);
  };
  VisualMapModel2.prototype.isTargetSeries = function(seriesModel) {
    var is2 = false;
    this.eachTargetSeries(function(model) {
      model === seriesModel && (is2 = true);
    });
    return is2;
  };
  VisualMapModel2.prototype.formatValueText = function(value, isCategory2, edgeSymbols) {
    var option = this.option;
    var precision = option.precision;
    var dataBound = this.dataBound;
    var formatter2 = option.formatter;
    var isMinMax;
    edgeSymbols = edgeSymbols || ["<", ">"];
    if (isArray$4(value)) {
      value = value.slice();
      isMinMax = true;
    }
    var textValue = isCategory2 ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
    if (isString$2(formatter2)) {
      return formatter2.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
    } else if (isFunction$2(formatter2)) {
      return isMinMax ? formatter2(value[0], value[1]) : formatter2(value);
    }
    if (isMinMax) {
      if (value[0] === dataBound[0]) {
        return edgeSymbols[0] + " " + textValue[1];
      } else if (value[1] === dataBound[1]) {
        return edgeSymbols[1] + " " + textValue[0];
      } else {
        return textValue[0] + " - " + textValue[1];
      }
    } else {
      return textValue;
    }
    function toFixed(val) {
      return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
    }
  };
  VisualMapModel2.prototype.resetExtent = function() {
    var thisOption = this.option;
    var extent3 = asc([thisOption.min, thisOption.max]);
    this._dataExtent = extent3;
  };
  VisualMapModel2.prototype.getDataDimensionIndex = function(data) {
    var optDim = this.option.dimension;
    if (optDim != null) {
      return data.getDimensionIndex(optDim);
    }
    var dimNames = data.dimensions;
    for (var i = dimNames.length - 1; i >= 0; i--) {
      var dimName = dimNames[i];
      var dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isCalculationCoord) {
        return dimInfo.storeDimIndex;
      }
    }
  };
  VisualMapModel2.prototype.getExtent = function() {
    return this._dataExtent.slice();
  };
  VisualMapModel2.prototype.completeVisualOption = function() {
    var ecModel = this.ecModel;
    var thisOption = this.option;
    var base2 = {
      inRange: thisOption.inRange,
      outOfRange: thisOption.outOfRange
    };
    var target = thisOption.target || (thisOption.target = {});
    var controller = thisOption.controller || (thisOption.controller = {});
    merge(target, base2);
    merge(controller, base2);
    var isCategory2 = this.isCategory();
    completeSingle.call(this, target);
    completeSingle.call(this, controller);
    completeInactive.call(this, target, "inRange", "outOfRange");
    completeController.call(this, controller);
    function completeSingle(base3) {
      if (isArray$3(thisOption.color) && !base3.inRange) {
        base3.inRange = {
          color: thisOption.color.slice().reverse()
        };
      }
      base3.inRange = base3.inRange || {
        color: ecModel.get("gradientColor")
      };
    }
    function completeInactive(base3, stateExist, stateAbsent) {
      var optExist = base3[stateExist];
      var optAbsent = base3[stateAbsent];
      if (optExist && !optAbsent) {
        optAbsent = base3[stateAbsent] = {};
        each$3(optExist, function(visualData, visualType) {
          if (!VisualMapping$1.isValidType(visualType)) {
            return;
          }
          var defa = visualDefault$1.get(visualType, "inactive", isCategory2);
          if (defa != null) {
            optAbsent[visualType] = defa;
            if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
              optAbsent.opacity = [0, 0];
            }
          }
        });
      }
    }
    function completeController(controller2) {
      var symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
      var symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
      var inactiveColor = this.get("inactiveColor");
      var itemSymbol = this.getItemSymbol();
      var defaultSymbol = itemSymbol || "roundRect";
      each$3(this.stateList, function(state) {
        var itemSize = this.itemSize;
        var visuals = controller2[state];
        if (!visuals) {
          visuals = controller2[state] = {
            color: isCategory2 ? inactiveColor : [inactiveColor]
          };
        }
        if (visuals.symbol == null) {
          visuals.symbol = symbolExists && clone$3(symbolExists) || (isCategory2 ? defaultSymbol : [defaultSymbol]);
        }
        if (visuals.symbolSize == null) {
          visuals.symbolSize = symbolSizeExists && clone$3(symbolSizeExists) || (isCategory2 ? itemSize[0] : [itemSize[0], itemSize[0]]);
        }
        visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
          return symbol === "none" ? defaultSymbol : symbol;
        });
        var symbolSize = visuals.symbolSize;
        if (symbolSize != null) {
          var max_1 = -Infinity;
          eachVisual(symbolSize, function(value) {
            value > max_1 && (max_1 = value);
          });
          visuals.symbolSize = mapVisual(symbolSize, function(value) {
            return linearMap$1(value, [0, max_1], [0, itemSize[0]], true);
          });
        }
      }, this);
    }
  };
  VisualMapModel2.prototype.resetItemSize = function() {
    this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
  };
  VisualMapModel2.prototype.isCategory = function() {
    return !!this.option.categories;
  };
  VisualMapModel2.prototype.setSelected = function(selected) {
  };
  VisualMapModel2.prototype.getSelected = function() {
    return null;
  };
  VisualMapModel2.prototype.getValueState = function(value) {
    return null;
  };
  VisualMapModel2.prototype.getVisualMeta = function(getColorVisual2) {
    return null;
  };
  VisualMapModel2.type = "visualMap";
  VisualMapModel2.dependencies = ["series"];
  VisualMapModel2.defaultOption = {
    show: true,
    z: 4,
    seriesIndex: "all",
    min: 0,
    max: 200,
    left: 0,
    right: null,
    top: null,
    bottom: 0,
    itemWidth: null,
    itemHeight: null,
    inverse: false,
    orient: "vertical",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    contentColor: "#5793f3",
    inactiveColor: "#aaa",
    borderWidth: 0,
    padding: 5,
    textGap: 10,
    precision: 0,
    textStyle: {
      color: "#333"
    }
  };
  return VisualMapModel2;
}(ComponentModel$1);
var VisualMapModel$1 = VisualMapModel;
var DEFAULT_BAR_BOUND = [20, 140];
var ContinuousModel = function(_super) {
  __extends(ContinuousModel2, _super);
  function ContinuousModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ContinuousModel2.type;
    return _this;
  }
  ContinuousModel2.prototype.optionUpdated = function(newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);
    this.resetExtent();
    this.resetVisual(function(mappingOption) {
      mappingOption.mappingMethod = "linear";
      mappingOption.dataExtent = this.getExtent();
    });
    this._resetRange();
  };
  ContinuousModel2.prototype.resetItemSize = function() {
    _super.prototype.resetItemSize.apply(this, arguments);
    var itemSize = this.itemSize;
    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
  };
  ContinuousModel2.prototype._resetRange = function() {
    var dataExtent = this.getExtent();
    var range = this.option.range;
    if (!range || range.auto) {
      dataExtent.auto = 1;
      this.option.range = dataExtent;
    } else if (isArray$4(range)) {
      if (range[0] > range[1]) {
        range.reverse();
      }
      range[0] = Math.max(range[0], dataExtent[0]);
      range[1] = Math.min(range[1], dataExtent[1]);
    }
  };
  ContinuousModel2.prototype.completeVisualOption = function() {
    _super.prototype.completeVisualOption.apply(this, arguments);
    each$e(this.stateList, function(state) {
      var symbolSize = this.option.controller[state].symbolSize;
      if (symbolSize && symbolSize[0] !== symbolSize[1]) {
        symbolSize[0] = symbolSize[1] / 3;
      }
    }, this);
  };
  ContinuousModel2.prototype.setSelected = function(selected) {
    this.option.range = selected.slice();
    this._resetRange();
  };
  ContinuousModel2.prototype.getSelected = function() {
    var dataExtent = this.getExtent();
    var dataInterval = asc$2((this.get("range") || []).slice());
    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
    return dataInterval;
  };
  ContinuousModel2.prototype.getValueState = function(value) {
    var range = this.option.range;
    var dataExtent = this.getExtent();
    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
  };
  ContinuousModel2.prototype.findTargetDataIndices = function(range) {
    var result = [];
    this.eachTargetSeries(function(seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  ContinuousModel2.prototype.getVisualMeta = function(getColorVisual2) {
    var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
    var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
    var stops = [];
    function setStop(value, valueState) {
      stops.push({
        value,
        color: getColorVisual2(value, valueState)
      });
    }
    var iIdx = 0;
    var oIdx = 0;
    var iLen = iVals.length;
    var oLen = oVals.length;
    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
      if (oVals[oIdx] < iVals[iIdx]) {
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
      first && stops.length && setStop(iVals[iIdx], "outOfRange");
      setStop(iVals[iIdx], "inRange");
    }
    for (var first = 1; oIdx < oLen; oIdx++) {
      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
        if (first) {
          stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
          first = 0;
        }
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    var stopsLen = stops.length;
    return {
      stops,
      outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
    };
  };
  ContinuousModel2.type = "visualMap.continuous";
  ContinuousModel2.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    align: "auto",
    calculable: false,
    hoverLink: true,
    realtime: true,
    handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
    handleSize: "120%",
    handleStyle: {
      borderColor: "#fff",
      borderWidth: 1
    },
    indicatorIcon: "circle",
    indicatorSize: "50%",
    indicatorStyle: {
      borderColor: "#fff",
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: "rgba(0,0,0,0.2)"
    }
  });
  return ContinuousModel2;
}(VisualMapModel$1);
function getColorStopValues(visualMapModel, valueState, dataExtent) {
  if (dataExtent[0] === dataExtent[1]) {
    return dataExtent.slice();
  }
  var count2 = 200;
  var step = (dataExtent[1] - dataExtent[0]) / count2;
  var value = dataExtent[0];
  var stopValues = [];
  for (var i = 0; i <= count2 && value < dataExtent[1]; i++) {
    stopValues.push(value);
    value += step;
  }
  stopValues.push(dataExtent[1]);
  return stopValues;
}
var ContinuousModel$1 = ContinuousModel;
var VisualMapView = function(_super) {
  __extends(VisualMapView2, _super);
  function VisualMapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = VisualMapView2.type;
    _this.autoPositionValues = {
      left: 1,
      right: 1,
      top: 1,
      bottom: 1
    };
    return _this;
  }
  VisualMapView2.prototype.init = function(ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
  };
  VisualMapView2.prototype.render = function(visualMapModel, ecModel, api, payload) {
    this.visualMapModel = visualMapModel;
    if (visualMapModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    this.doRender(visualMapModel, ecModel, api, payload);
  };
  VisualMapView2.prototype.renderBackground = function(group) {
    var visualMapModel = this.visualMapModel;
    var padding = normalizeCssArray(visualMapModel.get("padding") || 0);
    var rect = group.getBoundingRect();
    group.add(new Rect$2({
      z2: -1,
      silent: true,
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[3] + padding[1],
        height: rect.height + padding[0] + padding[2]
      },
      style: {
        fill: visualMapModel.get("backgroundColor"),
        stroke: visualMapModel.get("borderColor"),
        lineWidth: visualMapModel.get("borderWidth")
      }
    }));
  };
  VisualMapView2.prototype.getControllerVisual = function(targetValue, visualCluster, opts) {
    opts = opts || {};
    var forceState = opts.forceState;
    var visualMapModel = this.visualMapModel;
    var visualObj = {};
    if (visualCluster === "color") {
      var defaultColor = visualMapModel.get("contentColor");
      visualObj.color = defaultColor;
    }
    function getter(key2) {
      return visualObj[key2];
    }
    function setter(key2, value) {
      visualObj[key2] = value;
    }
    var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
    var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
    each$e(visualTypes, function(type) {
      var visualMapping = mappings[type];
      if (opts.convertOpacityToAlpha && type === "opacity") {
        type = "colorAlpha";
        visualMapping = mappings.__alphaForOpacity;
      }
      if (VisualMapping$1.dependsOn(type, visualCluster)) {
        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
      }
    });
    return visualObj[visualCluster];
  };
  VisualMapView2.prototype.positionGroup = function(group) {
    var model = this.visualMapModel;
    var api = this.api;
    positionElement(group, model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  VisualMapView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
  };
  VisualMapView2.type = "visualMap";
  return VisualMapView2;
}(ComponentView$1);
var VisualMapView$1 = VisualMapView;
var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
function getItemAlign(visualMapModel, api, itemSize) {
  var modelOption = visualMapModel.option;
  var itemAlign = modelOption.align;
  if (itemAlign != null && itemAlign !== "auto") {
    return itemAlign;
  }
  var ecSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
  var reals = paramsSet[realIndex];
  var fakeValue = [0, null, 10];
  var layoutInput = {};
  for (var i = 0; i < 3; i++) {
    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
  }
  var rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
  var rect = getLayoutRect$1(layoutInput, ecSize, modelOption.padding);
  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
}
function makeHighDownBatch(batch, visualMapModel) {
  each$e(batch || [], function(batchItem) {
    if (batchItem.dataIndex != null) {
      batchItem.dataIndexInside = batchItem.dataIndex;
      batchItem.dataIndex = null;
    }
    batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
  });
  return batch;
}
var linearMap = linearMap$2;
var each$2 = each$e;
var mathMin = Math.min;
var mathMax = Math.max;
var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6;
var ContinuousView = function(_super) {
  __extends(ContinuousView2, _super);
  function ContinuousView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ContinuousView2.type;
    _this._shapes = {};
    _this._dataInterval = [];
    _this._handleEnds = [];
    _this._hoverLinkDataIndices = [];
    return _this;
  }
  ContinuousView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
    this._api = api;
    if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
      this._buildView();
    }
  };
  ContinuousView2.prototype._buildView = function() {
    this.group.removeAll();
    var visualMapModel = this.visualMapModel;
    var thisGroup = this.group;
    this._orient = visualMapModel.get("orient");
    this._useHandle = visualMapModel.get("calculable");
    this._resetInterval();
    this._renderBar(thisGroup);
    var dataRangeText = visualMapModel.get("text");
    this._renderEndsText(thisGroup, dataRangeText, 0);
    this._renderEndsText(thisGroup, dataRangeText, 1);
    this._updateView(true);
    this.renderBackground(thisGroup);
    this._updateView();
    this._enableHoverLinkToSeries();
    this._enableHoverLinkFromSeries();
    this.positionGroup(thisGroup);
  };
  ContinuousView2.prototype._renderEndsText = function(group, dataRangeText, endsIndex) {
    if (!dataRangeText) {
      return;
    }
    var text2 = dataRangeText[1 - endsIndex];
    text2 = text2 != null ? text2 + "" : "";
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get("textGap");
    var itemSize = visualMapModel.itemSize;
    var barGroup = this._shapes.mainGroup;
    var position2 = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
    var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
    var orient = this._orient;
    var textStyleModel = this.visualMapModel.textStyleModel;
    this.group.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        x: position2[0],
        y: position2[1],
        verticalAlign: orient === "horizontal" ? "middle" : align,
        align: orient === "horizontal" ? align : "center",
        text: text2
      })
    }));
  };
  ContinuousView2.prototype._renderBar = function(targetGroup) {
    var visualMapModel = this.visualMapModel;
    var shapes = this._shapes;
    var itemSize = visualMapModel.itemSize;
    var orient = this._orient;
    var useHandle = this._useHandle;
    var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);
    var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);
    var gradientBarGroup = new Group$3();
    mainGroup.add(gradientBarGroup);
    gradientBarGroup.add(shapes.outOfRange = createPolygon());
    gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, bind$1(this._dragHandle, this, "all", false), bind$1(this._dragHandle, this, "all", true)));
    gradientBarGroup.setClipPath(new Rect$2({
      shape: {
        x: 0,
        y: 0,
        width: itemSize[0],
        height: itemSize[1],
        r: 3
      }
    }));
    var textRect = visualMapModel.textStyleModel.getTextRect("\u56FD");
    var textSize = mathMax(textRect.width, textRect.height);
    if (useHandle) {
      shapes.handleThumbs = [];
      shapes.handleLabels = [];
      shapes.handleLabelPoints = [];
      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);
      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
    }
    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);
    targetGroup.add(mainGroup);
  };
  ContinuousView2.prototype._createHandle = function(visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
    var onDrift = bind$1(this._dragHandle, this, handleIndex, false);
    var onDragEnd = bind$1(this._dragHandle, this, handleIndex, true);
    var handleSize = parsePercent$1(visualMapModel.get("handleSize"), itemSize[0]);
    var handleThumb = createSymbol(visualMapModel.get("handleIcon"), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
    var cursor = getCursor(this._orient);
    handleThumb.attr({
      cursor,
      draggable: true,
      drift: onDrift,
      ondragend: onDragEnd,
      onmousemove: function(e2) {
        stop(e2.event);
      }
    });
    handleThumb.x = itemSize[0] / 2;
    handleThumb.useStyle(visualMapModel.getModel("handleStyle").getItemStyle());
    handleThumb.setStyle({
      strokeNoScale: true,
      strokeFirst: true
    });
    handleThumb.style.lineWidth *= 2;
    handleThumb.ensureState("emphasis").style = visualMapModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
    setAsHighDownDispatcher(handleThumb, true);
    mainGroup.add(handleThumb);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var handleLabel = new ZRText$1({
      cursor,
      draggable: true,
      drift: onDrift,
      onmousemove: function(e2) {
        stop(e2.event);
      },
      ondragend: onDragEnd,
      style: createTextStyle$1(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    handleLabel.ensureState("blur").style = {
      opacity: 0.1
    };
    handleLabel.stateTransition = {
      duration: 200
    };
    this.group.add(handleLabel);
    var handleLabelPoint = [handleSize, 0];
    var shapes = this._shapes;
    shapes.handleThumbs[handleIndex] = handleThumb;
    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
    shapes.handleLabels[handleIndex] = handleLabel;
  };
  ContinuousView2.prototype._createIndicator = function(visualMapModel, mainGroup, itemSize, textSize, orient) {
    var scale2 = parsePercent$1(visualMapModel.get("indicatorSize"), itemSize[0]);
    var indicator = createSymbol(visualMapModel.get("indicatorIcon"), -scale2 / 2, -scale2 / 2, scale2, scale2, null, true);
    indicator.attr({
      cursor: "move",
      invisible: true,
      silent: true,
      x: itemSize[0] / 2
    });
    var indicatorStyle = visualMapModel.getModel("indicatorStyle").getItemStyle();
    if (indicator instanceof ZRImage$1) {
      var pathStyle = indicator.style;
      indicator.useStyle(extend$3({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, indicatorStyle));
    } else {
      indicator.useStyle(indicatorStyle);
    }
    mainGroup.add(indicator);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var indicatorLabel = new ZRText$1({
      silent: true,
      invisible: true,
      style: createTextStyle$1(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    this.group.add(indicatorLabel);
    var indicatorLabelPoint = [(orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];
    var shapes = this._shapes;
    shapes.indicator = indicator;
    shapes.indicatorLabel = indicatorLabel;
    shapes.indicatorLabelPoint = indicatorLabelPoint;
    this._firstShowIndicator = true;
  };
  ContinuousView2.prototype._dragHandle = function(handleIndex, isEnd, dx, dy) {
    if (!this._useHandle) {
      return;
    }
    this._dragging = !isEnd;
    if (!isEnd) {
      var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);
      this._updateInterval(handleIndex, vertex[1]);
      this._hideIndicator();
      this._updateView();
    }
    if (isEnd === !this.visualMapModel.get("realtime")) {
      this.api.dispatchAction({
        type: "selectDataRange",
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: this._dataInterval.slice()
      });
    }
    if (isEnd) {
      !this._hovering && this._clearHoverLinkToSeries();
    } else if (useHoverLinkOnHandle(this.visualMapModel)) {
      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
    }
  };
  ContinuousView2.prototype._resetInterval = function() {
    var visualMapModel = this.visualMapModel;
    var dataInterval = this._dataInterval = visualMapModel.getSelected();
    var dataExtent = visualMapModel.getExtent();
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
  };
  ContinuousView2.prototype._updateInterval = function(handleIndex, delta) {
    delta = delta || 0;
    var visualMapModel = this.visualMapModel;
    var handleEnds = this._handleEnds;
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);
    var dataExtent = visualMapModel.getExtent();
    this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
  };
  ContinuousView2.prototype._updateView = function(forSketch) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var shapes = this._shapes;
    var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
    var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
    var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
    var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
    shapes.inRange.setStyle({
      fill: visualInRange.barColor
    }).setShape("points", visualInRange.barPoints);
    shapes.outOfRange.setStyle({
      fill: visualOutOfRange.barColor
    }).setShape("points", visualOutOfRange.barPoints);
    this._updateHandle(inRangeHandleEnds, visualInRange);
  };
  ContinuousView2.prototype._createBarVisual = function(dataInterval, dataExtent, handleEnds, forceState) {
    var opts = {
      forceState,
      convertOpacityToAlpha: true
    };
    var colorStops = this._makeColorGradient(dataInterval, opts);
    var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
    var barPoints = this._createBarPoints(handleEnds, symbolSizes);
    return {
      barColor: new LinearGradient$1(0, 0, 0, 1, colorStops),
      barPoints,
      handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
    };
  };
  ContinuousView2.prototype._makeColorGradient = function(dataInterval, opts) {
    var sampleNumber = 100;
    var colorStops = [];
    var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
    colorStops.push({
      color: this.getControllerVisual(dataInterval[0], "color", opts),
      offset: 0
    });
    for (var i = 1; i < sampleNumber; i++) {
      var currValue = dataInterval[0] + step * i;
      if (currValue > dataInterval[1]) {
        break;
      }
      colorStops.push({
        color: this.getControllerVisual(currValue, "color", opts),
        offset: i / sampleNumber
      });
    }
    colorStops.push({
      color: this.getControllerVisual(dataInterval[1], "color", opts),
      offset: 1
    });
    return colorStops;
  };
  ContinuousView2.prototype._createBarPoints = function(handleEnds, symbolSizes) {
    var itemSize = this.visualMapModel.itemSize;
    return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
  };
  ContinuousView2.prototype._createBarGroup = function(itemAlign) {
    var orient = this._orient;
    var inverse = this.visualMapModel.get("inverse");
    return new Group$3(orient === "horizontal" && !inverse ? {
      scaleX: itemAlign === "bottom" ? 1 : -1,
      rotation: Math.PI / 2
    } : orient === "horizontal" && inverse ? {
      scaleX: itemAlign === "bottom" ? -1 : 1,
      rotation: -Math.PI / 2
    } : orient === "vertical" && !inverse ? {
      scaleX: itemAlign === "left" ? 1 : -1,
      scaleY: -1
    } : {
      scaleX: itemAlign === "left" ? 1 : -1
    });
  };
  ContinuousView2.prototype._updateHandle = function(handleEnds, visualInRange) {
    if (!this._useHandle) {
      return;
    }
    var shapes = this._shapes;
    var visualMapModel = this.visualMapModel;
    var handleThumbs = shapes.handleThumbs;
    var handleLabels = shapes.handleLabels;
    var itemSize = visualMapModel.itemSize;
    var dataExtent = visualMapModel.getExtent();
    each$2([0, 1], function(handleIndex) {
      var handleThumb = handleThumbs[handleIndex];
      handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
      handleThumb.y = handleEnds[handleIndex];
      var val = linearMap(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
      var symbolSize = this.getControllerVisual(val, "symbolSize");
      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
      handleThumb.x = itemSize[0] - symbolSize / 2;
      var textPoint = applyTransform(shapes.handleLabelPoints[handleIndex], getTransform$1(handleThumb, this.group));
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
        verticalAlign: "middle",
        align: this._orient === "vertical" ? this._applyTransform("left", shapes.mainGroup) : "center"
      });
    }, this);
  };
  ContinuousView2.prototype._showIndicator = function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var itemSize = visualMapModel.itemSize;
    var sizeExtent = [0, itemSize[1]];
    var shapes = this._shapes;
    var indicator = shapes.indicator;
    if (!indicator) {
      return;
    }
    indicator.attr("invisible", false);
    var opts = {
      convertOpacityToAlpha: true
    };
    var color2 = this.getControllerVisual(cursorValue, "color", opts);
    var symbolSize = this.getControllerVisual(cursorValue, "symbolSize");
    var y = linearMap(cursorValue, dataExtent, sizeExtent, true);
    var x2 = itemSize[0] - symbolSize / 2;
    var oldIndicatorPos = {
      x: indicator.x,
      y: indicator.y
    };
    indicator.y = y;
    indicator.x = x2;
    var textPoint = applyTransform(shapes.indicatorLabelPoint, getTransform$1(indicator, this.group));
    var indicatorLabel = shapes.indicatorLabel;
    indicatorLabel.attr("invisible", false);
    var align = this._applyTransform("left", shapes.mainGroup);
    var orient = this._orient;
    var isHorizontal = orient === "horizontal";
    indicatorLabel.setStyle({
      text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
      verticalAlign: isHorizontal ? align : "middle",
      align: isHorizontal ? "center" : align
    });
    var indicatorNewProps = {
      x: x2,
      y,
      style: {
        fill: color2
      }
    };
    var labelNewProps = {
      style: {
        x: textPoint[0],
        y: textPoint[1]
      }
    };
    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
      var animationCfg = {
        duration: 100,
        easing: "cubicInOut",
        additive: true
      };
      indicator.x = oldIndicatorPos.x;
      indicator.y = oldIndicatorPos.y;
      indicator.animateTo(indicatorNewProps, animationCfg);
      indicatorLabel.animateTo(labelNewProps, animationCfg);
    } else {
      indicator.attr(indicatorNewProps);
      indicatorLabel.attr(labelNewProps);
    }
    this._firstShowIndicator = false;
    var handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        this._api.enterBlur(handleLabels[i]);
      }
    }
  };
  ContinuousView2.prototype._enableHoverLinkToSeries = function() {
    var self2 = this;
    this._shapes.mainGroup.on("mousemove", function(e2) {
      self2._hovering = true;
      if (!self2._dragging) {
        var itemSize = self2.visualMapModel.itemSize;
        var pos = self2._applyTransform([e2.offsetX, e2.offsetY], self2._shapes.mainGroup, true, true);
        pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);
        self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
      }
    }).on("mouseout", function() {
      self2._hovering = false;
      !self2._dragging && self2._clearHoverLinkToSeries();
    });
  };
  ContinuousView2.prototype._enableHoverLinkFromSeries = function() {
    var zr = this.api.getZr();
    if (this.visualMapModel.option.hoverLink) {
      zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
      zr.on("mouseout", this._hideIndicator, this);
    } else {
      this._clearHoverLinkFromSeries();
    }
  };
  ContinuousView2.prototype._doHoverLinkToSeries = function(cursorPos, hoverOnBar) {
    var visualMapModel = this.visualMapModel;
    var itemSize = visualMapModel.itemSize;
    if (!visualMapModel.option.hoverLink) {
      return;
    }
    var sizeExtent = [0, itemSize[1]];
    var dataExtent = visualMapModel.getExtent();
    cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
    var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
    var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
    var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
    var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
    if (hoverOnBar) {
      if (valueRange[0] === -Infinity) {
        this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
      } else if (valueRange[1] === Infinity) {
        this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
      } else {
        this._showIndicator(cursorValue, cursorValue, "\u2248 ", halfHoverLinkSize);
      }
    }
    var oldBatch = this._hoverLinkDataIndices;
    var newBatch = [];
    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
    }
    var resultBatches = compressBatches(oldBatch, newBatch);
    this._dispatchHighDown("downplay", makeHighDownBatch(resultBatches[0], visualMapModel));
    this._dispatchHighDown("highlight", makeHighDownBatch(resultBatches[1], visualMapModel));
  };
  ContinuousView2.prototype._hoverLinkFromSeriesMouseOver = function(e2) {
    var el = e2.target;
    var visualMapModel = this.visualMapModel;
    if (!el || getECData(el).dataIndex == null) {
      return;
    }
    var ecData = getECData(el);
    var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
    if (!visualMapModel.isTargetSeries(dataModel)) {
      return;
    }
    var data = dataModel.getData(ecData.dataType);
    var value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);
    if (!isNaN(value)) {
      this._showIndicator(value, value);
    }
  };
  ContinuousView2.prototype._hideIndicator = function() {
    var shapes = this._shapes;
    shapes.indicator && shapes.indicator.attr("invisible", true);
    shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
    var handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        this._api.leaveBlur(handleLabels[i]);
      }
    }
  };
  ContinuousView2.prototype._clearHoverLinkToSeries = function() {
    this._hideIndicator();
    var indices = this._hoverLinkDataIndices;
    this._dispatchHighDown("downplay", makeHighDownBatch(indices, this.visualMapModel));
    indices.length = 0;
  };
  ContinuousView2.prototype._clearHoverLinkFromSeries = function() {
    this._hideIndicator();
    var zr = this.api.getZr();
    zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
    zr.off("mouseout", this._hideIndicator);
  };
  ContinuousView2.prototype._applyTransform = function(vertex, element, inverse, global2) {
    var transform2 = getTransform$1(element, global2 ? null : this.group);
    return isArray$4(vertex) ? applyTransform(vertex, transform2, inverse) : transformDirection(vertex, transform2, inverse);
  };
  ContinuousView2.prototype._dispatchHighDown = function(type, batch) {
    batch && batch.length && this.api.dispatchAction({
      type,
      batch
    });
  };
  ContinuousView2.prototype.dispose = function() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  };
  ContinuousView2.prototype.remove = function() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  };
  ContinuousView2.type = "visualMap.continuous";
  return ContinuousView2;
}(VisualMapView$1);
function createPolygon(points2, cursor, onDrift, onDragEnd) {
  return new Polygon$1({
    shape: {
      points: points2
    },
    draggable: !!onDrift,
    cursor,
    drift: onDrift,
    onmousemove: function(e2) {
      stop(e2.event);
    },
    ondragend: onDragEnd
  });
}
function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
  var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
  var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
  if (hoverLinkDataSize) {
    halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
  }
  return halfHoverLinkSize;
}
function useHoverLinkOnHandle(visualMapModel) {
  var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
  return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
}
function getCursor(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var ContinuousView$1 = ContinuousView;
var visualMapActionInfo = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  update: "update"
};
var visualMapActionHander = function(payload, ecModel) {
  ecModel.eachComponent({
    mainType: "visualMap",
    query: payload
  }, function(model) {
    model.setSelected(payload.selected);
  });
};
var visualMapEncodingHandlers = [
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var resetDefines = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        var pipelineContext = seriesModel.pipelineContext;
        if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
          return;
        }
        resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind$1(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
      });
      return resetDefines;
    }
  },
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      var visualMetaList = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          var visualMeta = visualMapModel.getVisualMeta(bind$1(getColorVisual, null, seriesModel, visualMapModel)) || {
            stops: [],
            outerColors: []
          };
          var dimIdx = visualMapModel.getDataDimensionIndex(data);
          if (dimIdx >= 0) {
            visualMeta.dimension = dimIdx;
            visualMetaList.push(visualMeta);
          }
        }
      });
      seriesModel.getData().setVisual("visualMeta", visualMetaList);
    }
  }
];
function getColorVisual(seriesModel, visualMapModel, value, valueState) {
  var mappings = visualMapModel.targetVisuals[valueState];
  var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
  var resultVisual = {
    color: getVisualFromData(seriesModel.getData(), "color")
  };
  for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
    var type = visualTypes[i];
    var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
    mapping && mapping.applyVisual(value, getVisual, setVisual);
  }
  return resultVisual.color;
  function getVisual(key2) {
    return resultVisual[key2];
  }
  function setVisual(key2, value2) {
    resultVisual[key2] = value2;
  }
}
var each$1 = each$e;
function visualMapPreprocessor(option) {
  var visualMap = option && option.visualMap;
  if (!isArray$4(visualMap)) {
    visualMap = visualMap ? [visualMap] : [];
  }
  each$1(visualMap, function(opt) {
    if (!opt) {
      return;
    }
    if (has(opt, "splitList") && !has(opt, "pieces")) {
      opt.pieces = opt.splitList;
      delete opt.splitList;
    }
    var pieces = opt.pieces;
    if (pieces && isArray$4(pieces)) {
      each$1(pieces, function(piece) {
        if (isObject$9(piece)) {
          if (has(piece, "start") && !has(piece, "min")) {
            piece.min = piece.start;
          }
          if (has(piece, "end") && !has(piece, "max")) {
            piece.max = piece.end;
          }
        }
      });
    }
  });
}
function has(obj, name) {
  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
}
var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }
  installed = true;
  registers.registerSubTypeDefaulter("visualMap", function(option) {
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
  });
  registers.registerAction(visualMapActionInfo, visualMapActionHander);
  each$e(visualMapEncodingHandlers, function(handler) {
    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
  });
  registers.registerPreprocessor(visualMapPreprocessor);
}
function install$4(registers) {
  registers.registerComponentModel(ContinuousModel$1);
  registers.registerComponentView(ContinuousView$1);
  installCommon(registers);
}
var PiecewiseModel = function(_super) {
  __extends(PiecewiseModel2, _super);
  function PiecewiseModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PiecewiseModel2.type;
    _this._pieceList = [];
    return _this;
  }
  PiecewiseModel2.prototype.optionUpdated = function(newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);
    this.resetExtent();
    var mode = this._mode = this._determineMode();
    this._pieceList = [];
    resetMethods[this._mode].call(this, this._pieceList);
    this._resetSelected(newOption, isInit);
    var categories = this.option.categories;
    this.resetVisual(function(mappingOption, state) {
      if (mode === "categories") {
        mappingOption.mappingMethod = "category";
        mappingOption.categories = clone$3(categories);
      } else {
        mappingOption.dataExtent = this.getExtent();
        mappingOption.mappingMethod = "piecewise";
        mappingOption.pieceList = map$1(this._pieceList, function(piece) {
          piece = clone$3(piece);
          if (state !== "inRange") {
            piece.visual = null;
          }
          return piece;
        });
      }
    });
  };
  PiecewiseModel2.prototype.completeVisualOption = function() {
    var option = this.option;
    var visualTypesInPieces = {};
    var visualTypes = VisualMapping$1.listVisualTypes();
    var isCategory2 = this.isCategory();
    each$e(option.pieces, function(piece) {
      each$e(visualTypes, function(visualType) {
        if (piece.hasOwnProperty(visualType)) {
          visualTypesInPieces[visualType] = 1;
        }
      });
    });
    each$e(visualTypesInPieces, function(v2, visualType) {
      var exists = false;
      each$e(this.stateList, function(state) {
        exists = exists || has2(option, state, visualType) || has2(option.target, state, visualType);
      }, this);
      !exists && each$e(this.stateList, function(state) {
        (option[state] || (option[state] = {}))[visualType] = visualDefault$1.get(visualType, state === "inRange" ? "active" : "inactive", isCategory2);
      });
    }, this);
    function has2(obj, state, visualType) {
      return obj && obj[state] && obj[state].hasOwnProperty(visualType);
    }
    _super.prototype.completeVisualOption.apply(this, arguments);
  };
  PiecewiseModel2.prototype._resetSelected = function(newOption, isInit) {
    var thisOption = this.option;
    var pieceList = this._pieceList;
    var selected = (isInit ? thisOption : newOption).selected || {};
    thisOption.selected = selected;
    each$e(pieceList, function(piece, index2) {
      var key2 = this.getSelectedMapKey(piece);
      if (!selected.hasOwnProperty(key2)) {
        selected[key2] = true;
      }
    }, this);
    if (thisOption.selectedMode === "single") {
      var hasSel_1 = false;
      each$e(pieceList, function(piece, index2) {
        var key2 = this.getSelectedMapKey(piece);
        if (selected[key2]) {
          hasSel_1 ? selected[key2] = false : hasSel_1 = true;
        }
      }, this);
    }
  };
  PiecewiseModel2.prototype.getItemSymbol = function() {
    return this.get("itemSymbol");
  };
  PiecewiseModel2.prototype.getSelectedMapKey = function(piece) {
    return this._mode === "categories" ? piece.value + "" : piece.index + "";
  };
  PiecewiseModel2.prototype.getPieceList = function() {
    return this._pieceList;
  };
  PiecewiseModel2.prototype._determineMode = function() {
    var option = this.option;
    return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
  };
  PiecewiseModel2.prototype.setSelected = function(selected) {
    this.option.selected = clone$3(selected);
  };
  PiecewiseModel2.prototype.getValueState = function(value) {
    var index2 = VisualMapping$1.findPieceIndex(value, this._pieceList);
    return index2 != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index2])] ? "inRange" : "outOfRange" : "outOfRange";
  };
  PiecewiseModel2.prototype.findTargetDataIndices = function(pieceIndex) {
    var result = [];
    var pieceList = this._pieceList;
    this.eachTargetSeries(function(seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        var pIdx = VisualMapping$1.findPieceIndex(value, pieceList);
        pIdx === pieceIndex && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  PiecewiseModel2.prototype.getRepresentValue = function(piece) {
    var representValue;
    if (this.isCategory()) {
      representValue = piece.value;
    } else {
      if (piece.value != null) {
        representValue = piece.value;
      } else {
        var pieceInterval = piece.interval || [];
        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
      }
    }
    return representValue;
  };
  PiecewiseModel2.prototype.getVisualMeta = function(getColorVisual2) {
    if (this.isCategory()) {
      return;
    }
    var stops = [];
    var outerColors = ["", ""];
    var visualMapModel = this;
    function setStop(interval, valueState) {
      var representValue = visualMapModel.getRepresentValue({
        interval
      });
      if (!valueState) {
        valueState = visualMapModel.getValueState(representValue);
      }
      var color2 = getColorVisual2(representValue, valueState);
      if (interval[0] === -Infinity) {
        outerColors[0] = color2;
      } else if (interval[1] === Infinity) {
        outerColors[1] = color2;
      } else {
        stops.push({
          value: interval[0],
          color: color2
        }, {
          value: interval[1],
          color: color2
        });
      }
    }
    var pieceList = this._pieceList.slice();
    if (!pieceList.length) {
      pieceList.push({
        interval: [-Infinity, Infinity]
      });
    } else {
      var edge = pieceList[0].interval[0];
      edge !== -Infinity && pieceList.unshift({
        interval: [-Infinity, edge]
      });
      edge = pieceList[pieceList.length - 1].interval[1];
      edge !== Infinity && pieceList.push({
        interval: [edge, Infinity]
      });
    }
    var curr = -Infinity;
    each$e(pieceList, function(piece) {
      var interval = piece.interval;
      if (interval) {
        interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
        setStop(interval.slice());
        curr = interval[1];
      }
    }, this);
    return {
      stops,
      outerColors
    };
  };
  PiecewiseModel2.type = "visualMap.piecewise";
  PiecewiseModel2.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    selected: null,
    minOpen: false,
    maxOpen: false,
    align: "auto",
    itemWidth: 20,
    itemHeight: 14,
    itemSymbol: "roundRect",
    pieces: null,
    categories: null,
    splitNumber: 5,
    selectedMode: "multiple",
    itemGap: 10,
    hoverLink: true
  });
  return PiecewiseModel2;
}(VisualMapModel$1);
var resetMethods = {
  splitNumber: function(outPieceList) {
    var thisOption = this.option;
    var precision = Math.min(thisOption.precision, 20);
    var dataExtent = this.getExtent();
    var splitNumber = thisOption.splitNumber;
    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
    thisOption.splitNumber = splitNumber;
    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
      precision++;
    }
    thisOption.precision = precision;
    splitStep = +splitStep.toFixed(precision);
    if (thisOption.minOpen) {
      outPieceList.push({
        interval: [-Infinity, dataExtent[0]],
        close: [0, 0]
      });
    }
    for (var index2 = 0, curr = dataExtent[0]; index2 < splitNumber; curr += splitStep, index2++) {
      var max3 = index2 === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
      outPieceList.push({
        interval: [curr, max3],
        close: [1, 1]
      });
    }
    if (thisOption.maxOpen) {
      outPieceList.push({
        interval: [dataExtent[1], Infinity],
        close: [0, 0]
      });
    }
    reformIntervals(outPieceList);
    each$e(outPieceList, function(piece, index3) {
      piece.index = index3;
      piece.text = this.formatValueText(piece.interval);
    }, this);
  },
  categories: function(outPieceList) {
    var thisOption = this.option;
    each$e(thisOption.categories, function(cate) {
      outPieceList.push({
        text: this.formatValueText(cate, true),
        value: cate
      });
    }, this);
    normalizeReverse(thisOption, outPieceList);
  },
  pieces: function(outPieceList) {
    var thisOption = this.option;
    each$e(thisOption.pieces, function(pieceListItem, index2) {
      if (!isObject$9(pieceListItem)) {
        pieceListItem = {
          value: pieceListItem
        };
      }
      var item = {
        text: "",
        index: index2
      };
      if (pieceListItem.label != null) {
        item.text = pieceListItem.label;
      }
      if (pieceListItem.hasOwnProperty("value")) {
        var value = item.value = pieceListItem.value;
        item.interval = [value, value];
        item.close = [1, 1];
      } else {
        var interval = item.interval = [];
        var close_1 = item.close = [0, 0];
        var closeList = [1, 0, 1];
        var infinityList = [-Infinity, Infinity];
        var useMinMax = [];
        for (var lg = 0; lg < 2; lg++) {
          var names2 = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
          for (var i = 0; i < 3 && interval[lg] == null; i++) {
            interval[lg] = pieceListItem[names2[i]];
            close_1[lg] = closeList[i];
            useMinMax[lg] = i === 2;
          }
          interval[lg] == null && (interval[lg] = infinityList[lg]);
        }
        useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);
        useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);
        if (interval[0] === interval[1] && close_1[0] && close_1[1]) {
          item.value = interval[0];
        }
      }
      item.visual = VisualMapping$1.retrieveVisuals(pieceListItem);
      outPieceList.push(item);
    }, this);
    normalizeReverse(thisOption, outPieceList);
    reformIntervals(outPieceList);
    each$e(outPieceList, function(piece) {
      var close2 = piece.close;
      var edgeSymbols = [["<", "\u2264"][close2[1]], [">", "\u2265"][close2[0]]];
      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
    }, this);
  }
};
function normalizeReverse(thisOption, pieceList) {
  var inverse = thisOption.inverse;
  if (thisOption.orient === "vertical" ? !inverse : inverse) {
    pieceList.reverse();
  }
}
var PiecewiseModel$1 = PiecewiseModel;
var PiecewiseVisualMapView = function(_super) {
  __extends(PiecewiseVisualMapView2, _super);
  function PiecewiseVisualMapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PiecewiseVisualMapView2.type;
    return _this;
  }
  PiecewiseVisualMapView2.prototype.doRender = function() {
    var thisGroup = this.group;
    thisGroup.removeAll();
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get("textGap");
    var textStyleModel = visualMapModel.textStyleModel;
    var textFont = textStyleModel.getFont();
    var textFill = textStyleModel.getTextColor();
    var itemAlign = this._getItemAlign();
    var itemSize = visualMapModel.itemSize;
    var viewData = this._getViewData();
    var endsText = viewData.endsText;
    var showLabel = retrieve(visualMapModel.get("showLabel", true), !endsText);
    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
    each$e(viewData.viewPieceList, function(item) {
      var piece = item.piece;
      var itemGroup = new Group$3();
      itemGroup.onclick = bind$1(this._onItemClick, this, piece);
      this._enableHoverLink(itemGroup, item.indexInModelPieceList);
      var representValue = visualMapModel.getRepresentValue(piece);
      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
      if (showLabel) {
        var visualState = this.visualMapModel.getValueState(representValue);
        itemGroup.add(new ZRText$1({
          style: {
            x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
            y: itemSize[1] / 2,
            text: piece.text,
            verticalAlign: "middle",
            align: itemAlign,
            font: textFont,
            fill: textFill,
            opacity: visualState === "outOfRange" ? 0.5 : 1
          }
        }));
      }
      thisGroup.add(itemGroup);
    }, this);
    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
    box$1(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
    this.renderBackground(thisGroup);
    this.positionGroup(thisGroup);
  };
  PiecewiseVisualMapView2.prototype._enableHoverLink = function(itemGroup, pieceIndex) {
    var _this = this;
    itemGroup.on("mouseover", function() {
      return onHoverLink("highlight");
    }).on("mouseout", function() {
      return onHoverLink("downplay");
    });
    var onHoverLink = function(method) {
      var visualMapModel = _this.visualMapModel;
      visualMapModel.option.hoverLink && _this.api.dispatchAction({
        type: method,
        batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
      });
    };
  };
  PiecewiseVisualMapView2.prototype._getItemAlign = function() {
    var visualMapModel = this.visualMapModel;
    var modelOption = visualMapModel.option;
    if (modelOption.orient === "vertical") {
      return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
    } else {
      var align = modelOption.align;
      if (!align || align === "auto") {
        align = "left";
      }
      return align;
    }
  };
  PiecewiseVisualMapView2.prototype._renderEndsText = function(group, text2, itemSize, showLabel, itemAlign) {
    if (!text2) {
      return;
    }
    var itemGroup = new Group$3();
    var textStyleModel = this.visualMapModel.textStyleModel;
    itemGroup.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
        y: itemSize[1] / 2,
        verticalAlign: "middle",
        align: showLabel ? itemAlign : "center",
        text: text2
      })
    }));
    group.add(itemGroup);
  };
  PiecewiseVisualMapView2.prototype._getViewData = function() {
    var visualMapModel = this.visualMapModel;
    var viewPieceList = map$1(visualMapModel.getPieceList(), function(piece, index2) {
      return {
        piece,
        indexInModelPieceList: index2
      };
    });
    var endsText = visualMapModel.get("text");
    var orient = visualMapModel.get("orient");
    var inverse = visualMapModel.get("inverse");
    if (orient === "horizontal" ? inverse : !inverse) {
      viewPieceList.reverse();
    } else if (endsText) {
      endsText = endsText.slice().reverse();
    }
    return {
      viewPieceList,
      endsText
    };
  };
  PiecewiseVisualMapView2.prototype._createItemSymbol = function(group, representValue, shapeParam) {
    group.add(createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
  };
  PiecewiseVisualMapView2.prototype._onItemClick = function(piece) {
    var visualMapModel = this.visualMapModel;
    var option = visualMapModel.option;
    var selected = clone$3(option.selected);
    var newKey = visualMapModel.getSelectedMapKey(piece);
    if (option.selectedMode === "single") {
      selected[newKey] = true;
      each$e(selected, function(o2, key2) {
        selected[key2] = key2 === newKey;
      });
    } else {
      selected[newKey] = !selected[newKey];
    }
    this.api.dispatchAction({
      type: "selectDataRange",
      from: this.uid,
      visualMapId: this.visualMapModel.id,
      selected
    });
  };
  PiecewiseVisualMapView2.type = "visualMap.piecewise";
  return PiecewiseVisualMapView2;
}(VisualMapView$1);
var PiecewiseView = PiecewiseVisualMapView;
function install$3(registers) {
  registers.registerComponentModel(PiecewiseModel$1);
  registers.registerComponentView(PiecewiseView);
  installCommon(registers);
}
function install$2(registers) {
  use(install$4);
  use(install$3);
}
var DEFAULT_OPTION = {
  label: {
    enabled: true
  },
  decal: {
    show: false
  }
};
var inner = makeInner();
var decalPaletteScope = {};
function ariaVisual(ecModel, api) {
  var ariaModel = ecModel.getModel("aria");
  if (!ariaModel.get("enabled")) {
    return;
  }
  var defaultOption2 = clone$3(DEFAULT_OPTION);
  merge(defaultOption2.label, ecModel.getLocaleModel().get("aria"), false);
  merge(ariaModel.option, defaultOption2, false);
  setDecal();
  setLabel();
  function setDecal() {
    var decalModel = ariaModel.getModel("decal");
    var useDecal = decalModel.get("show");
    if (useDecal) {
      var paletteScopeGroupByType_1 = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.isColorBySeries()) {
          return;
        }
        var decalScope = paletteScopeGroupByType_1.get(seriesModel.type);
        if (!decalScope) {
          decalScope = {};
          paletteScopeGroupByType_1.set(seriesModel.type, decalScope);
        }
        inner(seriesModel).scope = decalScope;
      });
      ecModel.eachRawSeries(function(seriesModel) {
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        if (isFunction$2(seriesModel.enableAriaDecal)) {
          seriesModel.enableAriaDecal();
          return;
        }
        var data = seriesModel.getData();
        if (!seriesModel.isColorBySeries()) {
          var dataAll_1 = seriesModel.getRawData();
          var idxMap_1 = {};
          var decalScope_1 = inner(seriesModel).scope;
          data.each(function(idx) {
            var rawIdx = data.getRawIndex(idx);
            idxMap_1[rawIdx] = idx;
          });
          var dataCount_1 = dataAll_1.count();
          dataAll_1.each(function(rawIdx) {
            var idx = idxMap_1[rawIdx];
            var name = dataAll_1.getName(rawIdx) || rawIdx + "";
            var paletteDecal2 = getDecalFromPalette(seriesModel.ecModel, name, decalScope_1, dataCount_1);
            var specifiedDecal2 = data.getItemVisual(idx, "decal");
            data.setItemVisual(idx, "decal", mergeDecal(specifiedDecal2, paletteDecal2));
          });
        } else {
          var paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
          var specifiedDecal = data.getVisual("decal");
          data.setVisual("decal", mergeDecal(specifiedDecal, paletteDecal));
        }
        function mergeDecal(specifiedDecal2, paletteDecal2) {
          var resultDecal = specifiedDecal2 ? extend$3(extend$3({}, paletteDecal2), specifiedDecal2) : paletteDecal2;
          resultDecal.dirty = true;
          return resultDecal;
        }
      });
    }
  }
  function setLabel() {
    var labelLocale = ecModel.getLocaleModel().get("aria");
    var labelModel = ariaModel.getModel("label");
    labelModel.option = defaults$1(labelModel.option, labelLocale);
    if (!labelModel.get("enabled")) {
      return;
    }
    var dom = api.getZr().dom;
    if (labelModel.get("description")) {
      dom.setAttribute("aria-label", labelModel.get("description"));
      return;
    }
    var seriesCnt = ecModel.getSeriesCount();
    var maxDataCnt = labelModel.get(["data", "maxCount"]) || 10;
    var maxSeriesCnt = labelModel.get(["series", "maxCount"]) || 10;
    var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
    var ariaLabel;
    if (seriesCnt < 1) {
      return;
    } else {
      var title = getTitle();
      if (title) {
        var withTitle = labelModel.get(["general", "withTitle"]);
        ariaLabel = replace(withTitle, {
          title
        });
      } else {
        ariaLabel = labelModel.get(["general", "withoutTitle"]);
      }
      var seriesLabels_1 = [];
      var prefix = seriesCnt > 1 ? labelModel.get(["series", "multiple", "prefix"]) : labelModel.get(["series", "single", "prefix"]);
      ariaLabel += replace(prefix, {
        seriesCount: seriesCnt
      });
      ecModel.eachSeries(function(seriesModel, idx) {
        if (idx < displaySeriesCnt) {
          var seriesLabel = void 0;
          var seriesName = seriesModel.get("name");
          var withName = seriesName ? "withName" : "withoutName";
          seriesLabel = seriesCnt > 1 ? labelModel.get(["series", "multiple", withName]) : labelModel.get(["series", "single", withName]);
          seriesLabel = replace(seriesLabel, {
            seriesId: seriesModel.seriesIndex,
            seriesName: seriesModel.get("name"),
            seriesType: getSeriesTypeName(seriesModel.subType)
          });
          var data = seriesModel.getData();
          if (data.count() > maxDataCnt) {
            var partialLabel = labelModel.get(["data", "partialData"]);
            seriesLabel += replace(partialLabel, {
              displayCnt: maxDataCnt
            });
          } else {
            seriesLabel += labelModel.get(["data", "allData"]);
          }
          var middleSeparator_1 = labelModel.get(["data", "separator", "middle"]);
          var endSeparator_1 = labelModel.get(["data", "separator", "end"]);
          var dataLabels = [];
          for (var i = 0; i < data.count(); i++) {
            if (i < maxDataCnt) {
              var name_1 = data.getName(i);
              var value = data.getValues(i);
              var dataLabel = labelModel.get(["data", name_1 ? "withName" : "withoutName"]);
              dataLabels.push(replace(dataLabel, {
                name: name_1,
                value: value.join(middleSeparator_1)
              }));
            }
          }
          seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1;
          seriesLabels_1.push(seriesLabel);
        }
      });
      var separatorModel = labelModel.getModel(["series", "multiple", "separator"]);
      var middleSeparator = separatorModel.get("middle");
      var endSeparator = separatorModel.get("end");
      ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator;
      dom.setAttribute("aria-label", ariaLabel);
    }
  }
  function replace(str, keyValues) {
    if (!isString$2(str)) {
      return str;
    }
    var result = str;
    each$e(keyValues, function(value, key2) {
      result = result.replace(new RegExp("\\{\\s*" + key2 + "\\s*\\}", "g"), value);
    });
    return result;
  }
  function getTitle() {
    var title = ecModel.get("title");
    if (title && title.length) {
      title = title[0];
    }
    return title && title.text;
  }
  function getSeriesTypeName(type) {
    return ecModel.getLocaleModel().get(["series", "typeNames"])[type] || "\u81EA\u5B9A\u4E49\u56FE";
  }
}
function ariaPreprocessor(option) {
  if (!option || !option.aria) {
    return;
  }
  var aria = option.aria;
  if (aria.show != null) {
    aria.enabled = aria.show;
  }
  aria.label = aria.label || {};
  each$e(["description", "general", "series", "data"], function(name) {
    if (aria[name] != null) {
      aria.label[name] = aria[name];
    }
  });
}
function install$1(registers) {
  registers.registerPreprocessor(ariaPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);
}
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI = Math.PI;
var PI2 = Math.PI * 2;
var degree = 180 / PI;
var SVGPathRebuilder = function() {
  function SVGPathRebuilder2() {
  }
  SVGPathRebuilder2.prototype.reset = function(precision) {
    this._start = true;
    this._d = [];
    this._str = "";
    this._p = Math.pow(10, precision || 4);
  };
  SVGPathRebuilder2.prototype.moveTo = function(x2, y) {
    this._add("M", x2, y);
  };
  SVGPathRebuilder2.prototype.lineTo = function(x2, y) {
    this._add("L", x2, y);
  };
  SVGPathRebuilder2.prototype.bezierCurveTo = function(x2, y, x22, y2, x3, y3) {
    this._add("C", x2, y, x22, y2, x3, y3);
  };
  SVGPathRebuilder2.prototype.quadraticCurveTo = function(x2, y, x22, y2) {
    this._add("Q", x2, y, x22, y2);
  };
  SVGPathRebuilder2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
  };
  SVGPathRebuilder2.prototype.ellipse = function(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
    var dTheta = endAngle - startAngle;
    var clockwise = !anticlockwise;
    var dThetaPositive = Math.abs(dTheta);
    var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2);
    var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;
    var large = false;
    if (isCircle) {
      large = true;
    } else if (isAroundZero(dThetaPositive)) {
      large = false;
    } else {
      large = unifiedTheta >= PI === !!clockwise;
    }
    var x0 = cx + rx * mathCos(startAngle);
    var y0 = cy + ry * mathSin(startAngle);
    if (this._start) {
      this._add("M", x0, y0);
    }
    var xRot = Math.round(psi * degree);
    if (isCircle) {
      var p2 = 1 / this._p;
      var dTheta_1 = (clockwise ? 1 : -1) * (PI2 - p2);
      this._add("A", rx, ry, xRot, 1, +clockwise, cx + rx * mathCos(startAngle + dTheta_1), cy + ry * mathSin(startAngle + dTheta_1));
      if (p2 > 0.01) {
        this._add("A", rx, ry, xRot, 0, +clockwise, x0, y0);
      }
    } else {
      var x2 = cx + rx * mathCos(endAngle);
      var y = cy + ry * mathSin(endAngle);
      this._add("A", rx, ry, xRot, +large, +clockwise, x2, y);
    }
  };
  SVGPathRebuilder2.prototype.rect = function(x2, y, w2, h2) {
    this._add("M", x2, y);
    this._add("l", w2, 0);
    this._add("l", 0, h2);
    this._add("l", -w2, 0);
    this._add("Z");
  };
  SVGPathRebuilder2.prototype.closePath = function() {
    if (this._d.length > 0) {
      this._add("Z");
    }
  };
  SVGPathRebuilder2.prototype._add = function(cmd, a2, b2, c, d2, e2, f, g, h2) {
    var vals = [];
    var p2 = this._p;
    for (var i = 1; i < arguments.length; i++) {
      var val = arguments[i];
      if (isNaN(val)) {
        this._invalid = true;
        return;
      }
      vals.push(Math.round(val * p2) / p2);
    }
    this._d.push(cmd + vals.join(" "));
    this._start = cmd === "Z";
  };
  SVGPathRebuilder2.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join("");
    this._d = [];
  };
  SVGPathRebuilder2.prototype.getStr = function() {
    return this._str;
  };
  return SVGPathRebuilder2;
}();
var SVGPathRebuilder$1 = SVGPathRebuilder;
var NONE = "none";
var mathRound = Math.round;
function pathHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== NONE;
}
function pathHasStroke(style) {
  var stroke = style.stroke;
  return stroke != null && stroke !== NONE;
}
var strokeProps = ["lineCap", "miterLimit", "lineJoin"];
var svgStrokeProps = map$1(strokeProps, function(prop) {
  return "stroke-" + prop.toLowerCase();
});
function mapStyleToAttrs(updateAttr2, style, el, forceUpdate) {
  var opacity = style.opacity == null ? 1 : style.opacity;
  if (el instanceof ZRImage$1) {
    updateAttr2("opacity", opacity);
    return;
  }
  if (pathHasFill(style)) {
    var fill = normalizeColor(style.fill);
    updateAttr2("fill", fill.color);
    var fillOpacity = style.fillOpacity != null ? style.fillOpacity * fill.opacity * opacity : fill.opacity * opacity;
    if (forceUpdate || fillOpacity < 1) {
      updateAttr2("fill-opacity", fillOpacity);
    }
  } else {
    updateAttr2("fill", NONE);
  }
  if (pathHasStroke(style)) {
    var stroke = normalizeColor(style.stroke);
    updateAttr2("stroke", stroke.color);
    var strokeScale = style.strokeNoScale ? el.getLineScale() : 1;
    var strokeWidth = strokeScale ? (style.lineWidth || 0) / strokeScale : 0;
    var strokeOpacity = style.strokeOpacity != null ? style.strokeOpacity * stroke.opacity * opacity : stroke.opacity * opacity;
    var strokeFirst = style.strokeFirst;
    if (forceUpdate || strokeWidth !== 1) {
      updateAttr2("stroke-width", strokeWidth);
    }
    if (forceUpdate || strokeFirst) {
      updateAttr2("paint-order", strokeFirst ? "stroke" : "fill");
    }
    if (forceUpdate || strokeOpacity < 1) {
      updateAttr2("stroke-opacity", strokeOpacity);
    }
    if (style.lineDash) {
      var _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
      if (lineDash) {
        lineDashOffset = mathRound(lineDashOffset || 0);
        updateAttr2("stroke-dasharray", lineDash.join(","));
        if (lineDashOffset || forceUpdate) {
          updateAttr2("stroke-dashoffset", lineDashOffset);
        }
      }
    } else if (forceUpdate) {
      updateAttr2("stroke-dasharray", NONE);
    }
    for (var i = 0; i < strokeProps.length; i++) {
      var propName = strokeProps[i];
      if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
        var val = style[propName] || DEFAULT_PATH_STYLE[propName];
        val && updateAttr2(svgStrokeProps[i], val);
      }
    }
  } else if (forceUpdate) {
    updateAttr2("stroke", NONE);
  }
}
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
function createElement(name) {
  return document.createElementNS(SVGNS, name);
}
function createVNode(tag, key2, attrs, children2, text2) {
  return {
    tag,
    attrs: attrs || {},
    children: children2,
    text: text2,
    key: key2
  };
}
function createElementOpen(name, attrs) {
  var attrsStr = [];
  if (attrs) {
    for (var key2 in attrs) {
      var val = attrs[key2];
      var part = key2;
      if (val === false) {
        continue;
      } else if (val !== true && val != null) {
        part += '="' + val + '"';
      }
      attrsStr.push(part);
    }
  }
  return "<" + name + " " + attrsStr.join(" ") + ">";
}
function createElementClose(name) {
  return "</" + name + ">";
}
function vNodeToString(el, opts) {
  opts = opts || {};
  var S2 = opts.newline ? "\n" : "";
  function convertElToString(el2) {
    var children2 = el2.children, tag = el2.tag, attrs = el2.attrs;
    return createElementOpen(tag, attrs) + (el2.text || "") + (children2 ? "" + S2 + map$1(children2, function(child) {
      return convertElToString(child);
    }).join(S2) + S2 : "") + createElementClose(tag);
  }
  return convertElToString(el);
}
function getCssString(selectorNodes, animationNodes, opts) {
  opts = opts || {};
  var S2 = opts.newline ? "\n" : "";
  var bracketBegin = " {" + S2;
  var bracketEnd = S2 + "}";
  var selectors = map$1(keys$1(selectorNodes), function(className) {
    return className + bracketBegin + map$1(keys$1(selectorNodes[className]), function(attrName) {
      return attrName + ":" + selectorNodes[className][attrName] + ";";
    }).join(S2) + bracketEnd;
  }).join(S2);
  var animations = map$1(keys$1(animationNodes), function(animationName) {
    return "@keyframes " + animationName + bracketBegin + map$1(keys$1(animationNodes[animationName]), function(percent) {
      return percent + bracketBegin + map$1(keys$1(animationNodes[animationName][percent]), function(attrName) {
        var val = animationNodes[animationName][percent][attrName];
        if (attrName === "d") {
          val = 'path("' + val + '")';
        }
        return attrName + ":" + val + ";";
      }).join(S2) + bracketEnd;
    }).join(S2) + bracketEnd;
  }).join(S2);
  if (!selectors && !animations) {
    return "";
  }
  return ["<![CDATA[", selectors, animations, "]]>"].join(S2);
}
function createBrushScope(zrId) {
  return {
    zrId,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssClassIdx: 0,
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function createSVGVNode(width, height, children2, useViewBox) {
  return createVNode("svg", "root", {
    "width": width,
    "height": height,
    "xmlns": SVGNS,
    "xmlns:xlink": XLINKNS,
    "version": "1.1",
    "baseProfile": "full",
    "viewBox": useViewBox ? "0 0 " + width + " " + height : false
  }, children2);
}
var EASING_MAP = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
};
var transformOriginKey = "transform-origin";
function buildPathString(el, kfShape, path) {
  var shape = extend$3({}, el.shape);
  extend$3(shape, kfShape);
  el.buildPath(path, shape);
  var svgPathBuilder = new SVGPathRebuilder$1();
  svgPathBuilder.reset(getPathPrecision(el));
  path.rebuildPath(svgPathBuilder, 1);
  svgPathBuilder.generateStr();
  return svgPathBuilder.getStr();
}
function setTransformOrigin(target, transform2) {
  var originX = transform2.originX, originY = transform2.originY;
  if (originX || originY) {
    target[transformOriginKey] = originX + "px " + originY + "px";
  }
}
var ANIMATE_STYLE_MAP = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function addAnimation(cssAnim, scope) {
  var animationName = scope.zrId + "-ani-" + scope.cssAnimIdx++;
  scope.cssAnims[animationName] = cssAnim;
  return animationName;
}
function createCompoundPathCSSAnimation(el, attrs, scope) {
  var paths = el.shape.paths;
  var composedAnim = {};
  var cssAnimationCfg;
  var cssAnimationName;
  each$e(paths, function(path) {
    var subScope = createBrushScope(scope.zrId);
    subScope.animation = true;
    createCSSAnimation(path, {}, subScope, true);
    var cssAnims = subScope.cssAnims;
    var cssNodes = subScope.cssNodes;
    var animNames = keys$1(cssAnims);
    var len2 = animNames.length;
    if (!len2) {
      return;
    }
    cssAnimationName = animNames[len2 - 1];
    var lastAnim = cssAnims[cssAnimationName];
    for (var percent in lastAnim) {
      var kf = lastAnim[percent];
      composedAnim[percent] = composedAnim[percent] || { d: "" };
      composedAnim[percent].d += kf.d || "";
    }
    for (var className in cssNodes) {
      var val = cssNodes[className].animation;
      if (val.indexOf(cssAnimationName) >= 0) {
        cssAnimationCfg = val;
      }
    }
  });
  if (!cssAnimationCfg) {
    return;
  }
  attrs.d = false;
  var animationName = addAnimation(composedAnim, scope);
  return cssAnimationCfg.replace(cssAnimationName, animationName);
}
function getEasingFunc(easing) {
  return isString$2(easing) ? EASING_MAP[easing] ? "cubic-bezier(" + EASING_MAP[easing] + ")" : createCubicEasingFunc(easing) ? easing : "" : "";
}
function createCSSAnimation(el, attrs, scope, onlyShape) {
  var animators = el.animators;
  var len2 = animators.length;
  var cssAnimations = [];
  if (el instanceof CompoundPath$1) {
    var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    } else if (!len2) {
      return;
    }
  } else if (!len2) {
    return;
  }
  var groupAnimators = {};
  for (var i = 0; i < len2; i++) {
    var animator = animators[i];
    var cfgArr = [animator.getMaxTime() / 1e3 + "s"];
    var easing = getEasingFunc(animator.getClip().easing);
    var delay = animator.getDelay();
    if (easing) {
      cfgArr.push(easing);
    } else {
      cfgArr.push("linear");
    }
    if (delay) {
      cfgArr.push(delay / 1e3 + "s");
    }
    if (animator.getLoop()) {
      cfgArr.push("infinite");
    }
    var cfg = cfgArr.join(" ");
    groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];
    groupAnimators[cfg][1].push(animator);
  }
  function createSingleCSSAnimation(groupAnimator) {
    var animators2 = groupAnimator[1];
    var len3 = animators2.length;
    var transformKfs = {};
    var shapeKfs = {};
    var finalKfs = {};
    var animationTimingFunctionAttrName = "animation-timing-function";
    function saveAnimatorTrackToCssKfs(animator3, cssKfs, toCssAttrName) {
      var tracks = animator3.getTracks();
      var maxTime = animator3.getMaxTime();
      for (var k = 0; k < tracks.length; k++) {
        var track = tracks[k];
        if (track.needsAnimate()) {
          var kfs = track.keyframes;
          var attrName = track.propName;
          toCssAttrName && (attrName = toCssAttrName(attrName));
          if (attrName) {
            for (var i3 = 0; i3 < kfs.length; i3++) {
              var kf = kfs[i3];
              var percent2 = Math.round(kf.time / maxTime * 100) + "%";
              var kfEasing = getEasingFunc(kf.easing);
              var rawValue = kf.rawValue;
              if (isString$2(rawValue) || isNumber$1(rawValue)) {
                cssKfs[percent2] = cssKfs[percent2] || {};
                cssKfs[percent2][attrName] = kf.rawValue;
                if (kfEasing) {
                  cssKfs[percent2][animationTimingFunctionAttrName] = kfEasing;
                }
              }
            }
          }
        }
      }
    }
    for (var i2 = 0; i2 < len3; i2++) {
      var animator2 = animators2[i2];
      var targetProp = animator2.targetName;
      if (!targetProp) {
        !onlyShape && saveAnimatorTrackToCssKfs(animator2, transformKfs);
      } else if (targetProp === "shape") {
        saveAnimatorTrackToCssKfs(animator2, shapeKfs);
      }
    }
    for (var percent in transformKfs) {
      var transform2 = {};
      copyTransform(transform2, el);
      extend$3(transform2, transformKfs[percent]);
      var str = getSRTTransformString(transform2);
      var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];
      finalKfs[percent] = str ? {
        transform: str
      } : {};
      setTransformOrigin(finalKfs[percent], transform2);
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    var path;
    var canAnimateShape = true;
    for (var percent in shapeKfs) {
      finalKfs[percent] = finalKfs[percent] || {};
      var isFirst = !path;
      var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];
      if (isFirst) {
        path = new PathProxy$1();
      }
      var len_1 = path.len();
      path.reset();
      finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);
      var newLen = path.len();
      if (!isFirst && len_1 !== newLen) {
        canAnimateShape = false;
        break;
      }
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    if (!canAnimateShape) {
      for (var percent in finalKfs) {
        delete finalKfs[percent].d;
      }
    }
    if (!onlyShape) {
      for (var i2 = 0; i2 < len3; i2++) {
        var animator2 = animators2[i2];
        var targetProp = animator2.targetName;
        if (targetProp === "style") {
          saveAnimatorTrackToCssKfs(animator2, finalKfs, function(propName) {
            return ANIMATE_STYLE_MAP[propName];
          });
        }
      }
    }
    var percents = keys$1(finalKfs);
    var allTransformOriginSame = true;
    var transformOrigin;
    for (var i2 = 1; i2 < percents.length; i2++) {
      var p0 = percents[i2 - 1];
      var p1 = percents[i2];
      if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {
        allTransformOriginSame = false;
        break;
      }
      transformOrigin = finalKfs[p0][transformOriginKey];
    }
    if (allTransformOriginSame && transformOrigin) {
      for (var percent in finalKfs) {
        if (finalKfs[percent][transformOriginKey]) {
          delete finalKfs[percent][transformOriginKey];
        }
      }
      attrs[transformOriginKey] = transformOrigin;
    }
    if (filter$2(percents, function(percent2) {
      return keys$1(finalKfs[percent2]).length > 0;
    }).length) {
      var animationName = addAnimation(finalKfs, scope);
      return animationName + " " + groupAnimator[0] + " both";
    }
  }
  for (var key2 in groupAnimators) {
    var animationCfg = createSingleCSSAnimation(groupAnimators[key2]);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    }
  }
  if (cssAnimations.length) {
    var className = scope.zrId + "-cls-" + scope.cssClassIdx++;
    scope.cssNodes["." + className] = {
      animation: cssAnimations.join(",")
    };
    attrs["class"] = className;
  }
}
var round$1 = Math.round;
function isImageLike(val) {
  return val && isString$2(val.src);
}
function isCanvasLike(val) {
  return val && isFunction$2(val.toDataURL);
}
function setStyleAttrs(attrs, style, el, scope) {
  mapStyleToAttrs(function(key2, val) {
    var isFillStroke = key2 === "fill" || key2 === "stroke";
    if (isFillStroke && isGradient(val)) {
      setGradient(style, attrs, key2, scope);
    } else if (isFillStroke && isPattern(val)) {
      setPattern(el, attrs, key2, scope);
    } else {
      attrs[key2] = val;
    }
  }, style, el, false);
  setShadow(el, attrs, scope);
}
function noRotateScale(m2) {
  return isAroundZero(m2[0] - 1) && isAroundZero(m2[1]) && isAroundZero(m2[2]) && isAroundZero(m2[3] - 1);
}
function noTranslate(m2) {
  return isAroundZero(m2[4]) && isAroundZero(m2[5]);
}
function setTransform(attrs, m2, compress) {
  if (m2 && !(noTranslate(m2) && noRotateScale(m2))) {
    var mul2 = compress ? 10 : 1e4;
    attrs.transform = noRotateScale(m2) ? "translate(" + round$1(m2[4] * mul2) / mul2 + " " + round$1(m2[5] * mul2) / mul2 + ")" : getMatrixStr(m2);
  }
}
function convertPolyShape(shape, attrs, mul2) {
  var points2 = shape.points;
  var strArr = [];
  for (var i = 0; i < points2.length; i++) {
    strArr.push(round$1(points2[i][0] * mul2) / mul2);
    strArr.push(round$1(points2[i][1] * mul2) / mul2);
  }
  attrs.points = strArr.join(" ");
}
function validatePolyShape(shape) {
  return !shape.smooth;
}
function createAttrsConvert(desc) {
  var normalizedDesc = map$1(desc, function(item) {
    return typeof item === "string" ? [item, item] : item;
  });
  return function(shape, attrs, mul2) {
    for (var i = 0; i < normalizedDesc.length; i++) {
      var item = normalizedDesc[i];
      var val = shape[item[0]];
      if (val != null) {
        attrs[item[1]] = round$1(val * mul2) / mul2;
      }
    }
  };
}
var buitinShapesDef = {
  circle: [createAttrsConvert(["cx", "cy", "r"])],
  polyline: [convertPolyShape, validatePolyShape],
  polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(el) {
  var animators = el.animators;
  for (var i = 0; i < animators.length; i++) {
    if (animators[i].targetName === "shape") {
      return true;
    }
  }
  return false;
}
function brushSVGPath(el, scope) {
  var style = el.style;
  var shape = el.shape;
  var builtinShpDef = buitinShapesDef[el.type];
  var attrs = {};
  var needsAnimate = scope.animation;
  var svgElType = "path";
  var strokePercent = el.style.strokePercent;
  var precision = scope.compress && getPathPrecision(el) || 4;
  if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {
    svgElType = el.type;
    var mul2 = Math.pow(10, precision);
    builtinShpDef[0](shape, attrs, mul2);
  } else {
    if (!el.path) {
      el.createPathProxy();
    }
    var path = el.path;
    if (el.shapeChanged()) {
      path.beginPath();
      el.buildPath(path, el.shape);
      el.pathUpdated();
    }
    var pathVersion = path.getVersion();
    var elExt = el;
    var svgPathBuilder = elExt.__svgPathBuilder;
    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {
      if (!svgPathBuilder) {
        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder$1();
      }
      svgPathBuilder.reset(precision);
      path.rebuildPath(svgPathBuilder, strokePercent);
      svgPathBuilder.generateStr();
      elExt.__svgPathVersion = pathVersion;
      elExt.__svgPathStrokePercent = strokePercent;
    }
    attrs.d = svgPathBuilder.getStr();
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode(svgElType, el.id + "", attrs);
}
function brushSVGImage(el, scope) {
  var style = el.style;
  var image = style.image;
  if (image && !isString$2(image)) {
    if (isImageLike(image)) {
      image = image.src;
    } else if (isCanvasLike(image)) {
      image = image.toDataURL();
    }
  }
  if (!image) {
    return;
  }
  var x2 = style.x || 0;
  var y = style.y || 0;
  var dw = style.width;
  var dh = style.height;
  var attrs = {
    href: image,
    width: dw,
    height: dh
  };
  if (x2) {
    attrs.x = x2;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("image", el.id + "", attrs);
}
function brushSVGTSpan(el, scope) {
  var style = el.style;
  var text2 = style.text;
  text2 != null && (text2 += "");
  if (!text2 || isNaN(style.x) || isNaN(style.y)) {
    return;
  }
  var font = style.font || DEFAULT_FONT;
  var x2 = style.x || 0;
  var y = adjustTextY$1(style.y || 0, getLineHeight(font), style.textBaseline);
  var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
  var attrs = {
    "dominant-baseline": "central",
    "text-anchor": textAlign
  };
  if (hasSeparateFont(style)) {
    var separatedFontStr = "";
    var fontStyle = style.fontStyle;
    var fontSize = parseFontSize(style.fontSize);
    if (!parseFloat(fontSize)) {
      return;
    }
    var fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;
    var fontWeight = style.fontWeight;
    separatedFontStr += "font-size:" + fontSize + ";font-family:" + fontFamily + ";";
    if (fontStyle && fontStyle !== "normal") {
      separatedFontStr += "font-style:" + fontStyle + ";";
    }
    if (fontWeight && fontWeight !== "normal") {
      separatedFontStr += "font-weight:" + fontWeight + ";";
    }
    attrs.style = separatedFontStr;
  } else {
    attrs.style = "font: " + font;
  }
  if (text2.match(/\s/)) {
    attrs["xml:space"] = "preserve";
  }
  if (x2) {
    attrs.x = x2;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("text", el.id + "", attrs, void 0, text2);
}
function brush$1(el, scope) {
  if (el instanceof Path$1) {
    return brushSVGPath(el, scope);
  } else if (el instanceof ZRImage$1) {
    return brushSVGImage(el, scope);
  } else if (el instanceof TSpan$1) {
    return brushSVGTSpan(el, scope);
  }
}
function setShadow(el, attrs, scope) {
  var style = el.style;
  if (hasShadow(style)) {
    var shadowKey = getShadowKey(el);
    var shadowCache = scope.shadowCache;
    var shadowId = shadowCache[shadowKey];
    if (!shadowId) {
      var globalScale = el.getGlobalScale();
      var scaleX = globalScale[0];
      var scaleY = globalScale[1];
      if (!scaleX || !scaleY) {
        return;
      }
      var offsetX = style.shadowOffsetX || 0;
      var offsetY = style.shadowOffsetY || 0;
      var blur_1 = style.shadowBlur;
      var _a2 = normalizeColor(style.shadowColor), opacity = _a2.opacity, color2 = _a2.color;
      var stdDx = blur_1 / 2 / scaleX;
      var stdDy = blur_1 / 2 / scaleY;
      var stdDeviation = stdDx + " " + stdDy;
      shadowId = scope.zrId + "-s" + scope.shadowIdx++;
      scope.defs[shadowId] = createVNode("filter", shadowId, {
        "id": shadowId,
        "x": "-100%",
        "y": "-100%",
        "width": "300%",
        "height": "300%"
      }, [
        createVNode("feDropShadow", "", {
          "dx": offsetX / scaleX,
          "dy": offsetY / scaleY,
          "stdDeviation": stdDeviation,
          "flood-color": color2,
          "flood-opacity": opacity
        })
      ]);
      shadowCache[shadowKey] = shadowId;
    }
    attrs.filter = getIdURL(shadowId);
  }
}
function setGradient(style, attrs, target, scope) {
  var val = style[target];
  var gradientTag;
  var gradientAttrs = {
    "gradientUnits": val.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (isLinearGradient(val)) {
    gradientTag = "linearGradient";
    gradientAttrs.x1 = val.x;
    gradientAttrs.y1 = val.y;
    gradientAttrs.x2 = val.x2;
    gradientAttrs.y2 = val.y2;
  } else if (isRadialGradient(val)) {
    gradientTag = "radialGradient";
    gradientAttrs.cx = retrieve2(val.x, 0.5);
    gradientAttrs.cy = retrieve2(val.y, 0.5);
    gradientAttrs.r = retrieve2(val.r, 0.5);
  } else {
    return;
  }
  var colors = val.colorStops;
  var colorStops = [];
  for (var i = 0, len2 = colors.length; i < len2; ++i) {
    var offset2 = round4(colors[i].offset) * 100 + "%";
    var stopColor = colors[i].color;
    var _a2 = normalizeColor(stopColor), color2 = _a2.color, opacity = _a2.opacity;
    var stopsAttrs = {
      "offset": offset2
    };
    stopsAttrs["stop-color"] = color2;
    if (opacity < 1) {
      stopsAttrs["stop-opacity"] = opacity;
    }
    colorStops.push(createVNode("stop", i + "", stopsAttrs));
  }
  var gradientVNode = createVNode(gradientTag, "", gradientAttrs, colorStops);
  var gradientKey = vNodeToString(gradientVNode);
  var gradientCache = scope.gradientCache;
  var gradientId = gradientCache[gradientKey];
  if (!gradientId) {
    gradientId = scope.zrId + "-g" + scope.gradientIdx++;
    gradientCache[gradientKey] = gradientId;
    gradientAttrs.id = gradientId;
    scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);
  }
  attrs[target] = getIdURL(gradientId);
}
function setPattern(el, attrs, target, scope) {
  var val = el.style[target];
  var patternAttrs = {
    "patternUnits": "userSpaceOnUse"
  };
  var child;
  if (isImagePattern(val)) {
    var imageWidth_1 = val.imageWidth;
    var imageHeight_1 = val.imageHeight;
    var imageSrc = void 0;
    var patternImage = val.image;
    if (isString$2(patternImage)) {
      imageSrc = patternImage;
    } else if (isImageLike(patternImage)) {
      imageSrc = patternImage.src;
    } else if (isCanvasLike(patternImage)) {
      imageSrc = patternImage.toDataURL();
    }
    if (typeof Image === "undefined") {
      var errMsg = "Image width/height must been given explictly in svg-ssr renderer.";
      assert(imageWidth_1, errMsg);
      assert(imageHeight_1, errMsg);
    } else if (imageWidth_1 == null || imageHeight_1 == null) {
      var setSizeToVNode_1 = function(vNode, img) {
        if (vNode) {
          var svgEl = vNode.elm;
          var width = vNode.attrs.width = imageWidth_1 || img.width;
          var height = vNode.attrs.height = imageHeight_1 || img.height;
          if (svgEl) {
            svgEl.setAttribute("width", width);
            svgEl.setAttribute("height", height);
          }
        }
      };
      var createdImage = createOrUpdateImage(imageSrc, null, el, function(img) {
        setSizeToVNode_1(patternVNode, img);
        setSizeToVNode_1(child, img);
      });
      if (createdImage && createdImage.width && createdImage.height) {
        imageWidth_1 = imageWidth_1 || createdImage.width;
        imageHeight_1 = imageHeight_1 || createdImage.height;
      }
    }
    child = createVNode("image", "img", {
      href: imageSrc,
      width: imageWidth_1,
      height: imageHeight_1
    });
    patternAttrs.width = imageWidth_1;
    patternAttrs.height = imageHeight_1;
  } else if (val.svgElement) {
    child = clone$3(val.svgElement);
    patternAttrs.width = val.svgWidth;
    patternAttrs.height = val.svgHeight;
  }
  if (!child) {
    return;
  }
  patternAttrs.patternTransform = getSRTTransformString(val);
  var patternVNode = createVNode("pattern", "", patternAttrs, [child]);
  var patternKey = vNodeToString(patternVNode);
  var patternCache = scope.patternCache;
  var patternId = patternCache[patternKey];
  if (!patternId) {
    patternId = scope.zrId + "-p" + scope.patternIdx++;
    patternCache[patternKey] = patternId;
    patternAttrs.id = patternId;
    patternVNode = scope.defs[patternId] = createVNode("pattern", patternId, patternAttrs, [child]);
  }
  attrs[target] = getIdURL(patternId);
}
function setClipPath(clipPath, attrs, scope) {
  var clipPathCache = scope.clipPathCache, defs = scope.defs;
  var clipPathId = clipPathCache[clipPath.id];
  if (!clipPathId) {
    clipPathId = scope.zrId + "-c" + scope.clipPathIdx++;
    var clipPathAttrs = {
      id: clipPathId
    };
    clipPathCache[clipPath.id] = clipPathId;
    defs[clipPathId] = createVNode("clipPath", clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);
  }
  attrs["clip-path"] = getIdURL(clipPathId);
}
function createTextNode(text2) {
  return document.createTextNode(text2);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function setTextContent(node, text2) {
  node.textContent = text2;
}
var colonChar = 58;
var xChar = 120;
var emptyNode = createVNode("", "");
function isUndef(s2) {
  return s2 === void 0;
}
function isDef(s2) {
  return s2 !== void 0;
}
function createKeyToOldIdx(children2, beginIdx, endIdx) {
  var map2 = {};
  for (var i = beginIdx; i <= endIdx; ++i) {
    var key2 = children2[i].key;
    if (key2 !== void 0) {
      map2[key2] = i;
    }
  }
  return map2;
}
function sameVnode(vnode1, vnode2) {
  var isSameKey = vnode1.key === vnode2.key;
  var isSameTag = vnode1.tag === vnode2.tag;
  return isSameTag && isSameKey;
}
function createElm(vnode) {
  var i;
  var children2 = vnode.children;
  var tag = vnode.tag;
  if (isDef(tag)) {
    var elm = vnode.elm = createElement(tag);
    updateAttrs(emptyNode, vnode);
    if (isArray$4(children2)) {
      for (i = 0; i < children2.length; ++i) {
        var ch = children2[i];
        if (ch != null) {
          appendChild(elm, createElm(ch));
        }
      }
    } else if (isDef(vnode.text) && !isObject$9(vnode.text)) {
      appendChild(elm, createTextNode(vnode.text));
    }
  } else {
    vnode.elm = createTextNode(vnode.text);
  }
  return vnode.elm;
}
function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    var ch = vnodes[startIdx];
    if (ch != null) {
      insertBefore(parentElm, createElm(ch), before);
    }
  }
}
function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    var ch = vnodes[startIdx];
    if (ch != null) {
      if (isDef(ch.tag)) {
        var parent_1 = parentNode(ch.elm);
        removeChild(parent_1, ch.elm);
      } else {
        removeChild(parentElm, ch.elm);
      }
    }
  }
}
function updateAttrs(oldVnode, vnode) {
  var key2;
  var elm = vnode.elm;
  var oldAttrs = oldVnode && oldVnode.attrs || {};
  var attrs = vnode.attrs || {};
  if (oldAttrs === attrs) {
    return;
  }
  for (key2 in attrs) {
    var cur = attrs[key2];
    var old = oldAttrs[key2];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key2, "");
      } else if (cur === false) {
        elm.removeAttribute(key2);
      } else {
        if (key2.charCodeAt(0) !== xChar) {
          elm.setAttribute(key2, cur);
        } else if (key2 === "xmlns:xlink" || key2 === "xmlns") {
          elm.setAttributeNS(XMLNS, key2, cur);
        } else if (key2.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(XML_NAMESPACE, key2, cur);
        } else if (key2.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(XLINKNS, key2, cur);
        } else {
          elm.setAttribute(key2, cur);
        }
      }
    }
  }
  for (key2 in oldAttrs) {
    if (!(key2 in attrs)) {
      elm.removeAttribute(key2);
    }
  }
}
function updateChildren(parentElm, oldCh, newCh) {
  var oldStartIdx = 0;
  var newStartIdx = 0;
  var oldEndIdx = oldCh.length - 1;
  var oldStartVnode = oldCh[0];
  var oldEndVnode = oldCh[oldEndIdx];
  var newEndIdx = newCh.length - 1;
  var newStartVnode = newCh[0];
  var newEndVnode = newCh[newEndIdx];
  var oldKeyToIdx;
  var idxInOld;
  var elmToMove;
  var before;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode);
      insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode);
      insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      idxInOld = oldKeyToIdx[newStartVnode.key];
      if (isUndef(idxInOld)) {
        insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
      } else {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.tag !== newStartVnode.tag) {
          insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
        } else {
          patchVnode(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }
  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
    if (oldStartIdx > oldEndIdx) {
      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
    } else {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }
}
function patchVnode(oldVnode, vnode) {
  var elm = vnode.elm = oldVnode.elm;
  var oldCh = oldVnode.children;
  var ch = vnode.children;
  if (oldVnode === vnode) {
    return;
  }
  updateAttrs(oldVnode, vnode);
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) {
        updateChildren(elm, oldCh, ch);
      }
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) {
        setTextContent(elm, "");
      }
      addVnodes(elm, null, ch, 0, ch.length - 1);
    } else if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      setTextContent(elm, "");
    }
  } else if (oldVnode.text !== vnode.text) {
    if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    }
    setTextContent(elm, vnode.text);
  }
}
function patch(oldVnode, vnode) {
  if (sameVnode(oldVnode, vnode)) {
    patchVnode(oldVnode, vnode);
  } else {
    var elm = oldVnode.elm;
    var parent_2 = parentNode(elm);
    createElm(vnode);
    if (parent_2 !== null) {
      insertBefore(parent_2, vnode.elm, nextSibling(elm));
      removeVnodes(parent_2, [oldVnode], 0, 0);
    }
  }
  return vnode;
}
var svgId = 0;
var SVGPainter = function() {
  function SVGPainter2(root2, storage2, opts) {
    this.type = "svg";
    this.refreshHover = createMethodNotSupport();
    this.configLayer = createMethodNotSupport();
    this.storage = storage2;
    this._opts = opts = extend$3({}, opts);
    this.root = root2;
    this._id = "zr" + svgId++;
    this._oldVNode = createSVGVNode(opts.width, opts.height);
    if (root2 && !opts.ssr) {
      var viewport2 = this._viewport = document.createElement("div");
      viewport2.style.cssText = "position:relative;overflow:hidden";
      var svgDom = this._svgDom = this._oldVNode.elm = createElement("svg");
      updateAttrs(null, this._oldVNode);
      viewport2.appendChild(svgDom);
      root2.appendChild(viewport2);
    }
    this.resize(opts.width, opts.height);
  }
  SVGPainter2.prototype.getType = function() {
    return this.type;
  };
  SVGPainter2.prototype.getViewportRoot = function() {
    return this._viewport;
  };
  SVGPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  SVGPainter2.prototype.getSvgDom = function() {
    return this._svgDom;
  };
  SVGPainter2.prototype.refresh = function() {
    if (this.root) {
      var vnode = this.renderToVNode({
        willUpdate: true
      });
      vnode.attrs.style = "position:absolute;left:0;top:0;user-select:none";
      patch(this._oldVNode, vnode);
      this._oldVNode = vnode;
    }
  };
  SVGPainter2.prototype.renderOneToVNode = function(el) {
    return brush$1(el, createBrushScope(this._id));
  };
  SVGPainter2.prototype.renderToVNode = function(opts) {
    opts = opts || {};
    var list2 = this.storage.getDisplayList(true);
    var bgColor = this._backgroundColor;
    var width = this._width;
    var height = this._height;
    var scope = createBrushScope(this._id);
    scope.animation = opts.animation;
    scope.willUpdate = opts.willUpdate;
    scope.compress = opts.compress;
    var children2 = [];
    if (bgColor && bgColor !== "none") {
      var _a2 = normalizeColor(bgColor), color2 = _a2.color, opacity = _a2.opacity;
      this._bgVNode = createVNode("rect", "bg", {
        width,
        height,
        x: "0",
        y: "0",
        id: "0",
        fill: color2,
        "fill-opacity": opacity
      });
      children2.push(this._bgVNode);
    } else {
      this._bgVNode = null;
    }
    var mainVNode = !opts.compress ? this._mainVNode = createVNode("g", "main", {}, []) : null;
    this._paintList(list2, scope, mainVNode ? mainVNode.children : children2);
    mainVNode && children2.push(mainVNode);
    var defs = map$1(keys$1(scope.defs), function(id) {
      return scope.defs[id];
    });
    if (defs.length) {
      children2.push(createVNode("defs", "defs", {}, defs));
    }
    if (opts.animation) {
      var animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, { newline: true });
      if (animationCssStr) {
        var styleNode = createVNode("style", "stl", {}, [], animationCssStr);
        children2.push(styleNode);
      }
    }
    return createSVGVNode(width, height, children2, opts.useViewBox);
  };
  SVGPainter2.prototype.renderToString = function(opts) {
    opts = opts || {};
    return vNodeToString(this.renderToVNode({
      animation: retrieve2(opts.cssAnimation, true),
      willUpdate: false,
      compress: true,
      useViewBox: retrieve2(opts.useViewBox, true)
    }), { newline: true });
  };
  SVGPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    var bgVNode = this._bgVNode;
    if (bgVNode && bgVNode.elm) {
      var _a2 = normalizeColor(backgroundColor2), color2 = _a2.color, opacity = _a2.opacity;
      bgVNode.elm.setAttribute("fill", color2);
      if (opacity < 1) {
        bgVNode.elm.setAttribute("fill-opacity", opacity);
      }
    }
  };
  SVGPainter2.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  };
  SVGPainter2.prototype._paintList = function(list2, scope, out2) {
    var listLen = list2.length;
    var clipPathsGroupsStack = [];
    var clipPathsGroupsStackDepth = 0;
    var currentClipPathGroup;
    var prevClipPaths;
    var clipGroupNodeIdx = 0;
    for (var i = 0; i < listLen; i++) {
      var displayable = list2[i];
      if (!displayable.invisible) {
        var clipPaths = displayable.__clipPaths;
        var len2 = clipPaths && clipPaths.length || 0;
        var prevLen = prevClipPaths && prevClipPaths.length || 0;
        var lca = void 0;
        for (lca = Math.max(len2 - 1, prevLen - 1); lca >= 0; lca--) {
          if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) {
            break;
          }
        }
        for (var i_1 = prevLen - 1; i_1 > lca; i_1--) {
          clipPathsGroupsStackDepth--;
          currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];
        }
        for (var i_2 = lca + 1; i_2 < len2; i_2++) {
          var groupAttrs = {};
          setClipPath(clipPaths[i_2], groupAttrs, scope);
          var g = createVNode("g", "clip-g-" + clipGroupNodeIdx++, groupAttrs, []);
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(g);
          clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;
          currentClipPathGroup = g;
        }
        prevClipPaths = clipPaths;
        var ret = brush$1(displayable, scope);
        if (ret) {
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(ret);
        }
      }
    }
  };
  SVGPainter2.prototype.resize = function(width, height) {
    var opts = this._opts;
    var root2 = this.root;
    var viewport2 = this._viewport;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    if (root2 && viewport2) {
      viewport2.style.display = "none";
      width = getSize$1(root2, 0, opts);
      height = getSize$1(root2, 1, opts);
      viewport2.style.display = "";
    }
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      if (viewport2) {
        var viewportStyle = viewport2.style;
        viewportStyle.width = width + "px";
        viewportStyle.height = height + "px";
      }
      var svgDom = this._svgDom;
      if (svgDom) {
        svgDom.setAttribute("width", width);
        svgDom.setAttribute("height", height);
      }
    }
  };
  SVGPainter2.prototype.getWidth = function() {
    return this._width;
  };
  SVGPainter2.prototype.getHeight = function() {
    return this._height;
  };
  SVGPainter2.prototype.dispose = function() {
    if (this.root) {
      this.root.innerHTML = "";
    }
    this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  };
  SVGPainter2.prototype.clear = function() {
    if (this._svgDom) {
      this._svgDom.innerHTML = null;
    }
    this._oldVNode = null;
  };
  SVGPainter2.prototype.toDataURL = function(base64) {
    var str = encodeURIComponent(this.renderToString());
    var prefix = "data:image/svg+xml;";
    if (base64) {
      str = encodeBase64(str);
      return str && prefix + "base64," + str;
    }
    return prefix + "charset=UTF-8," + str;
  };
  return SVGPainter2;
}();
function createMethodNotSupport(method) {
  return function() {
  };
}
var SVGPainter$1 = SVGPainter;
function install(registers) {
  registers.registerPainter("svg", SVGPainter$1);
}
use([
  install$8,
  install$c,
  install$d,
  install$j,
  install$i,
  install$1,
  install$m,
  install$t,
  install$u,
  install$s,
  install$n,
  install$p,
  install,
  install$l,
  install$q,
  install$e,
  install$5,
  install$2,
  install$b,
  install$h,
  install$g
]);
function useECharts(elRef, theme2 = "default") {
  let chartInstance = null;
  let resizeFn = resize;
  const cacheOptions = ref({});
  let removeResizeFn = () => {
  };
  resizeFn = useDebounceFn(resize, 200);
  const getOptions = computed(() => cacheOptions.value);
  function initCharts(t = theme2) {
    const el = unref(elRef);
    if (!el || !unref(el)) {
      return;
    }
    chartInstance = echarts.init(el, t);
    const { removeEvent } = useEventListener$1({
      el: window,
      name: "resize",
      listener: resizeFn
    });
    removeResizeFn = removeEvent;
    if (el.offsetHeight === 0) {
      useTimeoutFn$1(() => {
        resizeFn();
      }, 30);
    }
  }
  function setOptions(options, clear2 = true) {
    var _a2;
    cacheOptions.value = options;
    if (((_a2 = unref(elRef)) == null ? void 0 : _a2.offsetHeight) === 0) {
      useTimeoutFn$1(() => {
        setOptions(unref(getOptions));
      }, 30);
      return;
    }
    nextTick$1(() => {
      useTimeoutFn$1(() => {
        if (!chartInstance) {
          initCharts();
          if (!chartInstance)
            return;
        }
        clear2 && (chartInstance == null ? void 0 : chartInstance.clear());
        chartInstance == null ? void 0 : chartInstance.setOption(unref(getOptions));
      }, 30);
    });
  }
  function resize() {
    chartInstance == null ? void 0 : chartInstance.resize();
  }
  tryOnUnmounted(() => {
    if (!chartInstance)
      return;
    removeResizeFn();
    chartInstance.dispose();
    chartInstance = null;
  });
  function getInstance2() {
    if (!chartInstance) {
      initCharts();
    }
    return chartInstance;
  }
  return {
    setOptions,
    resize,
    echarts,
    getInstance: getInstance2
  };
}
function deepMerge(src, target) {
  let key2;
  for (key2 in target) {
    src[key2] = isObject$a(src[key2]) ? deepMerge(src[key2], target[key2]) : src[key2] = target[key2];
  }
  return src;
}
var Card_vue_vue_type_style_index_0_scoped_true_lang = "";
const _withScopeId$1 = (n) => (pushScopeId("data-v-482ae5b2"), n = n(), popScopeId(), n);
const _hoisted_1$5b = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("span", { class: "top-left" }, null, -1));
const _hoisted_2$4V = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("span", { class: "top-right" }, null, -1));
const _hoisted_3$4H = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("span", { class: "bottom-left" }, null, -1));
const _hoisted_4$1u = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("span", { class: "bottom-right" }, null, -1));
const _hoisted_5$w = { class: "dpi_card_header" };
const _hoisted_6$b = { class: "dpi_card_title" };
const _hoisted_7$7 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("span", { class: "dpi_card_ion1" }, null, -1));
const _hoisted_8$6 = { class: "dpi_card_body" };
const _hoisted_9$6 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "dpi_card_empty" }, "\u6682\u65E0\u6570\u636E", -1));
const _sfc_main$5A = {
  props: {
    title: {
      type: String,
      default: () => ""
    },
    width: {
      type: Number,
      default: () => null
    },
    height: {
      type: Number,
      default: () => null
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "dpi_card",
        style: normalizeStyle$1({ width: `${__props.width}px`, height: `${__props.height}px` })
      }, [
        _hoisted_1$5b,
        _hoisted_2$4V,
        _hoisted_3$4H,
        _hoisted_4$1u,
        createElementVNode("header", _hoisted_5$w, [
          createElementVNode("span", _hoisted_6$b, [
            _hoisted_7$7,
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(__props.title), 1)
            ], true)
          ])
        ]),
        createElementVNode("article", _hoisted_8$6, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            _hoisted_9$6
          ], true)
        ])
      ], 4);
    };
  }
};
var Card = /* @__PURE__ */ _export_sfc$2(_sfc_main$5A, [["__scopeId", "data-v-482ae5b2"]]);
var index_vue_vue_type_style_index_0_scoped_true_lang$e = "";
const _hoisted_1$5a = { class: "d-en-chart" };
const _hoisted_2$4U = { class: "coordinate" };
const _sfc_main$5z = {
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup(__props) {
    const props2 = __props;
    const charRef = ref();
    const { setOptions } = useECharts(charRef);
    const degrees = ["E", "30\xB0", "60", "S", "120", "150", "W", "210", "240", "N", "300\xB0", "330\xB0"];
    const chartOptions = {
      polar: {
        center: ["50%", "50%"]
      },
      grid: {
        show: false,
        left: 23,
        right: 23,
        top: 23,
        bottom: 23
      },
      angleAxis: {
        type: "category",
        startAngle: 0,
        data: degrees,
        boundaryGap: false,
        splitLine: {
          show: true
        }
      },
      radiusAxis: {
        min: 0,
        max: 18,
        splitNumber: 6,
        nameTextStyle: {
          color: "#fff",
          fontSize: 18
        },
        axisLabel: {
          fontSize: 10
        },
        axisLine: {
          show: true,
          lineStyle: {
            color: "#fff",
            width: 2
          }
        },
        axisTick: {
          interval: 1,
          lineStyle: {
            color: "#fff",
            width: 2
          }
        }
      },
      xAxis: {
        name: "x",
        show: false,
        min: -18,
        max: 18,
        minorTick: {
          show: true
        },
        minorSplitLine: {
          show: true
        },
        splitArea: { show: false }
      },
      yAxis: {
        name: "y",
        show: false,
        min: -18,
        max: 18,
        minorTick: {
          show: true
        },
        minorSplitLine: {
          show: true
        },
        splitArea: { show: false }
      },
      dataZoom: [
        {
          show: false,
          type: "inside",
          filterMode: "none",
          xAxisIndex: [0],
          startValue: -18,
          endValue: 18,
          disabled: true
        },
        {
          show: false,
          type: "inside",
          filterMode: "none",
          yAxisIndex: [0],
          startValue: -18,
          endValue: 18,
          disabled: true
        }
      ],
      series: [
        {
          type: "line",
          itemStyle: {
            color: "#26D1D4",
            borderColor: "#26D1D4"
          },
          clip: true,
          data: []
        }
      ]
    };
    watch$1(() => props2.data, (data) => {
      const option = deepMerge(chartOptions, {
        series: [
          {
            type: "line",
            itemStyle: {
              color: "#26D1D4",
              borderColor: "#26D1D4"
            },
            clip: true,
            data
          }
        ]
      });
      setOptions(option);
    }, {
      immediate: true
    });
    setOptions(chartOptions);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Card, { title: "GNSS\u5F53\u65E5\u5E73\u9762E/N\u5750\u6807\u5C55\u793A\u56FE" }, {
        default: withCtx(() => [
          createElementVNode("div", _hoisted_1$5a, [
            createElementVNode("div", _hoisted_2$4U, [
              createElementVNode("div", {
                ref_key: "charRef",
                ref: charRef,
                style: { width: "240px", height: "240px" }
              }, null, 512)
            ])
          ])
        ]),
        _: 1
      });
    };
  }
};
var EnChart = /* @__PURE__ */ _export_sfc$2(_sfc_main$5z, [["__scopeId", "data-v-5b265050"]]);
const EnChartPlugin = {
  install(app) {
    app.component("d-en-chart", EnChart);
  }
};
function isObject$5(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$2(target = {}, src = {}) {
  Object.keys(src).forEach((key2) => {
    if (typeof target[key2] === "undefined")
      target[key2] = src[key2];
    else if (isObject$5(src[key2]) && isObject$5(target[key2]) && Object.keys(src[key2]).length > 0) {
      extend$2(target[key2], src[key2]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc = typeof document !== "undefined" ? document : {};
  extend$2(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow$1() {
  const win = typeof window !== "undefined" ? window : {};
  extend$2(win, ssrWindow);
  return win;
}
function makeReactive(obj) {
  const proto2 = obj.__proto__;
  Object.defineProperty(obj, "__proto__", {
    get() {
      return proto2;
    },
    set(value) {
      proto2.__proto__ = value;
    }
  });
}
class Dom7 extends Array {
  constructor(items) {
    if (typeof items === "number") {
      super(items);
    } else {
      super(...items || []);
      makeReactive(this);
    }
  }
}
function arrayFlat(arr = []) {
  const res = [];
  arr.forEach((el) => {
    if (Array.isArray(el)) {
      res.push(...arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter$1(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1)
      uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function qsa(selector, context) {
  if (typeof selector !== "string") {
    return [selector];
  }
  const a2 = [];
  const res = context.querySelectorAll(selector);
  for (let i = 0; i < res.length; i += 1) {
    a2.push(res[i]);
  }
  return a2;
}
function $(selector, context) {
  const window2 = getWindow$1();
  const document2 = getDocument();
  let arr = [];
  if (!context && selector instanceof Dom7) {
    return selector;
  }
  if (!selector) {
    return new Dom7(arr);
  }
  if (typeof selector === "string") {
    const html2 = selector.trim();
    if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
      let toCreate = "div";
      if (html2.indexOf("<li") === 0)
        toCreate = "ul";
      if (html2.indexOf("<tr") === 0)
        toCreate = "tbody";
      if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0)
        toCreate = "tr";
      if (html2.indexOf("<tbody") === 0)
        toCreate = "table";
      if (html2.indexOf("<option") === 0)
        toCreate = "select";
      const tempParent = document2.createElement(toCreate);
      tempParent.innerHTML = html2;
      for (let i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document2);
    }
  } else if (selector.nodeType || selector === window2 || selector === document2) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7)
      return selector;
    arr = selector;
  }
  return new Dom7(arrayUnique(arr));
}
$.fn = Dom7.prototype;
function addClass$1(...classes2) {
  const classNames = arrayFlat(classes2.map((c) => c.split(" ")));
  this.forEach((el) => {
    el.classList.add(...classNames);
  });
  return this;
}
function removeClass$1(...classes2) {
  const classNames = arrayFlat(classes2.map((c) => c.split(" ")));
  this.forEach((el) => {
    el.classList.remove(...classNames);
  });
  return this;
}
function toggleClass(...classes2) {
  const classNames = arrayFlat(classes2.map((c) => c.split(" ")));
  this.forEach((el) => {
    classNames.forEach((className) => {
      el.classList.toggle(className);
    });
  });
}
function hasClass$1(...classes2) {
  const classNames = arrayFlat(classes2.map((c) => c.split(" ")));
  return arrayFilter$1(this, (el) => {
    return classNames.filter((className) => el.classList.contains(className)).length > 0;
  }).length > 0;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === "string") {
    if (this[0])
      return this[0].getAttribute(attrs);
    return void 0;
  }
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      this[i].setAttribute(attrs, value);
    } else {
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
function removeAttr(attr2) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr2);
  }
  return this;
}
function transform(transform2) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform2;
  }
  return this;
}
function transition$1(duration) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== "string" ? `${duration}ms` : duration;
  }
  return this;
}
function on$1(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === "function") {
    [eventType, listener, capture] = args;
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  function handleLiveEvent(e2) {
    const target = e2.target;
    if (!target)
      return;
    const eventData = e2.target.dom7EventData || [];
    if (eventData.indexOf(e2) < 0) {
      eventData.unshift(e2);
    }
    if ($(target).is(targetSelector))
      listener.apply(target, eventData);
    else {
      const parents2 = $(target).parents();
      for (let k = 0; k < parents2.length; k += 1) {
        if ($(parents2[k]).is(targetSelector))
          listener.apply(parents2[k], eventData);
      }
    }
  }
  function handleEvent(e2) {
    const eventData = e2 && e2.target ? e2.target.dom7EventData || [] : [];
    if (eventData.indexOf(e2) < 0) {
      eventData.unshift(e2);
    }
    listener.apply(this, eventData);
  }
  const events2 = eventType.split(" ");
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events2.length; j += 1) {
        const event = events2[j];
        if (!el.dom7Listeners)
          el.dom7Listeners = {};
        if (!el.dom7Listeners[event])
          el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      for (j = 0; j < events2.length; j += 1) {
        const event = events2[j];
        if (!el.dom7LiveListeners)
          el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event])
          el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off$1(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === "function") {
    [eventType, listener, capture] = args;
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  const events2 = eventType.split(" ");
  for (let i = 0; i < events2.length; i += 1) {
    const event = events2[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers2;
      if (!targetSelector && el.dom7Listeners) {
        handlers2 = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers2 = el.dom7LiveListeners[event];
      }
      if (handlers2 && handlers2.length) {
        for (let k = handlers2.length - 1; k >= 0; k -= 1) {
          const handler = handlers2[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers2.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers2.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers2.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function trigger(...args) {
  const window2 = getWindow$1();
  const events2 = args[0].split(" ");
  const eventData = args[1];
  for (let i = 0; i < events2.length; i += 1) {
    const event = events2[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      if (window2.CustomEvent) {
        const evt = new window2.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }
  return this;
}
function transitionEnd$1(callback) {
  const dom = this;
  function fireCallBack(e2) {
    if (e2.target !== this)
      return;
    callback.call(this, e2);
    dom.off("transitionend", fireCallBack);
  }
  if (callback) {
    dom.on("transitionend", fireCallBack);
  }
  return this;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles2 = this.styles();
      return this[0].offsetWidth + parseFloat(styles2.getPropertyValue("margin-right")) + parseFloat(styles2.getPropertyValue("margin-left"));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      const styles2 = this.styles();
      return this[0].offsetHeight + parseFloat(styles2.getPropertyValue("margin-top")) + parseFloat(styles2.getPropertyValue("margin-bottom"));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset$2() {
  if (this.length > 0) {
    const window2 = getWindow$1();
    const document2 = getDocument();
    const el = this[0];
    const box2 = el.getBoundingClientRect();
    const body = document2.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
    const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
    return {
      top: box2.top + scrollTop - clientTop,
      left: box2.left + scrollLeft - clientLeft
    };
  }
  return null;
}
function styles() {
  const window2 = getWindow$1();
  if (this[0])
    return window2.getComputedStyle(this[0], null);
  return {};
}
function css(props2, value) {
  const window2 = getWindow$1();
  let i;
  if (arguments.length === 1) {
    if (typeof props2 === "string") {
      if (this[0])
        return window2.getComputedStyle(this[0], null).getPropertyValue(props2);
    } else {
      for (i = 0; i < this.length; i += 1) {
        for (const prop in props2) {
          this[i].style[prop] = props2[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props2 === "string") {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props2] = value;
    }
    return this;
  }
  return this;
}
function each(callback) {
  if (!callback)
    return this;
  this.forEach((el, index2) => {
    callback.apply(el, [el, index2]);
  });
  return this;
}
function filter$1(callback) {
  const result = arrayFilter$1(this, callback);
  return $(result);
}
function html(html2) {
  if (typeof html2 === "undefined") {
    return this[0] ? this[0].innerHTML : null;
  }
  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html2;
  }
  return this;
}
function text(text2) {
  if (typeof text2 === "undefined") {
    return this[0] ? this[0].textContent.trim() : null;
  }
  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text2;
  }
  return this;
}
function is(selector) {
  const window2 = getWindow$1();
  const document2 = getDocument();
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === "undefined")
    return false;
  if (typeof selector === "string") {
    if (el.matches)
      return el.matches(selector);
    if (el.webkitMatchesSelector)
      return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector)
      return el.msMatchesSelector(selector);
    compareWith = $(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el)
        return true;
    }
    return false;
  }
  if (selector === document2) {
    return el === document2;
  }
  if (selector === window2) {
    return el === window2;
  }
  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el)
        return true;
    }
    return false;
  }
  return false;
}
function index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1)
        i += 1;
    }
    return i;
  }
  return void 0;
}
function eq$1(index2) {
  if (typeof index2 === "undefined")
    return this;
  const length2 = this.length;
  if (index2 > length2 - 1) {
    return $([]);
  }
  if (index2 < 0) {
    const returnIndex = length2 + index2;
    if (returnIndex < 0)
      return $([]);
    return $([this[returnIndex]]);
  }
  return $([this[index2]]);
}
function append(...els) {
  let newChild;
  const document2 = getDocument();
  for (let k = 0; k < els.length; k += 1) {
    newChild = els[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === "string") {
        const tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }
  return this;
}
function prepend(newChild) {
  const document2 = getDocument();
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === "string") {
      const tempDiv = document2.createElement("div");
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }
      return $([]);
    }
    if (this[0].nextElementSibling)
      return $([this[0].nextElementSibling]);
    return $([]);
  }
  return $([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el)
    return $([]);
  while (el.nextElementSibling) {
    const next2 = el.nextElementSibling;
    if (selector) {
      if ($(next2).is(selector))
        nextEls.push(next2);
    } else
      nextEls.push(next2);
    el = next2;
  }
  return $(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }
      return $([]);
    }
    if (el.previousElementSibling)
      return $([el.previousElementSibling]);
    return $([]);
  }
  return $([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el)
    return $([]);
  while (el.previousElementSibling) {
    const prev2 = el.previousElementSibling;
    if (selector) {
      if ($(prev2).is(selector))
        prevEls.push(prev2);
    } else
      prevEls.push(prev2);
    el = prev2;
  }
  return $(prevEls);
}
function parent(selector) {
  const parents2 = [];
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector))
          parents2.push(this[i].parentNode);
      } else {
        parents2.push(this[i].parentNode);
      }
    }
  }
  return $(parents2);
}
function parents(selector) {
  const parents2 = [];
  for (let i = 0; i < this.length; i += 1) {
    let parent2 = this[i].parentNode;
    while (parent2) {
      if (selector) {
        if ($(parent2).is(selector))
          parents2.push(parent2);
      } else {
        parents2.push(parent2);
      }
      parent2 = parent2.parentNode;
    }
  }
  return $(parents2);
}
function closest(selector) {
  let closest2 = this;
  if (typeof selector === "undefined") {
    return $([]);
  }
  if (!closest2.is(selector)) {
    closest2 = closest2.parents(selector).eq(0);
  }
  return closest2;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return $(foundElements);
}
function children(selector) {
  const children2 = [];
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].children;
    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children2.push(childNodes[j]);
      }
    }
  }
  return $(children2);
}
function remove$1() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode)
      this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
const Methods = {
  addClass: addClass$1,
  removeClass: removeClass$1,
  hasClass: hasClass$1,
  toggleClass,
  attr,
  removeAttr,
  transform,
  transition: transition$1,
  on: on$1,
  off: off$1,
  trigger,
  transitionEnd: transitionEnd$1,
  outerWidth,
  outerHeight,
  styles,
  offset: offset$2,
  css,
  each,
  html,
  text,
  is,
  index,
  eq: eq$1,
  append,
  prepend,
  next,
  nextAll,
  prev,
  prevAll,
  parent,
  parents,
  closest,
  find,
  children,
  filter: filter$1,
  remove: remove$1
};
Object.keys(Methods).forEach((methodName) => {
  Object.defineProperty($.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach((key2) => {
    try {
      object[key2] = null;
    } catch (e2) {
    }
    try {
      delete object[key2];
    } catch (e2) {
    }
  });
}
function nextTick(callback, delay = 0) {
  return setTimeout(callback, delay);
}
function now$2() {
  return Date.now();
}
function getComputedStyle$2(el) {
  const window2 = getWindow$1();
  let style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis = "x") {
  const window2 = getWindow$1();
  let matrix2;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$2(el);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a2) => a2.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix2 = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix2.length === 16)
      curTransform = parseFloat(matrix2[12]);
    else
      curTransform = parseFloat(matrix2[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix2.length === 16)
      curTransform = parseFloat(matrix2[13]);
    else
      curTransform = parseFloat(matrix2[5]);
  }
  return curTransform || 0;
}
function isObject$4(o2) {
  return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}
function isNode(node) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend$1(...args) {
  const to = Object(args[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i = 1; i < args.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key2) => noExtend.indexOf(key2) < 0);
      for (let nextIndex = 0, len2 = keysArray.length; nextIndex < len2; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject$4(to[nextKey]) && isObject$4(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$4(to[nextKey]) && isObject$4(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  const window2 = getWindow$1();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time2;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir3 = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current, target) => {
    return dir3 === "next" && current >= target || dir3 === "prev" && current <= target;
  };
  const animate = () => {
    time2 = new Date().getTime();
    if (startTime === null) {
      startTime = time2;
    }
    const progress = Math.max(Math.min((time2 - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = "";
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
let support;
function calcSupport() {
  const window2 = getWindow$1();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, "passive", {
          get() {
            supportsPassive = true;
          }
        });
        window2.addEventListener("testPassiveListener", null, opts);
      } catch (e2) {
      }
      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return "ongesturestart" in window2;
    }()
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice({
  userAgent
} = {}) {
  const support2 = getSupport();
  const window2 = getWindow$1();
  const platform2 = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone2 = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform2 === "Win32";
  let macos = platform2 === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone2 || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice(overrides = {}) {
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow$1();
  function isSafari() {
    const ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  return {
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize({
  swiper,
  on: on2,
  emit
}) {
  const window2 = getWindow$1();
  let observer = null;
  const resizeHandler2 = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit("beforeResize");
    emit("resize");
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    observer = new ResizeObserver((entries) => {
      const {
        width,
        height
      } = swiper;
      let newWidth = width;
      let newHeight = height;
      entries.forEach(({
        contentBoxSize,
        contentRect,
        target
      }) => {
        if (target && target !== swiper.el)
          return;
        newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
        newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
      });
      if (newWidth !== width || newHeight !== height) {
        resizeHandler2();
      }
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit("orientationchange");
  };
  on2("init", () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler2);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on2("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler2);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}
function Observer({
  swiper,
  extendParams,
  on: on2,
  emit
}) {
  const observers = [];
  const window2 = getWindow$1();
  const attach = (target, options = {}) => {
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (mutations.length === 1) {
        emit("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: typeof options.childList === "undefined" ? true : options.childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init2 = () => {
    if (!swiper.params.observer)
      return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    });
    attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on2("init", init2);
  on2("destroy", destroy);
}
var eventsEmitter = {
  on(events2, handler, priority) {
    const self2 = this;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event) => {
      if (!self2.eventsListeners[event])
        self2.eventsListeners[event] = [];
      self2.eventsListeners[event][method](handler);
    });
    return self2;
  },
  once(events2, handler, priority) {
    const self2 = this;
    if (typeof handler !== "function")
      return self2;
    function onceHandler(...args) {
      self2.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      handler.apply(self2, args);
    }
    onceHandler.__emitterProxy = handler;
    return self2.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self2 = this;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    if (self2.eventsAnyListeners.indexOf(handler) < 0) {
      self2.eventsAnyListeners[method](handler);
    }
    return self2;
  },
  offAny(handler) {
    const self2 = this;
    if (!self2.eventsAnyListeners)
      return self2;
    const index2 = self2.eventsAnyListeners.indexOf(handler);
    if (index2 >= 0) {
      self2.eventsAnyListeners.splice(index2, 1);
    }
    return self2;
  },
  off(events2, handler) {
    const self2 = this;
    if (!self2.eventsListeners)
      return self2;
    events2.split(" ").forEach((event) => {
      if (typeof handler === "undefined") {
        self2.eventsListeners[event] = [];
      } else if (self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler, index2) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self2.eventsListeners[event].splice(index2, 1);
          }
        });
      }
    });
    return self2;
  },
  emit(...args) {
    const self2 = this;
    if (!self2.eventsListeners)
      return self2;
    let events2;
    let data;
    let context;
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context = self2;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context = args[0].context || self2;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event) => {
      if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
        self2.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self2.eventsListeners && self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self2;
  }
};
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }
  width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
  height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
  if (Number.isNaN(width))
    width = 0;
  if (Number.isNaN(height))
    height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}
function updateSlides() {
  const swiper = this;
  function getDirectionLabel(property2) {
    if (swiper.isHorizontal()) {
      return property2;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property2];
  }
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    $wrapperEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index2 = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  }
  swiper.virtualSize = -spaceBetween;
  if (rtl)
    slides.css({
      marginLeft: "",
      marginBottom: "",
      marginTop: ""
    });
  else
    slides.css({
      marginRight: "",
      marginBottom: "",
      marginTop: ""
    });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key2) => {
    return typeof params.breakpoints[key2].slidesPerView !== "undefined";
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide2 = slides.eq(i);
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide2, slidesLength, getDirectionLabel);
    }
    if (slide2.css("display") === "none")
      continue;
    if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slides[i].style[getDirectionLabel("width")] = ``;
      }
      const slideStyles = getComputedStyle(slide2[0]);
      const currentTransform = slide2[0].style.transform;
      const currentWebKitTransform = slide2[0].style.webkitTransform;
      if (currentTransform) {
        slide2[0].style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide2[0].style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide2.outerWidth(true) : slide2.outerHeight(true);
      } else {
        const width = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide2[0];
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index2 % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index2 += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    $wrapperEl.css({
      width: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }
  if (params.setWrapperSize) {
    $wrapperEl.css({
      [getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths)
        slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (params.spaceBetween !== 0) {
    const key2 = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
    slides.filter((_2, slideIndex) => {
      if (!params.cssMode)
        return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).css({
      [key2]: `${spaceBetween}px`
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap < 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v2) => v2 + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map((v2) => v2 + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow)
      swiper.checkOverflow();
    swiper.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
}
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === "number") {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = (index2) => {
    if (isVirtual) {
      return swiper.slides.filter((el) => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index2)[0];
    }
    return swiper.slides.eq(index2)[0];
  };
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index2 = swiper.activeIndex + i;
        if (index2 > swiper.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index2));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== "undefined") {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0)
    swiper.$wrapperEl.css("height", `${newHeight}px`);
}
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}
function updateSlidesProgress(translate2 = this && this.translate || 0) {
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === "undefined")
    swiper.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl)
    offsetCenter = translate2;
  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  for (let i = 0; i < slides.length; i += 1) {
    const slide2 = slides[i];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + params.spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide2);
      swiper.visibleSlidesIndexes.push(i);
      slides.eq(i).addClass(params.slideVisibleClass);
    }
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
  swiper.visibleSlides = $(swiper.visibleSlides);
}
function updateProgress(translate2) {
  const swiper = this;
  if (typeof translate2 === "undefined") {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate2 - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Object.assign(swiper, {
    progress,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
    swiper.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit("fromEdge");
  }
  swiper.emit("progress", progress);
}
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    $wrapperEl,
    activeIndex,
    realIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }
  activeSlide.addClass(params.slideActiveClass);
  if (params.loop) {
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    }
  }
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
    }
  }
  swiper.emitSlidesClasses();
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid,
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === "undefined") {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate2 >= slidesGrid[i] && translate2 < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate2 >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined")
        activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit("snapIndexChange");
    }
    return;
  }
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
  Object.assign(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  swiper.emit("activeIndexChange");
  swiper.emit("snapIndexChange");
  if (previousRealIndex !== realIndex) {
    swiper.emit("realIndexChange");
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit("slideChange");
  }
}
function updateClickedSlide(e2) {
  const swiper = this;
  const params = swiper.params;
  const slide2 = $(e2).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide2) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper.clickedSlide = slide2;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt($(slide2).attr("data-swiper-slide-index"), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(axis = this.isHorizontal() ? "x" : "y") {
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    $wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    $wrapperEl,
    wrapperEl,
    progress
  } = swiper;
  let x2 = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x2 = rtl ? -translate2 : translate2;
  } else {
    y = translate2;
  }
  if (params.roundLengths) {
    x2 = Math.floor(x2);
    y = Math.floor(y);
  }
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x2 : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x2}px, ${y}px, ${z}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x2 : y;
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate2);
  }
  swiper.emit("setTranslate", swiper.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2 = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper.minTranslate();
  const maxTranslate2 = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate2;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionEnd");
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionStart");
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e2) {
          if (!swiper || swiper.destroyed)
            return;
          if (e2.target !== this)
            return;
          swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit("transitionEnd");
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
var translate$1 = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }
  swiper.emit("setTransition", duration, byController);
}
function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir3 = direction;
  if (!dir3) {
    if (activeIndex > previousIndex)
      dir3 = "next";
    else if (activeIndex < previousIndex)
      dir3 = "prev";
    else
      dir3 = "reset";
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir3 === "reset") {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir3 === "next") {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}
function transitionStart(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "Start"
  });
}
function transitionEnd(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode)
    return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "End"
  });
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(index2 = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
  if (typeof index2 !== "number" && typeof index2 !== "string") {
    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);
  }
  if (typeof index2 === "string") {
    const indexAsNumber = parseInt(index2, 10);
    const isValidNumber = isFinite(indexAsNumber);
    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
    }
    index2 = indexAsNumber;
  }
  const swiper = this;
  let slideIndex = index2;
  if (slideIndex < 0)
    slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit("beforeSlideChangeStart");
  }
  const translate2 = -snapGrid[snapIndex];
  swiper.updateProgress(translate2);
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate2 < swiper.translate && translate2 < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex)
        return false;
    }
  }
  let direction;
  if (slideIndex > activeIndex)
    direction = "next";
  else if (slideIndex < activeIndex)
    direction = "prev";
  else
    direction = "reset";
  if (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper.setTranslate(translate2);
    }
    if (direction !== "reset") {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate2 : -translate2;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = "none";
        swiper._immediateVirtual = true;
      }
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = "";
          swiper._swiperImmediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t,
        behavior: "smooth"
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate2);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit("beforeTransitionStart", speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e2) {
        if (!swiper || swiper.destroyed)
          return;
        if (e2.target !== this)
          return;
        swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index2 = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index2;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }
  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    animating,
    enabled,
    params
  } = swiper;
  if (!enabled)
    return swiper;
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params,
    animating,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return swiper;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize2(val) {
    if (val < 0)
      return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize2(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize2(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    return swiper.slideTo(swiper.slides.length - 1, speed, runCallbacks, internal);
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  let index2 = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
  const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
  const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate2 >= swiper.snapGrid[snapIndex]) {
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
      index2 += swiper.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index2 -= swiper.params.slidesPerGroup;
    }
  }
  index2 = Math.max(index2, 0);
  index2 = Math.min(index2, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index2, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    $wrapperEl
  } = swiper;
  const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating)
      return;
    realIndex = parseInt($(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate() {
  const swiper = this;
  const document2 = getDocument();
  const {
    params,
    $wrapperEl
  } = swiper;
  const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;
  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  let slides = $selector.children(`.${params.slideClass}`);
  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = $(document2.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $selector.append(blankNode);
      }
      slides = $selector.children(`.${params.slideClass}`);
    }
  }
  if (params.slidesPerView === "auto" && !params.loopedSlides)
    params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }
  const prependSlides = [];
  const appendSlides = [];
  slides.each((el, index2) => {
    const slide2 = $(el);
    if (index2 < swiper.loopedSlides) {
      appendSlides.push(el);
    }
    if (index2 < slides.length && index2 >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }
    slide2.attr("data-swiper-slide-index", index2);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}
function loopFix() {
  const swiper = this;
  swiper.emit("beforeLoopFix");
  const {
    activeIndex,
    slides,
    loopedSlides,
    allowSlidePrev,
    allowSlideNext,
    snapGrid,
    rtlTranslate: rtl
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();
  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit("loopFix");
}
function loopDestroy() {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    slides
  } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr("data-swiper-slide-index");
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(moving) {
  const swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
    return;
  const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
  el.style.cursor = "move";
  el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
  el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
  el.style.cursor = moving ? "grabbing" : "grab";
}
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(selector, base2 = this) {
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow$1())
      return null;
    if (el.assignedSlot)
      el = el.assignedSlot;
    const found = el.closest(selector);
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base2);
}
function onTouchStart(event) {
  const swiper = this;
  const document2 = getDocument();
  const window2 = getWindow$1();
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled)
    return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  let $targetEl = $(e2.target);
  if (params.touchEventsTarget === "wrapper") {
    if (!$targetEl.closest(swiper.wrapperEl).length)
      return;
  }
  data.isTouchEvent = e2.type === "touchstart";
  if (!data.isTouchEvent && "which" in e2 && e2.which === 3)
    return;
  if (!data.isTouchEvent && "button" in e2 && e2.button > 0)
    return;
  if (data.isTouched && data.isMoved)
    return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  if (swipingClassHasValue && e2.target && e2.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = $(event.path[0]);
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e2.target && e2.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e2.target) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0])
      return;
  }
  touches.currentX = e2.type === "touchstart" ? e2.targetTouches[0].pageX : e2.pageX;
  touches.currentY = e2.type === "touchstart" ? e2.targetTouches[0].pageY : e2.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event.preventDefault();
    } else {
      return;
    }
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now$2();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0)
    data.allowThresholdMove = false;
  if (e2.type !== "touchstart") {
    let preventDefault2 = true;
    if ($targetEl.is(data.focusableElements))
      preventDefault2 = false;
    if (document2.activeElement && $(document2.activeElement).is(data.focusableElements) && document2.activeElement !== $targetEl[0]) {
      document2.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault2 && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e2.preventDefault();
    }
  }
  swiper.emit("touchStart", e2);
}
function onTouchMove(event) {
  const document2 = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled)
    return;
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit("touchMoveOpposite", e2);
    }
    return;
  }
  if (data.isTouchEvent && e2.type !== "touchmove")
    return;
  const targetTouch = e2.type === "touchmove" && e2.targetTouches && (e2.targetTouches[0] || e2.changedTouches[0]);
  const pageX = e2.type === "touchmove" ? targetTouch.pageX : e2.pageX;
  const pageY = e2.type === "touchmove" ? targetTouch.pageY : e2.pageY;
  if (e2.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    swiper.allowClick = false;
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now$2();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (data.isTouchEvent && document2.activeElement) {
    if (e2.target === document2.activeElement && $(e2.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit("touchMove", e2);
  }
  if (e2.targetTouches && e2.targetTouches.length > 1)
    return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
    return;
  if (typeof data.isScrolling === "undefined") {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit("touchMoveOpposite", e2);
  }
  if (typeof data.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e2.cancelable) {
    e2.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e2.stopPropagation();
  }
  if (!data.isMoved) {
    if (params.loop && !params.cssMode) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit("sliderFirstMove", e2);
  }
  swiper.emit("sliderMove", e2);
  data.isMoved = true;
  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl)
    diff = -diff;
  swiper.swipeDirection = diff > 0 ? "prev" : "next";
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
  }
  if (disableParentSwiper) {
    e2.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  swiper.updateProgress(data.currentTranslate);
  swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled)
    return;
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit("touchEnd", e2);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  const touchEndTime = now$2();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper.allowClick) {
    const pathTree = e2.path || e2.composedPath && e2.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e2.target);
    swiper.emit("tap click", e2);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit("doubleTap doubleClick", e2);
    }
  }
  data.lastClickTime = now$2();
  nextTick(() => {
    if (!swiper.destroyed)
      swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment2] !== "undefined") {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment2] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio)
        swiper.slideTo(stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio)
        swiper.slideTo(stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e2.target === swiper.navigation.nextEl || e2.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === "next") {
        swiper.slideTo(stopIndex + increment);
      }
      if (swiper.swipeDirection === "prev") {
        swiper.slideTo(stopIndex);
      }
    } else if (e2.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
function onClick(e2) {
  const swiper = this;
  if (!swiper.enabled)
    return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks)
      e2.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === -0)
    swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit("setTranslate", swiper.translate, false);
}
let dummyEventAttached = false;
function dummyEventListener() {
}
const events = (swiper, method) => {
  const document2 = getDocument();
  const {
    params,
    touchEvents,
    el,
    wrapperEl,
    device,
    support: support2
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  if (!support2.touch) {
    el[domMethod](touchEvents.start, swiper.onTouchStart, false);
    document2[domMethod](touchEvents.move, swiper.onTouchMove, capture);
    document2[domMethod](touchEvents.end, swiper.onTouchEnd, false);
  } else {
    const passiveListener = touchEvents.start === "touchstart" && support2.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
    el[domMethod](touchEvents.move, swiper.onTouchMove, support2.passiveListener ? {
      passive: false,
      capture
    } : capture);
    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
    if (touchEvents.cancel) {
      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
    }
  }
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper[swiperMethod]("observerUpdate", onResize, true);
  }
};
function attachEvents() {
  const swiper = this;
  const document2 = getDocument();
  const {
    params,
    support: support2
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  if (support2.touch && !dummyEventAttached) {
    document2.addEventListener("touchstart", dummyEventListener);
    dummyEventAttached = true;
  }
  events(swiper, "on");
}
function detachEvents() {
  const swiper = this;
  events(swiper, "off");
}
var events$1 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    activeIndex,
    initialized,
    loopedSlides = 0,
    params,
    $el
  } = swiper;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
    return;
  const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint)
    return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      $el.addClass(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend$1(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit("_beforeBreakpoint", breakpointParams);
  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }
  swiper.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base2 = "window", containerEl) {
  if (!breakpoints2 || base2 === "container" && !containerEl)
    return void 0;
  let breakpoint = false;
  const window2 = getWindow$1();
  const currentHeight = base2 === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points2 = Object.keys(breakpoints2).map((point) => {
    if (typeof point === "string" && point.indexOf("@") === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points2.sort((a2, b2) => parseInt(a2.value, 10) - parseInt(b2.value, 10));
  for (let i = 0; i < points2.length; i += 1) {
    const {
      point,
      value
    } = points2[i];
    if (base2 === "window") {
      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    $el,
    device,
    support: support2
  } = swiper;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "pointer-events": !support2.touch
  }, {
    "free-mode": swiper.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  $el.addClass([...classNames].join(" "));
  swiper.emitContainerClasses();
}
function removeClasses() {
  const swiper = this;
  const {
    $el,
    classNames
  } = swiper;
  $el.removeClass(classNames.join(" "));
  swiper.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses
};
function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  const window2 = getWindow$1();
  let image;
  function onReady() {
    if (callback)
      callback();
  }
  const isPicture = $(imageEl).parent("picture")[0];
  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window2.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    onReady();
  }
}
function preloadImages() {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find("img");
  function onReady() {
    if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed)
      return;
    if (swiper.imagesLoaded !== void 0)
      swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady)
        swiper.update();
      swiper.emit("imagesReady");
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
  }
}
var images = {
  loadImage,
  preloadImages
};
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? "lock" : "unlock");
  }
}
var checkOverflow$1 = {
  checkOverflow
};
var defaults = {
  init: true,
  direction: "horizontal",
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  width: null,
  height: null,
  preventInteractionOnTransition: false,
  userAgent: null,
  url: null,
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  autoHeight: false,
  setWrapperSize: false,
  virtualTranslate: false,
  effect: "slide",
  breakpoints: void 0,
  breakpointsBase: "window",
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  slidesOffsetAfter: 0,
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  watchOverflow: true,
  roundLengths: false,
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  uniqueNavElements: true,
  resistance: true,
  resistanceRatio: 0.85,
  watchSlidesProgress: false,
  grabCursor: false,
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  preloadImages: true,
  updateOnImagesReady: true,
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  rewind: false,
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  passiveListeners: true,
  containerModifierClass: "swiper-",
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-invisible-blank",
  slideActiveClass: "swiper-slide-active",
  slideDuplicateActiveClass: "swiper-slide-duplicate-active",
  slideVisibleClass: "swiper-slide-visible",
  slideDuplicateClass: "swiper-slide-duplicate",
  slideNextClass: "swiper-slide-next",
  slideDuplicateNextClass: "swiper-slide-duplicate-next",
  slidePrevClass: "swiper-slide-prev",
  slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
  wrapperClass: "swiper-wrapper",
  runCallbacksOnInit: true,
  _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj = {}) {
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName])
      params[moduleParamName] = {
        enabled: false
      };
    extend$1(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate: translate$1,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images
};
const extendedDefaults = {};
class Swiper$1 {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params)
      params = {};
    params = extend$1({}, params);
    if (el && !params.el)
      params.el = el;
    if (params.el && $(params.el).length > 1) {
      const swipers = [];
      $(params.el).each((containerEl) => {
        const newParams = extend$1({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper$1(newParams));
      });
      return swipers;
    }
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach((mod) => {
      mod({
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });
    const swiperParams = extend$1({}, defaults, allModulesParams);
    swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend$1({}, swiper.params);
    swiper.passedParams = extend$1({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach((eventName) => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    swiper.$ = $;
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      classNames: [],
      slides: $(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical() {
        return swiper.params.direction === "vertical";
      },
      activeIndex: 0,
      realIndex: 0,
      isBeginning: true,
      isEnd: false,
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      touchEvents: function touchEvents() {
        const touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
        const desktop = ["pointerdown", "pointermove", "pointerup"];
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        focusableElements: swiper.params.focusableElements,
        lastClickTime: now$2(),
        clickTimeout: void 0,
        velocities: [],
        allowMomentumBounce: void 0,
        isTouchEvent: void 0,
        startMoving: void 0
      },
      allowClick: true,
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit("_swiper");
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }
  enable() {
    const swiper = this;
    if (swiper.enabled)
      return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit("enable");
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled)
      return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min3 = swiper.minTranslate();
    const max3 = swiper.maxTranslate();
    const current = (max3 - min3) * progress + min3;
    swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const cls = swiper.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const updates = [];
    swiper.slides.each((slideEl) => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit("_slideClass", slideEl, classNames);
    });
    swiper.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view2 = "current", exact = false) {
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      if (view2 === "current") {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed)
      return;
    const {
      snapGrid,
      params
    } = swiper;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
      setTranslate2();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit("update");
  }
  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper;
    }
    swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper.emit("changeDirection");
    if (needUpdate)
      swiper.update();
    return swiper;
  }
  mount(el) {
    const swiper = this;
    if (swiper.mounted)
      return true;
    const $el = $(el || swiper.params.el);
    el = $el[0];
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = $(el.shadowRoot.querySelector(getWrapperSelector()));
        res.children = (options) => $el.children(options);
        return res;
      }
      return $el.children(getWrapperSelector());
    };
    let $wrapperEl = getWrapper();
    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      const document2 = getDocument();
      const wrapper = document2.createElement("div");
      $wrapperEl = $(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {
        $wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
      wrongRTL: $wrapperEl.css("display") === "-webkit-box"
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized)
      return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false)
      return swiper;
    swiper.emit("beforeInit");
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    if (swiper.params.loop) {
      swiper.loopCreate();
    }
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }
    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }
    swiper.attachEvents();
    swiper.initialized = true;
    swiper.emit("init");
    swiper.emit("afterInit");
    return swiper;
  }
  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params,
      $el,
      $wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === "undefined" || swiper.destroyed) {
      return null;
    }
    swiper.emit("beforeDestroy");
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr("style");
      $wrapperEl.removeAttr("style");
      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
      }
    }
    swiper.emit("destroy");
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend$1(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper$1.prototype.__modules__)
      Swiper$1.prototype.__modules__ = [];
    const modules = Swiper$1.prototype.__modules__;
    if (typeof mod === "function" && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module2) {
    if (Array.isArray(module2)) {
      module2.forEach((m2) => Swiper$1.installModule(m2));
      return Swiper$1;
    }
    Swiper$1.installModule(module2);
    return Swiper$1;
  }
}
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper$1.use([Resize, Observer]);
function Autoplay({
  swiper,
  extendParams,
  on: on2,
  emit
}) {
  let timeout;
  swiper.autoplay = {
    running: false,
    paused: false
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3e3,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  function run() {
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr("data-swiper-autoplay")) {
      delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay;
    }
    clearTimeout(timeout);
    timeout = nextTick(() => {
      let autoplayResult;
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          emit("autoplay");
        } else {
          stop2();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit("autoplay");
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit("autoplay");
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        emit("autoplay");
      } else {
        stop2();
      }
      if (swiper.params.cssMode && swiper.autoplay.running)
        run();
      else if (autoplayResult === false) {
        run();
      }
    }, delay);
  }
  function start2() {
    if (typeof timeout !== "undefined")
      return false;
    if (swiper.autoplay.running)
      return false;
    swiper.autoplay.running = true;
    emit("autoplayStart");
    run();
    return true;
  }
  function stop2() {
    if (!swiper.autoplay.running)
      return false;
    if (typeof timeout === "undefined")
      return false;
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    swiper.autoplay.running = false;
    emit("autoplayStop");
    return true;
  }
  function pause(speed) {
    if (!swiper.autoplay.running)
      return;
    if (swiper.autoplay.paused)
      return;
    if (timeout)
      clearTimeout(timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      run();
    } else {
      ["transitionend", "webkitTransitionEnd"].forEach((event) => {
        swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);
      });
    }
  }
  function onVisibilityChange() {
    const document2 = getDocument();
    if (document2.visibilityState === "hidden" && swiper.autoplay.running) {
      pause();
    }
    if (document2.visibilityState === "visible" && swiper.autoplay.paused) {
      run();
      swiper.autoplay.paused = false;
    }
  }
  function onTransitionEnd(e2) {
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl)
      return;
    if (e2.target !== swiper.$wrapperEl[0])
      return;
    ["transitionend", "webkitTransitionEnd"].forEach((event) => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
    swiper.autoplay.paused = false;
    if (!swiper.autoplay.running) {
      stop2();
    } else {
      run();
    }
  }
  function onMouseEnter() {
    if (swiper.params.autoplay.disableOnInteraction) {
      stop2();
    } else {
      pause();
    }
    ["transitionend", "webkitTransitionEnd"].forEach((event) => {
      swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);
    });
  }
  function onMouseLeave() {
    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }
    swiper.autoplay.paused = false;
    run();
  }
  function attachMouseEvents() {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on("mouseenter", onMouseEnter);
      swiper.$el.on("mouseleave", onMouseLeave);
    }
  }
  function detachMouseEvents() {
    swiper.$el.off("mouseenter", onMouseEnter);
    swiper.$el.off("mouseleave", onMouseLeave);
  }
  on2("init", () => {
    if (swiper.params.autoplay.enabled) {
      start2();
      const document2 = getDocument();
      document2.addEventListener("visibilitychange", onVisibilityChange);
      attachMouseEvents();
    }
  });
  on2("beforeTransitionStart", (_s, speed, internal) => {
    if (swiper.autoplay.running) {
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.pause(speed);
      } else {
        stop2();
      }
    }
  });
  on2("sliderFirstMove", () => {
    if (swiper.autoplay.running) {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop2();
      } else {
        pause();
      }
    }
  });
  on2("touchEnd", () => {
    if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
      run();
    }
  });
  on2("destroy", () => {
    detachMouseEvents();
    if (swiper.autoplay.running) {
      stop2();
    }
    const document2 = getDocument();
    document2.removeEventListener("visibilitychange", onVisibilityChange);
  });
  Object.assign(swiper.autoplay, {
    pause,
    run,
    start: start2,
    stop: stop2
  });
}
function isObject$3(o2) {
  return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}
function extend(target, src) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key2) => noExtend.indexOf(key2) < 0).forEach((key2) => {
    if (typeof target[key2] === "undefined")
      target[key2] = src[key2];
    else if (isObject$3(src[key2]) && isObject$3(target[key2]) && Object.keys(src[key2]).length > 0) {
      if (src[key2].__swiper__)
        target[key2] = src[key2];
      else
        extend(target[key2], src[key2]);
    } else {
      target[key2] = src[key2];
    }
  });
}
function needsNavigation(props2 = {}) {
  return props2.navigation && typeof props2.navigation.nextEl === "undefined" && typeof props2.navigation.prevEl === "undefined";
}
function needsPagination(props2 = {}) {
  return props2.pagination && typeof props2.pagination.el === "undefined";
}
function needsScrollbar(props2 = {}) {
  return props2.scrollbar && typeof props2.scrollbar.el === "undefined";
}
function uniqueClasses(classNames = "") {
  const classes2 = classNames.split(" ").map((c) => c.trim()).filter((c) => !!c);
  const unique2 = [];
  classes2.forEach((c) => {
    if (unique2.indexOf(c) < 0)
      unique2.push(c);
  });
  return unique2.join(" ");
}
const paramsList = [
  "modules",
  "init",
  "_direction",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "_spaceBetween",
  "_slidesPerView",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_preloadImages",
  "updateOnImagesReady",
  "_loop",
  "_loopAdditionalSlides",
  "_loopedSlides",
  "_loopFillGroupWithBlank",
  "loopPreventsSlide",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideBlankClass",
  "slideActiveClass",
  "slideDuplicateActiveClass",
  "slideVisibleClass",
  "slideDuplicateClass",
  "slideNextClass",
  "slideDuplicateNextClass",
  "slidePrevClass",
  "slideDuplicatePrevClass",
  "wrapperClass",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  "a11y",
  "autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "lazy",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom"
];
function getParams(obj = {}) {
  const params = {
    on: {}
  };
  const passedParams = {};
  extend(params, Swiper$1.defaults);
  extend(params, Swiper$1.extendedDefaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map((key2) => key2.replace(/_/, ""));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach((key2) => {
    if (typeof obj[key2] === "undefined")
      return;
    if (allowedParams.indexOf(key2) >= 0) {
      if (isObject$3(obj[key2])) {
        params[key2] = {};
        passedParams[key2] = {};
        extend(params[key2], obj[key2]);
        extend(passedParams[key2], obj[key2]);
      } else {
        params[key2] = obj[key2];
        passedParams[key2] = obj[key2];
      }
    } else if (key2.search(/on[A-Z]/) === 0 && typeof obj[key2] === "function") {
      params.on[`${key2[2].toLowerCase()}${key2.substr(3)}`] = obj[key2];
    } else {
      rest[key2] = obj[key2];
    }
  });
  ["navigation", "pagination", "scrollbar"].forEach((key2) => {
    if (params[key2] === true)
      params[key2] = {};
    if (params[key2] === false)
      delete params[key2];
  });
  return {
    params,
    passedParams,
    rest
  };
}
function initSwiper(swiperParams) {
  return new Swiper$1(swiperParams);
}
function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper.init(el);
}
function calcLoopedSlides(slides, swiperParams) {
  let slidesPerViewParams = swiperParams.slidesPerView;
  if (swiperParams.breakpoints) {
    const breakpoint = Swiper$1.prototype.getBreakpoint(swiperParams.breakpoints);
    const breakpointOnlyParams = breakpoint in swiperParams.breakpoints ? swiperParams.breakpoints[breakpoint] : void 0;
    if (breakpointOnlyParams && breakpointOnlyParams.slidesPerView) {
      slidesPerViewParams = breakpointOnlyParams.slidesPerView;
    }
  }
  let loopedSlides = Math.ceil(parseFloat(swiperParams.loopedSlides || slidesPerViewParams, 10));
  loopedSlides += swiperParams.loopAdditionalSlides;
  if (loopedSlides > slides.length) {
    loopedSlides = slides.length;
  }
  return loopedSlides;
}
function renderLoop(swiperRef, slides, swiperParams) {
  const modifiedSlides = slides.map((child, index2) => {
    if (!child.props)
      child.props = {};
    child.props.swiperRef = swiperRef;
    child.props["data-swiper-slide-index"] = index2;
    return child;
  });
  function duplicateSlide(child, index2, position2) {
    if (!child.props)
      child.props = {};
    return h$1(child.type, __spreadProps(__spreadValues({}, child.props), {
      key: `${child.key}-duplicate-${index2}-${position2}`,
      class: `${child.props.className || ""} ${swiperParams.slideDuplicateClass} ${child.props.class || ""}`
    }), child.children);
  }
  if (swiperParams.loopFillGroupWithBlank) {
    const blankSlidesNum = swiperParams.slidesPerGroup - modifiedSlides.length % swiperParams.slidesPerGroup;
    if (blankSlidesNum !== swiperParams.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankSlide = h$1("div", {
          class: `${swiperParams.slideClass} ${swiperParams.slideBlankClass}`
        });
        modifiedSlides.push(blankSlide);
      }
    }
  }
  if (swiperParams.slidesPerView === "auto" && !swiperParams.loopedSlides) {
    swiperParams.loopedSlides = modifiedSlides.length;
  }
  const loopedSlides = calcLoopedSlides(modifiedSlides, swiperParams);
  const prependSlides = [];
  const appendSlides = [];
  modifiedSlides.forEach((child, index2) => {
    if (index2 < loopedSlides) {
      appendSlides.push(duplicateSlide(child, index2, "prepend"));
    }
    if (index2 < modifiedSlides.length && index2 >= modifiedSlides.length - loopedSlides) {
      prependSlides.push(duplicateSlide(child, index2, "append"));
    }
  });
  if (swiperRef.value) {
    swiperRef.value.loopedSlides = loopedSlides;
  }
  return [...prependSlides, ...modifiedSlides, ...appendSlides];
}
function getChangedParams(swiperParams, oldParams, children2, oldChildren) {
  const keys2 = [];
  if (!oldParams)
    return keys2;
  const addKey = (key2) => {
    if (keys2.indexOf(key2) < 0)
      keys2.push(key2);
  };
  const oldChildrenKeys = oldChildren.map((child) => child.props && child.props.key);
  const childrenKeys = children2.map((child) => child.props && child.props.key);
  if (oldChildrenKeys.join("") !== childrenKeys.join(""))
    keys2.push("children");
  if (oldChildren.length !== children2.length)
    keys2.push("children");
  const watchParams = paramsList.filter((key2) => key2[0] === "_").map((key2) => key2.replace(/_/, ""));
  watchParams.forEach((key2) => {
    if (key2 in swiperParams && key2 in oldParams) {
      if (isObject$3(swiperParams[key2]) && isObject$3(oldParams[key2])) {
        const newKeys = Object.keys(swiperParams[key2]);
        const oldKeys = Object.keys(oldParams[key2]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key2);
        } else {
          newKeys.forEach((newKey) => {
            if (swiperParams[key2][newKey] !== oldParams[key2][newKey]) {
              addKey(key2);
            }
          });
          oldKeys.forEach((oldKey) => {
            if (swiperParams[key2][oldKey] !== oldParams[key2][oldKey])
              addKey(key2);
          });
        }
      } else if (swiperParams[key2] !== oldParams[key2]) {
        addKey(key2);
      }
    }
  });
  return keys2;
}
function getChildren(originalSlots = {}, slidesRef, oldSlidesRef) {
  const slides = [];
  const slots = {
    "container-start": [],
    "container-end": [],
    "wrapper-start": [],
    "wrapper-end": []
  };
  const getSlidesFromElements = (els, slotName) => {
    if (!Array.isArray(els)) {
      return;
    }
    els.forEach((vnode) => {
      const isFragment = typeof vnode.type === "symbol";
      if (slotName === "default")
        slotName = "container-end";
      if (isFragment && vnode.children) {
        getSlidesFromElements(vnode.children, "default");
      } else if (vnode.type && (vnode.type.name === "SwiperSlide" || vnode.type.name === "AsyncComponentWrapper")) {
        slides.push(vnode);
      } else if (slots[slotName]) {
        slots[slotName].push(vnode);
      }
    });
  };
  Object.keys(originalSlots).forEach((slotName) => {
    const els = originalSlots[slotName]();
    getSlidesFromElements(els, slotName);
  });
  oldSlidesRef.value = slidesRef.value;
  slidesRef.value = slides;
  return {
    slides,
    slots
  };
}
function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl
}) {
  const updateParams = changedParams.filter((key2) => key2 !== "children" && key2 !== "direction");
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = (mod) => {
    if (!swiper[mod])
      return;
    swiper[mod].destroy();
    if (mod === "navigation") {
      currentParams[mod].prevEl = void 0;
      currentParams[mod].nextEl = void 0;
      swiper[mod].prevEl = void 0;
      swiper[mod].nextEl = void 0;
    } else {
      currentParams[mod].el = void 0;
      swiper[mod].el = void 0;
    }
  };
  updateParams.forEach((key2) => {
    if (isObject$3(currentParams[key2]) && isObject$3(passedParams[key2])) {
      extend(currentParams[key2], passedParams[key2]);
    } else {
      const newValue = passedParams[key2];
      if ((newValue === true || newValue === false) && (key2 === "navigation" || key2 === "pagination" || key2 === "scrollbar")) {
        if (newValue === false) {
          destroyModule(key2);
        }
      } else {
        currentParams[key2] = passedParams[key2];
      }
    }
  });
  if (changedParams.includes("children") && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes("children") && swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized)
      thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (paginationEl)
      currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (scrollbarEl)
      currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (nextEl)
      currentParams.navigation.nextEl = nextEl;
    if (prevEl)
      currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes("allowSlideNext")) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes("allowSlidePrev")) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes("direction")) {
    swiper.changeDirection(passedParams.direction, false);
  }
  swiper.update();
}
function updateOnVirtualData(swiper) {
  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled)
    return;
  swiper.updateSlides();
  swiper.updateProgress();
  swiper.updateSlidesClasses();
  if (swiper.lazy && swiper.params.lazy.enabled) {
    swiper.lazy.load();
  }
  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
    swiper.parallax.setTranslate();
  }
}
function renderVirtual(swiperRef, slides, virtualData) {
  if (!virtualData)
    return null;
  const style = swiperRef.value.isHorizontal() ? {
    [swiperRef.value.rtlTranslate ? "right" : "left"]: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  return slides.filter((slide2, index2) => index2 >= virtualData.from && index2 <= virtualData.to).map((slide2) => {
    if (!slide2.props)
      slide2.props = {};
    if (!slide2.props.style)
      slide2.props.style = {};
    slide2.props.swiperRef = swiperRef;
    slide2.props.style = style;
    return h$1(slide2.type, __spreadValues({}, slide2.props), slide2.children);
  });
}
const Swiper = {
  name: "Swiper",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    wrapperTag: {
      type: String,
      default: "div"
    },
    modules: {
      type: Array,
      default: void 0
    },
    init: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String,
      default: void 0
    },
    touchEventsTarget: {
      type: String,
      default: void 0
    },
    initialSlide: {
      type: Number,
      default: void 0
    },
    speed: {
      type: Number,
      default: void 0
    },
    cssMode: {
      type: Boolean,
      default: void 0
    },
    updateOnWindowResize: {
      type: Boolean,
      default: void 0
    },
    resizeObserver: {
      type: Boolean,
      default: void 0
    },
    nested: {
      type: Boolean,
      default: void 0
    },
    focusableElements: {
      type: String,
      default: void 0
    },
    width: {
      type: Number,
      default: void 0
    },
    height: {
      type: Number,
      default: void 0
    },
    preventInteractionOnTransition: {
      type: Boolean,
      default: void 0
    },
    userAgent: {
      type: String,
      default: void 0
    },
    url: {
      type: String,
      default: void 0
    },
    edgeSwipeDetection: {
      type: [Boolean, String],
      default: void 0
    },
    edgeSwipeThreshold: {
      type: Number,
      default: void 0
    },
    autoHeight: {
      type: Boolean,
      default: void 0
    },
    setWrapperSize: {
      type: Boolean,
      default: void 0
    },
    virtualTranslate: {
      type: Boolean,
      default: void 0
    },
    effect: {
      type: String,
      default: void 0
    },
    breakpoints: {
      type: Object,
      default: void 0
    },
    spaceBetween: {
      type: Number,
      default: void 0
    },
    slidesPerView: {
      type: [Number, String],
      default: void 0
    },
    slidesPerGroup: {
      type: Number,
      default: void 0
    },
    slidesPerGroupSkip: {
      type: Number,
      default: void 0
    },
    slidesPerGroupAuto: {
      type: Boolean,
      default: void 0
    },
    centeredSlides: {
      type: Boolean,
      default: void 0
    },
    centeredSlidesBounds: {
      type: Boolean,
      default: void 0
    },
    slidesOffsetBefore: {
      type: Number,
      default: void 0
    },
    slidesOffsetAfter: {
      type: Number,
      default: void 0
    },
    normalizeSlideIndex: {
      type: Boolean,
      default: void 0
    },
    centerInsufficientSlides: {
      type: Boolean,
      default: void 0
    },
    watchOverflow: {
      type: Boolean,
      default: void 0
    },
    roundLengths: {
      type: Boolean,
      default: void 0
    },
    touchRatio: {
      type: Number,
      default: void 0
    },
    touchAngle: {
      type: Number,
      default: void 0
    },
    simulateTouch: {
      type: Boolean,
      default: void 0
    },
    shortSwipes: {
      type: Boolean,
      default: void 0
    },
    longSwipes: {
      type: Boolean,
      default: void 0
    },
    longSwipesRatio: {
      type: Number,
      default: void 0
    },
    longSwipesMs: {
      type: Number,
      default: void 0
    },
    followFinger: {
      type: Boolean,
      default: void 0
    },
    allowTouchMove: {
      type: Boolean,
      default: void 0
    },
    threshold: {
      type: Number,
      default: void 0
    },
    touchMoveStopPropagation: {
      type: Boolean,
      default: void 0
    },
    touchStartPreventDefault: {
      type: Boolean,
      default: void 0
    },
    touchStartForcePreventDefault: {
      type: Boolean,
      default: void 0
    },
    touchReleaseOnEdges: {
      type: Boolean,
      default: void 0
    },
    uniqueNavElements: {
      type: Boolean,
      default: void 0
    },
    resistance: {
      type: Boolean,
      default: void 0
    },
    resistanceRatio: {
      type: Number,
      default: void 0
    },
    watchSlidesProgress: {
      type: Boolean,
      default: void 0
    },
    grabCursor: {
      type: Boolean,
      default: void 0
    },
    preventClicks: {
      type: Boolean,
      default: void 0
    },
    preventClicksPropagation: {
      type: Boolean,
      default: void 0
    },
    slideToClickedSlide: {
      type: Boolean,
      default: void 0
    },
    preloadImages: {
      type: Boolean,
      default: void 0
    },
    updateOnImagesReady: {
      type: Boolean,
      default: void 0
    },
    loop: {
      type: Boolean,
      default: void 0
    },
    loopAdditionalSlides: {
      type: Number,
      default: void 0
    },
    loopedSlides: {
      type: Number,
      default: void 0
    },
    loopFillGroupWithBlank: {
      type: Boolean,
      default: void 0
    },
    loopPreventsSlide: {
      type: Boolean,
      default: void 0
    },
    rewind: {
      type: Boolean,
      default: void 0
    },
    allowSlidePrev: {
      type: Boolean,
      default: void 0
    },
    allowSlideNext: {
      type: Boolean,
      default: void 0
    },
    swipeHandler: {
      type: Boolean,
      default: void 0
    },
    noSwiping: {
      type: Boolean,
      default: void 0
    },
    noSwipingClass: {
      type: String,
      default: void 0
    },
    noSwipingSelector: {
      type: String,
      default: void 0
    },
    passiveListeners: {
      type: Boolean,
      default: void 0
    },
    containerModifierClass: {
      type: String,
      default: void 0
    },
    slideClass: {
      type: String,
      default: void 0
    },
    slideBlankClass: {
      type: String,
      default: void 0
    },
    slideActiveClass: {
      type: String,
      default: void 0
    },
    slideDuplicateActiveClass: {
      type: String,
      default: void 0
    },
    slideVisibleClass: {
      type: String,
      default: void 0
    },
    slideDuplicateClass: {
      type: String,
      default: void 0
    },
    slideNextClass: {
      type: String,
      default: void 0
    },
    slideDuplicateNextClass: {
      type: String,
      default: void 0
    },
    slidePrevClass: {
      type: String,
      default: void 0
    },
    slideDuplicatePrevClass: {
      type: String,
      default: void 0
    },
    wrapperClass: {
      type: String,
      default: void 0
    },
    runCallbacksOnInit: {
      type: Boolean,
      default: void 0
    },
    observer: {
      type: Boolean,
      default: void 0
    },
    observeParents: {
      type: Boolean,
      default: void 0
    },
    observeSlideChildren: {
      type: Boolean,
      default: void 0
    },
    a11y: {
      type: [Boolean, Object],
      default: void 0
    },
    autoplay: {
      type: [Boolean, Object],
      default: void 0
    },
    controller: {
      type: Object,
      default: void 0
    },
    coverflowEffect: {
      type: Object,
      default: void 0
    },
    cubeEffect: {
      type: Object,
      default: void 0
    },
    fadeEffect: {
      type: Object,
      default: void 0
    },
    flipEffect: {
      type: Object,
      default: void 0
    },
    creativeEffect: {
      type: Object,
      default: void 0
    },
    cardsEffect: {
      type: Object,
      default: void 0
    },
    hashNavigation: {
      type: [Boolean, Object],
      default: void 0
    },
    history: {
      type: [Boolean, Object],
      default: void 0
    },
    keyboard: {
      type: [Boolean, Object],
      default: void 0
    },
    lazy: {
      type: [Boolean, Object],
      default: void 0
    },
    mousewheel: {
      type: [Boolean, Object],
      default: void 0
    },
    navigation: {
      type: [Boolean, Object],
      default: void 0
    },
    pagination: {
      type: [Boolean, Object],
      default: void 0
    },
    parallax: {
      type: [Boolean, Object],
      default: void 0
    },
    scrollbar: {
      type: [Boolean, Object],
      default: void 0
    },
    thumbs: {
      type: Object,
      default: void 0
    },
    virtual: {
      type: [Boolean, Object],
      default: void 0
    },
    zoom: {
      type: [Boolean, Object],
      default: void 0
    },
    grid: {
      type: [Object],
      default: void 0
    },
    freeMode: {
      type: [Boolean, Object],
      default: void 0
    }
  },
  emits: ["_beforeBreakpoint", "_containerClasses", "_slideClass", "_slideClasses", "_swiper", "activeIndexChange", "afterInit", "autoplay", "autoplayStart", "autoplayStop", "beforeDestroy", "beforeInit", "beforeLoopFix", "beforeResize", "beforeSlideChangeStart", "beforeTransitionStart", "breakpoint", "changeDirection", "click", "disable", "doubleTap", "doubleClick", "destroy", "enable", "fromEdge", "hashChange", "hashSet", "imagesReady", "init", "keyPress", "lazyImageLoad", "lazyImageReady", "lock", "loopFix", "momentumBounce", "navigationHide", "navigationShow", "observerUpdate", "orientationchange", "paginationHide", "paginationRender", "paginationShow", "paginationUpdate", "progress", "reachBeginning", "reachEnd", "realIndexChange", "resize", "scroll", "scrollbarDragEnd", "scrollbarDragMove", "scrollbarDragStart", "setTransition", "setTranslate", "slideChange", "slideChangeTransitionEnd", "slideChangeTransitionStart", "slideNextTransitionEnd", "slideNextTransitionStart", "slidePrevTransitionEnd", "slidePrevTransitionStart", "slideResetTransitionStart", "slideResetTransitionEnd", "sliderMove", "sliderFirstMove", "slidesLengthChange", "slidesGridLengthChange", "snapGridLengthChange", "snapIndexChange", "swiper", "tap", "toEdge", "touchEnd", "touchMove", "touchMoveOpposite", "touchStart", "transitionEnd", "transitionStart", "unlock", "update", "zoomChange"],
  setup(props2, {
    slots: originalSlots,
    emit
  }) {
    const {
      tag: Tag2,
      wrapperTag: WrapperTag
    } = props2;
    const containerClasses = ref("swiper");
    const virtualData = ref(null);
    const breakpointChanged = ref(false);
    const initializedRef = ref(false);
    const swiperElRef = ref(null);
    const swiperRef = ref(null);
    const oldPassedParamsRef = ref(null);
    const slidesRef = {
      value: []
    };
    const oldSlidesRef = {
      value: []
    };
    const nextElRef = ref(null);
    const prevElRef = ref(null);
    const paginationElRef = ref(null);
    const scrollbarElRef = ref(null);
    const {
      params: swiperParams,
      passedParams
    } = getParams(props2);
    getChildren(originalSlots, slidesRef, oldSlidesRef);
    oldPassedParamsRef.value = passedParams;
    oldSlidesRef.value = slidesRef.value;
    const onBeforeBreakpoint = () => {
      getChildren(originalSlots, slidesRef, oldSlidesRef);
      breakpointChanged.value = true;
    };
    swiperParams.onAny = (event, ...args) => {
      emit(event, ...args);
    };
    Object.assign(swiperParams.on, {
      _beforeBreakpoint: onBeforeBreakpoint,
      _containerClasses(swiper, classes2) {
        containerClasses.value = classes2;
      }
    });
    swiperRef.value = initSwiper(swiperParams);
    swiperRef.value.loopCreate = () => {
    };
    swiperRef.value.loopDestroy = () => {
    };
    if (swiperParams.loop) {
      swiperRef.value.loopedSlides = calcLoopedSlides(slidesRef.value, swiperParams);
    }
    if (swiperRef.value.virtual && swiperRef.value.params.virtual.enabled) {
      swiperRef.value.virtual.slides = slidesRef.value;
      const extendWith = {
        cache: false,
        slides: slidesRef.value,
        renderExternal: (data) => {
          virtualData.value = data;
        },
        renderExternalUpdate: false
      };
      extend(swiperRef.value.params.virtual, extendWith);
      extend(swiperRef.value.originalParams.virtual, extendWith);
    }
    onUpdated(() => {
      if (!initializedRef.value && swiperRef.value) {
        swiperRef.value.emitSlidesClasses();
        initializedRef.value = true;
      }
      const {
        passedParams: newPassedParams
      } = getParams(props2);
      const changedParams = getChangedParams(newPassedParams, oldPassedParamsRef.value, slidesRef.value, oldSlidesRef.value);
      oldPassedParamsRef.value = newPassedParams;
      if ((changedParams.length || breakpointChanged.value) && swiperRef.value && !swiperRef.value.destroyed) {
        updateSwiper({
          swiper: swiperRef.value,
          slides: slidesRef.value,
          passedParams: newPassedParams,
          changedParams,
          nextEl: nextElRef.value,
          prevEl: prevElRef.value,
          scrollbarEl: scrollbarElRef.value,
          paginationEl: paginationElRef.value
        });
      }
      breakpointChanged.value = false;
    });
    watch$1(virtualData, () => {
      nextTick$1(() => {
        updateOnVirtualData(swiperRef.value);
      });
    });
    onMounted(() => {
      if (!swiperElRef.value)
        return;
      mountSwiper({
        el: swiperElRef.value,
        nextEl: nextElRef.value,
        prevEl: prevElRef.value,
        paginationEl: paginationElRef.value,
        scrollbarEl: scrollbarElRef.value,
        swiper: swiperRef.value
      }, swiperParams);
      emit("swiper", swiperRef.value);
    });
    onBeforeUnmount(() => {
      if (swiperRef.value && !swiperRef.value.destroyed) {
        swiperRef.value.destroy(true, false);
      }
    });
    function renderSlides(slides) {
      if (swiperParams.virtual) {
        return renderVirtual(swiperRef, slides, virtualData.value);
      }
      if (!swiperParams.loop || swiperRef.value && swiperRef.value.destroyed) {
        slides.forEach((slide2) => {
          if (!slide2.props)
            slide2.props = {};
          slide2.props.swiperRef = swiperRef;
        });
        return slides;
      }
      return renderLoop(swiperRef, slides, swiperParams);
    }
    return () => {
      const {
        slides,
        slots
      } = getChildren(originalSlots, slidesRef, oldSlidesRef);
      return h$1(Tag2, {
        ref: swiperElRef,
        class: uniqueClasses(containerClasses.value)
      }, [slots["container-start"], needsNavigation(props2) && [h$1("div", {
        ref: prevElRef,
        class: "swiper-button-prev"
      }), h$1("div", {
        ref: nextElRef,
        class: "swiper-button-next"
      })], needsScrollbar(props2) && h$1("div", {
        ref: scrollbarElRef,
        class: "swiper-scrollbar"
      }), needsPagination(props2) && h$1("div", {
        ref: paginationElRef,
        class: "swiper-pagination"
      }), h$1(WrapperTag, {
        class: "swiper-wrapper"
      }, [slots["wrapper-start"], renderSlides(slides), slots["wrapper-end"]]), slots["container-end"]]);
    };
  }
};
const SwiperSlide = {
  name: "SwiperSlide",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    swiperRef: {
      type: Object,
      required: false
    },
    zoom: {
      type: Boolean,
      default: void 0
    },
    virtualIndex: {
      type: [String, Number],
      default: void 0
    }
  },
  setup(props2, {
    slots
  }) {
    let eventAttached = false;
    const {
      swiperRef
    } = props2;
    const slideElRef = ref(null);
    const slideClasses = ref("swiper-slide");
    function updateClasses(swiper, el, classNames) {
      if (el === slideElRef.value) {
        slideClasses.value = classNames;
      }
    }
    onMounted(() => {
      if (!swiperRef.value)
        return;
      swiperRef.value.on("_slideClass", updateClasses);
      eventAttached = true;
    });
    onBeforeUpdate(() => {
      if (eventAttached || !swiperRef || !swiperRef.value)
        return;
      swiperRef.value.on("_slideClass", updateClasses);
      eventAttached = true;
    });
    onUpdated(() => {
      if (!slideElRef.value || !swiperRef || !swiperRef.value)
        return;
      if (swiperRef.value.destroyed) {
        if (slideClasses.value !== "swiper-slide") {
          slideClasses.value = "swiper-slide";
        }
      }
    });
    onBeforeUnmount(() => {
      if (!swiperRef || !swiperRef.value)
        return;
      swiperRef.value.off("_slideClass", updateClasses);
    });
    const slideData = computed(() => ({
      isActive: slideClasses.value.indexOf("swiper-slide-active") >= 0 || slideClasses.value.indexOf("swiper-slide-duplicate-active") >= 0,
      isVisible: slideClasses.value.indexOf("swiper-slide-visible") >= 0,
      isDuplicate: slideClasses.value.indexOf("swiper-slide-duplicate") >= 0,
      isPrev: slideClasses.value.indexOf("swiper-slide-prev") >= 0 || slideClasses.value.indexOf("swiper-slide-duplicate-prev") >= 0,
      isNext: slideClasses.value.indexOf("swiper-slide-next") >= 0 || slideClasses.value.indexOf("swiper-slide-duplicate-next") >= 0
    }));
    return () => {
      return h$1(props2.tag, {
        class: uniqueClasses(`${slideClasses.value}`),
        ref: slideElRef,
        "data-swiper-slide-index": props2.virtualIndex
      }, props2.zoom ? h$1("div", {
        class: "swiper-zoom-container",
        "data-swiper-zoom": typeof props2.zoom === "number" ? props2.zoom : void 0
      }, slots.default && slots.default(slideData.value)) : slots.default && slots.default(slideData.value));
    };
  }
};
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$c = Object.prototype;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var nativeObjectToString$1 = objectProto$c.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$b = Object.prototype;
var nativeObjectToString = objectProto$b.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray$1 = Array.isArray;
var isArray$2 = isArray$1;
var INFINITY$3 = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$2(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
function identity(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject$2(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key2) {
  return object == null ? void 0 : object[key2];
}
function getNative(object, key2) {
  var value = getValue(object, key2);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap = getNative(root$1, "WeakMap");
var WeakMap$1 = WeakMap;
function noop$1() {
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty$1 = defineProperty;
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value) {
  return value !== value;
}
function strictIndexOf(array, value, fromIndex) {
  var index2 = fromIndex - 1, length2 = array.length;
  while (++index2 < length2) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
function arrayIncludes(array, value) {
  var length2 = array == null ? 0 : array.length;
  return !!length2 && baseIndexOf(array, value, 0) > -1;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function baseAssignValue(object, key2, value) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function assignValue(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty$8.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue(object, key2, value);
  }
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
var objectProto$8 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto2;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$2(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$6.call(value, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length2)))) {
      result.push(key2);
    }
  }
  return result;
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$5.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$2(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$4.call(data, key2) ? data[key2] : void 0;
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$3.call(data, key2);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key2) {
  var length2 = array.length;
  while (length2--) {
    if (eq(array[length2][0], key2)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key2) {
  var data = map2.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data = getMapData(this, key2), size = data.size;
  data.set(key2, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$2(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}
var INFINITY$2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values) {
  var index2 = -1, length2 = values.length, offset2 = array.length;
  while (++index2 < length2) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray$2(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length2) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayFilter(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2()) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key2) {
  return cache.has(key2);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key2) {
    result[++index2] = [key2, value];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$2.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$2(object), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data = matchData[index2];
    var key2 = data[0], objValue = object[key2], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key2 in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key2, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject$2(value);
}
function getMatchData(object) {
  var result = keys(object), length2 = result.length;
  while (length2--) {
    var key2 = result[length2], value = object[key2];
    result[length2] = [key2, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key2, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
function baseHasIn(object, key2) {
  return object != null && key2 in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key2 = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key2))) {
      break;
    }
    object = object[key2];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray$2(object) || isArguments$1(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key2) {
  return function(object) {
    return object == null ? void 0 : object[key2];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var now = function() {
  return root$1.Date.now();
};
var now$1 = now;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$2(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now$1();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time2 = now$1(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function arrayIncludesWith(array, value, comparator) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (comparator(value, array[index2])) {
      return true;
    }
  }
  return false;
}
var INFINITY$1 = 1 / 0;
function flattenDeep(array) {
  var length2 = array == null ? 0 : array.length;
  return length2 ? baseFlatten(array, INFINITY$1) : [];
}
function fromPairs(pairs) {
  var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length2) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function isNil(value) {
  return value == null;
}
function baseSet(object, path, value, customizer) {
  if (!isObject$2(object)) {
    return object;
  }
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
  while (nested != null && ++index2 < length2) {
    var key2 = toKey(path[index2]), newValue = value;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object;
}
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}
var INFINITY = 1 / 0;
var createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY) ? noop$1 : function(values) {
  return new Set$2(values);
};
var createSet$1 = createSet;
var LARGE_ARRAY_SIZE = 200;
function baseUniq(array, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length2 = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length2 >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet$1(array);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length2) {
      var value = array[index2], computed2 = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed2) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed2);
        }
        result.push(value);
      } else if (!includes(seen, computed2, comparator)) {
        if (seen !== result) {
          seen.push(computed2);
        }
        result.push(value);
      }
    }
  return result;
}
function uniqBy(array, iteratee) {
  return array && array.length ? baseUniq(array, baseIteratee(iteratee)) : [];
}
var Card_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$59 = /* @__PURE__ */ createElementVNode("span", { class: "top-left" }, null, -1);
const _hoisted_2$4T = /* @__PURE__ */ createElementVNode("span", { class: "top-right" }, null, -1);
const _hoisted_3$4G = /* @__PURE__ */ createElementVNode("span", { class: "bottom-left" }, null, -1);
const _hoisted_4$1t = /* @__PURE__ */ createElementVNode("span", { class: "bottom-right" }, null, -1);
const _hoisted_5$v = { class: "dpi_card_header" };
const _hoisted_6$a = { class: "dpi_card_title" };
const _hoisted_7$6 = /* @__PURE__ */ createElementVNode("span", { class: "dpi_card_ion1" }, null, -1);
const _hoisted_8$5 = { class: "dpi_card_body" };
const _hoisted_9$5 = /* @__PURE__ */ createElementVNode("div", { class: "dpi_card_empty" }, "\u6682\u65E0\u6570\u636E", -1);
const _sfc_main$5y = {
  props: {
    title: {
      type: String,
      default: () => ""
    },
    width: {
      type: Number,
      default: () => null
    },
    height: {
      type: Number,
      default: () => null
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "dpi_card",
        style: normalizeStyle$1({ width: `${__props.width}px`, height: `${__props.height}px` })
      }, [
        _hoisted_1$59,
        _hoisted_2$4T,
        _hoisted_3$4G,
        _hoisted_4$1t,
        createElementVNode("header", _hoisted_5$v, [
          createElementVNode("span", _hoisted_6$a, [
            _hoisted_7$6,
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(__props.title), 1)
            ])
          ])
        ]),
        createElementVNode("article", _hoisted_8$5, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            _hoisted_9$5
          ])
        ])
      ], 4);
    };
  }
};
var swiper_min = "";
var index_vue_vue_type_style_index_0_lang = "";
var index_vue_vue_type_style_index_1_lang$2 = "";
const _hoisted_1$58 = { class: "warning_type_header" };
const _hoisted_2$4S = { class: "no_alarm_data" };
const _hoisted_3$4F = /* @__PURE__ */ createElementVNode("span", null, "\u6682\u65E0\u9884\u8B66", -1);
const _hoisted_4$1s = [
  _hoisted_3$4F
];
const _hoisted_5$u = /* @__PURE__ */ createElementVNode("span", null, [
  /* @__PURE__ */ createElementVNode("i", { class: "circle" })
], -1);
const _hoisted_6$9 = ["innerHTML"];
const _sfc_main$5x = {
  props: {
    infos: {
      type: Array,
      default: () => []
    },
    uniqKey: {
      type: String,
      default: () => "id"
    }
  },
  setup(__props) {
    const props2 = __props;
    const modules = [Autoplay];
    const infoListRef = ref([]);
    watch$1(props2.infos, (data) => {
      debugger;
      infoListRef.value.push(...data);
      infoListRef.value = uniqBy(infoListRef.value, uniqKey);
    });
    const handleSlideChangeTransitionEnd = () => {
      if (infoListRef.value.length > 10) {
        infoListRef.value.pop();
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$5y, { title: "\u9884\u8B66\u6D88\u606F" }, {
        default: withCtx(() => [
          createElementVNode("div", _hoisted_1$58, [
            withDirectives(createElementVNode("div", _hoisted_2$4S, _hoisted_4$1s, 512), [
              [vShow, !__props.infos.length]
            ]),
            withDirectives(createVNode$1(unref(Swiper), {
              modules,
              direction: "vertical",
              "slides-per-view": __props.infos.length > 1 ? 2 : 1,
              "space-between": 20,
              observer: true,
              "observe-parents": false,
              loop: true,
              autoplay: {
                delay: 6e4,
                disableOnInteraction: true
              },
              onSlideChangeTransitionEnd: handleSlideChangeTransitionEnd
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.infos, (info, index2) => {
                  return openBlock(), createBlock(unref(SwiperSlide), {
                    key: index2,
                    class: "swiper_item"
                  }, {
                    default: withCtx(() => [
                      _hoisted_5$u,
                      createElementVNode("span", {
                        innerHTML: info.content
                      }, null, 8, _hoisted_6$9)
                    ]),
                    _: 2
                  }, 1024);
                }), 128))
              ]),
              _: 1
            }, 8, ["slides-per-view"]), [
              [vShow, __props.infos.length]
            ])
          ])
        ]),
        _: 1
      });
    };
  }
};
const AlarmInfoPlugin = {
  install(app) {
    app.component("d-alarm-info", _sfc_main$5x);
  }
};
const isLeaf = (el) => !el.getAttribute("aria-owns");
const getSibling = (el, distance2, elClass) => {
  const { parentNode: parentNode2 } = el;
  if (!parentNode2)
    return null;
  const siblings = parentNode2.querySelectorAll(elClass);
  const index2 = Array.prototype.indexOf.call(siblings, el);
  return siblings[index2 + distance2] || null;
};
const focusNode = (el) => {
  if (!el)
    return;
  el.focus();
  !isLeaf(el) && el.click();
};
const on = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.addEventListener(event, handler, useCapture);
  }
};
const off = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.removeEventListener(event, handler, useCapture);
  }
};
const once = (el, event, fn2) => {
  const listener = function(...args) {
    if (fn2) {
      fn2.apply(this, args);
    }
    off(el, event, listener);
  };
  on(el, event, listener);
};
const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
  const handleEvent = (event) => {
    const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
    if (checkForDefaultPrevented === false || !shouldPrevent) {
      return oursHandler == null ? void 0 : oursHandler(event);
    }
  };
  return handleEvent;
};
function tryOnScopeDispose(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
const isClient = typeof window !== "undefined";
const isBoolean = (val) => typeof val === "boolean";
const isNumber = (val) => typeof val === "number";
const isString$1 = (val) => typeof val === "string";
const noop = () => {
};
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer2 = null;
  function clear2() {
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear2();
  }
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer2 = setTimeout(() => {
      isPending.value = false;
      timer2 = null;
      cb(...args);
    }, unref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending,
    start: start2,
    stop: stop2
  };
}
function unrefElement(elRef) {
  var _a2;
  const plain = unref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString$1(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch$1(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore, capture = true } = options;
  if (!window2)
    return;
  const shouldListen = ref(true);
  const listener = (event) => {
    const el = unrefElement(target);
    const composedPath = event.composedPath();
    if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value)
      return;
    if (ignore && ignore.length > 0) {
      if (ignore.some((target2) => {
        const el2 = unrefElement(target2);
        return el2 && (event.target === el2 || composedPath.includes(el2));
      }))
        return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e2) => {
      const el = unrefElement(target);
      shouldListen.value = !!el && !e2.composedPath().includes(el);
    }, { passive: true })
  ];
  const stop2 = () => cleanup.forEach((fn2) => fn2());
  return stop2;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
_global[globalKey];
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$c.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$c.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = window2 && "ResizeObserver" in window2;
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch$1(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop2);
  return {
    isSupported,
    stop: stop2
  };
}
var _a, _b;
isClient && (window == null ? void 0 : window.navigator) && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.platform) && /iP(ad|hone|od)/.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.platform);
const resizeHandler = function(entries) {
  for (const entry of entries) {
    const listeners = entry.target.__resizeListeners__ || [];
    if (listeners.length) {
      listeners.forEach((fn2) => {
        fn2();
      });
    }
  }
};
const addResizeListener = function(element, fn2) {
  if (!isClient || !element)
    return;
  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new ResizeObserver(resizeHandler);
    element.__ro__.observe(element);
  }
  element.__resizeListeners__.push(fn2);
};
const removeResizeListener = function(element, fn2) {
  var _a2;
  if (!element || !element.__resizeListeners__)
    return;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn2), 1);
  if (!element.__resizeListeners__.length) {
    (_a2 = element.__ro__) == null ? void 0 : _a2.disconnect();
  }
};
const NOOP = () => {
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key2) => hasOwnProperty.call(val, key2);
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c) => c ? c.toUpperCase() : "");
});
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const isUndefined = (val) => val === void 0;
const isEmpty = (val) => !val && val !== 0 || isArray(val) && val.length === 0 || isObject$1(val) && !Object.keys(val).length;
const isElement$1 = (e2) => {
  if (typeof Element === "undefined")
    return false;
  return e2 instanceof Element;
};
const escapeStringRegexp = (string = "") => string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
const entriesOf = (arr) => Object.entries(arr);
const getProp = (obj, path, defaultValue) => {
  return {
    get value() {
      return get(obj, path, defaultValue);
    },
    set value(val) {
      set(obj, path, val);
    }
  };
};
const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
const hasClass = (el, cls) => {
  if (!el || !cls)
    return false;
  if (cls.includes(" "))
    throw new Error("className should not contain space.");
  return el.classList.contains(cls);
};
const addClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.add(...classNameToArray(cls));
};
const removeClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.remove(...classNameToArray(cls));
};
const getStyle = (element, styleName) => {
  var _a2;
  if (!isClient || !element || !styleName)
    return "";
  camelize(styleName);
  try {
    const style = element.style[styleName];
    if (style)
      return style;
    const computed2 = (_a2 = document.defaultView) == null ? void 0 : _a2.getComputedStyle(element, "");
    return computed2 ? computed2[styleName] : "";
  } catch (e2) {
    return element.style[styleName];
  }
};
let scrollBarWidth;
const getScrollBarWidth = () => {
  var _a2;
  if (!isClient)
    return 0;
  if (scrollBarWidth !== void 0)
    return scrollBarWidth;
  const outer = document.createElement("div");
  outer.className = "el-scrollbar__wrap";
  outer.style.visibility = "hidden";
  outer.style.width = "100px";
  outer.style.position = "absolute";
  outer.style.top = "-9999px";
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = "scroll";
  const inner2 = document.createElement("div");
  inner2.style.width = "100%";
  outer.appendChild(inner2);
  const widthWithScroll = inner2.offsetWidth;
  (_a2 = outer.parentNode) == null ? void 0 : _a2.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
};
function scrollIntoView(container, selected) {
  if (!isClient)
    return;
  if (!selected) {
    container.scrollTop = 0;
    return;
  }
  const offsetParents = [];
  let pointer2 = selected.offsetParent;
  while (pointer2 !== null && container !== pointer2 && container.contains(pointer2)) {
    offsetParents.push(pointer2);
    pointer2 = pointer2.offsetParent;
  }
  const top2 = selected.offsetTop + offsetParents.reduce((prev2, curr) => prev2 + curr.offsetTop, 0);
  const bottom2 = top2 + selected.offsetHeight;
  const viewRectTop = container.scrollTop;
  const viewRectBottom = viewRectTop + container.clientHeight;
  if (top2 < viewRectTop) {
    container.scrollTop = top2;
  } else if (bottom2 > viewRectBottom) {
    container.scrollTop = bottom2 - container.clientHeight;
  }
}
var _export_sfc$1 = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props2) {
    target[key2] = val;
  }
  return target;
};
const _sfc_main$5w = defineComponent({
  name: "AddLocation"
});
const _hoisted_1$57 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$4E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_4$1r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 384h96a32 32 0 1 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96v-96a32 32 0 0 1 64 0v96z"
}, null, -1);
const _hoisted_5$t = [
  _hoisted_2$4R,
  _hoisted_3$4E,
  _hoisted_4$1r
];
function _sfc_render$52(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$57, _hoisted_5$t);
}
var addLocation = /* @__PURE__ */ _export_sfc$1(_sfc_main$5w, [["render", _sfc_render$52]]);
const _sfc_main$5v = defineComponent({
  name: "Aim"
});
const _hoisted_1$56 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4Q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_3$4D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 96a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V128a32 32 0 0 1 32-32zm0 576a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V704a32 32 0 0 1 32-32zM96 512a32 32 0 0 1 32-32h192a32 32 0 0 1 0 64H128a32 32 0 0 1-32-32zm576 0a32 32 0 0 1 32-32h192a32 32 0 1 1 0 64H704a32 32 0 0 1-32-32z"
}, null, -1);
const _hoisted_4$1q = [
  _hoisted_2$4Q,
  _hoisted_3$4D
];
function _sfc_render$51(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$56, _hoisted_4$1q);
}
var aim = /* @__PURE__ */ _export_sfc$1(_sfc_main$5v, [["render", _sfc_render$51]]);
const _sfc_main$5u = defineComponent({
  name: "AlarmClock"
});
const _hoisted_1$55 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4P = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 832a320 320 0 1 0 0-640 320 320 0 0 0 0 640zm0 64a384 384 0 1 1 0-768 384 384 0 0 1 0 768z"
}, null, -1);
const _hoisted_3$4C = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m292.288 824.576 55.424 32-48 83.136a32 32 0 1 1-55.424-32l48-83.136zm439.424 0-55.424 32 48 83.136a32 32 0 1 0 55.424-32l-48-83.136zM512 512h160a32 32 0 1 1 0 64H480a32 32 0 0 1-32-32V320a32 32 0 0 1 64 0v192zM90.496 312.256A160 160 0 0 1 312.32 90.496l-46.848 46.848a96 96 0 0 0-128 128L90.56 312.256zm835.264 0A160 160 0 0 0 704 90.496l46.848 46.848a96 96 0 0 1 128 128l46.912 46.912z"
}, null, -1);
const _hoisted_4$1p = [
  _hoisted_2$4P,
  _hoisted_3$4C
];
function _sfc_render$50(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$55, _hoisted_4$1p);
}
var alarmClock = /* @__PURE__ */ _export_sfc$1(_sfc_main$5u, [["render", _sfc_render$50]]);
const _sfc_main$5t = defineComponent({
  name: "Apple"
});
const _hoisted_1$54 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4O = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M599.872 203.776a189.44 189.44 0 0 1 64.384-4.672l2.624.128c31.168 1.024 51.2 4.096 79.488 16.32 37.632 16.128 74.496 45.056 111.488 89.344 96.384 115.264 82.752 372.8-34.752 521.728-7.68 9.728-32 41.6-30.72 39.936a426.624 426.624 0 0 1-30.08 35.776c-31.232 32.576-65.28 49.216-110.08 50.048-31.36.64-53.568-5.312-84.288-18.752l-6.528-2.88c-20.992-9.216-30.592-11.904-47.296-11.904-18.112 0-28.608 2.88-51.136 12.672l-6.464 2.816c-28.416 12.224-48.32 18.048-76.16 19.2-74.112 2.752-116.928-38.08-180.672-132.16-96.64-142.08-132.608-349.312-55.04-486.4 46.272-81.92 129.92-133.632 220.672-135.04 32.832-.576 60.288 6.848 99.648 22.72 27.136 10.88 34.752 13.76 37.376 14.272 16.256-20.16 27.776-36.992 34.56-50.24 13.568-26.304 27.2-59.968 40.704-100.8a32 32 0 1 1 60.8 20.224c-12.608 37.888-25.408 70.4-38.528 97.664zm-51.52 78.08c-14.528 17.792-31.808 37.376-51.904 58.816a32 32 0 1 1-46.72-43.776l12.288-13.248c-28.032-11.2-61.248-26.688-95.68-26.112-70.4 1.088-135.296 41.6-171.648 105.792C121.6 492.608 176 684.16 247.296 788.992c34.816 51.328 76.352 108.992 130.944 106.944 52.48-2.112 72.32-34.688 135.872-34.688 63.552 0 81.28 34.688 136.96 33.536 56.448-1.088 75.776-39.04 126.848-103.872 107.904-136.768 107.904-362.752 35.776-449.088-72.192-86.272-124.672-84.096-151.68-85.12-41.472-4.288-81.6 12.544-113.664 25.152z"
}, null, -1);
const _hoisted_3$4B = [
  _hoisted_2$4O
];
function _sfc_render$4$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$54, _hoisted_3$4B);
}
var apple = /* @__PURE__ */ _export_sfc$1(_sfc_main$5t, [["render", _sfc_render$4$]]);
const _sfc_main$5s = defineComponent({
  name: "ArrowDownBold"
});
const _hoisted_1$53 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4N = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M104.704 338.752a64 64 0 0 1 90.496 0l316.8 316.8 316.8-316.8a64 64 0 0 1 90.496 90.496L557.248 791.296a64 64 0 0 1-90.496 0L104.704 429.248a64 64 0 0 1 0-90.496z"
}, null, -1);
const _hoisted_3$4A = [
  _hoisted_2$4N
];
function _sfc_render$4_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$53, _hoisted_3$4A);
}
var arrowDownBold = /* @__PURE__ */ _export_sfc$1(_sfc_main$5s, [["render", _sfc_render$4_]]);
const _sfc_main$5r = defineComponent({
  name: "ArrowDown"
});
const _hoisted_1$52 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4M = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
}, null, -1);
const _hoisted_3$4z = [
  _hoisted_2$4M
];
function _sfc_render$4Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$52, _hoisted_3$4z);
}
var arrowDown = /* @__PURE__ */ _export_sfc$1(_sfc_main$5r, [["render", _sfc_render$4Z]]);
const _sfc_main$5q = defineComponent({
  name: "ArrowLeftBold"
});
const _hoisted_1$51 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M685.248 104.704a64 64 0 0 1 0 90.496L368.448 512l316.8 316.8a64 64 0 0 1-90.496 90.496L232.704 557.248a64 64 0 0 1 0-90.496l362.048-362.048a64 64 0 0 1 90.496 0z"
}, null, -1);
const _hoisted_3$4y = [
  _hoisted_2$4L
];
function _sfc_render$4Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$51, _hoisted_3$4y);
}
var arrowLeftBold = /* @__PURE__ */ _export_sfc$1(_sfc_main$5q, [["render", _sfc_render$4Y]]);
const _sfc_main$5p = defineComponent({
  name: "ArrowLeft"
});
const _hoisted_1$50 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4K = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
}, null, -1);
const _hoisted_3$4x = [
  _hoisted_2$4K
];
function _sfc_render$4X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$50, _hoisted_3$4x);
}
var arrowLeft = /* @__PURE__ */ _export_sfc$1(_sfc_main$5p, [["render", _sfc_render$4X]]);
const _sfc_main$5o = defineComponent({
  name: "ArrowRightBold"
});
const _hoisted_1$4$ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4J = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M338.752 104.704a64 64 0 0 0 0 90.496l316.8 316.8-316.8 316.8a64 64 0 0 0 90.496 90.496l362.048-362.048a64 64 0 0 0 0-90.496L429.248 104.704a64 64 0 0 0-90.496 0z"
}, null, -1);
const _hoisted_3$4w = [
  _hoisted_2$4J
];
function _sfc_render$4W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4$, _hoisted_3$4w);
}
var arrowRightBold = /* @__PURE__ */ _export_sfc$1(_sfc_main$5o, [["render", _sfc_render$4W]]);
const _sfc_main$5n = defineComponent({
  name: "ArrowRight"
});
const _hoisted_1$4_ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
}, null, -1);
const _hoisted_3$4v = [
  _hoisted_2$4I
];
function _sfc_render$4V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4_, _hoisted_3$4v);
}
var arrowRight = /* @__PURE__ */ _export_sfc$1(_sfc_main$5n, [["render", _sfc_render$4V]]);
const _sfc_main$5m = defineComponent({
  name: "ArrowUpBold"
});
const _hoisted_1$4Z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4H = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M104.704 685.248a64 64 0 0 0 90.496 0l316.8-316.8 316.8 316.8a64 64 0 0 0 90.496-90.496L557.248 232.704a64 64 0 0 0-90.496 0L104.704 594.752a64 64 0 0 0 0 90.496z"
}, null, -1);
const _hoisted_3$4u = [
  _hoisted_2$4H
];
function _sfc_render$4U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4Z, _hoisted_3$4u);
}
var arrowUpBold = /* @__PURE__ */ _export_sfc$1(_sfc_main$5m, [["render", _sfc_render$4U]]);
const _sfc_main$5l = defineComponent({
  name: "ArrowUp"
});
const _hoisted_1$4Y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4G = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
}, null, -1);
const _hoisted_3$4t = [
  _hoisted_2$4G
];
function _sfc_render$4T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4Y, _hoisted_3$4t);
}
var arrowUp = /* @__PURE__ */ _export_sfc$1(_sfc_main$5l, [["render", _sfc_render$4T]]);
const _sfc_main$5k = defineComponent({
  name: "Avatar"
});
const _hoisted_1$4X = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M628.736 528.896A416 416 0 0 1 928 928H96a415.872 415.872 0 0 1 299.264-399.104L512 704l116.736-175.104zM720 304a208 208 0 1 1-416 0 208 208 0 0 1 416 0z"
}, null, -1);
const _hoisted_3$4s = [
  _hoisted_2$4F
];
function _sfc_render$4S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4X, _hoisted_3$4s);
}
var avatar = /* @__PURE__ */ _export_sfc$1(_sfc_main$5k, [["render", _sfc_render$4S]]);
const _sfc_main$5j = defineComponent({
  name: "Back"
});
const _hoisted_1$4W = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64z"
}, null, -1);
const _hoisted_3$4r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312L237.248 512z"
}, null, -1);
const _hoisted_4$1o = [
  _hoisted_2$4E,
  _hoisted_3$4r
];
function _sfc_render$4R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4W, _hoisted_4$1o);
}
var back = /* @__PURE__ */ _export_sfc$1(_sfc_main$5j, [["render", _sfc_render$4R]]);
const _sfc_main$5i = defineComponent({
  name: "Baseball"
});
const _hoisted_1$4V = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M195.2 828.8a448 448 0 1 1 633.6-633.6 448 448 0 0 1-633.6 633.6zm45.248-45.248a384 384 0 1 0 543.104-543.104 384 384 0 0 0-543.104 543.104z"
}, null, -1);
const _hoisted_3$4q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M497.472 96.896c22.784 4.672 44.416 9.472 64.896 14.528a256.128 256.128 0 0 0 350.208 350.208c5.056 20.48 9.856 42.112 14.528 64.896A320.128 320.128 0 0 1 497.472 96.896zM108.48 491.904a320.128 320.128 0 0 1 423.616 423.68c-23.04-3.648-44.992-7.424-65.728-11.52a256.128 256.128 0 0 0-346.496-346.432 1736.64 1736.64 0 0 1-11.392-65.728z"
}, null, -1);
const _hoisted_4$1n = [
  _hoisted_2$4D,
  _hoisted_3$4q
];
function _sfc_render$4Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4V, _hoisted_4$1n);
}
var baseball = /* @__PURE__ */ _export_sfc$1(_sfc_main$5i, [["render", _sfc_render$4Q]]);
const _sfc_main$5h = defineComponent({
  name: "Basketball"
});
const _hoisted_1$4U = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4C = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M778.752 788.224a382.464 382.464 0 0 0 116.032-245.632 256.512 256.512 0 0 0-241.728-13.952 762.88 762.88 0 0 1 125.696 259.584zm-55.04 44.224a699.648 699.648 0 0 0-125.056-269.632 256.128 256.128 0 0 0-56.064 331.968 382.72 382.72 0 0 0 181.12-62.336zm-254.08 61.248A320.128 320.128 0 0 1 557.76 513.6a715.84 715.84 0 0 0-48.192-48.128 320.128 320.128 0 0 1-379.264 88.384 382.4 382.4 0 0 0 110.144 229.696 382.4 382.4 0 0 0 229.184 110.08zM129.28 481.088a256.128 256.128 0 0 0 331.072-56.448 699.648 699.648 0 0 0-268.8-124.352 382.656 382.656 0 0 0-62.272 180.8zm106.56-235.84a762.88 762.88 0 0 1 258.688 125.056 256.512 256.512 0 0 0-13.44-241.088A382.464 382.464 0 0 0 235.84 245.248zm318.08-114.944c40.576 89.536 37.76 193.92-8.448 281.344a779.84 779.84 0 0 1 66.176 66.112 320.832 320.832 0 0 1 282.112-8.128 382.4 382.4 0 0 0-110.144-229.12 382.4 382.4 0 0 0-229.632-110.208zM828.8 828.8a448 448 0 1 1-633.6-633.6 448 448 0 0 1 633.6 633.6z"
}, null, -1);
const _hoisted_3$4p = [
  _hoisted_2$4C
];
function _sfc_render$4P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4U, _hoisted_3$4p);
}
var basketball = /* @__PURE__ */ _export_sfc$1(_sfc_main$5h, [["render", _sfc_render$4P]]);
const _sfc_main$5g = defineComponent({
  name: "BellFilled"
});
const _hoisted_1$4T = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4B = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 832a128 128 0 0 1-256 0h256zm192-64H134.4a38.4 38.4 0 0 1 0-76.8H192V448c0-154.88 110.08-284.16 256.32-313.6a64 64 0 1 1 127.36 0A320.128 320.128 0 0 1 832 448v243.2h57.6a38.4 38.4 0 0 1 0 76.8H832z"
}, null, -1);
const _hoisted_3$4o = [
  _hoisted_2$4B
];
function _sfc_render$4O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4T, _hoisted_3$4o);
}
var bellFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$5g, [["render", _sfc_render$4O]]);
const _sfc_main$5f = defineComponent({
  name: "Bell"
});
const _hoisted_1$4S = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4A = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a64 64 0 0 1 64 64v64H448v-64a64 64 0 0 1 64-64z"
}, null, -1);
const _hoisted_3$4n = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 768h512V448a256 256 0 1 0-512 0v320zm256-640a320 320 0 0 1 320 320v384H192V448a320 320 0 0 1 320-320z"
}, null, -1);
const _hoisted_4$1m = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M96 768h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm352 128h128a64 64 0 0 1-128 0z"
}, null, -1);
const _hoisted_5$s = [
  _hoisted_2$4A,
  _hoisted_3$4n,
  _hoisted_4$1m
];
function _sfc_render$4N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4S, _hoisted_5$s);
}
var bell = /* @__PURE__ */ _export_sfc$1(_sfc_main$5f, [["render", _sfc_render$4N]]);
const _sfc_main$5e = defineComponent({
  name: "Bicycle"
});
const _hoisted_1$4R = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4z = /* @__PURE__ */ createStaticVNode('<path fill="currentColor" d="M256 832a128 128 0 1 0 0-256 128 128 0 0 0 0 256zm0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384z"></path><path fill="currentColor" d="M288 672h320q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"></path><path fill="currentColor" d="M768 832a128 128 0 1 0 0-256 128 128 0 0 0 0 256zm0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384z"></path><path fill="currentColor" d="M480 192a32 32 0 0 1 0-64h160a32 32 0 0 1 31.04 24.256l96 384a32 32 0 0 1-62.08 15.488L615.04 192H480zM96 384a32 32 0 0 1 0-64h128a32 32 0 0 1 30.336 21.888l64 192a32 32 0 1 1-60.672 20.224L200.96 384H96z"></path><path fill="currentColor" d="m373.376 599.808-42.752-47.616 320-288 42.752 47.616z"></path>', 5);
const _hoisted_7$5 = [
  _hoisted_2$4z
];
function _sfc_render$4M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4R, _hoisted_7$5);
}
var bicycle = /* @__PURE__ */ _export_sfc$1(_sfc_main$5e, [["render", _sfc_render$4M]]);
const _sfc_main$5d = defineComponent({
  name: "BottomLeft"
});
const _hoisted_1$4Q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 768h416a32 32 0 1 1 0 64H224a32 32 0 0 1-32-32V352a32 32 0 0 1 64 0v416z"
}, null, -1);
const _hoisted_3$4m = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M246.656 822.656a32 32 0 0 1-45.312-45.312l544-544a32 32 0 0 1 45.312 45.312l-544 544z"
}, null, -1);
const _hoisted_4$1l = [
  _hoisted_2$4y,
  _hoisted_3$4m
];
function _sfc_render$4L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4Q, _hoisted_4$1l);
}
var bottomLeft = /* @__PURE__ */ _export_sfc$1(_sfc_main$5d, [["render", _sfc_render$4L]]);
const _sfc_main$5c = defineComponent({
  name: "BottomRight"
});
const _hoisted_1$4P = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4x = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 768a32 32 0 1 0 0 64h448a32 32 0 0 0 32-32V352a32 32 0 0 0-64 0v416H352z"
}, null, -1);
const _hoisted_3$4l = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M777.344 822.656a32 32 0 0 0 45.312-45.312l-544-544a32 32 0 0 0-45.312 45.312l544 544z"
}, null, -1);
const _hoisted_4$1k = [
  _hoisted_2$4x,
  _hoisted_3$4l
];
function _sfc_render$4K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4P, _hoisted_4$1k);
}
var bottomRight = /* @__PURE__ */ _export_sfc$1(_sfc_main$5c, [["render", _sfc_render$4K]]);
const _sfc_main$5b = defineComponent({
  name: "Bottom"
});
const _hoisted_1$4O = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4w = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 805.888V168a32 32 0 1 0-64 0v637.888L246.656 557.952a30.72 30.72 0 0 0-45.312 0 35.52 35.52 0 0 0 0 48.064l288 306.048a30.72 30.72 0 0 0 45.312 0l288-306.048a35.52 35.52 0 0 0 0-48 30.72 30.72 0 0 0-45.312 0L544 805.824z"
}, null, -1);
const _hoisted_3$4k = [
  _hoisted_2$4w
];
function _sfc_render$4J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4O, _hoisted_3$4k);
}
var bottom$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$5b, [["render", _sfc_render$4J]]);
const _sfc_main$5a = defineComponent({
  name: "Bowl"
});
const _hoisted_1$4N = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M714.432 704a351.744 351.744 0 0 0 148.16-256H161.408a351.744 351.744 0 0 0 148.16 256h404.864zM288 766.592A415.68 415.68 0 0 1 96 416a32 32 0 0 1 32-32h768a32 32 0 0 1 32 32 415.68 415.68 0 0 1-192 350.592V832a64 64 0 0 1-64 64H352a64 64 0 0 1-64-64v-65.408zM493.248 320h-90.496l254.4-254.4a32 32 0 1 1 45.248 45.248L493.248 320zm187.328 0h-128l269.696-155.712a32 32 0 0 1 32 55.424L680.576 320zM352 768v64h320v-64H352z"
}, null, -1);
const _hoisted_3$4j = [
  _hoisted_2$4v
];
function _sfc_render$4I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4N, _hoisted_3$4j);
}
var bowl = /* @__PURE__ */ _export_sfc$1(_sfc_main$5a, [["render", _sfc_render$4I]]);
const _sfc_main$59 = defineComponent({
  name: "Box"
});
const _hoisted_1$4M = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4u = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M317.056 128 128 344.064V896h768V344.064L706.944 128H317.056zm-14.528-64h418.944a32 32 0 0 1 24.064 10.88l206.528 236.096A32 32 0 0 1 960 332.032V928a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V332.032a32 32 0 0 1 7.936-21.12L278.4 75.008A32 32 0 0 1 302.528 64z"
}, null, -1);
const _hoisted_3$4i = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M64 320h896v64H64z"
}, null, -1);
const _hoisted_4$1j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M448 327.872V640h128V327.872L526.08 128h-28.16L448 327.872zM448 64h128l64 256v352a32 32 0 0 1-32 32H416a32 32 0 0 1-32-32V320l64-256z"
}, null, -1);
const _hoisted_5$r = [
  _hoisted_2$4u,
  _hoisted_3$4i,
  _hoisted_4$1j
];
function _sfc_render$4H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4M, _hoisted_5$r);
}
var box = /* @__PURE__ */ _export_sfc$1(_sfc_main$59, [["render", _sfc_render$4H]]);
const _sfc_main$58 = defineComponent({
  name: "Briefcase"
});
const _hoisted_1$4L = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4t = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M320 320V128h384v192h192v192H128V320h192zM128 576h768v320H128V576zm256-256h256.064V192H384v128z"
}, null, -1);
const _hoisted_3$4h = [
  _hoisted_2$4t
];
function _sfc_render$4G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4L, _hoisted_3$4h);
}
var briefcase = /* @__PURE__ */ _export_sfc$1(_sfc_main$58, [["render", _sfc_render$4G]]);
const _sfc_main$57 = defineComponent({
  name: "BrushFilled"
});
const _hoisted_1$4K = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4s = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M608 704v160a96 96 0 0 1-192 0V704h-96a128 128 0 0 1-128-128h640a128 128 0 0 1-128 128h-96zM192 512V128.064h640V512H192z"
}, null, -1);
const _hoisted_3$4g = [
  _hoisted_2$4s
];
function _sfc_render$4F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4K, _hoisted_3$4g);
}
var brushFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$57, [["render", _sfc_render$4F]]);
const _sfc_main$56 = defineComponent({
  name: "Brush"
});
const _hoisted_1$4J = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M896 448H128v192a64 64 0 0 0 64 64h192v192h256V704h192a64 64 0 0 0 64-64V448zm-770.752-64c0-47.552 5.248-90.24 15.552-128 14.72-54.016 42.496-107.392 83.2-160h417.28l-15.36 70.336L736 96h211.2c-24.832 42.88-41.92 96.256-51.2 160a663.872 663.872 0 0 0-6.144 128H960v256a128 128 0 0 1-128 128H704v160a32 32 0 0 1-32 32H352a32 32 0 0 1-32-32V768H192A128 128 0 0 1 64 640V384h61.248zm64 0h636.544c-2.048-45.824.256-91.584 6.848-137.216 4.48-30.848 10.688-59.776 18.688-86.784h-96.64l-221.12 141.248L561.92 160H256.512c-25.856 37.888-43.776 75.456-53.952 112.832-8.768 32.064-13.248 69.12-13.312 111.168z"
}, null, -1);
const _hoisted_3$4f = [
  _hoisted_2$4r
];
function _sfc_render$4E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4J, _hoisted_3$4f);
}
var brush = /* @__PURE__ */ _export_sfc$1(_sfc_main$56, [["render", _sfc_render$4E]]);
const _sfc_main$55 = defineComponent({
  name: "Burger"
});
const _hoisted_1$4I = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 512a32 32 0 0 0-32 32v64a32 32 0 0 0 30.08 32H864a32 32 0 0 0 32-32v-64a32 32 0 0 0-32-32H160zm736-58.56A96 96 0 0 1 960 544v64a96 96 0 0 1-51.968 85.312L855.36 833.6a96 96 0 0 1-89.856 62.272H258.496A96 96 0 0 1 168.64 833.6l-52.608-140.224A96 96 0 0 1 64 608v-64a96 96 0 0 1 64-90.56V448a384 384 0 1 1 768 5.44zM832 448a320 320 0 0 0-640 0h640zM512 704H188.352l40.192 107.136a32 32 0 0 0 29.952 20.736h507.008a32 32 0 0 0 29.952-20.736L835.648 704H512z"
}, null, -1);
const _hoisted_3$4e = [
  _hoisted_2$4q
];
function _sfc_render$4D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4I, _hoisted_3$4e);
}
var burger = /* @__PURE__ */ _export_sfc$1(_sfc_main$55, [["render", _sfc_render$4D]]);
const _sfc_main$54 = defineComponent({
  name: "Calendar"
});
const _hoisted_1$4H = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"
}, null, -1);
const _hoisted_3$4d = [
  _hoisted_2$4p
];
function _sfc_render$4C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4H, _hoisted_3$4d);
}
var calendar = /* @__PURE__ */ _export_sfc$1(_sfc_main$54, [["render", _sfc_render$4C]]);
const _sfc_main$53 = defineComponent({
  name: "CameraFilled"
});
const _hoisted_1$4G = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4o = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 224a64 64 0 0 0-64 64v512a64 64 0 0 0 64 64h704a64 64 0 0 0 64-64V288a64 64 0 0 0-64-64H748.416l-46.464-92.672A64 64 0 0 0 644.736 96H379.328a64 64 0 0 0-57.216 35.392L275.776 224H160zm352 435.2a115.2 115.2 0 1 0 0-230.4 115.2 115.2 0 0 0 0 230.4zm0 140.8a256 256 0 1 1 0-512 256 256 0 0 1 0 512z"
}, null, -1);
const _hoisted_3$4c = [
  _hoisted_2$4o
];
function _sfc_render$4B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4G, _hoisted_3$4c);
}
var cameraFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$53, [["render", _sfc_render$4B]]);
const _sfc_main$52 = defineComponent({
  name: "Camera"
});
const _hoisted_1$4F = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4n = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M896 256H128v576h768V256zm-199.424-64-32.064-64h-304.96l-32 64h369.024zM96 192h160l46.336-92.608A64 64 0 0 1 359.552 64h304.96a64 64 0 0 1 57.216 35.328L768.192 192H928a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32zm416 512a160 160 0 1 0 0-320 160 160 0 0 0 0 320zm0 64a224 224 0 1 1 0-448 224 224 0 0 1 0 448z"
}, null, -1);
const _hoisted_3$4b = [
  _hoisted_2$4n
];
function _sfc_render$4A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4F, _hoisted_3$4b);
}
var camera = /* @__PURE__ */ _export_sfc$1(_sfc_main$52, [["render", _sfc_render$4A]]);
const _sfc_main$51 = defineComponent({
  name: "CaretBottom"
});
const _hoisted_1$4E = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4m = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m192 384 320 384 320-384z"
}, null, -1);
const _hoisted_3$4a = [
  _hoisted_2$4m
];
function _sfc_render$4z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4E, _hoisted_3$4a);
}
var caretBottom = /* @__PURE__ */ _export_sfc$1(_sfc_main$51, [["render", _sfc_render$4z]]);
const _sfc_main$50 = defineComponent({
  name: "CaretLeft"
});
const _hoisted_1$4D = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4l = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M672 192 288 511.936 672 832z"
}, null, -1);
const _hoisted_3$49 = [
  _hoisted_2$4l
];
function _sfc_render$4y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4D, _hoisted_3$49);
}
var caretLeft = /* @__PURE__ */ _export_sfc$1(_sfc_main$50, [["render", _sfc_render$4y]]);
const _sfc_main$4$ = defineComponent({
  name: "CaretRight"
});
const _hoisted_1$4C = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4k = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 192v640l384-320.064z"
}, null, -1);
const _hoisted_3$48 = [
  _hoisted_2$4k
];
function _sfc_render$4x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4C, _hoisted_3$48);
}
var caretRight = /* @__PURE__ */ _export_sfc$1(_sfc_main$4$, [["render", _sfc_render$4x]]);
const _sfc_main$4_ = defineComponent({
  name: "CaretTop"
});
const _hoisted_1$4B = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 320 192 704h639.936z"
}, null, -1);
const _hoisted_3$47 = [
  _hoisted_2$4j
];
function _sfc_render$4w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4B, _hoisted_3$47);
}
var caretTop = /* @__PURE__ */ _export_sfc$1(_sfc_main$4_, [["render", _sfc_render$4w]]);
const _sfc_main$4Z = defineComponent({
  name: "Cellphone"
});
const _hoisted_1$4A = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4i = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 128a64 64 0 0 0-64 64v640a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64H256zm0-64h512a128 128 0 0 1 128 128v640a128 128 0 0 1-128 128H256a128 128 0 0 1-128-128V192A128 128 0 0 1 256 64zm128 128h256a32 32 0 1 1 0 64H384a32 32 0 0 1 0-64zm128 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128z"
}, null, -1);
const _hoisted_3$46 = [
  _hoisted_2$4i
];
function _sfc_render$4v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4A, _hoisted_3$46);
}
var cellphone = /* @__PURE__ */ _export_sfc$1(_sfc_main$4Z, [["render", _sfc_render$4v]]);
const _sfc_main$4Y = defineComponent({
  name: "ChatDotRound"
});
const _hoisted_1$4z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4h = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m174.72 855.68 135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0 1 89.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.056 461.056 0 0 1-206.912-48.384l-175.616 58.56z"
}, null, -1);
const _hoisted_3$45 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 563.2a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm192 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm-384 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4z"
}, null, -1);
const _hoisted_4$1i = [
  _hoisted_2$4h,
  _hoisted_3$45
];
function _sfc_render$4u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4z, _hoisted_4$1i);
}
var chatDotRound = /* @__PURE__ */ _export_sfc$1(_sfc_main$4Y, [["render", _sfc_render$4u]]);
const _sfc_main$4X = defineComponent({
  name: "ChatDotSquare"
});
const _hoisted_1$4y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4g = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88L273.536 736zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128H296z"
}, null, -1);
const _hoisted_3$44 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 499.2a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm192 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4zm-384 0a51.2 51.2 0 1 1 0-102.4 51.2 51.2 0 0 1 0 102.4z"
}, null, -1);
const _hoisted_4$1h = [
  _hoisted_2$4g,
  _hoisted_3$44
];
function _sfc_render$4t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4y, _hoisted_4$1h);
}
var chatDotSquare = /* @__PURE__ */ _export_sfc$1(_sfc_main$4X, [["render", _sfc_render$4t]]);
const _sfc_main$4W = defineComponent({
  name: "ChatLineRound"
});
const _hoisted_1$4x = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4f = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m174.72 855.68 135.296-45.12 23.68 11.84C388.096 849.536 448.576 864 512 864c211.84 0 384-166.784 384-352S723.84 160 512 160 128 326.784 128 512c0 69.12 24.96 139.264 70.848 199.232l22.08 28.8-46.272 115.584zm-45.248 82.56A32 32 0 0 1 89.6 896l58.368-145.92C94.72 680.32 64 596.864 64 512 64 299.904 256 96 512 96s448 203.904 448 416-192 416-448 416a461.056 461.056 0 0 1-206.912-48.384l-175.616 58.56z"
}, null, -1);
const _hoisted_3$43 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 576h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zm32-192h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$1g = [
  _hoisted_2$4f,
  _hoisted_3$43
];
function _sfc_render$4s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4x, _hoisted_4$1g);
}
var chatLineRound = /* @__PURE__ */ _export_sfc$1(_sfc_main$4W, [["render", _sfc_render$4s]]);
const _sfc_main$4V = defineComponent({
  name: "ChatLineSquare"
});
const _hoisted_1$4w = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4e = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 826.88 273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128H296z"
}, null, -1);
const _hoisted_3$42 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 512h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zm0-192h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$1f = [
  _hoisted_2$4e,
  _hoisted_3$42
];
function _sfc_render$4r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4w, _hoisted_4$1f);
}
var chatLineSquare = /* @__PURE__ */ _export_sfc$1(_sfc_main$4V, [["render", _sfc_render$4r]]);
const _sfc_main$4U = defineComponent({
  name: "ChatRound"
});
const _hoisted_1$4v = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4d = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m174.72 855.68 130.048-43.392 23.424 11.392C382.4 849.984 444.352 864 512 864c223.744 0 384-159.872 384-352 0-192.832-159.104-352-384-352S128 319.168 128 512a341.12 341.12 0 0 0 69.248 204.288l21.632 28.8-44.16 110.528zm-45.248 82.56A32 32 0 0 1 89.6 896l56.512-141.248A405.12 405.12 0 0 1 64 512C64 299.904 235.648 96 512 96s448 203.904 448 416-173.44 416-448 416c-79.68 0-150.848-17.152-211.712-46.72l-170.88 56.96z"
}, null, -1);
const _hoisted_3$41 = [
  _hoisted_2$4d
];
function _sfc_render$4q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4v, _hoisted_3$41);
}
var chatRound = /* @__PURE__ */ _export_sfc$1(_sfc_main$4U, [["render", _sfc_render$4q]]);
const _sfc_main$4T = defineComponent({
  name: "ChatSquare"
});
const _hoisted_1$4u = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M273.536 736H800a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H224a64 64 0 0 0-64 64v570.88L273.536 736zM296 800 147.968 918.4A32 32 0 0 1 96 893.44V256a128 128 0 0 1 128-128h576a128 128 0 0 1 128 128v416a128 128 0 0 1-128 128H296z"
}, null, -1);
const _hoisted_3$40 = [
  _hoisted_2$4c
];
function _sfc_render$4p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4u, _hoisted_3$40);
}
var chatSquare = /* @__PURE__ */ _export_sfc$1(_sfc_main$4T, [["render", _sfc_render$4p]]);
const _sfc_main$4S = defineComponent({
  name: "Check"
});
const _hoisted_1$4t = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4b = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
}, null, -1);
const _hoisted_3$3$ = [
  _hoisted_2$4b
];
function _sfc_render$4o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4t, _hoisted_3$3$);
}
var check = /* @__PURE__ */ _export_sfc$1(_sfc_main$4S, [["render", _sfc_render$4o]]);
const _sfc_main$4R = defineComponent({
  name: "Checked"
});
const _hoisted_1$4s = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$4a = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 192h160v736H160V192h160.064v64H704v-64zM311.616 537.28l-45.312 45.248L447.36 763.52l316.8-316.8-45.312-45.184L447.36 673.024 311.616 537.28zM384 192V96h256v96H384z"
}, null, -1);
const _hoisted_3$3_ = [
  _hoisted_2$4a
];
function _sfc_render$4n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4s, _hoisted_3$3_);
}
var checked = /* @__PURE__ */ _export_sfc$1(_sfc_main$4R, [["render", _sfc_render$4n]]);
const _sfc_main$4Q = defineComponent({
  name: "Cherry"
});
const _hoisted_1$4r = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$49 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M261.056 449.6c13.824-69.696 34.88-128.96 63.36-177.728 23.744-40.832 61.12-88.64 112.256-143.872H320a32 32 0 0 1 0-64h384a32 32 0 1 1 0 64H554.752c14.912 39.168 41.344 86.592 79.552 141.76 47.36 68.48 84.8 106.752 106.304 114.304a224 224 0 1 1-84.992 14.784c-22.656-22.912-47.04-53.76-73.92-92.608-38.848-56.128-67.008-105.792-84.352-149.312-55.296 58.24-94.528 107.52-117.76 147.2-23.168 39.744-41.088 88.768-53.568 147.072a224.064 224.064 0 1 1-64.96-1.6zM288 832a160 160 0 1 0 0-320 160 160 0 0 0 0 320zm448-64a160 160 0 1 0 0-320 160 160 0 0 0 0 320z"
}, null, -1);
const _hoisted_3$3Z = [
  _hoisted_2$49
];
function _sfc_render$4m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4r, _hoisted_3$3Z);
}
var cherry = /* @__PURE__ */ _export_sfc$1(_sfc_main$4Q, [["render", _sfc_render$4m]]);
const _sfc_main$4P = defineComponent({
  name: "Chicken"
});
const _hoisted_1$4q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$48 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M349.952 716.992 478.72 588.16a106.688 106.688 0 0 1-26.176-19.072 106.688 106.688 0 0 1-19.072-26.176L304.704 671.744c.768 3.072 1.472 6.144 2.048 9.216l2.048 31.936 31.872 1.984c3.136.64 6.208 1.28 9.28 2.112zm57.344 33.152a128 128 0 1 1-216.32 114.432l-1.92-32-32-1.92a128 128 0 1 1 114.432-216.32L416.64 469.248c-2.432-101.44 58.112-239.104 149.056-330.048 107.328-107.328 231.296-85.504 316.8 0 85.44 85.44 107.328 209.408 0 316.8-91.008 90.88-228.672 151.424-330.112 149.056L407.296 750.08zm90.496-226.304c49.536 49.536 233.344-7.04 339.392-113.088 78.208-78.208 63.232-163.072 0-226.304-63.168-63.232-148.032-78.208-226.24 0C504.896 290.496 448.32 474.368 497.792 523.84zM244.864 708.928a64 64 0 1 0-59.84 59.84l56.32-3.52 3.52-56.32zm8.064 127.68a64 64 0 1 0 59.84-59.84l-56.32 3.52-3.52 56.32z"
}, null, -1);
const _hoisted_3$3Y = [
  _hoisted_2$48
];
function _sfc_render$4l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4q, _hoisted_3$3Y);
}
var chicken = /* @__PURE__ */ _export_sfc$1(_sfc_main$4P, [["render", _sfc_render$4l]]);
const _sfc_main$4O = defineComponent({
  name: "CircleCheckFilled"
});
const _hoisted_1$4p = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$47 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1);
const _hoisted_3$3X = [
  _hoisted_2$47
];
function _sfc_render$4k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4p, _hoisted_3$3X);
}
var circleCheckFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$4O, [["render", _sfc_render$4k]]);
const _sfc_main$4N = defineComponent({
  name: "CircleCheck"
});
const _hoisted_1$4o = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$46 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_3$3W = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
}, null, -1);
const _hoisted_4$1e = [
  _hoisted_2$46,
  _hoisted_3$3W
];
function _sfc_render$4j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4o, _hoisted_4$1e);
}
var circleCheck = /* @__PURE__ */ _export_sfc$1(_sfc_main$4N, [["render", _sfc_render$4j]]);
const _sfc_main$4M = defineComponent({
  name: "CircleCloseFilled"
});
const _hoisted_1$4n = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$45 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
}, null, -1);
const _hoisted_3$3V = [
  _hoisted_2$45
];
function _sfc_render$4i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4n, _hoisted_3$3V);
}
var circleCloseFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$4M, [["render", _sfc_render$4i]]);
const _sfc_main$4L = defineComponent({
  name: "CircleClose"
});
const _hoisted_1$4m = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$44 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
}, null, -1);
const _hoisted_3$3U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_4$1d = [
  _hoisted_2$44,
  _hoisted_3$3U
];
function _sfc_render$4h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4m, _hoisted_4$1d);
}
var circleClose = /* @__PURE__ */ _export_sfc$1(_sfc_main$4L, [["render", _sfc_render$4h]]);
const _sfc_main$4K = defineComponent({
  name: "CirclePlusFilled"
});
const _hoisted_1$4l = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$43 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-38.4 409.6H326.4a38.4 38.4 0 1 0 0 76.8h147.2v147.2a38.4 38.4 0 0 0 76.8 0V550.4h147.2a38.4 38.4 0 0 0 0-76.8H550.4V326.4a38.4 38.4 0 1 0-76.8 0v147.2z"
}, null, -1);
const _hoisted_3$3T = [
  _hoisted_2$43
];
function _sfc_render$4g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4l, _hoisted_3$3T);
}
var circlePlusFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$4K, [["render", _sfc_render$4g]]);
const _sfc_main$4J = defineComponent({
  name: "CirclePlus"
});
const _hoisted_1$4k = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$42 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
}, null, -1);
const _hoisted_3$3S = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 672V352a32 32 0 1 1 64 0v320a32 32 0 0 1-64 0z"
}, null, -1);
const _hoisted_4$1c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_5$q = [
  _hoisted_2$42,
  _hoisted_3$3S,
  _hoisted_4$1c
];
function _sfc_render$4f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4k, _hoisted_5$q);
}
var circlePlus = /* @__PURE__ */ _export_sfc$1(_sfc_main$4J, [["render", _sfc_render$4f]]);
const _sfc_main$4I = defineComponent({
  name: "Clock"
});
const _hoisted_1$4j = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$41 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_3$3R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_4$1b = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_5$p = [
  _hoisted_2$41,
  _hoisted_3$3R,
  _hoisted_4$1b
];
function _sfc_render$4e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4j, _hoisted_5$p);
}
var clock = /* @__PURE__ */ _export_sfc$1(_sfc_main$4I, [["render", _sfc_render$4e]]);
const _sfc_main$4H = defineComponent({
  name: "CloseBold"
});
const _hoisted_1$4i = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$40 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M195.2 195.2a64 64 0 0 1 90.496 0L512 421.504 738.304 195.2a64 64 0 0 1 90.496 90.496L602.496 512 828.8 738.304a64 64 0 0 1-90.496 90.496L512 602.496 285.696 828.8a64 64 0 0 1-90.496-90.496L421.504 512 195.2 285.696a64 64 0 0 1 0-90.496z"
}, null, -1);
const _hoisted_3$3Q = [
  _hoisted_2$40
];
function _sfc_render$4d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4i, _hoisted_3$3Q);
}
var closeBold = /* @__PURE__ */ _export_sfc$1(_sfc_main$4H, [["render", _sfc_render$4d]]);
const _sfc_main$4G = defineComponent({
  name: "Close"
});
const _hoisted_1$4h = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3$ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
}, null, -1);
const _hoisted_3$3P = [
  _hoisted_2$3$
];
function _sfc_render$4c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4h, _hoisted_3$3P);
}
var close = /* @__PURE__ */ _export_sfc$1(_sfc_main$4G, [["render", _sfc_render$4c]]);
const _sfc_main$4F = defineComponent({
  name: "Cloudy"
});
const _hoisted_1$4g = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3_ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M598.4 831.872H328.192a256 256 0 0 1-34.496-510.528A352 352 0 1 1 598.4 831.872zm-271.36-64h272.256a288 288 0 1 0-248.512-417.664L335.04 381.44l-34.816 3.584a192 192 0 0 0 26.88 382.848z"
}, null, -1);
const _hoisted_3$3O = [
  _hoisted_2$3_
];
function _sfc_render$4b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4g, _hoisted_3$3O);
}
var cloudy = /* @__PURE__ */ _export_sfc$1(_sfc_main$4F, [["render", _sfc_render$4b]]);
const _sfc_main$4E = defineComponent({
  name: "CoffeeCup"
});
const _hoisted_1$4f = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3Z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M768 192a192 192 0 1 1-8 383.808A256.128 256.128 0 0 1 512 768H320A256 256 0 0 1 64 512V160a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v32zm0 64v256a128 128 0 1 0 0-256zM96 832h640a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64zm32-640v320a192 192 0 0 0 192 192h192a192 192 0 0 0 192-192V192H128z"
}, null, -1);
const _hoisted_3$3N = [
  _hoisted_2$3Z
];
function _sfc_render$4a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4f, _hoisted_3$3N);
}
var coffeeCup = /* @__PURE__ */ _export_sfc$1(_sfc_main$4E, [["render", _sfc_render$4a]]);
const _sfc_main$4D = defineComponent({
  name: "Coffee"
});
const _hoisted_1$4e = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3Y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M822.592 192h14.272a32 32 0 0 1 31.616 26.752l21.312 128A32 32 0 0 1 858.24 384h-49.344l-39.04 546.304A32 32 0 0 1 737.92 960H285.824a32 32 0 0 1-32-29.696L214.912 384H165.76a32 32 0 0 1-31.552-37.248l21.312-128A32 32 0 0 1 187.136 192h14.016l-6.72-93.696A32 32 0 0 1 226.368 64h571.008a32 32 0 0 1 31.936 34.304L822.592 192zm-64.128 0 4.544-64H260.736l4.544 64h493.184zm-548.16 128H820.48l-10.688-64H214.208l-10.688 64h6.784zm68.736 64 36.544 512H708.16l36.544-512H279.04z"
}, null, -1);
const _hoisted_3$3M = [
  _hoisted_2$3Y
];
function _sfc_render$49(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4e, _hoisted_3$3M);
}
var coffee = /* @__PURE__ */ _export_sfc$1(_sfc_main$4D, [["render", _sfc_render$49]]);
const _sfc_main$4C = defineComponent({
  name: "Coin"
});
const _hoisted_1$4d = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3X = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m161.92 580.736 29.888 58.88C171.328 659.776 160 681.728 160 704c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 615.808 928 657.664 928 704c0 129.728-188.544 224-416 224S96 833.728 96 704c0-46.592 24.32-88.576 65.92-123.264z"
}, null, -1);
const _hoisted_3$3L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m161.92 388.736 29.888 58.88C171.328 467.84 160 489.792 160 512c0 82.304 155.328 160 352 160s352-77.696 352-160c0-22.272-11.392-44.16-31.808-64.32l30.464-58.432C903.936 423.808 928 465.664 928 512c0 129.728-188.544 224-416 224S96 641.728 96 512c0-46.592 24.32-88.576 65.92-123.264z"
}, null, -1);
const _hoisted_4$1a = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 544c-227.456 0-416-94.272-416-224S284.544 96 512 96s416 94.272 416 224-188.544 224-416 224zm0-64c196.672 0 352-77.696 352-160S708.672 160 512 160s-352 77.696-352 160 155.328 160 352 160z"
}, null, -1);
const _hoisted_5$o = [
  _hoisted_2$3X,
  _hoisted_3$3L,
  _hoisted_4$1a
];
function _sfc_render$48(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4d, _hoisted_5$o);
}
var coin = /* @__PURE__ */ _export_sfc$1(_sfc_main$4C, [["render", _sfc_render$48]]);
const _sfc_main$4B = defineComponent({
  name: "ColdDrink"
});
const _hoisted_1$4c = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3W = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M768 64a192 192 0 1 1-69.952 370.88L480 725.376V896h96a32 32 0 1 1 0 64H320a32 32 0 1 1 0-64h96V725.376L76.8 273.536a64 64 0 0 1-12.8-38.4v-10.688a32 32 0 0 1 32-32h71.808l-65.536-83.84a32 32 0 0 1 50.432-39.424l96.256 123.264h337.728A192.064 192.064 0 0 1 768 64zM656.896 192.448H800a32 32 0 0 1 32 32v10.624a64 64 0 0 1-12.8 38.4l-80.448 107.2a128 128 0 1 0-81.92-188.16v-.064zm-357.888 64 129.472 165.76a32 32 0 0 1-50.432 39.36l-160.256-205.12H144l304 404.928 304-404.928H299.008z"
}, null, -1);
const _hoisted_3$3K = [
  _hoisted_2$3W
];
function _sfc_render$47(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4c, _hoisted_3$3K);
}
var coldDrink = /* @__PURE__ */ _export_sfc$1(_sfc_main$4B, [["render", _sfc_render$47]]);
const _sfc_main$4A = defineComponent({
  name: "CollectionTag"
});
const _hoisted_1$4b = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3V = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 128v698.88l196.032-156.864a96 96 0 0 1 119.936 0L768 826.816V128H256zm-32-64h576a32 32 0 0 1 32 32v797.44a32 32 0 0 1-51.968 24.96L531.968 720a32 32 0 0 0-39.936 0L243.968 918.4A32 32 0 0 1 192 893.44V96a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$3J = [
  _hoisted_2$3V
];
function _sfc_render$46(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4b, _hoisted_3$3J);
}
var collectionTag = /* @__PURE__ */ _export_sfc$1(_sfc_main$4A, [["render", _sfc_render$46]]);
const _sfc_main$4z = defineComponent({
  name: "Collection"
});
const _hoisted_1$4a = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 736h640V128H256a64 64 0 0 0-64 64v544zm64-672h608a32 32 0 0 1 32 32v672a32 32 0 0 1-32 32H160l-32 57.536V192A128 128 0 0 1 256 64z"
}, null, -1);
const _hoisted_3$3I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M240 800a48 48 0 1 0 0 96h592v-96H240zm0-64h656v160a64 64 0 0 1-64 64H240a112 112 0 0 1 0-224zm144-608v250.88l96-76.8 96 76.8V128H384zm-64-64h320v381.44a32 32 0 0 1-51.968 24.96L480 384l-108.032 86.4A32 32 0 0 1 320 445.44V64z"
}, null, -1);
const _hoisted_4$19 = [
  _hoisted_2$3U,
  _hoisted_3$3I
];
function _sfc_render$45(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4a, _hoisted_4$19);
}
var collection = /* @__PURE__ */ _export_sfc$1(_sfc_main$4z, [["render", _sfc_render$45]]);
const _sfc_main$4y = defineComponent({
  name: "Comment"
});
const _hoisted_1$49 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3T = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M736 504a56 56 0 1 1 0-112 56 56 0 0 1 0 112zm-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112zm-224 0a56 56 0 1 1 0-112 56 56 0 0 1 0 112zM128 128v640h192v160l224-160h352V128H128z"
}, null, -1);
const _hoisted_3$3H = [
  _hoisted_2$3T
];
function _sfc_render$44(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$49, _hoisted_3$3H);
}
var comment = /* @__PURE__ */ _export_sfc$1(_sfc_main$4y, [["render", _sfc_render$44]]);
const _sfc_main$4x = defineComponent({
  name: "Compass"
});
const _hoisted_1$48 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3S = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_3$3G = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M725.888 315.008C676.48 428.672 624 513.28 568.576 568.64c-55.424 55.424-139.968 107.904-253.568 157.312a12.8 12.8 0 0 1-16.896-16.832c49.536-113.728 102.016-198.272 157.312-253.632 55.36-55.296 139.904-107.776 253.632-157.312a12.8 12.8 0 0 1 16.832 16.832z"
}, null, -1);
const _hoisted_4$18 = [
  _hoisted_2$3S,
  _hoisted_3$3G
];
function _sfc_render$43(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$48, _hoisted_4$18);
}
var compass = /* @__PURE__ */ _export_sfc$1(_sfc_main$4x, [["render", _sfc_render$43]]);
const _sfc_main$4w = defineComponent({
  name: "Connection"
});
const _hoisted_1$47 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 384v64H448a128 128 0 0 0-128 128v128a128 128 0 0 0 128 128h320a128 128 0 0 0 128-128V576a128 128 0 0 0-64-110.848V394.88c74.56 26.368 128 97.472 128 181.056v128a192 192 0 0 1-192 192H448a192 192 0 0 1-192-192V576a192 192 0 0 1 192-192h192z"
}, null, -1);
const _hoisted_3$3F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 640v-64h192a128 128 0 0 0 128-128V320a128 128 0 0 0-128-128H256a128 128 0 0 0-128 128v128a128 128 0 0 0 64 110.848v70.272A192.064 192.064 0 0 1 64 448V320a192 192 0 0 1 192-192h320a192 192 0 0 1 192 192v128a192 192 0 0 1-192 192H384z"
}, null, -1);
const _hoisted_4$17 = [
  _hoisted_2$3R,
  _hoisted_3$3F
];
function _sfc_render$42(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$47, _hoisted_4$17);
}
var connection = /* @__PURE__ */ _export_sfc$1(_sfc_main$4w, [["render", _sfc_render$42]]);
const _sfc_main$4v = defineComponent({
  name: "Coordinate"
});
const _hoisted_1$46 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3Q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 512h64v320h-64z"
}, null, -1);
const _hoisted_3$3E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 896h640a64 64 0 0 0-64-64H256a64 64 0 0 0-64 64zm64-128h512a128 128 0 0 1 128 128v64H128v-64a128 128 0 0 1 128-128zm256-256a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512z"
}, null, -1);
const _hoisted_4$16 = [
  _hoisted_2$3Q,
  _hoisted_3$3E
];
function _sfc_render$41(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$46, _hoisted_4$16);
}
var coordinate = /* @__PURE__ */ _export_sfc$1(_sfc_main$4v, [["render", _sfc_render$41]]);
const _sfc_main$4u = defineComponent({
  name: "CopyDocument"
});
const _hoisted_1$45 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3P = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M768 832a128 128 0 0 1-128 128H192A128 128 0 0 1 64 832V384a128 128 0 0 1 128-128v64a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64h64z"
}, null, -1);
const _hoisted_3$3D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 128a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V192a64 64 0 0 0-64-64H384zm0-64h448a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H384a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64z"
}, null, -1);
const _hoisted_4$15 = [
  _hoisted_2$3P,
  _hoisted_3$3D
];
function _sfc_render$40(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$45, _hoisted_4$15);
}
var copyDocument = /* @__PURE__ */ _export_sfc$1(_sfc_main$4u, [["render", _sfc_render$40]]);
const _sfc_main$4t = defineComponent({
  name: "Cpu"
});
const _hoisted_1$44 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3O = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M320 256a64 64 0 0 0-64 64v384a64 64 0 0 0 64 64h384a64 64 0 0 0 64-64V320a64 64 0 0 0-64-64H320zm0-64h384a128 128 0 0 1 128 128v384a128 128 0 0 1-128 128H320a128 128 0 0 1-128-128V320a128 128 0 0 1 128-128z"
}, null, -1);
const _hoisted_3$3C = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32zm160 0a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32zm-320 0a32 32 0 0 1 32 32v128h-64V96a32 32 0 0 1 32-32zm160 896a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32zm160 0a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32zm-320 0a32 32 0 0 1-32-32V800h64v128a32 32 0 0 1-32 32zM64 512a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32zm0-160a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32zm0 320a32 32 0 0 1 32-32h128v64H96a32 32 0 0 1-32-32zm896-160a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32zm0-160a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32zm0 320a32 32 0 0 1-32 32H800v-64h128a32 32 0 0 1 32 32z"
}, null, -1);
const _hoisted_4$14 = [
  _hoisted_2$3O,
  _hoisted_3$3C
];
function _sfc_render$3$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$44, _hoisted_4$14);
}
var cpu = /* @__PURE__ */ _export_sfc$1(_sfc_main$4t, [["render", _sfc_render$3$]]);
const _sfc_main$4s = defineComponent({
  name: "CreditCard"
});
const _hoisted_1$43 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3N = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M896 324.096c0-42.368-2.496-55.296-9.536-68.48a52.352 52.352 0 0 0-22.144-22.08c-13.12-7.04-26.048-9.536-68.416-9.536H228.096c-42.368 0-55.296 2.496-68.48 9.536a52.352 52.352 0 0 0-22.08 22.144c-7.04 13.12-9.536 26.048-9.536 68.416v375.808c0 42.368 2.496 55.296 9.536 68.48a52.352 52.352 0 0 0 22.144 22.08c13.12 7.04 26.048 9.536 68.416 9.536h567.808c42.368 0 55.296-2.496 68.48-9.536a52.352 52.352 0 0 0 22.08-22.144c7.04-13.12 9.536-26.048 9.536-68.416V324.096zm64 0v375.808c0 57.088-5.952 77.76-17.088 98.56-11.136 20.928-27.52 37.312-48.384 48.448-20.864 11.136-41.6 17.088-98.56 17.088H228.032c-57.088 0-77.76-5.952-98.56-17.088a116.288 116.288 0 0 1-48.448-48.384c-11.136-20.864-17.088-41.6-17.088-98.56V324.032c0-57.088 5.952-77.76 17.088-98.56 11.136-20.928 27.52-37.312 48.384-48.448 20.864-11.136 41.6-17.088 98.56-17.088H795.84c57.088 0 77.76 5.952 98.56 17.088 20.928 11.136 37.312 27.52 48.448 48.384 11.136 20.864 17.088 41.6 17.088 98.56z"
}, null, -1);
const _hoisted_3$3B = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M64 320h896v64H64v-64zm0 128h896v64H64v-64zm128 192h256v64H192z"
}, null, -1);
const _hoisted_4$13 = [
  _hoisted_2$3N,
  _hoisted_3$3B
];
function _sfc_render$3_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$43, _hoisted_4$13);
}
var creditCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$4s, [["render", _sfc_render$3_]]);
const _sfc_main$4r = defineComponent({
  name: "Crop"
});
const _hoisted_1$42 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3M = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 768h672a32 32 0 1 1 0 64H224a32 32 0 0 1-32-32V96a32 32 0 0 1 64 0v672z"
}, null, -1);
const _hoisted_3$3A = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 224v704a32 32 0 1 1-64 0V256H96a32 32 0 0 1 0-64h704a32 32 0 0 1 32 32z"
}, null, -1);
const _hoisted_4$12 = [
  _hoisted_2$3M,
  _hoisted_3$3A
];
function _sfc_render$3Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$42, _hoisted_4$12);
}
var crop = /* @__PURE__ */ _export_sfc$1(_sfc_main$4r, [["render", _sfc_render$3Z]]);
const _sfc_main$4q = defineComponent({
  name: "DArrowLeft"
});
const _hoisted_1$41 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
}, null, -1);
const _hoisted_3$3z = [
  _hoisted_2$3L
];
function _sfc_render$3Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$41, _hoisted_3$3z);
}
var dArrowLeft = /* @__PURE__ */ _export_sfc$1(_sfc_main$4q, [["render", _sfc_render$3Y]]);
const _sfc_main$4p = defineComponent({
  name: "DArrowRight"
});
const _hoisted_1$40 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3K = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
}, null, -1);
const _hoisted_3$3y = [
  _hoisted_2$3K
];
function _sfc_render$3X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$40, _hoisted_3$3y);
}
var dArrowRight = /* @__PURE__ */ _export_sfc$1(_sfc_main$4p, [["render", _sfc_render$3X]]);
const _sfc_main$4o = defineComponent({
  name: "DCaret"
});
const _hoisted_1$3$ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3J = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m512 128 288 320H224l288-320zM224 576h576L512 896 224 576z"
}, null, -1);
const _hoisted_3$3x = [
  _hoisted_2$3J
];
function _sfc_render$3W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3$, _hoisted_3$3x);
}
var dCaret = /* @__PURE__ */ _export_sfc$1(_sfc_main$4o, [["render", _sfc_render$3W]]);
const _sfc_main$4n = defineComponent({
  name: "DataAnalysis"
});
const _hoisted_1$3_ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m665.216 768 110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32l110.848-192H160a32 32 0 0 1-32-32V192H64a32 32 0 0 1 0-64h896a32 32 0 1 1 0 64h-64v544a32 32 0 0 1-32 32H665.216zM832 192H192v512h640V192zM352 448a32 32 0 0 1 32 32v64a32 32 0 0 1-64 0v-64a32 32 0 0 1 32-32zm160-64a32 32 0 0 1 32 32v128a32 32 0 0 1-64 0V416a32 32 0 0 1 32-32zm160-64a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V352a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$3w = [
  _hoisted_2$3I
];
function _sfc_render$3V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3_, _hoisted_3$3w);
}
var dataAnalysis = /* @__PURE__ */ _export_sfc$1(_sfc_main$4n, [["render", _sfc_render$3V]]);
const _sfc_main$4m = defineComponent({
  name: "DataBoard"
});
const _hoisted_1$3Z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3H = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M32 128h960v64H32z"
}, null, -1);
const _hoisted_3$3v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 192v512h640V192H192zm-64-64h768v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V128z"
}, null, -1);
const _hoisted_4$11 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M322.176 960H248.32l144.64-250.56 55.424 32L322.176 960zm453.888 0h-73.856L576 741.44l55.424-32L776.064 960z"
}, null, -1);
const _hoisted_5$n = [
  _hoisted_2$3H,
  _hoisted_3$3v,
  _hoisted_4$11
];
function _sfc_render$3U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3Z, _hoisted_5$n);
}
var dataBoard = /* @__PURE__ */ _export_sfc$1(_sfc_main$4m, [["render", _sfc_render$3U]]);
const _sfc_main$4l = defineComponent({
  name: "DataLine"
});
const _hoisted_1$3Y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3G = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M359.168 768H160a32 32 0 0 1-32-32V192H64a32 32 0 0 1 0-64h896a32 32 0 1 1 0 64h-64v544a32 32 0 0 1-32 32H665.216l110.848 192h-73.856L591.36 768H433.024L322.176 960H248.32l110.848-192zM832 192H192v512h640V192zM342.656 534.656a32 32 0 1 1-45.312-45.312L444.992 341.76l125.44 94.08L679.04 300.032a32 32 0 1 1 49.92 39.936L581.632 524.224 451.008 426.24 342.656 534.592z"
}, null, -1);
const _hoisted_3$3u = [
  _hoisted_2$3G
];
function _sfc_render$3T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3Y, _hoisted_3$3u);
}
var dataLine = /* @__PURE__ */ _export_sfc$1(_sfc_main$4l, [["render", _sfc_render$3T]]);
const _sfc_main$4k = defineComponent({
  name: "DeleteFilled"
});
const _hoisted_1$3X = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 192V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64H96a32 32 0 0 1 0-64h256zm64 0h192v-64H416v64zM192 960a32 32 0 0 1-32-32V256h704v672a32 32 0 0 1-32 32H192zm224-192a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32zm192 0a32 32 0 0 0 32-32V416a32 32 0 0 0-64 0v320a32 32 0 0 0 32 32z"
}, null, -1);
const _hoisted_3$3t = [
  _hoisted_2$3F
];
function _sfc_render$3S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3X, _hoisted_3$3t);
}
var deleteFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$4k, [["render", _sfc_render$3S]]);
const _sfc_main$4j = defineComponent({
  name: "DeleteLocation"
});
const _hoisted_1$3W = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$3s = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_4$10 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 384h256q32 0 32 32t-32 32H384q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_5$m = [
  _hoisted_2$3E,
  _hoisted_3$3s,
  _hoisted_4$10
];
function _sfc_render$3R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3W, _hoisted_5$m);
}
var deleteLocation = /* @__PURE__ */ _export_sfc$1(_sfc_main$4j, [["render", _sfc_render$3R]]);
const _sfc_main$4i = defineComponent({
  name: "Delete"
});
const _hoisted_1$3V = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
}, null, -1);
const _hoisted_3$3r = [
  _hoisted_2$3D
];
function _sfc_render$3Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3V, _hoisted_3$3r);
}
var _delete = /* @__PURE__ */ _export_sfc$1(_sfc_main$4i, [["render", _sfc_render$3Q]]);
const _sfc_main$4h = defineComponent({
  name: "Dessert"
});
const _hoisted_1$3U = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3C = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 416v-48a144 144 0 0 1 168.64-141.888 224.128 224.128 0 0 1 430.72 0A144 144 0 0 1 896 368v48a384 384 0 0 1-352 382.72V896h-64v-97.28A384 384 0 0 1 128 416zm287.104-32.064h193.792a143.808 143.808 0 0 1 58.88-132.736 160.064 160.064 0 0 0-311.552 0 143.808 143.808 0 0 1 58.88 132.8zm-72.896 0a72 72 0 1 0-140.48 0h140.48zm339.584 0h140.416a72 72 0 1 0-140.48 0zM512 736a320 320 0 0 0 318.4-288.064H193.6A320 320 0 0 0 512 736zM384 896.064h256a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64z"
}, null, -1);
const _hoisted_3$3q = [
  _hoisted_2$3C
];
function _sfc_render$3P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3U, _hoisted_3$3q);
}
var dessert = /* @__PURE__ */ _export_sfc$1(_sfc_main$4h, [["render", _sfc_render$3P]]);
const _sfc_main$4g = defineComponent({
  name: "Discount"
});
const _hoisted_1$3T = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3B = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 704h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0L224 318.336V704zm0 64v128h576V768H224zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0z"
}, null, -1);
const _hoisted_3$3p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"
}, null, -1);
const _hoisted_4$$ = [
  _hoisted_2$3B,
  _hoisted_3$3p
];
function _sfc_render$3O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3T, _hoisted_4$$);
}
var discount = /* @__PURE__ */ _export_sfc$1(_sfc_main$4g, [["render", _sfc_render$3O]]);
const _sfc_main$4f = defineComponent({
  name: "DishDot"
});
const _hoisted_1$3S = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3A = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m384.064 274.56.064-50.688A128 128 0 0 1 512.128 96c70.528 0 127.68 57.152 127.68 127.68v50.752A448.192 448.192 0 0 1 955.392 768H68.544A448.192 448.192 0 0 1 384 274.56zM96 832h832a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64zm32-128h768a384 384 0 1 0-768 0zm447.808-448v-32.32a63.68 63.68 0 0 0-63.68-63.68 64 64 0 0 0-64 63.936V256h127.68z"
}, null, -1);
const _hoisted_3$3o = [
  _hoisted_2$3A
];
function _sfc_render$3N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3S, _hoisted_3$3o);
}
var dishDot = /* @__PURE__ */ _export_sfc$1(_sfc_main$4f, [["render", _sfc_render$3N]]);
const _sfc_main$4e = defineComponent({
  name: "Dish"
});
const _hoisted_1$3R = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 257.152V192h-96a32 32 0 0 1 0-64h256a32 32 0 1 1 0 64h-96v65.152A448 448 0 0 1 955.52 768H68.48A448 448 0 0 1 480 257.152zM128 704h768a384 384 0 1 0-768 0zM96 832h832a32 32 0 1 1 0 64H96a32 32 0 1 1 0-64z"
}, null, -1);
const _hoisted_3$3n = [
  _hoisted_2$3z
];
function _sfc_render$3M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3R, _hoisted_3$3n);
}
var dish = /* @__PURE__ */ _export_sfc$1(_sfc_main$4e, [["render", _sfc_render$3M]]);
const _sfc_main$4d = defineComponent({
  name: "DocumentAdd"
});
const _hoisted_1$3Q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm320 512V448h64v128h128v64H544v128h-64V640H352v-64h128z"
}, null, -1);
const _hoisted_3$3m = [
  _hoisted_2$3y
];
function _sfc_render$3L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3Q, _hoisted_3$3m);
}
var documentAdd = /* @__PURE__ */ _export_sfc$1(_sfc_main$4d, [["render", _sfc_render$3L]]);
const _sfc_main$4c = defineComponent({
  name: "DocumentChecked"
});
const _hoisted_1$3P = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3x = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M805.504 320 640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm318.4 582.144 180.992-180.992L704.64 510.4 478.4 736.64 320 578.304l45.248-45.312L478.4 646.144z"
}, null, -1);
const _hoisted_3$3l = [
  _hoisted_2$3x
];
function _sfc_render$3K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3P, _hoisted_3$3l);
}
var documentChecked = /* @__PURE__ */ _export_sfc$1(_sfc_main$4c, [["render", _sfc_render$3K]]);
const _sfc_main$4b = defineComponent({
  name: "DocumentCopy"
});
const _hoisted_1$3O = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3w = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 320v576h576V320H128zm-32-64h640a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32zM960 96v704a32 32 0 0 1-32 32h-96v-64h64V128H384v64h-64V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32zM256 672h320v64H256v-64zm0-192h320v64H256v-64z"
}, null, -1);
const _hoisted_3$3k = [
  _hoisted_2$3w
];
function _sfc_render$3J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3O, _hoisted_3$3k);
}
var documentCopy = /* @__PURE__ */ _export_sfc$1(_sfc_main$4b, [["render", _sfc_render$3J]]);
const _sfc_main$4a = defineComponent({
  name: "DocumentDelete"
});
const _hoisted_1$3N = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M805.504 320 640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm308.992 546.304-90.496-90.624 45.248-45.248 90.56 90.496 90.496-90.432 45.248 45.248-90.496 90.56 90.496 90.496-45.248 45.248-90.496-90.496-90.56 90.496-45.248-45.248 90.496-90.496z"
}, null, -1);
const _hoisted_3$3j = [
  _hoisted_2$3v
];
function _sfc_render$3I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3N, _hoisted_3$3j);
}
var documentDelete = /* @__PURE__ */ _export_sfc$1(_sfc_main$4a, [["render", _sfc_render$3I]]);
const _sfc_main$49 = defineComponent({
  name: "DocumentRemove"
});
const _hoisted_1$3M = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3u = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M805.504 320 640 154.496V320h165.504zM832 384H576V128H192v768h640V384zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm192 512h320v64H352v-64z"
}, null, -1);
const _hoisted_3$3i = [
  _hoisted_2$3u
];
function _sfc_render$3H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3M, _hoisted_3$3i);
}
var documentRemove = /* @__PURE__ */ _export_sfc$1(_sfc_main$49, [["render", _sfc_render$3H]]);
const _sfc_main$48 = defineComponent({
  name: "Document"
});
const _hoisted_1$3L = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3t = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1);
const _hoisted_3$3h = [
  _hoisted_2$3t
];
function _sfc_render$3G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3L, _hoisted_3$3h);
}
var document$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$48, [["render", _sfc_render$3G]]);
const _sfc_main$47 = defineComponent({
  name: "Download"
});
const _hoisted_1$3K = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3s = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-253.696 236.288-236.352 45.248 45.248L508.8 704 192 387.2l45.248-45.248L480 584.704V128h64v450.304z"
}, null, -1);
const _hoisted_3$3g = [
  _hoisted_2$3s
];
function _sfc_render$3F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3K, _hoisted_3$3g);
}
var download = /* @__PURE__ */ _export_sfc$1(_sfc_main$47, [["render", _sfc_render$3F]]);
const _sfc_main$46 = defineComponent({
  name: "Drizzling"
});
const _hoisted_1$3J = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m739.328 291.328-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0 0 35.776-380.672zM959.552 480a256 256 0 0 1-256 256h-400A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 959.552 480zM288 800h64v64h-64v-64zm192 0h64v64h-64v-64zm-96 96h64v64h-64v-64zm192 0h64v64h-64v-64zm96-96h64v64h-64v-64z"
}, null, -1);
const _hoisted_3$3f = [
  _hoisted_2$3r
];
function _sfc_render$3E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3J, _hoisted_3$3f);
}
var drizzling = /* @__PURE__ */ _export_sfc$1(_sfc_main$46, [["render", _sfc_render$3E]]);
const _sfc_main$45 = defineComponent({
  name: "EditPen"
});
const _hoisted_1$3I = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3q = /* @__PURE__ */ createElementVNode("path", {
  d: "m199.04 672.64 193.984 112 224-387.968-193.92-112-224 388.032zm-23.872 60.16 32.896 148.288 144.896-45.696L175.168 732.8zM455.04 229.248l193.92 112 56.704-98.112-193.984-112-56.64 98.112zM104.32 708.8l384-665.024 304.768 175.936L409.152 884.8h.064l-248.448 78.336L104.32 708.8zm384 254.272v-64h448v64h-448z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$3e = [
  _hoisted_2$3q
];
function _sfc_render$3D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3I, _hoisted_3$3e);
}
var editPen = /* @__PURE__ */ _export_sfc$1(_sfc_main$45, [["render", _sfc_render$3D]]);
const _sfc_main$44 = defineComponent({
  name: "Edit"
});
const _hoisted_1$3H = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 512a32 32 0 1 1 64 0v352a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h352a32 32 0 0 1 0 64H192v640h640V512z"
}, null, -1);
const _hoisted_3$3d = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m469.952 554.24 52.8-7.552L847.104 222.4a32 32 0 1 0-45.248-45.248L477.44 501.44l-7.552 52.8zm422.4-422.4a96 96 0 0 1 0 135.808l-331.84 331.84a32 32 0 0 1-18.112 9.088L436.8 623.68a32 32 0 0 1-36.224-36.224l15.104-105.6a32 32 0 0 1 9.024-18.112l331.904-331.84a96 96 0 0 1 135.744 0z"
}, null, -1);
const _hoisted_4$_ = [
  _hoisted_2$3p,
  _hoisted_3$3d
];
function _sfc_render$3C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3H, _hoisted_4$_);
}
var edit = /* @__PURE__ */ _export_sfc$1(_sfc_main$44, [["render", _sfc_render$3C]]);
const _sfc_main$43 = defineComponent({
  name: "ElemeFilled"
});
const _hoisted_1$3G = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3o = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M176 64h672c61.824 0 112 50.176 112 112v672a112 112 0 0 1-112 112H176A112 112 0 0 1 64 848V176c0-61.824 50.176-112 112-112zm150.528 173.568c-152.896 99.968-196.544 304.064-97.408 456.96a330.688 330.688 0 0 0 456.96 96.64c9.216-5.888 17.6-11.776 25.152-18.56a18.24 18.24 0 0 0 4.224-24.32L700.352 724.8a47.552 47.552 0 0 0-65.536-14.272A234.56 234.56 0 0 1 310.592 641.6C240 533.248 271.104 387.968 379.456 316.48a234.304 234.304 0 0 1 276.352 15.168c1.664.832 2.56 2.56 3.392 4.224 5.888 8.384 3.328 19.328-5.12 25.216L456.832 489.6a47.552 47.552 0 0 0-14.336 65.472l16 24.384c5.888 8.384 16.768 10.88 25.216 5.056l308.224-199.936a19.584 19.584 0 0 0 6.72-23.488v-.896c-4.992-9.216-10.048-17.6-15.104-26.88-99.968-151.168-304.064-194.88-456.96-95.744zM786.88 504.704l-62.208 40.32c-8.32 5.888-10.88 16.768-4.992 25.216L760 632.32c5.888 8.448 16.768 11.008 25.152 5.12l31.104-20.16a55.36 55.36 0 0 0 16-76.48l-20.224-31.04a19.52 19.52 0 0 0-25.152-5.12z"
}, null, -1);
const _hoisted_3$3c = [
  _hoisted_2$3o
];
function _sfc_render$3B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3G, _hoisted_3$3c);
}
var elemeFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$43, [["render", _sfc_render$3B]]);
const _sfc_main$42 = defineComponent({
  name: "Eleme"
});
const _hoisted_1$3F = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3n = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M300.032 188.8c174.72-113.28 408-63.36 522.24 109.44 5.76 10.56 11.52 20.16 17.28 30.72v.96a22.4 22.4 0 0 1-7.68 26.88l-352.32 228.48c-9.6 6.72-22.08 3.84-28.8-5.76l-18.24-27.84a54.336 54.336 0 0 1 16.32-74.88l225.6-146.88c9.6-6.72 12.48-19.2 5.76-28.8-.96-1.92-1.92-3.84-3.84-4.8a267.84 267.84 0 0 0-315.84-17.28c-123.84 81.6-159.36 247.68-78.72 371.52a268.096 268.096 0 0 0 370.56 78.72 54.336 54.336 0 0 1 74.88 16.32l17.28 26.88c5.76 9.6 3.84 21.12-4.8 27.84-8.64 7.68-18.24 14.4-28.8 21.12a377.92 377.92 0 0 1-522.24-110.4c-113.28-174.72-63.36-408 111.36-522.24zm526.08 305.28a22.336 22.336 0 0 1 28.8 5.76l23.04 35.52a63.232 63.232 0 0 1-18.24 87.36l-35.52 23.04c-9.6 6.72-22.08 3.84-28.8-5.76l-46.08-71.04c-6.72-9.6-3.84-22.08 5.76-28.8l71.04-46.08z"
}, null, -1);
const _hoisted_3$3b = [
  _hoisted_2$3n
];
function _sfc_render$3A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3F, _hoisted_3$3b);
}
var eleme = /* @__PURE__ */ _export_sfc$1(_sfc_main$42, [["render", _sfc_render$3A]]);
const _sfc_main$41 = defineComponent({
  name: "ElementPlus"
});
const _hoisted_1$3E = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3m = /* @__PURE__ */ createElementVNode("path", {
  d: "M839.7 734.7c0 33.3-17.9 41-17.9 41S519.7 949.8 499.2 960c-10.2 5.1-20.5 5.1-30.7 0 0 0-314.9-184.3-325.1-192-5.1-5.1-10.2-12.8-12.8-20.5V368.6c0-17.9 20.5-28.2 20.5-28.2L466 158.6c12.8-5.1 25.6-5.1 38.4 0 0 0 279 161.3 309.8 179.2 17.9 7.7 28.2 25.6 25.6 46.1-.1-5-.1 317.5-.1 350.8zM714.2 371.2c-64-35.8-217.6-125.4-217.6-125.4-7.7-5.1-20.5-5.1-30.7 0L217.6 389.1s-17.9 10.2-17.9 23v297c0 5.1 5.1 12.8 7.7 17.9 7.7 5.1 256 148.5 256 148.5 7.7 5.1 17.9 5.1 25.6 0 15.4-7.7 250.9-145.9 250.9-145.9s12.8-5.1 12.8-30.7v-74.2l-276.5 169v-64c0-17.9 7.7-30.7 20.5-46.1L745 535c5.1-7.7 10.2-20.5 10.2-30.7v-66.6l-279 169v-69.1c0-15.4 5.1-30.7 17.9-38.4l220.1-128zM919 135.7c0-5.1-5.1-7.7-7.7-7.7h-58.9V66.6c0-5.1-5.1-5.1-10.2-5.1l-30.7 5.1c-5.1 0-5.1 2.6-5.1 5.1V128h-56.3c-5.1 0-5.1 5.1-7.7 5.1v38.4h69.1v64c0 5.1 5.1 5.1 10.2 5.1l30.7-5.1c5.1 0 5.1-2.6 5.1-5.1v-56.3h64l-2.5-38.4z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$3a = [
  _hoisted_2$3m
];
function _sfc_render$3z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3E, _hoisted_3$3a);
}
var elementPlus = /* @__PURE__ */ _export_sfc$1(_sfc_main$41, [["render", _sfc_render$3z]]);
const _sfc_main$40 = defineComponent({
  name: "Expand"
});
const _hoisted_1$3D = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3l = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 192h768v128H128V192zm0 256h512v128H128V448zm0 256h768v128H128V704zm576-352 192 160-192 128V352z"
}, null, -1);
const _hoisted_3$39 = [
  _hoisted_2$3l
];
function _sfc_render$3y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3D, _hoisted_3$39);
}
var expand = /* @__PURE__ */ _export_sfc$1(_sfc_main$40, [["render", _sfc_render$3y]]);
const _sfc_main$3$ = defineComponent({
  name: "Failed"
});
const _hoisted_1$3C = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3k = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m557.248 608 135.744-135.744-45.248-45.248-135.68 135.744-135.808-135.68-45.248 45.184L466.752 608l-135.68 135.68 45.184 45.312L512 653.248l135.744 135.744 45.248-45.248L557.312 608zM704 192h160v736H160V192h160v64h384v-64zm-320 0V96h256v96H384z"
}, null, -1);
const _hoisted_3$38 = [
  _hoisted_2$3k
];
function _sfc_render$3x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3C, _hoisted_3$38);
}
var failed = /* @__PURE__ */ _export_sfc$1(_sfc_main$3$, [["render", _sfc_render$3x]]);
const _sfc_main$3_ = defineComponent({
  name: "Female"
});
const _hoisted_1$3B = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 640a256 256 0 1 0 0-512 256 256 0 0 0 0 512zm0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640z"
}, null, -1);
const _hoisted_3$37 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 640q32 0 32 32v256q0 32-32 32t-32-32V672q0-32 32-32z"
}, null, -1);
const _hoisted_4$Z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 800h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_5$l = [
  _hoisted_2$3j,
  _hoisted_3$37,
  _hoisted_4$Z
];
function _sfc_render$3w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3B, _hoisted_5$l);
}
var female = /* @__PURE__ */ _export_sfc$1(_sfc_main$3_, [["render", _sfc_render$3w]]);
const _sfc_main$3Z = defineComponent({
  name: "Files"
});
const _hoisted_1$3A = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3i = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 384v448h768V384H128zm-32-64h832a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32zm64-128h704v64H160zm96-128h512v64H256z"
}, null, -1);
const _hoisted_3$36 = [
  _hoisted_2$3i
];
function _sfc_render$3v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3A, _hoisted_3$36);
}
var files = /* @__PURE__ */ _export_sfc$1(_sfc_main$3Z, [["render", _sfc_render$3v]]);
const _sfc_main$3Y = defineComponent({
  name: "Film"
});
const _hoisted_1$3z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3h = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 160v704h704V160H160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$35 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M320 288V128h64v352h256V128h64v160h160v64H704v128h160v64H704v128h160v64H704v160h-64V544H384v352h-64V736H128v-64h192V544H128v-64h192V352H128v-64h192z"
}, null, -1);
const _hoisted_4$Y = [
  _hoisted_2$3h,
  _hoisted_3$35
];
function _sfc_render$3u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3z, _hoisted_4$Y);
}
var film = /* @__PURE__ */ _export_sfc$1(_sfc_main$3Y, [["render", _sfc_render$3u]]);
const _sfc_main$3X = defineComponent({
  name: "Filter"
});
const _hoisted_1$3y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3g = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 523.392V928a32 32 0 0 0 46.336 28.608l192-96A32 32 0 0 0 640 832V523.392l280.768-343.104a32 32 0 1 0-49.536-40.576l-288 352A32 32 0 0 0 576 512v300.224l-128 64V512a32 32 0 0 0-7.232-20.288L195.52 192H704a32 32 0 1 0 0-64H128a32 32 0 0 0-24.768 52.288L384 523.392z"
}, null, -1);
const _hoisted_3$34 = [
  _hoisted_2$3g
];
function _sfc_render$3t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3y, _hoisted_3$34);
}
var filter = /* @__PURE__ */ _export_sfc$1(_sfc_main$3X, [["render", _sfc_render$3t]]);
const _sfc_main$3W = defineComponent({
  name: "Finished"
});
const _hoisted_1$3x = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3f = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M280.768 753.728 691.456 167.04a32 32 0 1 1 52.416 36.672L314.24 817.472a32 32 0 0 1-45.44 7.296l-230.4-172.8a32 32 0 0 1 38.4-51.2l203.968 152.96zM736 448a32 32 0 1 1 0-64h192a32 32 0 1 1 0 64H736zM608 640a32 32 0 0 1 0-64h319.936a32 32 0 1 1 0 64H608zM480 832a32 32 0 1 1 0-64h447.936a32 32 0 1 1 0 64H480z"
}, null, -1);
const _hoisted_3$33 = [
  _hoisted_2$3f
];
function _sfc_render$3s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3x, _hoisted_3$33);
}
var finished = /* @__PURE__ */ _export_sfc$1(_sfc_main$3W, [["render", _sfc_render$3s]]);
const _sfc_main$3V = defineComponent({
  name: "FirstAidKit"
});
const _hoisted_1$3w = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3e = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 256a64 64 0 0 0-64 64v448a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V320a64 64 0 0 0-64-64H192zm0-64h640a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H192A128 128 0 0 1 64 768V320a128 128 0 0 1 128-128z"
}, null, -1);
const _hoisted_3$32 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 512h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96v-96a32 32 0 0 1 64 0v96zM352 128v64h320v-64H352zm-32-64h384a32 32 0 0 1 32 32v128a32 32 0 0 1-32 32H320a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_4$X = [
  _hoisted_2$3e,
  _hoisted_3$32
];
function _sfc_render$3r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3w, _hoisted_4$X);
}
var firstAidKit = /* @__PURE__ */ _export_sfc$1(_sfc_main$3V, [["render", _sfc_render$3r]]);
const _sfc_main$3U = defineComponent({
  name: "Flag"
});
const _hoisted_1$3v = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3d = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 128h608L736 384l160 256H288v320h-96V64h96v64z"
}, null, -1);
const _hoisted_3$31 = [
  _hoisted_2$3d
];
function _sfc_render$3q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3v, _hoisted_3$31);
}
var flag = /* @__PURE__ */ _export_sfc$1(_sfc_main$3U, [["render", _sfc_render$3q]]);
const _sfc_main$3T = defineComponent({
  name: "Fold"
});
const _hoisted_1$3u = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M896 192H128v128h768V192zm0 256H384v128h512V448zm0 256H128v128h768V704zM320 384 128 512l192 128V384z"
}, null, -1);
const _hoisted_3$30 = [
  _hoisted_2$3c
];
function _sfc_render$3p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3u, _hoisted_3$30);
}
var fold = /* @__PURE__ */ _export_sfc$1(_sfc_main$3T, [["render", _sfc_render$3p]]);
const _sfc_main$3S = defineComponent({
  name: "FolderAdd"
});
const _hoisted_1$3t = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3b = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm384 416V416h64v128h128v64H544v128h-64V608H352v-64h128z"
}, null, -1);
const _hoisted_3$2$ = [
  _hoisted_2$3b
];
function _sfc_render$3o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3t, _hoisted_3$2$);
}
var folderAdd = /* @__PURE__ */ _export_sfc$1(_sfc_main$3S, [["render", _sfc_render$3o]]);
const _sfc_main$3R = defineComponent({
  name: "FolderChecked"
});
const _hoisted_1$3s = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3a = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm414.08 502.144 180.992-180.992L736.32 494.4 510.08 720.64l-158.4-158.336 45.248-45.312L510.08 630.144z"
}, null, -1);
const _hoisted_3$2_ = [
  _hoisted_2$3a
];
function _sfc_render$3n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3s, _hoisted_3$2_);
}
var folderChecked = /* @__PURE__ */ _export_sfc$1(_sfc_main$3R, [["render", _sfc_render$3n]]);
const _sfc_main$3Q = defineComponent({
  name: "FolderDelete"
});
const _hoisted_1$3r = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$39 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm370.752 448-90.496-90.496 45.248-45.248L512 530.752l90.496-90.496 45.248 45.248L557.248 576l90.496 90.496-45.248 45.248L512 621.248l-90.496 90.496-45.248-45.248L466.752 576z"
}, null, -1);
const _hoisted_3$2Z = [
  _hoisted_2$39
];
function _sfc_render$3m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3r, _hoisted_3$2Z);
}
var folderDelete = /* @__PURE__ */ _export_sfc$1(_sfc_main$3Q, [["render", _sfc_render$3m]]);
const _sfc_main$3P = defineComponent({
  name: "FolderOpened"
});
const _hoisted_1$3q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$38 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M878.08 448H241.92l-96 384h636.16l96-384zM832 384v-64H485.76L357.504 192H128v448l57.92-231.744A32 32 0 0 1 216.96 384H832zm-24.96 512H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h287.872l128.384 128H864a32 32 0 0 1 32 32v96h23.04a32 32 0 0 1 31.04 39.744l-112 448A32 32 0 0 1 807.04 896z"
}, null, -1);
const _hoisted_3$2Y = [
  _hoisted_2$38
];
function _sfc_render$3l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3q, _hoisted_3$2Y);
}
var folderOpened = /* @__PURE__ */ _export_sfc$1(_sfc_main$3P, [["render", _sfc_render$3l]]);
const _sfc_main$3O = defineComponent({
  name: "FolderRemove"
});
const _hoisted_1$3p = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$37 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32zm256 416h320v64H352v-64z"
}, null, -1);
const _hoisted_3$2X = [
  _hoisted_2$37
];
function _sfc_render$3k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3p, _hoisted_3$2X);
}
var folderRemove = /* @__PURE__ */ _export_sfc$1(_sfc_main$3O, [["render", _sfc_render$3k]]);
const _sfc_main$3N = defineComponent({
  name: "Folder"
});
const _hoisted_1$3o = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$36 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 192v640h768V320H485.76L357.504 192H128zm-32-64h287.872l128.384 128H928a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$2W = [
  _hoisted_2$36
];
function _sfc_render$3j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3o, _hoisted_3$2W);
}
var folder = /* @__PURE__ */ _export_sfc$1(_sfc_main$3N, [["render", _sfc_render$3j]]);
const _sfc_main$3M = defineComponent({
  name: "Food"
});
const _hoisted_1$3n = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$35 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 352.576V352a288 288 0 0 1 491.072-204.224 192 192 0 0 1 274.24 204.48 64 64 0 0 1 57.216 74.24C921.6 600.512 850.048 710.656 736 756.992V800a96 96 0 0 1-96 96H384a96 96 0 0 1-96-96v-43.008c-114.048-46.336-185.6-156.48-214.528-330.496A64 64 0 0 1 128 352.64zm64-.576h64a160 160 0 0 1 320 0h64a224 224 0 0 0-448 0zm128 0h192a96 96 0 0 0-192 0zm439.424 0h68.544A128.256 128.256 0 0 0 704 192c-15.36 0-29.952 2.688-43.52 7.616 11.328 18.176 20.672 37.76 27.84 58.304A64.128 64.128 0 0 1 759.424 352zM672 768H352v32a32 32 0 0 0 32 32h256a32 32 0 0 0 32-32v-32zm-342.528-64h365.056c101.504-32.64 165.76-124.928 192.896-288H136.576c27.136 163.072 91.392 255.36 192.896 288z"
}, null, -1);
const _hoisted_3$2V = [
  _hoisted_2$35
];
function _sfc_render$3i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3n, _hoisted_3$2V);
}
var food = /* @__PURE__ */ _export_sfc$1(_sfc_main$3M, [["render", _sfc_render$3i]]);
const _sfc_main$3L = defineComponent({
  name: "Football"
});
const _hoisted_1$3m = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$34 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896zm0-64a384 384 0 1 0 0-768 384 384 0 0 0 0 768z"
}, null, -1);
const _hoisted_3$2U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M186.816 268.288c16-16.384 31.616-31.744 46.976-46.08 17.472 30.656 39.808 58.112 65.984 81.28l-32.512 56.448a385.984 385.984 0 0 1-80.448-91.648zm653.696-5.312a385.92 385.92 0 0 1-83.776 96.96l-32.512-56.384a322.923 322.923 0 0 0 68.48-85.76c15.552 14.08 31.488 29.12 47.808 45.184zM465.984 445.248l11.136-63.104a323.584 323.584 0 0 0 69.76 0l11.136 63.104a387.968 387.968 0 0 1-92.032 0zm-62.72-12.8A381.824 381.824 0 0 1 320 396.544l32-55.424a319.885 319.885 0 0 0 62.464 27.712l-11.2 63.488zm300.8-35.84a381.824 381.824 0 0 1-83.328 35.84l-11.2-63.552A319.885 319.885 0 0 0 672 341.184l32 55.424zm-520.768 364.8a385.92 385.92 0 0 1 83.968-97.28l32.512 56.32c-26.88 23.936-49.856 52.352-67.52 84.032-16-13.44-32.32-27.712-48.96-43.072zm657.536.128a1442.759 1442.759 0 0 1-49.024 43.072 321.408 321.408 0 0 0-67.584-84.16l32.512-56.32c33.216 27.456 61.696 60.352 84.096 97.408zM465.92 578.752a387.968 387.968 0 0 1 92.032 0l-11.136 63.104a323.584 323.584 0 0 0-69.76 0l-11.136-63.104zm-62.72 12.8 11.2 63.552a319.885 319.885 0 0 0-62.464 27.712L320 627.392a381.824 381.824 0 0 1 83.264-35.84zm300.8 35.84-32 55.424a318.272 318.272 0 0 0-62.528-27.712l11.2-63.488c29.44 8.64 57.28 20.736 83.264 35.776z"
}, null, -1);
const _hoisted_4$W = [
  _hoisted_2$34,
  _hoisted_3$2U
];
function _sfc_render$3h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3m, _hoisted_4$W);
}
var football = /* @__PURE__ */ _export_sfc$1(_sfc_main$3L, [["render", _sfc_render$3h]]);
const _sfc_main$3K = defineComponent({
  name: "ForkSpoon"
});
const _hoisted_1$3l = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$33 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 410.304V96a32 32 0 0 1 64 0v314.304a96 96 0 0 0 64-90.56V96a32 32 0 0 1 64 0v223.744a160 160 0 0 1-128 156.8V928a32 32 0 1 1-64 0V476.544a160 160 0 0 1-128-156.8V96a32 32 0 0 1 64 0v223.744a96 96 0 0 0 64 90.56zM672 572.48C581.184 552.128 512 446.848 512 320c0-141.44 85.952-256 192-256s192 114.56 192 256c0 126.848-69.184 232.128-160 252.48V928a32 32 0 1 1-64 0V572.48zM704 512c66.048 0 128-82.56 128-192s-61.952-192-128-192-128 82.56-128 192 61.952 192 128 192z"
}, null, -1);
const _hoisted_3$2T = [
  _hoisted_2$33
];
function _sfc_render$3g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3l, _hoisted_3$2T);
}
var forkSpoon = /* @__PURE__ */ _export_sfc$1(_sfc_main$3K, [["render", _sfc_render$3g]]);
const _sfc_main$3J = defineComponent({
  name: "Fries"
});
const _hoisted_1$3k = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$32 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M608 224v-64a32 32 0 0 0-64 0v336h26.88A64 64 0 0 0 608 484.096V224zm101.12 160A64 64 0 0 0 672 395.904V384h64V224a32 32 0 1 0-64 0v160h37.12zm74.88 0a92.928 92.928 0 0 1 91.328 110.08l-60.672 323.584A96 96 0 0 1 720.32 896H303.68a96 96 0 0 1-94.336-78.336L148.672 494.08A92.928 92.928 0 0 1 240 384h-16V224a96 96 0 0 1 188.608-25.28A95.744 95.744 0 0 1 480 197.44V160a96 96 0 0 1 188.608-25.28A96 96 0 0 1 800 224v160h-16zM670.784 512a128 128 0 0 1-99.904 48H453.12a128 128 0 0 1-99.84-48H352v-1.536a128.128 128.128 0 0 1-9.984-14.976L314.88 448H240a28.928 28.928 0 0 0-28.48 34.304L241.088 640h541.824l29.568-157.696A28.928 28.928 0 0 0 784 448h-74.88l-27.136 47.488A132.405 132.405 0 0 1 672 510.464V512h-1.216zM480 288a32 32 0 0 0-64 0v196.096A64 64 0 0 0 453.12 496H480V288zm-128 96V224a32 32 0 0 0-64 0v160h64-37.12A64 64 0 0 1 352 395.904zm-98.88 320 19.072 101.888A32 32 0 0 0 303.68 832h416.64a32 32 0 0 0 31.488-26.112L770.88 704H253.12z"
}, null, -1);
const _hoisted_3$2S = [
  _hoisted_2$32
];
function _sfc_render$3f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3k, _hoisted_3$2S);
}
var fries = /* @__PURE__ */ _export_sfc$1(_sfc_main$3J, [["render", _sfc_render$3f]]);
const _sfc_main$3I = defineComponent({
  name: "FullScreen"
});
const _hoisted_1$3j = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$31 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
}, null, -1);
const _hoisted_3$2R = [
  _hoisted_2$31
];
function _sfc_render$3e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3j, _hoisted_3$2R);
}
var fullScreen = /* @__PURE__ */ _export_sfc$1(_sfc_main$3I, [["render", _sfc_render$3e]]);
const _sfc_main$3H = defineComponent({
  name: "GobletFull"
});
const _hoisted_1$3i = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$30 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 320h512c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320zm503.936 64H264.064a256.128 256.128 0 0 0 495.872 0zM544 638.4V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.4A320 320 0 0 1 192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 0 1-288 318.4z"
}, null, -1);
const _hoisted_3$2Q = [
  _hoisted_2$30
];
function _sfc_render$3d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3i, _hoisted_3$2Q);
}
var gobletFull = /* @__PURE__ */ _export_sfc$1(_sfc_main$3H, [["render", _sfc_render$3d]]);
const _sfc_main$3G = defineComponent({
  name: "GobletSquareFull"
});
const _hoisted_1$3h = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2$ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 270.912c10.048 6.72 22.464 14.912 28.992 18.624a220.16 220.16 0 0 0 114.752 30.72c30.592 0 49.408-9.472 91.072-41.152l.64-.448c52.928-40.32 82.368-55.04 132.288-54.656 55.552.448 99.584 20.8 142.72 57.408l1.536 1.28V128H256v142.912zm.96 76.288C266.368 482.176 346.88 575.872 512 576c157.44.064 237.952-85.056 253.248-209.984a952.32 952.32 0 0 1-40.192-35.712c-32.704-27.776-63.36-41.92-101.888-42.24-31.552-.256-50.624 9.28-93.12 41.6l-.576.448c-52.096 39.616-81.024 54.208-129.792 54.208-54.784 0-100.48-13.376-142.784-37.056zM480 638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v224c0 122.816-58.624 303.68-288 318.912V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.848z"
}, null, -1);
const _hoisted_3$2P = [
  _hoisted_2$2$
];
function _sfc_render$3c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3h, _hoisted_3$2P);
}
var gobletSquareFull = /* @__PURE__ */ _export_sfc$1(_sfc_main$3G, [["render", _sfc_render$3c]]);
const _sfc_main$3F = defineComponent({
  name: "GobletSquare"
});
const _hoisted_1$3g = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2_ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 638.912V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.848C250.624 623.424 192 442.496 192 319.68V96a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v224c0 122.816-58.624 303.68-288 318.912zM256 319.68c0 149.568 80 256.192 256 256.256C688.128 576 768 469.568 768 320V128H256v191.68z"
}, null, -1);
const _hoisted_3$2O = [
  _hoisted_2$2_
];
function _sfc_render$3b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3g, _hoisted_3$2O);
}
var gobletSquare = /* @__PURE__ */ _export_sfc$1(_sfc_main$3F, [["render", _sfc_render$3b]]);
const _sfc_main$3E = defineComponent({
  name: "Goblet"
});
const _hoisted_1$3f = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2Z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 638.4V896h96a32 32 0 1 1 0 64H384a32 32 0 1 1 0-64h96V638.4A320 320 0 0 1 192 320c0-85.632 21.312-170.944 64-256h512c42.688 64.32 64 149.632 64 256a320 320 0 0 1-288 318.4zM256 320a256 256 0 1 0 512 0c0-78.592-12.608-142.4-36.928-192h-434.24C269.504 192.384 256 256.256 256 320z"
}, null, -1);
const _hoisted_3$2N = [
  _hoisted_2$2Z
];
function _sfc_render$3a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3f, _hoisted_3$2N);
}
var goblet = /* @__PURE__ */ _export_sfc$1(_sfc_main$3E, [["render", _sfc_render$3a]]);
const _sfc_main$3D = defineComponent({
  name: "GoodsFilled"
});
const _hoisted_1$3e = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2Y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 352h640l64 544H128l64-544zm128 224h64V448h-64v128zm320 0h64V448h-64v128zM384 288h-64a192 192 0 1 1 384 0h-64a128 128 0 1 0-256 0z"
}, null, -1);
const _hoisted_3$2M = [
  _hoisted_2$2Y
];
function _sfc_render$39(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3e, _hoisted_3$2M);
}
var goodsFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$3D, [["render", _sfc_render$39]]);
const _sfc_main$3C = defineComponent({
  name: "Goods"
});
const _hoisted_1$3d = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2X = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M320 288v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4h131.072a32 32 0 0 1 31.808 28.8l57.6 576a32 32 0 0 1-31.808 35.2H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320zm64 0h256v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4zm-64 64H217.92l-51.2 512h690.56l-51.264-512H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96z"
}, null, -1);
const _hoisted_3$2L = [
  _hoisted_2$2X
];
function _sfc_render$38(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3d, _hoisted_3$2L);
}
var goods = /* @__PURE__ */ _export_sfc$1(_sfc_main$3C, [["render", _sfc_render$38]]);
const _sfc_main$3B = defineComponent({
  name: "Grape"
});
const _hoisted_1$3c = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2W = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 195.2a160 160 0 0 1 96 60.8 160 160 0 1 1 146.24 254.976 160 160 0 0 1-128 224 160 160 0 1 1-292.48 0 160 160 0 0 1-128-224A160 160 0 1 1 384 256a160 160 0 0 1 96-60.8V128h-64a32 32 0 0 1 0-64h192a32 32 0 0 1 0 64h-64v67.2zM512 448a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm-256 0a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128 224a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128 224a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128-224a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm128-224a96 96 0 1 0 0-192 96 96 0 0 0 0 192z"
}, null, -1);
const _hoisted_3$2K = [
  _hoisted_2$2W
];
function _sfc_render$37(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3c, _hoisted_3$2K);
}
var grape = /* @__PURE__ */ _export_sfc$1(_sfc_main$3B, [["render", _sfc_render$37]]);
const _sfc_main$3A = defineComponent({
  name: "Grid"
});
const _hoisted_1$3b = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2V = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
}, null, -1);
const _hoisted_3$2J = [
  _hoisted_2$2V
];
function _sfc_render$36(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3b, _hoisted_3$2J);
}
var grid = /* @__PURE__ */ _export_sfc$1(_sfc_main$3A, [["render", _sfc_render$36]]);
const _sfc_main$3z = defineComponent({
  name: "Guide"
});
const _hoisted_1$3a = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 608h-64V416h64v192zm0 160v160a32 32 0 0 1-32 32H416a32 32 0 0 1-32-32V768h64v128h128V768h64zM384 608V416h64v192h-64zm256-352h-64V128H448v128h-64V96a32 32 0 0 1 32-32h192a32 32 0 0 1 32 32v160z"
}, null, -1);
const _hoisted_3$2I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m220.8 256-71.232 80 71.168 80H768V256H220.8zm-14.4-64H800a32 32 0 0 1 32 32v224a32 32 0 0 1-32 32H206.4a32 32 0 0 1-23.936-10.752l-99.584-112a32 32 0 0 1 0-42.496l99.584-112A32 32 0 0 1 206.4 192zm678.784 496-71.104 80H266.816V608h547.2l71.168 80zm-56.768-144H234.88a32 32 0 0 0-32 32v224a32 32 0 0 0 32 32h593.6a32 32 0 0 0 23.936-10.752l99.584-112a32 32 0 0 0 0-42.496l-99.584-112A32 32 0 0 0 828.48 544z"
}, null, -1);
const _hoisted_4$V = [
  _hoisted_2$2U,
  _hoisted_3$2I
];
function _sfc_render$35(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3a, _hoisted_4$V);
}
var guide = /* @__PURE__ */ _export_sfc$1(_sfc_main$3z, [["render", _sfc_render$35]]);
const _sfc_main$3y = defineComponent({
  name: "Headset"
});
const _hoisted_1$39 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2T = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M896 529.152V512a384 384 0 1 0-768 0v17.152A128 128 0 0 1 320 640v128a128 128 0 1 1-256 0V512a448 448 0 1 1 896 0v256a128 128 0 1 1-256 0V640a128 128 0 0 1 192-110.848zM896 640a64 64 0 0 0-128 0v128a64 64 0 0 0 128 0V640zm-768 0v128a64 64 0 0 0 128 0V640a64 64 0 1 0-128 0z"
}, null, -1);
const _hoisted_3$2H = [
  _hoisted_2$2T
];
function _sfc_render$34(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$39, _hoisted_3$2H);
}
var headset = /* @__PURE__ */ _export_sfc$1(_sfc_main$3y, [["render", _sfc_render$34]]);
const _sfc_main$3x = defineComponent({
  name: "HelpFilled"
});
const _hoisted_1$38 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2S = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M926.784 480H701.312A192.512 192.512 0 0 0 544 322.688V97.216A416.064 416.064 0 0 1 926.784 480zm0 64A416.064 416.064 0 0 1 544 926.784V701.312A192.512 192.512 0 0 0 701.312 544h225.472zM97.28 544h225.472A192.512 192.512 0 0 0 480 701.312v225.472A416.064 416.064 0 0 1 97.216 544zm0-64A416.064 416.064 0 0 1 480 97.216v225.472A192.512 192.512 0 0 0 322.688 480H97.216z"
}, null, -1);
const _hoisted_3$2G = [
  _hoisted_2$2S
];
function _sfc_render$33(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$38, _hoisted_3$2G);
}
var helpFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$3x, [["render", _sfc_render$33]]);
const _sfc_main$3w = defineComponent({
  name: "Help"
});
const _hoisted_1$37 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m759.936 805.248-90.944-91.008A254.912 254.912 0 0 1 512 768a254.912 254.912 0 0 1-156.992-53.76l-90.944 91.008A382.464 382.464 0 0 0 512 896c94.528 0 181.12-34.176 247.936-90.752zm45.312-45.312A382.464 382.464 0 0 0 896 512c0-94.528-34.176-181.12-90.752-247.936l-91.008 90.944C747.904 398.4 768 452.864 768 512c0 59.136-20.096 113.6-53.76 156.992l91.008 90.944zm-45.312-541.184A382.464 382.464 0 0 0 512 128c-94.528 0-181.12 34.176-247.936 90.752l90.944 91.008A254.912 254.912 0 0 1 512 256c59.136 0 113.6 20.096 156.992 53.76l90.944-91.008zm-541.184 45.312A382.464 382.464 0 0 0 128 512c0 94.528 34.176 181.12 90.752 247.936l91.008-90.944A254.912 254.912 0 0 1 256 512c0-59.136 20.096-113.6 53.76-156.992l-91.008-90.944zm417.28 394.496a194.56 194.56 0 0 0 22.528-22.528C686.912 602.56 704 559.232 704 512a191.232 191.232 0 0 0-67.968-146.56A191.296 191.296 0 0 0 512 320a191.232 191.232 0 0 0-146.56 67.968C337.088 421.44 320 464.768 320 512a191.232 191.232 0 0 0 67.968 146.56C421.44 686.912 464.768 704 512 704c47.296 0 90.56-17.088 124.032-45.44zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_3$2F = [
  _hoisted_2$2R
];
function _sfc_render$32(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$37, _hoisted_3$2F);
}
var help = /* @__PURE__ */ _export_sfc$1(_sfc_main$3w, [["render", _sfc_render$32]]);
const _sfc_main$3v = defineComponent({
  name: "Hide"
});
const _hoisted_1$36 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2Q = /* @__PURE__ */ createElementVNode("path", {
  d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$2E = /* @__PURE__ */ createElementVNode("path", {
  d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",
  fill: "currentColor"
}, null, -1);
const _hoisted_4$U = [
  _hoisted_2$2Q,
  _hoisted_3$2E
];
function _sfc_render$31(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$36, _hoisted_4$U);
}
var hide$2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$3v, [["render", _sfc_render$31]]);
const _sfc_main$3u = defineComponent({
  name: "Histogram"
});
const _hoisted_1$35 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2P = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M416 896V128h192v768H416zm-288 0V448h192v448H128zm576 0V320h192v576H704z"
}, null, -1);
const _hoisted_3$2D = [
  _hoisted_2$2P
];
function _sfc_render$30(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$35, _hoisted_3$2D);
}
var histogram = /* @__PURE__ */ _export_sfc$1(_sfc_main$3u, [["render", _sfc_render$30]]);
const _sfc_main$3t = defineComponent({
  name: "HomeFilled"
});
const _hoisted_1$34 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2O = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 128 128 447.936V896h255.936V640H640v256h255.936V447.936z"
}, null, -1);
const _hoisted_3$2C = [
  _hoisted_2$2O
];
function _sfc_render$2$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$34, _hoisted_3$2C);
}
var homeFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$3t, [["render", _sfc_render$2$]]);
const _sfc_main$3s = defineComponent({
  name: "HotWater"
});
const _hoisted_1$33 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2N = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M273.067 477.867h477.866V409.6H273.067v68.267zm0 68.266v51.2A187.733 187.733 0 0 0 460.8 785.067h102.4a187.733 187.733 0 0 0 187.733-187.734v-51.2H273.067zm-34.134-204.8h546.134a34.133 34.133 0 0 1 34.133 34.134v221.866a256 256 0 0 1-256 256H460.8a256 256 0 0 1-256-256V375.467a34.133 34.133 0 0 1 34.133-34.134zM512 34.133a34.133 34.133 0 0 1 34.133 34.134v170.666a34.133 34.133 0 0 1-68.266 0V68.267A34.133 34.133 0 0 1 512 34.133zM375.467 102.4a34.133 34.133 0 0 1 34.133 34.133v102.4a34.133 34.133 0 0 1-68.267 0v-102.4a34.133 34.133 0 0 1 34.134-34.133zm273.066 0a34.133 34.133 0 0 1 34.134 34.133v102.4a34.133 34.133 0 1 1-68.267 0v-102.4a34.133 34.133 0 0 1 34.133-34.133zM170.667 921.668h682.666a34.133 34.133 0 1 1 0 68.267H170.667a34.133 34.133 0 1 1 0-68.267z"
}, null, -1);
const _hoisted_3$2B = [
  _hoisted_2$2N
];
function _sfc_render$2_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$33, _hoisted_3$2B);
}
var hotWater = /* @__PURE__ */ _export_sfc$1(_sfc_main$3s, [["render", _sfc_render$2_]]);
const _sfc_main$3r = defineComponent({
  name: "House"
});
const _hoisted_1$32 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2M = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 413.952V896h640V413.952L512 147.328 192 413.952zM139.52 374.4l352-293.312a32 32 0 0 1 40.96 0l352 293.312A32 32 0 0 1 896 398.976V928a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V398.976a32 32 0 0 1 11.52-24.576z"
}, null, -1);
const _hoisted_3$2A = [
  _hoisted_2$2M
];
function _sfc_render$2Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$32, _hoisted_3$2A);
}
var house = /* @__PURE__ */ _export_sfc$1(_sfc_main$3r, [["render", _sfc_render$2Z]]);
const _sfc_main$3q = defineComponent({
  name: "IceCreamRound"
});
const _hoisted_1$31 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m308.352 489.344 226.304 226.304a32 32 0 0 0 45.248 0L783.552 512A192 192 0 1 0 512 240.448L308.352 444.16a32 32 0 0 0 0 45.248zm135.744 226.304L308.352 851.392a96 96 0 0 1-135.744-135.744l135.744-135.744-45.248-45.248a96 96 0 0 1 0-135.808L466.752 195.2A256 256 0 0 1 828.8 557.248L625.152 760.96a96 96 0 0 1-135.808 0l-45.248-45.248zM398.848 670.4 353.6 625.152 217.856 760.896a32 32 0 0 0 45.248 45.248L398.848 670.4zm248.96-384.64a32 32 0 0 1 0 45.248L466.624 512a32 32 0 1 1-45.184-45.248l180.992-181.056a32 32 0 0 1 45.248 0zm90.496 90.496a32 32 0 0 1 0 45.248L557.248 602.496A32 32 0 1 1 512 557.248l180.992-180.992a32 32 0 0 1 45.312 0z"
}, null, -1);
const _hoisted_3$2z = [
  _hoisted_2$2L
];
function _sfc_render$2Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$31, _hoisted_3$2z);
}
var iceCreamRound = /* @__PURE__ */ _export_sfc$1(_sfc_main$3q, [["render", _sfc_render$2Y]]);
const _sfc_main$3p = defineComponent({
  name: "IceCreamSquare"
});
const _hoisted_1$30 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2K = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M416 640h256a32 32 0 0 0 32-32V160a32 32 0 0 0-32-32H352a32 32 0 0 0-32 32v448a32 32 0 0 0 32 32h64zm192 64v160a96 96 0 0 1-192 0V704h-64a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96h320a96 96 0 0 1 96 96v448a96 96 0 0 1-96 96h-64zm-64 0h-64v160a32 32 0 1 0 64 0V704z"
}, null, -1);
const _hoisted_3$2y = [
  _hoisted_2$2K
];
function _sfc_render$2X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$30, _hoisted_3$2y);
}
var iceCreamSquare = /* @__PURE__ */ _export_sfc$1(_sfc_main$3p, [["render", _sfc_render$2X]]);
const _sfc_main$3o = defineComponent({
  name: "IceCream"
});
const _hoisted_1$2$ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2J = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128.64 448a208 208 0 0 1 193.536-191.552 224 224 0 0 1 445.248 15.488A208.128 208.128 0 0 1 894.784 448H896L548.8 983.68a32 32 0 0 1-53.248.704L128 448h.64zm64.256 0h286.208a144 144 0 0 0-286.208 0zm351.36 0h286.272a144 144 0 0 0-286.272 0zm-294.848 64 271.808 396.608L778.24 512H249.408zM511.68 352.64a207.872 207.872 0 0 1 189.184-96.192 160 160 0 0 0-314.752 5.632c52.608 12.992 97.28 46.08 125.568 90.56z"
}, null, -1);
const _hoisted_3$2x = [
  _hoisted_2$2J
];
function _sfc_render$2W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2$, _hoisted_3$2x);
}
var iceCream = /* @__PURE__ */ _export_sfc$1(_sfc_main$3o, [["render", _sfc_render$2W]]);
const _sfc_main$3n = defineComponent({
  name: "IceDrink"
});
const _hoisted_1$2_ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 448v128h239.68l16.064-128H512zm-64 0H256.256l16.064 128H448V448zm64-255.36V384h247.744A256.128 256.128 0 0 0 512 192.64zm-64 8.064A256.448 256.448 0 0 0 264.256 384H448V200.704zm64-72.064A320.128 320.128 0 0 1 825.472 384H896a32 32 0 1 1 0 64h-64v1.92l-56.96 454.016A64 64 0 0 1 711.552 960H312.448a64 64 0 0 1-63.488-56.064L192 449.92V448h-64a32 32 0 0 1 0-64h70.528A320.384 320.384 0 0 1 448 135.04V96a96 96 0 0 1 96-96h128a32 32 0 1 1 0 64H544a32 32 0 0 0-32 32v32.64zM743.68 640H280.32l32.128 256h399.104l32.128-256z"
}, null, -1);
const _hoisted_3$2w = [
  _hoisted_2$2I
];
function _sfc_render$2V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2_, _hoisted_3$2w);
}
var iceDrink = /* @__PURE__ */ _export_sfc$1(_sfc_main$3n, [["render", _sfc_render$2V]]);
const _sfc_main$3m = defineComponent({
  name: "IceTea"
});
const _hoisted_1$2Z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2H = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M197.696 259.648a320.128 320.128 0 0 1 628.608 0A96 96 0 0 1 896 352v64a96 96 0 0 1-71.616 92.864l-49.408 395.072A64 64 0 0 1 711.488 960H312.512a64 64 0 0 1-63.488-56.064l-49.408-395.072A96 96 0 0 1 128 416v-64a96 96 0 0 1 69.696-92.352zM264.064 256h495.872a256.128 256.128 0 0 0-495.872 0zm495.424 256H264.512l48 384h398.976l48-384zM224 448h576a32 32 0 0 0 32-32v-64a32 32 0 0 0-32-32H224a32 32 0 0 0-32 32v64a32 32 0 0 0 32 32zm160 192h64v64h-64v-64zm192 64h64v64h-64v-64zm-128 64h64v64h-64v-64zm64-192h64v64h-64v-64z"
}, null, -1);
const _hoisted_3$2v = [
  _hoisted_2$2H
];
function _sfc_render$2U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2Z, _hoisted_3$2v);
}
var iceTea = /* @__PURE__ */ _export_sfc$1(_sfc_main$3m, [["render", _sfc_render$2U]]);
const _sfc_main$3l = defineComponent({
  name: "InfoFilled"
});
const _hoisted_1$2Y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2G = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1);
const _hoisted_3$2u = [
  _hoisted_2$2G
];
function _sfc_render$2T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2Y, _hoisted_3$2u);
}
var infoFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$3l, [["render", _sfc_render$2T]]);
const _sfc_main$3k = defineComponent({
  name: "Iphone"
});
const _hoisted_1$2X = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 768v96.064a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64V768H224zm0-64h576V160a64 64 0 0 0-64-64H288a64 64 0 0 0-64 64v544zm32 288a96 96 0 0 1-96-96V128a96 96 0 0 1 96-96h512a96 96 0 0 1 96 96v768a96 96 0 0 1-96 96H256zm304-144a48 48 0 1 1-96 0 48 48 0 0 1 96 0z"
}, null, -1);
const _hoisted_3$2t = [
  _hoisted_2$2F
];
function _sfc_render$2S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2X, _hoisted_3$2t);
}
var iphone = /* @__PURE__ */ _export_sfc$1(_sfc_main$3k, [["render", _sfc_render$2S]]);
const _sfc_main$3j = defineComponent({
  name: "Key"
});
const _hoisted_1$2W = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M448 456.064V96a32 32 0 0 1 32-32.064L672 64a32 32 0 0 1 0 64H512v128h160a32 32 0 0 1 0 64H512v128a256 256 0 1 1-64 8.064zM512 896a192 192 0 1 0 0-384 192 192 0 0 0 0 384z"
}, null, -1);
const _hoisted_3$2s = [
  _hoisted_2$2E
];
function _sfc_render$2R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2W, _hoisted_3$2s);
}
var key = /* @__PURE__ */ _export_sfc$1(_sfc_main$3j, [["render", _sfc_render$2R]]);
const _sfc_main$3i = defineComponent({
  name: "KnifeFork"
});
const _hoisted_1$2V = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 410.56V96a32 32 0 0 1 64 0v314.56A96 96 0 0 0 384 320V96a32 32 0 0 1 64 0v224a160 160 0 0 1-128 156.8V928a32 32 0 1 1-64 0V476.8A160 160 0 0 1 128 320V96a32 32 0 0 1 64 0v224a96 96 0 0 0 64 90.56zm384-250.24V544h126.72c-3.328-78.72-12.928-147.968-28.608-207.744-14.336-54.528-46.848-113.344-98.112-175.872zM640 608v320a32 32 0 1 1-64 0V64h64c85.312 89.472 138.688 174.848 160 256 21.312 81.152 32 177.152 32 288H640z"
}, null, -1);
const _hoisted_3$2r = [
  _hoisted_2$2D
];
function _sfc_render$2Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2V, _hoisted_3$2r);
}
var knifeFork = /* @__PURE__ */ _export_sfc$1(_sfc_main$3i, [["render", _sfc_render$2Q]]);
const _sfc_main$3h = defineComponent({
  name: "Lightning"
});
const _hoisted_1$2U = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2C = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 671.36v64.128A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 736 734.016v-64.768a192 192 0 0 0 3.328-377.92l-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 91.968 70.464 167.36 160.256 175.232z"
}, null, -1);
const _hoisted_3$2q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M416 736a32 32 0 0 1-27.776-47.872l128-224a32 32 0 1 1 55.552 31.744L471.168 672H608a32 32 0 0 1 27.776 47.872l-128 224a32 32 0 1 1-55.68-31.744L552.96 736H416z"
}, null, -1);
const _hoisted_4$T = [
  _hoisted_2$2C,
  _hoisted_3$2q
];
function _sfc_render$2P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2U, _hoisted_4$T);
}
var lightning = /* @__PURE__ */ _export_sfc$1(_sfc_main$3h, [["render", _sfc_render$2P]]);
const _sfc_main$3g = defineComponent({
  name: "Link"
});
const _hoisted_1$2T = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2B = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M715.648 625.152 670.4 579.904l90.496-90.56c75.008-74.944 85.12-186.368 22.656-248.896-62.528-62.464-173.952-52.352-248.96 22.656L444.16 353.6l-45.248-45.248 90.496-90.496c100.032-99.968 251.968-110.08 339.456-22.656 87.488 87.488 77.312 239.424-22.656 339.456l-90.496 90.496zm-90.496 90.496-90.496 90.496C434.624 906.112 282.688 916.224 195.2 828.8c-87.488-87.488-77.312-239.424 22.656-339.456l90.496-90.496 45.248 45.248-90.496 90.56c-75.008 74.944-85.12 186.368-22.656 248.896 62.528 62.464 173.952 52.352 248.96-22.656l90.496-90.496 45.248 45.248zm0-362.048 45.248 45.248L398.848 670.4 353.6 625.152 625.152 353.6z"
}, null, -1);
const _hoisted_3$2p = [
  _hoisted_2$2B
];
function _sfc_render$2O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2T, _hoisted_3$2p);
}
var link = /* @__PURE__ */ _export_sfc$1(_sfc_main$3g, [["render", _sfc_render$2O]]);
const _sfc_main$3f = defineComponent({
  name: "List"
});
const _hoisted_1$2S = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2A = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 192h160v736H160V192h160v64h384v-64zM288 512h448v-64H288v64zm0 256h448v-64H288v64zm96-576V96h256v96H384z"
}, null, -1);
const _hoisted_3$2o = [
  _hoisted_2$2A
];
function _sfc_render$2N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2S, _hoisted_3$2o);
}
var list = /* @__PURE__ */ _export_sfc$1(_sfc_main$3f, [["render", _sfc_render$2N]]);
const _sfc_main$3e = defineComponent({
  name: "Loading"
});
const _hoisted_1$2R = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
}, null, -1);
const _hoisted_3$2n = [
  _hoisted_2$2z
];
function _sfc_render$2M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2R, _hoisted_3$2n);
}
var loading = /* @__PURE__ */ _export_sfc$1(_sfc_main$3e, [["render", _sfc_render$2M]]);
const _sfc_main$3d = defineComponent({
  name: "LocationFilled"
});
const _hoisted_1$2Q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 928c23.936 0 117.504-68.352 192.064-153.152C803.456 661.888 864 535.808 864 416c0-189.632-155.84-320-352-320S160 226.368 160 416c0 120.32 60.544 246.4 159.936 359.232C394.432 859.84 488 928 512 928zm0-435.2a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 140.8a204.8 204.8 0 1 1 0-409.6 204.8 204.8 0 0 1 0 409.6z"
}, null, -1);
const _hoisted_3$2m = [
  _hoisted_2$2y
];
function _sfc_render$2L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2Q, _hoisted_3$2m);
}
var locationFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$3d, [["render", _sfc_render$2L]]);
const _sfc_main$3c = defineComponent({
  name: "LocationInformation"
});
const _hoisted_1$2P = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2x = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 896h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$2l = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_4$S = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 512a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm0 64a160 160 0 1 1 0-320 160 160 0 0 1 0 320z"
}, null, -1);
const _hoisted_5$k = [
  _hoisted_2$2x,
  _hoisted_3$2l,
  _hoisted_4$S
];
function _sfc_render$2K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2P, _hoisted_5$k);
}
var locationInformation = /* @__PURE__ */ _export_sfc$1(_sfc_main$3c, [["render", _sfc_render$2K]]);
const _sfc_main$3b = defineComponent({
  name: "Location"
});
const _hoisted_1$2O = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2w = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_3$2k = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 512a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm0 64a160 160 0 1 1 0-320 160 160 0 0 1 0 320z"
}, null, -1);
const _hoisted_4$R = [
  _hoisted_2$2w,
  _hoisted_3$2k
];
function _sfc_render$2J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2O, _hoisted_4$R);
}
var location = /* @__PURE__ */ _export_sfc$1(_sfc_main$3b, [["render", _sfc_render$2J]]);
const _sfc_main$3a = defineComponent({
  name: "Lock"
});
const _hoisted_1$2N = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 448a32 32 0 0 0-32 32v384a32 32 0 0 0 32 32h576a32 32 0 0 0 32-32V480a32 32 0 0 0-32-32H224zm0-64h576a96 96 0 0 1 96 96v384a96 96 0 0 1-96 96H224a96 96 0 0 1-96-96V480a96 96 0 0 1 96-96z"
}, null, -1);
const _hoisted_3$2j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 544a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V576a32 32 0 0 1 32-32zm192-160v-64a192 192 0 1 0-384 0v64h384zM512 64a256 256 0 0 1 256 256v128H256V320A256 256 0 0 1 512 64z"
}, null, -1);
const _hoisted_4$Q = [
  _hoisted_2$2v,
  _hoisted_3$2j
];
function _sfc_render$2I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2N, _hoisted_4$Q);
}
var lock = /* @__PURE__ */ _export_sfc$1(_sfc_main$3a, [["render", _sfc_render$2I]]);
const _sfc_main$39 = defineComponent({
  name: "Lollipop"
});
const _hoisted_1$2M = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2u = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M513.28 448a64 64 0 1 1 76.544 49.728A96 96 0 0 0 768 448h64a160 160 0 0 1-320 0h1.28zm-126.976-29.696a256 256 0 1 0 43.52-180.48A256 256 0 0 1 832 448h-64a192 192 0 0 0-381.696-29.696zm105.664 249.472L285.696 874.048a96 96 0 0 1-135.68-135.744l206.208-206.272a320 320 0 1 1 135.744 135.744zm-54.464-36.032a321.92 321.92 0 0 1-45.248-45.248L195.2 783.552a32 32 0 1 0 45.248 45.248l197.056-197.12z"
}, null, -1);
const _hoisted_3$2i = [
  _hoisted_2$2u
];
function _sfc_render$2H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2M, _hoisted_3$2i);
}
var lollipop = /* @__PURE__ */ _export_sfc$1(_sfc_main$39, [["render", _sfc_render$2H]]);
const _sfc_main$38 = defineComponent({
  name: "MagicStick"
});
const _hoisted_1$2L = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2t = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64h64v192h-64V64zm0 576h64v192h-64V640zM160 480v-64h192v64H160zm576 0v-64h192v64H736zM249.856 199.04l45.248-45.184L430.848 289.6 385.6 334.848 249.856 199.104zM657.152 606.4l45.248-45.248 135.744 135.744-45.248 45.248L657.152 606.4zM114.048 923.2 68.8 877.952l316.8-316.8 45.248 45.248-316.8 316.8zM702.4 334.848 657.152 289.6l135.744-135.744 45.248 45.248L702.4 334.848z"
}, null, -1);
const _hoisted_3$2h = [
  _hoisted_2$2t
];
function _sfc_render$2G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2L, _hoisted_3$2h);
}
var magicStick = /* @__PURE__ */ _export_sfc$1(_sfc_main$38, [["render", _sfc_render$2G]]);
const _sfc_main$37 = defineComponent({
  name: "Magnet"
});
const _hoisted_1$2K = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2s = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 320V192H704v320a192 192 0 1 1-384 0V192H192v128h128v64H192v128a320 320 0 0 0 640 0V384H704v-64h128zM640 512V128h256v384a384 384 0 1 1-768 0V128h256v384a128 128 0 1 0 256 0z"
}, null, -1);
const _hoisted_3$2g = [
  _hoisted_2$2s
];
function _sfc_render$2F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2K, _hoisted_3$2g);
}
var magnet = /* @__PURE__ */ _export_sfc$1(_sfc_main$37, [["render", _sfc_render$2F]]);
const _sfc_main$36 = defineComponent({
  name: "Male"
});
const _hoisted_1$2J = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M399.5 849.5a225 225 0 1 0 0-450 225 225 0 0 0 0 450zm0 56.25a281.25 281.25 0 1 1 0-562.5 281.25 281.25 0 0 1 0 562.5zm253.125-787.5h225q28.125 0 28.125 28.125T877.625 174.5h-225q-28.125 0-28.125-28.125t28.125-28.125z"
}, null, -1);
const _hoisted_3$2f = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M877.625 118.25q28.125 0 28.125 28.125v225q0 28.125-28.125 28.125T849.5 371.375v-225q0-28.125 28.125-28.125z"
}, null, -1);
const _hoisted_4$P = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M604.813 458.9 565.1 419.131l292.613-292.668 39.825 39.824z"
}, null, -1);
const _hoisted_5$j = [
  _hoisted_2$2r,
  _hoisted_3$2f,
  _hoisted_4$P
];
function _sfc_render$2E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2J, _hoisted_5$j);
}
var male = /* @__PURE__ */ _export_sfc$1(_sfc_main$36, [["render", _sfc_render$2E]]);
const _sfc_main$35 = defineComponent({
  name: "Management"
});
const _hoisted_1$2I = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M576 128v288l96-96 96 96V128h128v768H320V128h256zm-448 0h128v768H128V128z"
}, null, -1);
const _hoisted_3$2e = [
  _hoisted_2$2q
];
function _sfc_render$2D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2I, _hoisted_3$2e);
}
var management = /* @__PURE__ */ _export_sfc$1(_sfc_main$35, [["render", _sfc_render$2D]]);
const _sfc_main$34 = defineComponent({
  name: "MapLocation"
});
const _hoisted_1$2H = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1);
const _hoisted_3$2d = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256zm345.6 192L960 960H672v-64H352v64H64l102.4-256h691.2zm-68.928 0H235.328l-76.8 192h706.944l-76.8-192z"
}, null, -1);
const _hoisted_4$O = [
  _hoisted_2$2p,
  _hoisted_3$2d
];
function _sfc_render$2C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2H, _hoisted_4$O);
}
var mapLocation = /* @__PURE__ */ _export_sfc$1(_sfc_main$34, [["render", _sfc_render$2C]]);
const _sfc_main$33 = defineComponent({
  name: "Medal"
});
const _hoisted_1$2G = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2o = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a256 256 0 1 0 0-512 256 256 0 0 0 0 512zm0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640z"
}, null, -1);
const _hoisted_3$2c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M576 128H448v200a286.72 286.72 0 0 1 64-8c19.52 0 40.832 2.688 64 8V128zm64 0v219.648c24.448 9.088 50.56 20.416 78.4 33.92L757.44 128H640zm-256 0H266.624l39.04 253.568c27.84-13.504 53.888-24.832 78.336-33.92V128zM229.312 64h565.376a32 32 0 0 1 31.616 36.864L768 480c-113.792-64-199.104-96-256-96-56.896 0-142.208 32-256 96l-58.304-379.136A32 32 0 0 1 229.312 64z"
}, null, -1);
const _hoisted_4$N = [
  _hoisted_2$2o,
  _hoisted_3$2c
];
function _sfc_render$2B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2G, _hoisted_4$N);
}
var medal = /* @__PURE__ */ _export_sfc$1(_sfc_main$33, [["render", _sfc_render$2B]]);
const _sfc_main$32 = defineComponent({
  name: "Menu"
});
const _hoisted_1$2F = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2n = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 448a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32H160zm448 0a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32H608zM160 896a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32H160zm448 0a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32H608z"
}, null, -1);
const _hoisted_3$2b = [
  _hoisted_2$2n
];
function _sfc_render$2A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2F, _hoisted_3$2b);
}
var menu = /* @__PURE__ */ _export_sfc$1(_sfc_main$32, [["render", _sfc_render$2A]]);
const _sfc_main$31 = defineComponent({
  name: "MessageBox"
});
const _hoisted_1$2E = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2m = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 384h448v64H288v-64zm96-128h256v64H384v-64zM131.456 512H384v128h256V512h252.544L721.856 192H302.144L131.456 512zM896 576H704v128H320V576H128v256h768V576zM275.776 128h472.448a32 32 0 0 1 28.608 17.664l179.84 359.552A32 32 0 0 1 960 519.552V864a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V519.552a32 32 0 0 1 3.392-14.336l179.776-359.552A32 32 0 0 1 275.776 128z"
}, null, -1);
const _hoisted_3$2a = [
  _hoisted_2$2m
];
function _sfc_render$2z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2E, _hoisted_3$2a);
}
var messageBox = /* @__PURE__ */ _export_sfc$1(_sfc_main$31, [["render", _sfc_render$2z]]);
const _sfc_main$30 = defineComponent({
  name: "Message"
});
const _hoisted_1$2D = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2l = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 224v512a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V224H128zm0-64h768a64 64 0 0 1 64 64v512a128 128 0 0 1-128 128H192A128 128 0 0 1 64 736V224a64 64 0 0 1 64-64z"
}, null, -1);
const _hoisted_3$29 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M904 224 656.512 506.88a192 192 0 0 1-289.024 0L120 224h784zm-698.944 0 210.56 240.704a128 128 0 0 0 192.704 0L818.944 224H205.056z"
}, null, -1);
const _hoisted_4$M = [
  _hoisted_2$2l,
  _hoisted_3$29
];
function _sfc_render$2y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2D, _hoisted_4$M);
}
var message = /* @__PURE__ */ _export_sfc$1(_sfc_main$30, [["render", _sfc_render$2y]]);
const _sfc_main$2$ = defineComponent({
  name: "Mic"
});
const _hoisted_1$2C = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2k = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 704h160a64 64 0 0 0 64-64v-32h-96a32 32 0 0 1 0-64h96v-96h-96a32 32 0 0 1 0-64h96v-96h-96a32 32 0 0 1 0-64h96v-32a64 64 0 0 0-64-64H384a64 64 0 0 0-64 64v32h96a32 32 0 0 1 0 64h-96v96h96a32 32 0 0 1 0 64h-96v96h96a32 32 0 0 1 0 64h-96v32a64 64 0 0 0 64 64h96zm64 64v128h192a32 32 0 1 1 0 64H288a32 32 0 1 1 0-64h192V768h-96a128 128 0 0 1-128-128V192A128 128 0 0 1 384 64h256a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128h-96z"
}, null, -1);
const _hoisted_3$28 = [
  _hoisted_2$2k
];
function _sfc_render$2x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2C, _hoisted_3$28);
}
var mic = /* @__PURE__ */ _export_sfc$1(_sfc_main$2$, [["render", _sfc_render$2x]]);
const _sfc_main$2_ = defineComponent({
  name: "Microphone"
});
const _hoisted_1$2B = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 128a128 128 0 0 0-128 128v256a128 128 0 1 0 256 0V256a128 128 0 0 0-128-128zm0-64a192 192 0 0 1 192 192v256a192 192 0 1 1-384 0V256A192 192 0 0 1 512 64zm-32 832v-64a288 288 0 0 1-288-288v-32a32 32 0 0 1 64 0v32a224 224 0 0 0 224 224h64a224 224 0 0 0 224-224v-32a32 32 0 1 1 64 0v32a288 288 0 0 1-288 288v64h64a32 32 0 1 1 0 64H416a32 32 0 1 1 0-64h64z"
}, null, -1);
const _hoisted_3$27 = [
  _hoisted_2$2j
];
function _sfc_render$2w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2B, _hoisted_3$27);
}
var microphone = /* @__PURE__ */ _export_sfc$1(_sfc_main$2_, [["render", _sfc_render$2w]]);
const _sfc_main$2Z = defineComponent({
  name: "MilkTea"
});
const _hoisted_1$2A = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2i = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M416 128V96a96 96 0 0 1 96-96h128a32 32 0 1 1 0 64H512a32 32 0 0 0-32 32v32h320a96 96 0 0 1 11.712 191.296l-39.68 581.056A64 64 0 0 1 708.224 960H315.776a64 64 0 0 1-63.872-59.648l-39.616-581.056A96 96 0 0 1 224 128h192zM276.48 320l39.296 576h392.448l4.8-70.784a224.064 224.064 0 0 1 30.016-439.808L747.52 320H276.48zM224 256h576a32 32 0 1 0 0-64H224a32 32 0 0 0 0 64zm493.44 503.872 21.12-309.12a160 160 0 0 0-21.12 309.12z"
}, null, -1);
const _hoisted_3$26 = [
  _hoisted_2$2i
];
function _sfc_render$2v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2A, _hoisted_3$26);
}
var milkTea = /* @__PURE__ */ _export_sfc$1(_sfc_main$2Z, [["render", _sfc_render$2v]]);
const _sfc_main$2Y = defineComponent({
  name: "Minus"
});
const _hoisted_1$2z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2h = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64z"
}, null, -1);
const _hoisted_3$25 = [
  _hoisted_2$2h
];
function _sfc_render$2u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2z, _hoisted_3$25);
}
var minus = /* @__PURE__ */ _export_sfc$1(_sfc_main$2Y, [["render", _sfc_render$2u]]);
const _sfc_main$2X = defineComponent({
  name: "Money"
});
const _hoisted_1$2y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2g = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 640v192h640V384H768v-64h150.976c14.272 0 19.456 1.472 24.64 4.288a29.056 29.056 0 0 1 12.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64v493.952c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H233.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 0 1-12.16-12.096c-2.688-5.184-4.224-10.368-4.224-24.576V640h64z"
}, null, -1);
const _hoisted_3$24 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M768 192H128v448h640V192zm64-22.976v493.952c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 0 1-12.16-12.096C65.536 682.432 64 677.248 64 663.04V169.024c0-14.272 1.472-19.456 4.288-24.64a29.056 29.056 0 0 1 12.096-12.16C85.568 129.536 90.752 128 104.96 128h685.952c14.272 0 19.456 1.472 24.64 4.288a29.056 29.056 0 0 1 12.16 12.096c2.752 5.184 4.224 10.368 4.224 24.64z"
}, null, -1);
const _hoisted_4$L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M448 576a160 160 0 1 1 0-320 160 160 0 0 1 0 320zm0-64a96 96 0 1 0 0-192 96 96 0 0 0 0 192z"
}, null, -1);
const _hoisted_5$i = [
  _hoisted_2$2g,
  _hoisted_3$24,
  _hoisted_4$L
];
function _sfc_render$2t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2y, _hoisted_5$i);
}
var money = /* @__PURE__ */ _export_sfc$1(_sfc_main$2X, [["render", _sfc_render$2t]]);
const _sfc_main$2W = defineComponent({
  name: "Monitor"
});
const _hoisted_1$2x = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2f = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 768v128h192a32 32 0 1 1 0 64H288a32 32 0 1 1 0-64h192V768H192A128 128 0 0 1 64 640V256a128 128 0 0 1 128-128h640a128 128 0 0 1 128 128v384a128 128 0 0 1-128 128H544zM192 192a64 64 0 0 0-64 64v384a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V256a64 64 0 0 0-64-64H192z"
}, null, -1);
const _hoisted_3$23 = [
  _hoisted_2$2f
];
function _sfc_render$2s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2x, _hoisted_3$23);
}
var monitor = /* @__PURE__ */ _export_sfc$1(_sfc_main$2W, [["render", _sfc_render$2s]]);
const _sfc_main$2V = defineComponent({
  name: "MoonNight"
});
const _hoisted_1$2w = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2e = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 512a448 448 0 0 1 215.872-383.296A384 384 0 0 0 213.76 640h188.8A448.256 448.256 0 0 1 384 512zM171.136 704a448 448 0 0 1 636.992-575.296A384 384 0 0 0 499.328 704h-328.32z"
}, null, -1);
const _hoisted_3$22 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M32 640h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32zm128 128h384a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm160 127.68 224 .256a32 32 0 0 1 32 32V928a32 32 0 0 1-32 32l-224-.384a32 32 0 0 1-32-32v-.064a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_4$K = [
  _hoisted_2$2e,
  _hoisted_3$22
];
function _sfc_render$2r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2w, _hoisted_4$K);
}
var moonNight = /* @__PURE__ */ _export_sfc$1(_sfc_main$2V, [["render", _sfc_render$2r]]);
const _sfc_main$2U = defineComponent({
  name: "Moon"
});
const _hoisted_1$2v = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2d = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M240.448 240.448a384 384 0 1 0 559.424 525.696 448 448 0 0 1-542.016-542.08 390.592 390.592 0 0 0-17.408 16.384zm181.056 362.048a384 384 0 0 0 525.632 16.384A448 448 0 1 1 405.056 76.8a384 384 0 0 0 16.448 525.696z"
}, null, -1);
const _hoisted_3$21 = [
  _hoisted_2$2d
];
function _sfc_render$2q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2v, _hoisted_3$21);
}
var moon = /* @__PURE__ */ _export_sfc$1(_sfc_main$2U, [["render", _sfc_render$2q]]);
const _sfc_main$2T = defineComponent({
  name: "MoreFilled"
});
const _hoisted_1$2u = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224z"
}, null, -1);
const _hoisted_3$20 = [
  _hoisted_2$2c
];
function _sfc_render$2p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2u, _hoisted_3$20);
}
var moreFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$2T, [["render", _sfc_render$2p]]);
const _sfc_main$2S = defineComponent({
  name: "More"
});
const _hoisted_1$2t = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2b = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"
}, null, -1);
const _hoisted_3$1$ = [
  _hoisted_2$2b
];
function _sfc_render$2o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2t, _hoisted_3$1$);
}
var more = /* @__PURE__ */ _export_sfc$1(_sfc_main$2S, [["render", _sfc_render$2o]]);
const _sfc_main$2R = defineComponent({
  name: "MostlyCloudy"
});
const _hoisted_1$2s = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2a = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M737.216 357.952 704 349.824l-11.776-32a192.064 192.064 0 0 0-367.424 23.04l-8.96 39.04-39.04 8.96A192.064 192.064 0 0 0 320 768h368a207.808 207.808 0 0 0 207.808-208 208.32 208.32 0 0 0-158.592-202.048zm15.168-62.208A272.32 272.32 0 0 1 959.744 560a271.808 271.808 0 0 1-271.552 272H320a256 256 0 0 1-57.536-505.536 256.128 256.128 0 0 1 489.92-30.72z"
}, null, -1);
const _hoisted_3$1_ = [
  _hoisted_2$2a
];
function _sfc_render$2n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2s, _hoisted_3$1_);
}
var mostlyCloudy = /* @__PURE__ */ _export_sfc$1(_sfc_main$2R, [["render", _sfc_render$2n]]);
const _sfc_main$2Q = defineComponent({
  name: "Mouse"
});
const _hoisted_1$2r = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$29 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M438.144 256c-68.352 0-92.736 4.672-117.76 18.112-20.096 10.752-35.52 26.176-46.272 46.272C260.672 345.408 256 369.792 256 438.144v275.712c0 68.352 4.672 92.736 18.112 117.76 10.752 20.096 26.176 35.52 46.272 46.272C345.408 891.328 369.792 896 438.144 896h147.712c68.352 0 92.736-4.672 117.76-18.112 20.096-10.752 35.52-26.176 46.272-46.272C763.328 806.592 768 782.208 768 713.856V438.144c0-68.352-4.672-92.736-18.112-117.76a110.464 110.464 0 0 0-46.272-46.272C678.592 260.672 654.208 256 585.856 256H438.144zm0-64h147.712c85.568 0 116.608 8.96 147.904 25.6 31.36 16.768 55.872 41.344 72.576 72.64C823.104 321.536 832 352.576 832 438.08v275.84c0 85.504-8.96 116.544-25.6 147.84a174.464 174.464 0 0 1-72.64 72.576C702.464 951.104 671.424 960 585.92 960H438.08c-85.504 0-116.544-8.96-147.84-25.6a174.464 174.464 0 0 1-72.64-72.704c-16.768-31.296-25.664-62.336-25.664-147.84v-275.84c0-85.504 8.96-116.544 25.6-147.84a174.464 174.464 0 0 1 72.768-72.576c31.232-16.704 62.272-25.6 147.776-25.6z"
}, null, -1);
const _hoisted_3$1Z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 320q32 0 32 32v128q0 32-32 32t-32-32V352q0-32 32-32zm32-96a32 32 0 0 1-64 0v-64a32 32 0 0 0-32-32h-96a32 32 0 0 1 0-64h96a96 96 0 0 1 96 96v64z"
}, null, -1);
const _hoisted_4$J = [
  _hoisted_2$29,
  _hoisted_3$1Z
];
function _sfc_render$2m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2r, _hoisted_4$J);
}
var mouse = /* @__PURE__ */ _export_sfc$1(_sfc_main$2Q, [["render", _sfc_render$2m]]);
const _sfc_main$2P = defineComponent({
  name: "Mug"
});
const _hoisted_1$2q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$28 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M736 800V160H160v640a64 64 0 0 0 64 64h448a64 64 0 0 0 64-64zm64-544h63.552a96 96 0 0 1 96 96v224a96 96 0 0 1-96 96H800v128a128 128 0 0 1-128 128H224A128 128 0 0 1 96 800V128a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v128zm0 64v288h63.552a32 32 0 0 0 32-32V352a32 32 0 0 0-32-32H800z"
}, null, -1);
const _hoisted_3$1Y = [
  _hoisted_2$28
];
function _sfc_render$2l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2q, _hoisted_3$1Y);
}
var mug = /* @__PURE__ */ _export_sfc$1(_sfc_main$2P, [["render", _sfc_render$2l]]);
const _sfc_main$2O = defineComponent({
  name: "MuteNotification"
});
const _hoisted_1$2p = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$27 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m241.216 832 63.616-64H768V448c0-42.368-10.24-82.304-28.48-117.504l46.912-47.232C815.36 331.392 832 387.84 832 448v320h96a32 32 0 1 1 0 64H241.216zm-90.24 0H96a32 32 0 1 1 0-64h96V448a320.128 320.128 0 0 1 256-313.6V128a64 64 0 1 1 128 0v6.4a319.552 319.552 0 0 1 171.648 97.088l-45.184 45.44A256 256 0 0 0 256 448v278.336L151.04 832zM448 896h128a64 64 0 0 1-128 0z"
}, null, -1);
const _hoisted_3$1X = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M150.72 859.072a32 32 0 0 1-45.44-45.056l704-708.544a32 32 0 0 1 45.44 45.056l-704 708.544z"
}, null, -1);
const _hoisted_4$I = [
  _hoisted_2$27,
  _hoisted_3$1X
];
function _sfc_render$2k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2p, _hoisted_4$I);
}
var muteNotification = /* @__PURE__ */ _export_sfc$1(_sfc_main$2O, [["render", _sfc_render$2k]]);
const _sfc_main$2N = defineComponent({
  name: "Mute"
});
const _hoisted_1$2o = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$26 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m412.16 592.128-45.44 45.44A191.232 191.232 0 0 1 320 512V256a192 192 0 1 1 384 0v44.352l-64 64V256a128 128 0 1 0-256 0v256c0 30.336 10.56 58.24 28.16 80.128zm51.968 38.592A128 128 0 0 0 640 512v-57.152l64-64V512a192 192 0 0 1-287.68 166.528l47.808-47.808zM314.88 779.968l46.144-46.08A222.976 222.976 0 0 0 480 768h64a224 224 0 0 0 224-224v-32a32 32 0 1 1 64 0v32a288 288 0 0 1-288 288v64h64a32 32 0 1 1 0 64H416a32 32 0 1 1 0-64h64v-64c-61.44 0-118.4-19.2-165.12-52.032zM266.752 737.6A286.976 286.976 0 0 1 192 544v-32a32 32 0 0 1 64 0v32c0 56.832 21.184 108.8 56.064 148.288L266.752 737.6z"
}, null, -1);
const _hoisted_3$1W = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M150.72 859.072a32 32 0 0 1-45.44-45.056l704-708.544a32 32 0 0 1 45.44 45.056l-704 708.544z"
}, null, -1);
const _hoisted_4$H = [
  _hoisted_2$26,
  _hoisted_3$1W
];
function _sfc_render$2j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2o, _hoisted_4$H);
}
var mute = /* @__PURE__ */ _export_sfc$1(_sfc_main$2N, [["render", _sfc_render$2j]]);
const _sfc_main$2M = defineComponent({
  name: "NoSmoking"
});
const _hoisted_1$2n = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$25 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M440.256 576H256v128h56.256l-64 64H224a32 32 0 0 1-32-32V544a32 32 0 0 1 32-32h280.256l-64 64zm143.488 128H704V583.744L775.744 512H928a32 32 0 0 1 32 32v192a32 32 0 0 1-32 32H519.744l64-64zM768 576v128h128V576H768zm-29.696-207.552 45.248 45.248-497.856 497.856-45.248-45.248zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"
}, null, -1);
const _hoisted_3$1V = [
  _hoisted_2$25
];
function _sfc_render$2i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2n, _hoisted_3$1V);
}
var noSmoking = /* @__PURE__ */ _export_sfc$1(_sfc_main$2M, [["render", _sfc_render$2i]]);
const _sfc_main$2L = defineComponent({
  name: "Notebook"
});
const _hoisted_1$2m = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$24 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 128v768h640V128H192zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$1U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M672 128h64v768h-64zM96 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32zm0 192h128q32 0 32 32t-32 32H96q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$G = [
  _hoisted_2$24,
  _hoisted_3$1U
];
function _sfc_render$2h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2m, _hoisted_4$G);
}
var notebook = /* @__PURE__ */ _export_sfc$1(_sfc_main$2L, [["render", _sfc_render$2h]]);
const _sfc_main$2K = defineComponent({
  name: "Notification"
});
const _hoisted_1$2l = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$23 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 128v64H256a64 64 0 0 0-64 64v512a64 64 0 0 0 64 64h512a64 64 0 0 0 64-64V512h64v256a128 128 0 0 1-128 128H256a128 128 0 0 1-128-128V256a128 128 0 0 1 128-128h256z"
}, null, -1);
const _hoisted_3$1T = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M768 384a128 128 0 1 0 0-256 128 128 0 0 0 0 256zm0 64a192 192 0 1 1 0-384 192 192 0 0 1 0 384z"
}, null, -1);
const _hoisted_4$F = [
  _hoisted_2$23,
  _hoisted_3$1T
];
function _sfc_render$2g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2l, _hoisted_4$F);
}
var notification = /* @__PURE__ */ _export_sfc$1(_sfc_main$2K, [["render", _sfc_render$2g]]);
const _sfc_main$2J = defineComponent({
  name: "Odometer"
});
const _hoisted_1$2k = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$22 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_3$1S = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 512a320 320 0 1 1 640 0 32 32 0 1 1-64 0 256 256 0 1 0-512 0 32 32 0 0 1-64 0z"
}, null, -1);
const _hoisted_4$E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M570.432 627.84A96 96 0 1 1 509.568 608l60.992-187.776A32 32 0 1 1 631.424 440l-60.992 187.776zM502.08 734.464a32 32 0 1 0 19.84-60.928 32 32 0 0 0-19.84 60.928z"
}, null, -1);
const _hoisted_5$h = [
  _hoisted_2$22,
  _hoisted_3$1S,
  _hoisted_4$E
];
function _sfc_render$2f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2k, _hoisted_5$h);
}
var odometer = /* @__PURE__ */ _export_sfc$1(_sfc_main$2J, [["render", _sfc_render$2f]]);
const _sfc_main$2I = defineComponent({
  name: "OfficeBuilding"
});
const _hoisted_1$2j = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$21 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 128v704h384V128H192zm-32-64h448a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$1R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 256h256v64H256v-64zm0 192h256v64H256v-64zm0 192h256v64H256v-64zm384-128h128v64H640v-64zm0 128h128v64H640v-64zM64 832h896v64H64v-64z"
}, null, -1);
const _hoisted_4$D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 384v448h192V384H640zm-32-64h256a32 32 0 0 1 32 32v512a32 32 0 0 1-32 32H608a32 32 0 0 1-32-32V352a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_5$g = [
  _hoisted_2$21,
  _hoisted_3$1R,
  _hoisted_4$D
];
function _sfc_render$2e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2j, _hoisted_5$g);
}
var officeBuilding = /* @__PURE__ */ _export_sfc$1(_sfc_main$2I, [["render", _sfc_render$2e]]);
const _sfc_main$2H = defineComponent({
  name: "Open"
});
const _hoisted_1$2i = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$20 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M329.956 257.138a254.862 254.862 0 0 0 0 509.724h364.088a254.862 254.862 0 0 0 0-509.724H329.956zm0-72.818h364.088a327.68 327.68 0 1 1 0 655.36H329.956a327.68 327.68 0 1 1 0-655.36z"
}, null, -1);
const _hoisted_3$1Q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M694.044 621.227a109.227 109.227 0 1 0 0-218.454 109.227 109.227 0 0 0 0 218.454zm0 72.817a182.044 182.044 0 1 1 0-364.088 182.044 182.044 0 0 1 0 364.088z"
}, null, -1);
const _hoisted_4$C = [
  _hoisted_2$20,
  _hoisted_3$1Q
];
function _sfc_render$2d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2i, _hoisted_4$C);
}
var open = /* @__PURE__ */ _export_sfc$1(_sfc_main$2H, [["render", _sfc_render$2d]]);
const _sfc_main$2G = defineComponent({
  name: "Operation"
});
const _hoisted_1$2h = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1$ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M389.44 768a96.064 96.064 0 0 1 181.12 0H896v64H570.56a96.064 96.064 0 0 1-181.12 0H128v-64h261.44zm192-288a96.064 96.064 0 0 1 181.12 0H896v64H762.56a96.064 96.064 0 0 1-181.12 0H128v-64h453.44zm-320-288a96.064 96.064 0 0 1 181.12 0H896v64H442.56a96.064 96.064 0 0 1-181.12 0H128v-64h133.44z"
}, null, -1);
const _hoisted_3$1P = [
  _hoisted_2$1$
];
function _sfc_render$2c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2h, _hoisted_3$1P);
}
var operation = /* @__PURE__ */ _export_sfc$1(_sfc_main$2G, [["render", _sfc_render$2c]]);
const _sfc_main$2F = defineComponent({
  name: "Opportunity"
});
const _hoisted_1$2g = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1_ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 960v-64h192.064v64H384zm448-544a350.656 350.656 0 0 1-128.32 271.424C665.344 719.04 640 763.776 640 813.504V832H320v-14.336c0-48-19.392-95.36-57.216-124.992a351.552 351.552 0 0 1-128.448-344.256c25.344-136.448 133.888-248.128 269.76-276.48A352.384 352.384 0 0 1 832 416zm-544 32c0-132.288 75.904-224 192-224v-64c-154.432 0-256 122.752-256 288h64z"
}, null, -1);
const _hoisted_3$1O = [
  _hoisted_2$1_
];
function _sfc_render$2b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2g, _hoisted_3$1O);
}
var opportunity = /* @__PURE__ */ _export_sfc$1(_sfc_main$2F, [["render", _sfc_render$2b]]);
const _sfc_main$2E = defineComponent({
  name: "Orange"
});
const _hoisted_1$2f = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1Z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 894.72a382.336 382.336 0 0 0 215.936-89.472L577.024 622.272c-10.24 6.016-21.248 10.688-33.024 13.696v258.688zm261.248-134.784A382.336 382.336 0 0 0 894.656 544H635.968c-3.008 11.776-7.68 22.848-13.696 33.024l182.976 182.912zM894.656 480a382.336 382.336 0 0 0-89.408-215.936L622.272 446.976c6.016 10.24 10.688 21.248 13.696 33.024h258.688zm-134.72-261.248A382.336 382.336 0 0 0 544 129.344v258.688c11.776 3.008 22.848 7.68 33.024 13.696l182.912-182.976zM480 129.344a382.336 382.336 0 0 0-215.936 89.408l182.912 182.976c10.24-6.016 21.248-10.688 33.024-13.696V129.344zm-261.248 134.72A382.336 382.336 0 0 0 129.344 480h258.688c3.008-11.776 7.68-22.848 13.696-33.024L218.752 264.064zM129.344 544a382.336 382.336 0 0 0 89.408 215.936l182.976-182.912A127.232 127.232 0 0 1 388.032 544H129.344zm134.72 261.248A382.336 382.336 0 0 0 480 894.656V635.968a127.232 127.232 0 0 1-33.024-13.696L264.064 805.248zM512 960a448 448 0 1 1 0-896 448 448 0 0 1 0 896zm0-384a64 64 0 1 0 0-128 64 64 0 0 0 0 128z"
}, null, -1);
const _hoisted_3$1N = [
  _hoisted_2$1Z
];
function _sfc_render$2a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2f, _hoisted_3$1N);
}
var orange = /* @__PURE__ */ _export_sfc$1(_sfc_main$2E, [["render", _sfc_render$2a]]);
const _sfc_main$2D = defineComponent({
  name: "Paperclip"
});
const _hoisted_1$2e = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1Y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M602.496 240.448A192 192 0 1 1 874.048 512l-316.8 316.8A256 256 0 0 1 195.2 466.752L602.496 59.456l45.248 45.248L240.448 512A192 192 0 0 0 512 783.552l316.8-316.8a128 128 0 1 0-181.056-181.056L353.6 579.904a32 32 0 1 0 45.248 45.248l294.144-294.144 45.312 45.248L444.096 670.4a96 96 0 1 1-135.744-135.744l294.144-294.208z"
}, null, -1);
const _hoisted_3$1M = [
  _hoisted_2$1Y
];
function _sfc_render$29(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2e, _hoisted_3$1M);
}
var paperclip = /* @__PURE__ */ _export_sfc$1(_sfc_main$2D, [["render", _sfc_render$29]]);
const _sfc_main$2C = defineComponent({
  name: "PartlyCloudy"
});
const _hoisted_1$2d = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1X = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M598.4 895.872H328.192a256 256 0 0 1-34.496-510.528A352 352 0 1 1 598.4 895.872zm-271.36-64h272.256a288 288 0 1 0-248.512-417.664L335.04 445.44l-34.816 3.584a192 192 0 0 0 26.88 382.848z"
}, null, -1);
const _hoisted_3$1L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M139.84 501.888a256 256 0 1 1 417.856-277.12c-17.728 2.176-38.208 8.448-61.504 18.816A192 192 0 1 0 189.12 460.48a6003.84 6003.84 0 0 0-49.28 41.408z"
}, null, -1);
const _hoisted_4$B = [
  _hoisted_2$1X,
  _hoisted_3$1L
];
function _sfc_render$28(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2d, _hoisted_4$B);
}
var partlyCloudy = /* @__PURE__ */ _export_sfc$1(_sfc_main$2C, [["render", _sfc_render$28]]);
const _sfc_main$2B = defineComponent({
  name: "Pear"
});
const _hoisted_1$2c = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1W = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M542.336 258.816a443.255 443.255 0 0 0-9.024 25.088 32 32 0 1 1-60.8-20.032l1.088-3.328a162.688 162.688 0 0 0-122.048 131.392l-17.088 102.72-20.736 15.36C256.192 552.704 224 610.88 224 672c0 120.576 126.4 224 288 224s288-103.424 288-224c0-61.12-32.192-119.296-89.728-161.92l-20.736-15.424-17.088-102.72a162.688 162.688 0 0 0-130.112-133.12zm-40.128-66.56c7.936-15.552 16.576-30.08 25.92-43.776 23.296-33.92 49.408-59.776 78.528-77.12a32 32 0 1 1 32.704 55.04c-20.544 12.224-40.064 31.552-58.432 58.304a316.608 316.608 0 0 0-9.792 15.104 226.688 226.688 0 0 1 164.48 181.568l12.8 77.248C819.456 511.36 864 587.392 864 672c0 159.04-157.568 288-352 288S160 831.04 160 672c0-84.608 44.608-160.64 115.584-213.376l12.8-77.248a226.624 226.624 0 0 1 213.76-189.184z"
}, null, -1);
const _hoisted_3$1K = [
  _hoisted_2$1W
];
function _sfc_render$27(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2c, _hoisted_3$1K);
}
var pear = /* @__PURE__ */ _export_sfc$1(_sfc_main$2B, [["render", _sfc_render$27]]);
const _sfc_main$2A = defineComponent({
  name: "PhoneFilled"
});
const _hoisted_1$2b = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1V = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M199.232 125.568 90.624 379.008a32 32 0 0 0 6.784 35.2l512.384 512.384a32 32 0 0 0 35.2 6.784l253.44-108.608a32 32 0 0 0 10.048-52.032L769.6 633.92a32 32 0 0 0-36.928-5.952l-130.176 65.088-271.488-271.552 65.024-130.176a32 32 0 0 0-5.952-36.928L251.2 115.52a32 32 0 0 0-51.968 10.048z"
}, null, -1);
const _hoisted_3$1J = [
  _hoisted_2$1V
];
function _sfc_render$26(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2b, _hoisted_3$1J);
}
var phoneFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$2A, [["render", _sfc_render$26]]);
const _sfc_main$2z = defineComponent({
  name: "Phone"
});
const _hoisted_1$2a = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M79.36 432.256 591.744 944.64a32 32 0 0 0 35.2 6.784l253.44-108.544a32 32 0 0 0 9.984-52.032l-153.856-153.92a32 32 0 0 0-36.928-6.016l-69.888 34.944L358.08 394.24l35.008-69.888a32 32 0 0 0-5.952-36.928L233.152 133.568a32 32 0 0 0-52.032 10.048L72.512 397.056a32 32 0 0 0 6.784 35.2zm60.48-29.952 81.536-190.08L325.568 316.48l-24.64 49.216-20.608 41.216 32.576 32.64 271.552 271.552 32.64 32.64 41.216-20.672 49.28-24.576 104.192 104.128-190.08 81.472L139.84 402.304zM512 320v-64a256 256 0 0 1 256 256h-64a192 192 0 0 0-192-192zm0-192V64a448 448 0 0 1 448 448h-64a384 384 0 0 0-384-384z"
}, null, -1);
const _hoisted_3$1I = [
  _hoisted_2$1U
];
function _sfc_render$25(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2a, _hoisted_3$1I);
}
var phone = /* @__PURE__ */ _export_sfc$1(_sfc_main$2z, [["render", _sfc_render$25]]);
const _sfc_main$2y = defineComponent({
  name: "PictureFilled"
});
const _hoisted_1$29 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1T = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32H96zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112zM256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384z"
}, null, -1);
const _hoisted_3$1H = [
  _hoisted_2$1T
];
function _sfc_render$24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$29, _hoisted_3$1H);
}
var pictureFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$2y, [["render", _sfc_render$24]]);
const _sfc_main$2x = defineComponent({
  name: "PictureRounded"
});
const _hoisted_1$28 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1S = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 128a384 384 0 1 0 0 768 384 384 0 0 0 0-768zm0-64a448 448 0 1 1 0 896 448 448 0 0 1 0-896z"
}, null, -1);
const _hoisted_3$1G = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM214.656 790.656l-45.312-45.312 185.664-185.6a96 96 0 0 1 123.712-10.24l138.24 98.688a32 32 0 0 0 39.872-2.176L906.688 422.4l42.624 47.744L699.52 693.696a96 96 0 0 1-119.808 6.592l-138.24-98.752a32 32 0 0 0-41.152 3.456l-185.664 185.6z"
}, null, -1);
const _hoisted_4$A = [
  _hoisted_2$1S,
  _hoisted_3$1G
];
function _sfc_render$23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$28, _hoisted_4$A);
}
var pictureRounded = /* @__PURE__ */ _export_sfc$1(_sfc_main$2x, [["render", _sfc_render$23]]);
const _sfc_main$2w = defineComponent({
  name: "Picture"
});
const _hoisted_1$27 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 160v704h704V160H160zm-32-64h768a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H128a32 32 0 0 1-32-32V128a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$1F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 288q64 0 64 64t-64 64q-64 0-64-64t64-64zM185.408 876.992l-50.816-38.912L350.72 556.032a96 96 0 0 1 134.592-17.856l1.856 1.472 122.88 99.136a32 32 0 0 0 44.992-4.864l216-269.888 49.92 39.936-215.808 269.824-.256.32a96 96 0 0 1-135.04 14.464l-122.88-99.072-.64-.512a32 32 0 0 0-44.8 5.952L185.408 876.992z"
}, null, -1);
const _hoisted_4$z = [
  _hoisted_2$1R,
  _hoisted_3$1F
];
function _sfc_render$22(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$27, _hoisted_4$z);
}
var picture = /* @__PURE__ */ _export_sfc$1(_sfc_main$2w, [["render", _sfc_render$22]]);
const _sfc_main$2v = defineComponent({
  name: "PieChart"
});
const _hoisted_1$26 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1Q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M448 68.48v64.832A384.128 384.128 0 0 0 512 896a384.128 384.128 0 0 0 378.688-320h64.768A448.128 448.128 0 0 1 64 512 448.128 448.128 0 0 1 448 68.48z"
}, null, -1);
const _hoisted_3$1E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M576 97.28V448h350.72A384.064 384.064 0 0 0 576 97.28zM512 64V33.152A448 448 0 0 1 990.848 512H512V64z"
}, null, -1);
const _hoisted_4$y = [
  _hoisted_2$1Q,
  _hoisted_3$1E
];
function _sfc_render$21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$26, _hoisted_4$y);
}
var pieChart = /* @__PURE__ */ _export_sfc$1(_sfc_main$2v, [["render", _sfc_render$21]]);
const _sfc_main$2u = defineComponent({
  name: "Place"
});
const _hoisted_1$25 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1P = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512z"
}, null, -1);
const _hoisted_3$1D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 512a32 32 0 0 1 32 32v256a32 32 0 1 1-64 0V544a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_4$x = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 649.088v64.96C269.76 732.352 192 771.904 192 800c0 37.696 139.904 96 320 96s320-58.304 320-96c0-28.16-77.76-67.648-192-85.952v-64.96C789.12 671.04 896 730.368 896 800c0 88.32-171.904 160-384 160s-384-71.68-384-160c0-69.696 106.88-128.96 256-150.912z"
}, null, -1);
const _hoisted_5$f = [
  _hoisted_2$1P,
  _hoisted_3$1D,
  _hoisted_4$x
];
function _sfc_render$20(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$25, _hoisted_5$f);
}
var place = /* @__PURE__ */ _export_sfc$1(_sfc_main$2u, [["render", _sfc_render$20]]);
const _sfc_main$2t = defineComponent({
  name: "Platform"
});
const _hoisted_1$24 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1O = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M448 832v-64h128v64h192v64H256v-64h192zM128 704V128h768v576H128z"
}, null, -1);
const _hoisted_3$1C = [
  _hoisted_2$1O
];
function _sfc_render$1$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$24, _hoisted_3$1C);
}
var platform = /* @__PURE__ */ _export_sfc$1(_sfc_main$2t, [["render", _sfc_render$1$]]);
const _sfc_main$2s = defineComponent({
  name: "Plus"
});
const _hoisted_1$23 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1N = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
}, null, -1);
const _hoisted_3$1B = [
  _hoisted_2$1N
];
function _sfc_render$1_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$23, _hoisted_3$1B);
}
var plus = /* @__PURE__ */ _export_sfc$1(_sfc_main$2s, [["render", _sfc_render$1_]]);
const _sfc_main$2r = defineComponent({
  name: "Pointer"
});
const _hoisted_1$22 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1M = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M511.552 128c-35.584 0-64.384 28.8-64.384 64.448v516.48L274.048 570.88a94.272 94.272 0 0 0-112.896-3.456 44.416 44.416 0 0 0-8.96 62.208L332.8 870.4A64 64 0 0 0 384 896h512V575.232a64 64 0 0 0-45.632-61.312l-205.952-61.76A96 96 0 0 1 576 360.192V192.448C576 156.8 547.2 128 511.552 128zM359.04 556.8l24.128 19.2V192.448a128.448 128.448 0 1 1 256.832 0v167.744a32 32 0 0 0 22.784 30.656l206.016 61.76A128 128 0 0 1 960 575.232V896a64 64 0 0 1-64 64H384a128 128 0 0 1-102.4-51.2L101.056 668.032A108.416 108.416 0 0 1 128 512.512a158.272 158.272 0 0 1 185.984 8.32L359.04 556.8z"
}, null, -1);
const _hoisted_3$1A = [
  _hoisted_2$1M
];
function _sfc_render$1Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$22, _hoisted_3$1A);
}
var pointer = /* @__PURE__ */ _export_sfc$1(_sfc_main$2r, [["render", _sfc_render$1Z]]);
const _sfc_main$2q = defineComponent({
  name: "Position"
});
const _hoisted_1$21 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m249.6 417.088 319.744 43.072 39.168 310.272L845.12 178.88 249.6 417.088zm-129.024 47.168a32 32 0 0 1-7.68-61.44l777.792-311.04a32 32 0 0 1 41.6 41.6l-310.336 775.68a32 32 0 0 1-61.44-7.808L512 516.992l-391.424-52.736z"
}, null, -1);
const _hoisted_3$1z = [
  _hoisted_2$1L
];
function _sfc_render$1Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$21, _hoisted_3$1z);
}
var position = /* @__PURE__ */ _export_sfc$1(_sfc_main$2q, [["render", _sfc_render$1Y]]);
const _sfc_main$2p = defineComponent({
  name: "Postcard"
});
const _hoisted_1$20 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1K = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 224a32 32 0 0 0-32 32v512a32 32 0 0 0 32 32h704a32 32 0 0 0 32-32V256a32 32 0 0 0-32-32H160zm0-64h704a96 96 0 0 1 96 96v512a96 96 0 0 1-96 96H160a96 96 0 0 1-96-96V256a96 96 0 0 1 96-96z"
}, null, -1);
const _hoisted_3$1y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 320a64 64 0 1 1 0 128 64 64 0 0 1 0-128zM288 448h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32zm0 128h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$w = [
  _hoisted_2$1K,
  _hoisted_3$1y
];
function _sfc_render$1X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$20, _hoisted_4$w);
}
var postcard = /* @__PURE__ */ _export_sfc$1(_sfc_main$2p, [["render", _sfc_render$1X]]);
const _sfc_main$2o = defineComponent({
  name: "Pouring"
});
const _hoisted_1$1$ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1J = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m739.328 291.328-35.2-6.592-12.8-33.408a192.064 192.064 0 0 0-365.952 23.232l-9.92 40.896-41.472 7.04a176.32 176.32 0 0 0-146.24 173.568c0 97.28 78.72 175.936 175.808 175.936h400a192 192 0 0 0 35.776-380.672zM959.552 480a256 256 0 0 1-256 256h-400A239.808 239.808 0 0 1 63.744 496.192a240.32 240.32 0 0 1 199.488-236.8 256.128 256.128 0 0 1 487.872-30.976A256.064 256.064 0 0 1 959.552 480zM224 800a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32zm192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32zm192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32zm192 0a32 32 0 0 1 32 32v96a32 32 0 1 1-64 0v-96a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$1x = [
  _hoisted_2$1J
];
function _sfc_render$1W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1$, _hoisted_3$1x);
}
var pouring = /* @__PURE__ */ _export_sfc$1(_sfc_main$2o, [["render", _sfc_render$1W]]);
const _sfc_main$2n = defineComponent({
  name: "Present"
});
const _hoisted_1$1_ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 896V640H192v-64h288V320H192v576h288zm64 0h288V320H544v256h288v64H544v256zM128 256h768v672a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V256z"
}, null, -1);
const _hoisted_3$1w = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M96 256h832q32 0 32 32t-32 32H96q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_4$v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M416 256a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"
}, null, -1);
const _hoisted_5$e = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M608 256a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"
}, null, -1);
const _hoisted_6$8 = [
  _hoisted_2$1I,
  _hoisted_3$1w,
  _hoisted_4$v,
  _hoisted_5$e
];
function _sfc_render$1V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1_, _hoisted_6$8);
}
var present = /* @__PURE__ */ _export_sfc$1(_sfc_main$2n, [["render", _sfc_render$1V]]);
const _sfc_main$2m = defineComponent({
  name: "PriceTag"
});
const _hoisted_1$1Z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1H = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 318.336V896h576V318.336L552.512 115.84a64 64 0 0 0-81.024 0L224 318.336zM593.024 66.304l259.2 212.096A32 32 0 0 1 864 303.168V928a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V303.168a32 32 0 0 1 11.712-24.768l259.2-212.096a128 128 0 0 1 162.112 0z"
}, null, -1);
const _hoisted_3$1v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 448a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"
}, null, -1);
const _hoisted_4$u = [
  _hoisted_2$1H,
  _hoisted_3$1v
];
function _sfc_render$1U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1Z, _hoisted_4$u);
}
var priceTag = /* @__PURE__ */ _export_sfc$1(_sfc_main$2m, [["render", _sfc_render$1U]]);
const _sfc_main$2l = defineComponent({
  name: "Printer"
});
const _hoisted_1$1Y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1G = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 768H105.024c-14.272 0-19.456-1.472-24.64-4.288a29.056 29.056 0 0 1-12.16-12.096C65.536 746.432 64 741.248 64 727.04V379.072c0-42.816 4.48-58.304 12.8-73.984 8.384-15.616 20.672-27.904 36.288-36.288 15.68-8.32 31.168-12.8 73.984-12.8H256V64h512v192h68.928c42.816 0 58.304 4.48 73.984 12.8 15.616 8.384 27.904 20.672 36.288 36.288 8.32 15.68 12.8 31.168 12.8 73.984v347.904c0 14.272-1.472 19.456-4.288 24.64a29.056 29.056 0 0 1-12.096 12.16c-5.184 2.752-10.368 4.224-24.64 4.224H768v192H256V768zm64-192v320h384V576H320zm-64 128V512h512v192h128V379.072c0-29.376-1.408-36.48-5.248-43.776a23.296 23.296 0 0 0-10.048-10.048c-7.232-3.84-14.4-5.248-43.776-5.248H187.072c-29.376 0-36.48 1.408-43.776 5.248a23.296 23.296 0 0 0-10.048 10.048c-3.84 7.232-5.248 14.4-5.248 43.776V704h128zm64-448h384V128H320v128zm-64 128h64v64h-64v-64zm128 0h64v64h-64v-64z"
}, null, -1);
const _hoisted_3$1u = [
  _hoisted_2$1G
];
function _sfc_render$1T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1Y, _hoisted_3$1u);
}
var printer = /* @__PURE__ */ _export_sfc$1(_sfc_main$2l, [["render", _sfc_render$1T]]);
const _sfc_main$2k = defineComponent({
  name: "Promotion"
});
const _hoisted_1$1X = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m64 448 832-320-128 704-446.08-243.328L832 192 242.816 545.472 64 448zm256 512V657.024L512 768 320 960z"
}, null, -1);
const _hoisted_3$1t = [
  _hoisted_2$1F
];
function _sfc_render$1S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1X, _hoisted_3$1t);
}
var promotion = /* @__PURE__ */ _export_sfc$1(_sfc_main$2k, [["render", _sfc_render$1S]]);
const _sfc_main$2j = defineComponent({
  name: "QuestionFilled"
});
const _hoisted_1$1W = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592 0-42.944-14.08-76.736-42.24-101.376-28.16-25.344-65.472-37.312-111.232-37.312zm-12.672 406.208a54.272 54.272 0 0 0-38.72 14.784 49.408 49.408 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.848 54.848 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.968 51.968 0 0 0-15.488-38.016 55.936 55.936 0 0 0-39.424-14.784z"
}, null, -1);
const _hoisted_3$1s = [
  _hoisted_2$1E
];
function _sfc_render$1R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1W, _hoisted_3$1s);
}
var questionFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$2j, [["render", _sfc_render$1R]]);
const _sfc_main$2i = defineComponent({
  name: "Rank"
});
const _hoisted_1$1V = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m186.496 544 41.408 41.344a32 32 0 1 1-45.248 45.312l-96-96a32 32 0 0 1 0-45.312l96-96a32 32 0 1 1 45.248 45.312L186.496 480h290.816V186.432l-41.472 41.472a32 32 0 1 1-45.248-45.184l96-96.128a32 32 0 0 1 45.312 0l96 96.064a32 32 0 0 1-45.248 45.184l-41.344-41.28V480H832l-41.344-41.344a32 32 0 0 1 45.248-45.312l96 96a32 32 0 0 1 0 45.312l-96 96a32 32 0 0 1-45.248-45.312L832 544H541.312v293.44l41.344-41.28a32 32 0 1 1 45.248 45.248l-96 96a32 32 0 0 1-45.312 0l-96-96a32 32 0 1 1 45.312-45.248l41.408 41.408V544H186.496z"
}, null, -1);
const _hoisted_3$1r = [
  _hoisted_2$1D
];
function _sfc_render$1Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1V, _hoisted_3$1r);
}
var rank = /* @__PURE__ */ _export_sfc$1(_sfc_main$2i, [["render", _sfc_render$1Q]]);
const _sfc_main$2h = defineComponent({
  name: "ReadingLamp"
});
const _hoisted_1$1U = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1C = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 896h320q32 0 32 32t-32 32H352q-32 0-32-32t32-32zm-44.672-768-99.52 448h608.384l-99.52-448H307.328zm-25.6-64h460.608a32 32 0 0 1 31.232 25.088l113.792 512A32 32 0 0 1 856.128 640H167.872a32 32 0 0 1-31.232-38.912l113.792-512A32 32 0 0 1 281.664 64z"
}, null, -1);
const _hoisted_3$1q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M672 576q32 0 32 32v128q0 32-32 32t-32-32V608q0-32 32-32zm-192-.064h64V960h-64z"
}, null, -1);
const _hoisted_4$t = [
  _hoisted_2$1C,
  _hoisted_3$1q
];
function _sfc_render$1P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1U, _hoisted_4$t);
}
var readingLamp = /* @__PURE__ */ _export_sfc$1(_sfc_main$2h, [["render", _sfc_render$1P]]);
const _sfc_main$2g = defineComponent({
  name: "Reading"
});
const _hoisted_1$1T = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1B = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m512 863.36 384-54.848v-638.72L525.568 222.72a96 96 0 0 1-27.136 0L128 169.792v638.72l384 54.848zM137.024 106.432l370.432 52.928a32 32 0 0 0 9.088 0l370.432-52.928A64 64 0 0 1 960 169.792v638.72a64 64 0 0 1-54.976 63.36l-388.48 55.488a32 32 0 0 1-9.088 0l-388.48-55.488A64 64 0 0 1 64 808.512v-638.72a64 64 0 0 1 73.024-63.36z"
}, null, -1);
const _hoisted_3$1p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 192h64v704h-64z"
}, null, -1);
const _hoisted_4$s = [
  _hoisted_2$1B,
  _hoisted_3$1p
];
function _sfc_render$1O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1T, _hoisted_4$s);
}
var reading = /* @__PURE__ */ _export_sfc$1(_sfc_main$2g, [["render", _sfc_render$1O]]);
const _sfc_main$2f = defineComponent({
  name: "RefreshLeft"
});
const _hoisted_1$1S = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1A = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
}, null, -1);
const _hoisted_3$1o = [
  _hoisted_2$1A
];
function _sfc_render$1N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1S, _hoisted_3$1o);
}
var refreshLeft = /* @__PURE__ */ _export_sfc$1(_sfc_main$2f, [["render", _sfc_render$1N]]);
const _sfc_main$2e = defineComponent({
  name: "RefreshRight"
});
const _hoisted_1$1R = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
}, null, -1);
const _hoisted_3$1n = [
  _hoisted_2$1z
];
function _sfc_render$1M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1R, _hoisted_3$1n);
}
var refreshRight = /* @__PURE__ */ _export_sfc$1(_sfc_main$2e, [["render", _sfc_render$1M]]);
const _sfc_main$2d = defineComponent({
  name: "Refresh"
});
const _hoisted_1$1Q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M771.776 794.88A384 384 0 0 1 128 512h64a320 320 0 0 0 555.712 216.448H654.72a32 32 0 1 1 0-64h149.056a32 32 0 0 1 32 32v148.928a32 32 0 1 1-64 0v-50.56zM276.288 295.616h92.992a32 32 0 0 1 0 64H220.16a32 32 0 0 1-32-32V178.56a32 32 0 0 1 64 0v50.56A384 384 0 0 1 896.128 512h-64a320 320 0 0 0-555.776-216.384z"
}, null, -1);
const _hoisted_3$1m = [
  _hoisted_2$1y
];
function _sfc_render$1L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1Q, _hoisted_3$1m);
}
var refresh = /* @__PURE__ */ _export_sfc$1(_sfc_main$2d, [["render", _sfc_render$1L]]);
const _sfc_main$2c = defineComponent({
  name: "Refrigerator"
});
const _hoisted_1$1P = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1x = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 448h512V160a32 32 0 0 0-32-32H288a32 32 0 0 0-32 32v288zm0 64v352a32 32 0 0 0 32 32h448a32 32 0 0 0 32-32V512H256zm32-448h448a96 96 0 0 1 96 96v704a96 96 0 0 1-96 96H288a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96zm32 224h64v96h-64v-96zm0 288h64v96h-64v-96z"
}, null, -1);
const _hoisted_3$1l = [
  _hoisted_2$1x
];
function _sfc_render$1K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1P, _hoisted_3$1l);
}
var refrigerator = /* @__PURE__ */ _export_sfc$1(_sfc_main$2c, [["render", _sfc_render$1K]]);
const _sfc_main$2b = defineComponent({
  name: "RemoveFilled"
});
const _hoisted_1$1O = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1w = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zM288 512a38.4 38.4 0 0 0 38.4 38.4h371.2a38.4 38.4 0 0 0 0-76.8H326.4A38.4 38.4 0 0 0 288 512z"
}, null, -1);
const _hoisted_3$1k = [
  _hoisted_2$1w
];
function _sfc_render$1J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1O, _hoisted_3$1k);
}
var removeFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$2b, [["render", _sfc_render$1J]]);
const _sfc_main$2a = defineComponent({
  name: "Remove"
});
const _hoisted_1$1N = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 480h320a32 32 0 1 1 0 64H352a32 32 0 0 1 0-64z"
}, null, -1);
const _hoisted_3$1j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_4$r = [
  _hoisted_2$1v,
  _hoisted_3$1j
];
function _sfc_render$1I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1N, _hoisted_4$r);
}
var remove = /* @__PURE__ */ _export_sfc$1(_sfc_main$2a, [["render", _sfc_render$1I]]);
const _sfc_main$29 = defineComponent({
  name: "Right"
});
const _hoisted_1$1M = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1u = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M754.752 480H160a32 32 0 1 0 0 64h594.752L521.344 777.344a32 32 0 0 0 45.312 45.312l288-288a32 32 0 0 0 0-45.312l-288-288a32 32 0 1 0-45.312 45.312L754.752 480z"
}, null, -1);
const _hoisted_3$1i = [
  _hoisted_2$1u
];
function _sfc_render$1H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1M, _hoisted_3$1i);
}
var right$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$29, [["render", _sfc_render$1H]]);
const _sfc_main$28 = defineComponent({
  name: "ScaleToOriginal"
});
const _hoisted_1$1L = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1t = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
}, null, -1);
const _hoisted_3$1h = [
  _hoisted_2$1t
];
function _sfc_render$1G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1L, _hoisted_3$1h);
}
var scaleToOriginal = /* @__PURE__ */ _export_sfc$1(_sfc_main$28, [["render", _sfc_render$1G]]);
const _sfc_main$27 = defineComponent({
  name: "School"
});
const _hoisted_1$1K = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1s = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 128v704h576V128H224zm-32-64h640a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$1g = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M64 832h896v64H64zm256-640h128v96H320z"
}, null, -1);
const _hoisted_4$q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 832h256v-64a128 128 0 1 0-256 0v64zm128-256a192 192 0 0 1 192 192v128H320V768a192 192 0 0 1 192-192zM320 384h128v96H320zm256-192h128v96H576zm0 192h128v96H576z"
}, null, -1);
const _hoisted_5$d = [
  _hoisted_2$1s,
  _hoisted_3$1g,
  _hoisted_4$q
];
function _sfc_render$1F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1K, _hoisted_5$d);
}
var school = /* @__PURE__ */ _export_sfc$1(_sfc_main$27, [["render", _sfc_render$1F]]);
const _sfc_main$26 = defineComponent({
  name: "Scissor"
});
const _hoisted_1$1J = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m512.064 578.368-106.88 152.768a160 160 0 1 1-23.36-78.208L472.96 522.56 196.864 128.256a32 32 0 1 1 52.48-36.736l393.024 561.344a160 160 0 1 1-23.36 78.208l-106.88-152.704zm54.4-189.248 208.384-297.6a32 32 0 0 1 52.48 36.736l-221.76 316.672-39.04-55.808zm-376.32 425.856a96 96 0 1 0 110.144-157.248 96 96 0 0 0-110.08 157.248zm643.84 0a96 96 0 1 0-110.08-157.248 96 96 0 0 0 110.08 157.248z"
}, null, -1);
const _hoisted_3$1f = [
  _hoisted_2$1r
];
function _sfc_render$1E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1J, _hoisted_3$1f);
}
var scissor = /* @__PURE__ */ _export_sfc$1(_sfc_main$26, [["render", _sfc_render$1E]]);
const _sfc_main$25 = defineComponent({
  name: "Search"
});
const _hoisted_1$1I = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
}, null, -1);
const _hoisted_3$1e = [
  _hoisted_2$1q
];
function _sfc_render$1D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1I, _hoisted_3$1e);
}
var search = /* @__PURE__ */ _export_sfc$1(_sfc_main$25, [["render", _sfc_render$1D]]);
const _sfc_main$24 = defineComponent({
  name: "Select"
});
const _hoisted_1$1H = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M77.248 415.04a64 64 0 0 1 90.496 0l226.304 226.304L846.528 188.8a64 64 0 1 1 90.56 90.496l-543.04 543.04-316.8-316.8a64 64 0 0 1 0-90.496z"
}, null, -1);
const _hoisted_3$1d = [
  _hoisted_2$1p
];
function _sfc_render$1C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1H, _hoisted_3$1d);
}
var select = /* @__PURE__ */ _export_sfc$1(_sfc_main$24, [["render", _sfc_render$1C]]);
const _sfc_main$23 = defineComponent({
  name: "Sell"
});
const _hoisted_1$1G = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1o = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 288h131.072a32 32 0 0 1 31.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4h256zm201.408 483.84L768 698.496V928a32 32 0 1 1-64 0V698.496l-73.344 73.344a32 32 0 1 1-45.248-45.248l128-128a32 32 0 0 1 45.248 0l128 128a32 32 0 1 1-45.248 45.248z"
}, null, -1);
const _hoisted_3$1c = [
  _hoisted_2$1o
];
function _sfc_render$1B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1G, _hoisted_3$1c);
}
var sell = /* @__PURE__ */ _export_sfc$1(_sfc_main$23, [["render", _sfc_render$1B]]);
const _sfc_main$22 = defineComponent({
  name: "SemiSelect"
});
const _hoisted_1$1F = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1n = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 448h768q64 0 64 64t-64 64H128q-64 0-64-64t64-64z"
}, null, -1);
const _hoisted_3$1b = [
  _hoisted_2$1n
];
function _sfc_render$1A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1F, _hoisted_3$1b);
}
var semiSelect = /* @__PURE__ */ _export_sfc$1(_sfc_main$22, [["render", _sfc_render$1A]]);
const _sfc_main$21 = defineComponent({
  name: "Service"
});
const _hoisted_1$1E = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1m = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M864 409.6a192 192 0 0 1-37.888 349.44A256.064 256.064 0 0 1 576 960h-96a32 32 0 1 1 0-64h96a192.064 192.064 0 0 0 181.12-128H736a32 32 0 0 1-32-32V416a32 32 0 0 1 32-32h32c10.368 0 20.544.832 30.528 2.432a288 288 0 0 0-573.056 0A193.235 193.235 0 0 1 256 384h32a32 32 0 0 1 32 32v320a32 32 0 0 1-32 32h-32a192 192 0 0 1-96-358.4 352 352 0 0 1 704 0zM256 448a128 128 0 1 0 0 256V448zm640 128a128 128 0 0 0-128-128v256a128 128 0 0 0 128-128z"
}, null, -1);
const _hoisted_3$1a = [
  _hoisted_2$1m
];
function _sfc_render$1z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1E, _hoisted_3$1a);
}
var service = /* @__PURE__ */ _export_sfc$1(_sfc_main$21, [["render", _sfc_render$1z]]);
const _sfc_main$20 = defineComponent({
  name: "SetUp"
});
const _hoisted_1$1D = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1l = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 160a64 64 0 0 0-64 64v576a64 64 0 0 0 64 64h576a64 64 0 0 0 64-64V224a64 64 0 0 0-64-64H224zm0-64h576a128 128 0 0 1 128 128v576a128 128 0 0 1-128 128H224A128 128 0 0 1 96 800V224A128 128 0 0 1 224 96z"
}, null, -1);
const _hoisted_3$19 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 416a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"
}, null, -1);
const _hoisted_4$p = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 320h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32zm160 416a64 64 0 1 0 0-128 64 64 0 0 0 0 128zm0 64a128 128 0 1 1 0-256 128 128 0 0 1 0 256z"
}, null, -1);
const _hoisted_5$c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 640h256q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_6$7 = [
  _hoisted_2$1l,
  _hoisted_3$19,
  _hoisted_4$p,
  _hoisted_5$c
];
function _sfc_render$1y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1D, _hoisted_6$7);
}
var setUp = /* @__PURE__ */ _export_sfc$1(_sfc_main$20, [["render", _sfc_render$1y]]);
const _sfc_main$1$ = defineComponent({
  name: "Setting"
});
const _hoisted_1$1C = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1k = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357.12 357.12 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a351.616 351.616 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357.12 357.12 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384zm0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256z"
}, null, -1);
const _hoisted_3$18 = [
  _hoisted_2$1k
];
function _sfc_render$1x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1C, _hoisted_3$18);
}
var setting = /* @__PURE__ */ _export_sfc$1(_sfc_main$1$, [["render", _sfc_render$1x]]);
const _sfc_main$1_ = defineComponent({
  name: "Share"
});
const _hoisted_1$1B = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m679.872 348.8-301.76 188.608a127.808 127.808 0 0 1 5.12 52.16l279.936 104.96a128 128 0 1 1-22.464 59.904l-279.872-104.96a128 128 0 1 1-16.64-166.272l301.696-188.608a128 128 0 1 1 33.92 54.272z"
}, null, -1);
const _hoisted_3$17 = [
  _hoisted_2$1j
];
function _sfc_render$1w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1B, _hoisted_3$17);
}
var share = /* @__PURE__ */ _export_sfc$1(_sfc_main$1_, [["render", _sfc_render$1w]]);
const _sfc_main$1Z = defineComponent({
  name: "Ship"
});
const _hoisted_1$1A = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1i = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 386.88V448h405.568a32 32 0 0 1 30.72 40.768l-76.48 267.968A192 192 0 0 1 687.168 896H336.832a192 192 0 0 1-184.64-139.264L75.648 488.768A32 32 0 0 1 106.368 448H448V117.888a32 32 0 0 1 47.36-28.096l13.888 7.616L512 96v2.88l231.68 126.4a32 32 0 0 1-2.048 57.216L512 386.88zm0-70.272 144.768-65.792L512 171.84v144.768zM512 512H148.864l18.24 64H856.96l18.24-64H512zM185.408 640l28.352 99.2A128 128 0 0 0 336.832 832h350.336a128 128 0 0 0 123.072-92.8l28.352-99.2H185.408z"
}, null, -1);
const _hoisted_3$16 = [
  _hoisted_2$1i
];
function _sfc_render$1v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1A, _hoisted_3$16);
}
var ship = /* @__PURE__ */ _export_sfc$1(_sfc_main$1Z, [["render", _sfc_render$1v]]);
const _sfc_main$1Y = defineComponent({
  name: "Shop"
});
const _hoisted_1$1z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1h = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 704h64v192H256V704h64v64h384v-64zm188.544-152.192C894.528 559.616 896 567.616 896 576a96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0 96 96 0 1 1-192 0c0-8.384 1.408-16.384 3.392-24.192L192 128h640l60.544 423.808z"
}, null, -1);
const _hoisted_3$15 = [
  _hoisted_2$1h
];
function _sfc_render$1u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1z, _hoisted_3$15);
}
var shop = /* @__PURE__ */ _export_sfc$1(_sfc_main$1Y, [["render", _sfc_render$1u]]);
const _sfc_main$1X = defineComponent({
  name: "ShoppingBag"
});
const _hoisted_1$1y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1g = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 320v96a32 32 0 0 1-32 32h-32V320H384v128h-32a32 32 0 0 1-32-32v-96H192v576h640V320H704zm-384-64a192 192 0 1 1 384 0h160a32 32 0 0 1 32 32v640a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32h160zm64 0h256a128 128 0 1 0-256 0z"
}, null, -1);
const _hoisted_3$14 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 704h640v64H192z"
}, null, -1);
const _hoisted_4$o = [
  _hoisted_2$1g,
  _hoisted_3$14
];
function _sfc_render$1t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1y, _hoisted_4$o);
}
var shoppingBag = /* @__PURE__ */ _export_sfc$1(_sfc_main$1X, [["render", _sfc_render$1t]]);
const _sfc_main$1W = defineComponent({
  name: "ShoppingCartFull"
});
const _hoisted_1$1x = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1f = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M432 928a48 48 0 1 1 0-96 48 48 0 0 1 0 96zm320 0a48 48 0 1 1 0-96 48 48 0 0 1 0 96zM96 128a32 32 0 0 1 0-64h160a32 32 0 0 1 31.36 25.728L320.64 256H928a32 32 0 0 1 31.296 38.72l-96 448A32 32 0 0 1 832 768H384a32 32 0 0 1-31.36-25.728L229.76 128H96zm314.24 576h395.904l82.304-384H333.44l76.8 384z"
}, null, -1);
const _hoisted_3$13 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M699.648 256 608 145.984 516.352 256h183.296zm-140.8-151.04a64 64 0 0 1 98.304 0L836.352 320H379.648l179.2-215.04z"
}, null, -1);
const _hoisted_4$n = [
  _hoisted_2$1f,
  _hoisted_3$13
];
function _sfc_render$1s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1x, _hoisted_4$n);
}
var shoppingCartFull = /* @__PURE__ */ _export_sfc$1(_sfc_main$1W, [["render", _sfc_render$1s]]);
const _sfc_main$1V = defineComponent({
  name: "ShoppingCart"
});
const _hoisted_1$1w = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1e = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M432 928a48 48 0 1 1 0-96 48 48 0 0 1 0 96zm320 0a48 48 0 1 1 0-96 48 48 0 0 1 0 96zM96 128a32 32 0 0 1 0-64h160a32 32 0 0 1 31.36 25.728L320.64 256H928a32 32 0 0 1 31.296 38.72l-96 448A32 32 0 0 1 832 768H384a32 32 0 0 1-31.36-25.728L229.76 128H96zm314.24 576h395.904l82.304-384H333.44l76.8 384z"
}, null, -1);
const _hoisted_3$12 = [
  _hoisted_2$1e
];
function _sfc_render$1r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1w, _hoisted_3$12);
}
var shoppingCart = /* @__PURE__ */ _export_sfc$1(_sfc_main$1V, [["render", _sfc_render$1r]]);
const _sfc_main$1U = defineComponent({
  name: "Smoking"
});
const _hoisted_1$1v = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1d = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 576v128h640V576H256zm-32-64h704a32 32 0 0 1 32 32v192a32 32 0 0 1-32 32H224a32 32 0 0 1-32-32V544a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$11 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 576h64v128h-64zM256 64h64v320h-64zM128 192h64v192h-64zM64 512h64v256H64z"
}, null, -1);
const _hoisted_4$m = [
  _hoisted_2$1d,
  _hoisted_3$11
];
function _sfc_render$1q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1v, _hoisted_4$m);
}
var smoking = /* @__PURE__ */ _export_sfc$1(_sfc_main$1U, [["render", _sfc_render$1q]]);
const _sfc_main$1T = defineComponent({
  name: "Soccer"
});
const _hoisted_1$1u = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M418.496 871.04 152.256 604.8c-16.512 94.016-2.368 178.624 42.944 224 44.928 44.928 129.344 58.752 223.296 42.24zm72.32-18.176a573.056 573.056 0 0 0 224.832-137.216 573.12 573.12 0 0 0 137.216-224.832L533.888 171.84a578.56 578.56 0 0 0-227.52 138.496A567.68 567.68 0 0 0 170.432 532.48l320.384 320.384zM871.04 418.496c16.512-93.952 2.688-178.368-42.24-223.296-44.544-44.544-128.704-58.048-222.592-41.536L871.04 418.496zM149.952 874.048c-112.96-112.96-88.832-408.96 111.168-608.96C461.056 65.152 760.96 36.928 874.048 149.952c113.024 113.024 86.784 411.008-113.152 610.944-199.936 199.936-497.92 226.112-610.944 113.152zm452.544-497.792 22.656-22.656a32 32 0 0 1 45.248 45.248l-22.656 22.656 45.248 45.248A32 32 0 1 1 647.744 512l-45.248-45.248L557.248 512l45.248 45.248a32 32 0 1 1-45.248 45.248L512 557.248l-45.248 45.248L512 647.744a32 32 0 1 1-45.248 45.248l-45.248-45.248-22.656 22.656a32 32 0 1 1-45.248-45.248l22.656-22.656-45.248-45.248A32 32 0 1 1 376.256 512l45.248 45.248L466.752 512l-45.248-45.248a32 32 0 1 1 45.248-45.248L512 466.752l45.248-45.248L512 376.256a32 32 0 0 1 45.248-45.248l45.248 45.248z"
}, null, -1);
const _hoisted_3$10 = [
  _hoisted_2$1c
];
function _sfc_render$1p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1u, _hoisted_3$10);
}
var soccer = /* @__PURE__ */ _export_sfc$1(_sfc_main$1T, [["render", _sfc_render$1p]]);
const _sfc_main$1S = defineComponent({
  name: "SoldOut"
});
const _hoisted_1$1t = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1b = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 288h131.072a32 32 0 0 1 31.808 28.8L886.4 512h-64.384l-16-160H704v96a32 32 0 1 1-64 0v-96H384v96a32 32 0 0 1-64 0v-96H217.92l-51.2 512H512v64H131.328a32 32 0 0 1-31.808-35.2l57.6-576a32 32 0 0 1 31.808-28.8H320v-22.336C320 154.688 405.504 64 512 64s192 90.688 192 201.664v22.4zm-64 0v-22.336C640 189.248 582.272 128 512 128c-70.272 0-128 61.248-128 137.664v22.4h256zm201.408 476.16a32 32 0 1 1 45.248 45.184l-128 128a32 32 0 0 1-45.248 0l-128-128a32 32 0 1 1 45.248-45.248L704 837.504V608a32 32 0 1 1 64 0v229.504l73.408-73.408z"
}, null, -1);
const _hoisted_3$$ = [
  _hoisted_2$1b
];
function _sfc_render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1t, _hoisted_3$$);
}
var soldOut = /* @__PURE__ */ _export_sfc$1(_sfc_main$1S, [["render", _sfc_render$1o]]);
const _sfc_main$1R = defineComponent({
  name: "SortDown"
});
const _hoisted_1$1s = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$1a = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0z"
}, null, -1);
const _hoisted_3$_ = [
  _hoisted_2$1a
];
function _sfc_render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1s, _hoisted_3$_);
}
var sortDown = /* @__PURE__ */ _export_sfc$1(_sfc_main$1R, [["render", _sfc_render$1n]]);
const _sfc_main$1Q = defineComponent({
  name: "SortUp"
});
const _hoisted_1$1r = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$19 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248z"
}, null, -1);
const _hoisted_3$Z = [
  _hoisted_2$19
];
function _sfc_render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1r, _hoisted_3$Z);
}
var sortUp = /* @__PURE__ */ _export_sfc$1(_sfc_main$1Q, [["render", _sfc_render$1m]]);
const _sfc_main$1P = defineComponent({
  name: "Sort"
});
const _hoisted_1$1q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$18 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 96a32 32 0 0 1 64 0v786.752a32 32 0 0 1-54.592 22.656L95.936 608a32 32 0 0 1 0-45.312h.128a32 32 0 0 1 45.184 0L384 805.632V96zm192 45.248a32 32 0 0 1 54.592-22.592L928.064 416a32 32 0 0 1 0 45.312h-.128a32 32 0 0 1-45.184 0L640 218.496V928a32 32 0 1 1-64 0V141.248z"
}, null, -1);
const _hoisted_3$Y = [
  _hoisted_2$18
];
function _sfc_render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1q, _hoisted_3$Y);
}
var sort = /* @__PURE__ */ _export_sfc$1(_sfc_main$1P, [["render", _sfc_render$1l]]);
const _sfc_main$1O = defineComponent({
  name: "Stamp"
});
const _hoisted_1$1p = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$17 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M624 475.968V640h144a128 128 0 0 1 128 128H128a128 128 0 0 1 128-128h144V475.968a192 192 0 1 1 224 0zM128 896v-64h768v64H128z"
}, null, -1);
const _hoisted_3$X = [
  _hoisted_2$17
];
function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1p, _hoisted_3$X);
}
var stamp = /* @__PURE__ */ _export_sfc$1(_sfc_main$1O, [["render", _sfc_render$1k]]);
const _sfc_main$1N = defineComponent({
  name: "StarFilled"
});
const _hoisted_1$1o = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$16 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M283.84 867.84 512 747.776l228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72z"
}, null, -1);
const _hoisted_3$W = [
  _hoisted_2$16
];
function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1o, _hoisted_3$W);
}
var starFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$1N, [["render", _sfc_render$1j]]);
const _sfc_main$1M = defineComponent({
  name: "Star"
});
const _hoisted_1$1n = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$15 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72L512 747.84zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
}, null, -1);
const _hoisted_3$V = [
  _hoisted_2$15
];
function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1n, _hoisted_3$V);
}
var star = /* @__PURE__ */ _export_sfc$1(_sfc_main$1M, [["render", _sfc_render$1i]]);
const _sfc_main$1L = defineComponent({
  name: "Stopwatch"
});
const _hoisted_1$1m = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$14 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1);
const _hoisted_3$U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M672 234.88c-39.168 174.464-80 298.624-122.688 372.48-64 110.848-202.624 30.848-138.624-80C453.376 453.44 540.48 355.968 672 234.816z"
}, null, -1);
const _hoisted_4$l = [
  _hoisted_2$14,
  _hoisted_3$U
];
function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1m, _hoisted_4$l);
}
var stopwatch = /* @__PURE__ */ _export_sfc$1(_sfc_main$1L, [["render", _sfc_render$1h]]);
const _sfc_main$1K = defineComponent({
  name: "SuccessFilled"
});
const _hoisted_1$1l = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$13 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1);
const _hoisted_3$T = [
  _hoisted_2$13
];
function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1l, _hoisted_3$T);
}
var successFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$1K, [["render", _sfc_render$1g]]);
const _sfc_main$1J = defineComponent({
  name: "Sugar"
});
const _hoisted_1$1k = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$12 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m801.728 349.184 4.48 4.48a128 128 0 0 1 0 180.992L534.656 806.144a128 128 0 0 1-181.056 0l-4.48-4.48-19.392 109.696a64 64 0 0 1-108.288 34.176L78.464 802.56a64 64 0 0 1 34.176-108.288l109.76-19.328-4.544-4.544a128 128 0 0 1 0-181.056l271.488-271.488a128 128 0 0 1 181.056 0l4.48 4.48 19.392-109.504a64 64 0 0 1 108.352-34.048l142.592 143.04a64 64 0 0 1-34.24 108.16l-109.248 19.2zm-548.8 198.72h447.168v2.24l60.8-60.8a63.808 63.808 0 0 0 18.752-44.416h-426.88l-89.664 89.728a64.064 64.064 0 0 0-10.24 13.248zm0 64c2.752 4.736 6.144 9.152 10.176 13.248l135.744 135.744a64 64 0 0 0 90.496 0L638.4 611.904H252.928zm490.048-230.976L625.152 263.104a64 64 0 0 0-90.496 0L416.768 380.928h326.208zM123.712 757.312l142.976 142.976 24.32-137.6a25.6 25.6 0 0 0-29.696-29.632l-137.6 24.256zm633.6-633.344-24.32 137.472a25.6 25.6 0 0 0 29.632 29.632l137.28-24.064-142.656-143.04z"
}, null, -1);
const _hoisted_3$S = [
  _hoisted_2$12
];
function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1k, _hoisted_3$S);
}
var sugar = /* @__PURE__ */ _export_sfc$1(_sfc_main$1J, [["render", _sfc_render$1f]]);
const _sfc_main$1I = defineComponent({
  name: "Suitcase"
});
const _hoisted_1$1j = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$11 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 384h768v-64a64 64 0 0 0-64-64H192a64 64 0 0 0-64 64v64zm0 64v320a64 64 0 0 0 64 64h640a64 64 0 0 0 64-64V448H128zm64-256h640a128 128 0 0 1 128 128v448a128 128 0 0 1-128 128H192A128 128 0 0 1 64 768V320a128 128 0 0 1 128-128z"
}, null, -1);
const _hoisted_3$R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 128v64h256v-64H384zm0-64h256a64 64 0 0 1 64 64v64a64 64 0 0 1-64 64H384a64 64 0 0 1-64-64v-64a64 64 0 0 1 64-64z"
}, null, -1);
const _hoisted_4$k = [
  _hoisted_2$11,
  _hoisted_3$R
];
function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1j, _hoisted_4$k);
}
var suitcase = /* @__PURE__ */ _export_sfc$1(_sfc_main$1I, [["render", _sfc_render$1e]]);
const _sfc_main$1H = defineComponent({
  name: "Sunny"
});
const _hoisted_1$1i = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$10 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 704a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512zm0-704a32 32 0 0 1 32 32v64a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 768a32 32 0 0 1 32 32v64a32 32 0 1 1-64 0v-64a32 32 0 0 1 32-32zM195.2 195.2a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 1 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm543.104 543.104a32 32 0 0 1 45.248 0l45.248 45.248a32 32 0 0 1-45.248 45.248l-45.248-45.248a32 32 0 0 1 0-45.248zM64 512a32 32 0 0 1 32-32h64a32 32 0 0 1 0 64H96a32 32 0 0 1-32-32zm768 0a32 32 0 0 1 32-32h64a32 32 0 1 1 0 64h-64a32 32 0 0 1-32-32zM195.2 828.8a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248L240.448 828.8a32 32 0 0 1-45.248 0zm543.104-543.104a32 32 0 0 1 0-45.248l45.248-45.248a32 32 0 0 1 45.248 45.248l-45.248 45.248a32 32 0 0 1-45.248 0z"
}, null, -1);
const _hoisted_3$Q = [
  _hoisted_2$10
];
function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1i, _hoisted_3$Q);
}
var sunny = /* @__PURE__ */ _export_sfc$1(_sfc_main$1H, [["render", _sfc_render$1d]]);
const _sfc_main$1G = defineComponent({
  name: "Sunrise"
});
const _hoisted_1$1h = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$$ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M32 768h960a32 32 0 1 1 0 64H32a32 32 0 1 1 0-64zm129.408-96a352 352 0 0 1 701.184 0h-64.32a288 288 0 0 0-572.544 0h-64.32zM512 128a32 32 0 0 1 32 32v96a32 32 0 0 1-64 0v-96a32 32 0 0 1 32-32zm407.296 168.704a32 32 0 0 1 0 45.248l-67.84 67.84a32 32 0 1 1-45.248-45.248l67.84-67.84a32 32 0 0 1 45.248 0zm-814.592 0a32 32 0 0 1 45.248 0l67.84 67.84a32 32 0 1 1-45.248 45.248l-67.84-67.84a32 32 0 0 1 0-45.248z"
}, null, -1);
const _hoisted_3$P = [
  _hoisted_2$$
];
function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1h, _hoisted_3$P);
}
var sunrise = /* @__PURE__ */ _export_sfc$1(_sfc_main$1G, [["render", _sfc_render$1c]]);
const _sfc_main$1F = defineComponent({
  name: "Sunset"
});
const _hoisted_1$1g = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$_ = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M82.56 640a448 448 0 1 1 858.88 0h-67.2a384 384 0 1 0-724.288 0H82.56zM32 704h960q32 0 32 32t-32 32H32q-32 0-32-32t32-32zm256 128h448q32 0 32 32t-32 32H288q-32 0-32-32t32-32z"
}, null, -1);
const _hoisted_3$O = [
  _hoisted_2$_
];
function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1g, _hoisted_3$O);
}
var sunset = /* @__PURE__ */ _export_sfc$1(_sfc_main$1F, [["render", _sfc_render$1b]]);
const _sfc_main$1E = defineComponent({
  name: "SwitchButton"
});
const _hoisted_1$1f = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$Z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 159.872V230.4a352 352 0 1 0 320 0v-70.528A416.128 416.128 0 0 1 512 960a416 416 0 0 1-160-800.128z"
}, null, -1);
const _hoisted_3$N = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64q32 0 32 32v320q0 32-32 32t-32-32V96q0-32 32-32z"
}, null, -1);
const _hoisted_4$j = [
  _hoisted_2$Z,
  _hoisted_3$N
];
function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1f, _hoisted_4$j);
}
var switchButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1E, [["render", _sfc_render$1a]]);
const _sfc_main$1D = defineComponent({
  name: "Switch"
});
const _hoisted_1$1e = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$Y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M118.656 438.656a32 32 0 0 1 0-45.248L416 96l4.48-3.776A32 32 0 0 1 461.248 96l3.712 4.48a32.064 32.064 0 0 1-3.712 40.832L218.56 384H928a32 32 0 1 1 0 64H141.248a32 32 0 0 1-22.592-9.344zM64 608a32 32 0 0 1 32-32h786.752a32 32 0 0 1 22.656 54.592L608 928l-4.48 3.776a32.064 32.064 0 0 1-40.832-49.024L805.632 640H96a32 32 0 0 1-32-32z"
}, null, -1);
const _hoisted_3$M = [
  _hoisted_2$Y
];
function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1e, _hoisted_3$M);
}
var _switch = /* @__PURE__ */ _export_sfc$1(_sfc_main$1D, [["render", _sfc_render$19]]);
const _sfc_main$1C = defineComponent({
  name: "TakeawayBox"
});
const _hoisted_1$1d = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$X = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 384H192v448h640V384zM96 320h832V128H96v192zm800 64v480a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V384H64a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h896a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32h-64zM416 512h192a32 32 0 0 1 0 64H416a32 32 0 0 1 0-64z"
}, null, -1);
const _hoisted_3$L = [
  _hoisted_2$X
];
function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1d, _hoisted_3$L);
}
var takeawayBox = /* @__PURE__ */ _export_sfc$1(_sfc_main$1C, [["render", _sfc_render$18]]);
const _sfc_main$1B = defineComponent({
  name: "Ticket"
});
const _hoisted_1$1c = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$W = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 832H64V640a128 128 0 1 0 0-256V192h576v160h64V192h256v192a128 128 0 1 0 0 256v192H704V672h-64v160zm0-416v192h64V416h-64z"
}, null, -1);
const _hoisted_3$K = [
  _hoisted_2$W
];
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1c, _hoisted_3$K);
}
var ticket = /* @__PURE__ */ _export_sfc$1(_sfc_main$1B, [["render", _sfc_render$17]]);
const _sfc_main$1A = defineComponent({
  name: "Tickets"
});
const _hoisted_1$1b = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$V = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M192 128v768h640V128H192zm-32-64h704a32 32 0 0 1 32 32v832a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h192v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1);
const _hoisted_3$J = [
  _hoisted_2$V
];
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1b, _hoisted_3$J);
}
var tickets = /* @__PURE__ */ _export_sfc$1(_sfc_main$1A, [["render", _sfc_render$16]]);
const _sfc_main$1z = defineComponent({
  name: "Timer"
});
const _hoisted_1$1a = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$U = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a320 320 0 1 0 0-640 320 320 0 0 0 0 640zm0 64a384 384 0 1 1 0-768 384 384 0 0 1 0 768z"
}, null, -1);
const _hoisted_3$I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 320a32 32 0 0 1 32 32l-.512 224a32 32 0 1 1-64 0L480 352a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_4$i = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M448 576a64 64 0 1 0 128 0 64 64 0 1 0-128 0zm96-448v128h-64V128h-96a32 32 0 0 1 0-64h256a32 32 0 1 1 0 64h-96z"
}, null, -1);
const _hoisted_5$b = [
  _hoisted_2$U,
  _hoisted_3$I,
  _hoisted_4$i
];
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1a, _hoisted_5$b);
}
var timer = /* @__PURE__ */ _export_sfc$1(_sfc_main$1z, [["render", _sfc_render$15]]);
const _sfc_main$1y = defineComponent({
  name: "ToiletPaper"
});
const _hoisted_1$19 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$T = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M595.2 128H320a192 192 0 0 0-192 192v576h384V352c0-90.496 32.448-171.2 83.2-224zM736 64c123.712 0 224 128.96 224 288S859.712 640 736 640H576v320H64V320A256 256 0 0 1 320 64h416zM576 352v224h160c84.352 0 160-97.28 160-224s-75.648-224-160-224-160 97.28-160 224z"
}, null, -1);
const _hoisted_3$H = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M736 448c-35.328 0-64-43.008-64-96s28.672-96 64-96 64 43.008 64 96-28.672 96-64 96z"
}, null, -1);
const _hoisted_4$h = [
  _hoisted_2$T,
  _hoisted_3$H
];
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$19, _hoisted_4$h);
}
var toiletPaper = /* @__PURE__ */ _export_sfc$1(_sfc_main$1y, [["render", _sfc_render$14]]);
const _sfc_main$1x = defineComponent({
  name: "Tools"
});
const _hoisted_1$18 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$S = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M764.416 254.72a351.68 351.68 0 0 1 86.336 149.184H960v192.064H850.752a351.68 351.68 0 0 1-86.336 149.312l54.72 94.72-166.272 96-54.592-94.72a352.64 352.64 0 0 1-172.48 0L371.136 936l-166.272-96 54.72-94.72a351.68 351.68 0 0 1-86.336-149.312H64v-192h109.248a351.68 351.68 0 0 1 86.336-149.312L204.8 160l166.208-96h.192l54.656 94.592a352.64 352.64 0 0 1 172.48 0L652.8 64h.128L819.2 160l-54.72 94.72zM704 499.968a192 192 0 1 0-384 0 192 192 0 0 0 384 0z"
}, null, -1);
const _hoisted_3$G = [
  _hoisted_2$S
];
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$18, _hoisted_3$G);
}
var tools = /* @__PURE__ */ _export_sfc$1(_sfc_main$1x, [["render", _sfc_render$13]]);
const _sfc_main$1w = defineComponent({
  name: "TopLeft"
});
const _hoisted_1$17 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$R = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 256h416a32 32 0 1 0 0-64H224a32 32 0 0 0-32 32v448a32 32 0 0 0 64 0V256z"
}, null, -1);
const _hoisted_3$F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M246.656 201.344a32 32 0 0 0-45.312 45.312l544 544a32 32 0 0 0 45.312-45.312l-544-544z"
}, null, -1);
const _hoisted_4$g = [
  _hoisted_2$R,
  _hoisted_3$F
];
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$17, _hoisted_4$g);
}
var topLeft = /* @__PURE__ */ _export_sfc$1(_sfc_main$1w, [["render", _sfc_render$12]]);
const _sfc_main$1v = defineComponent({
  name: "TopRight"
});
const _hoisted_1$16 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$Q = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M768 256H353.6a32 32 0 1 1 0-64H800a32 32 0 0 1 32 32v448a32 32 0 0 1-64 0V256z"
}, null, -1);
const _hoisted_3$E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M777.344 201.344a32 32 0 0 1 45.312 45.312l-544 544a32 32 0 0 1-45.312-45.312l544-544z"
}, null, -1);
const _hoisted_4$f = [
  _hoisted_2$Q,
  _hoisted_3$E
];
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$16, _hoisted_4$f);
}
var topRight = /* @__PURE__ */ _export_sfc$1(_sfc_main$1v, [["render", _sfc_render$11]]);
const _sfc_main$1u = defineComponent({
  name: "Top"
});
const _hoisted_1$15 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$P = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M572.235 205.282v600.365a30.118 30.118 0 1 1-60.235 0V205.282L292.382 438.633a28.913 28.913 0 0 1-42.646 0 33.43 33.43 0 0 1 0-45.236l271.058-288.045a28.913 28.913 0 0 1 42.647 0L834.5 393.397a33.43 33.43 0 0 1 0 45.176 28.913 28.913 0 0 1-42.647 0l-219.618-233.23z"
}, null, -1);
const _hoisted_3$D = [
  _hoisted_2$P
];
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$15, _hoisted_3$D);
}
var top$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1u, [["render", _sfc_render$10]]);
const _sfc_main$1t = defineComponent({
  name: "TrendCharts"
});
const _hoisted_1$14 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$O = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 896V128h768v768H128zm291.712-327.296 128 102.4 180.16-201.792-47.744-42.624-139.84 156.608-128-102.4-180.16 201.792 47.744 42.624 139.84-156.608zM816 352a48 48 0 1 0-96 0 48 48 0 0 0 96 0z"
}, null, -1);
const _hoisted_3$C = [
  _hoisted_2$O
];
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$14, _hoisted_3$C);
}
var trendCharts = /* @__PURE__ */ _export_sfc$1(_sfc_main$1t, [["render", _sfc_render$$]]);
const _sfc_main$1s = defineComponent({
  name: "Trophy"
});
const _hoisted_1$13 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$N = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 896V702.08A256.256 256.256 0 0 1 264.064 512h-32.64a96 96 0 0 1-91.968-68.416L93.632 290.88a76.8 76.8 0 0 1 73.6-98.88H256V96a32 32 0 0 1 32-32h448a32 32 0 0 1 32 32v96h88.768a76.8 76.8 0 0 1 73.6 98.88L884.48 443.52A96 96 0 0 1 792.576 512h-32.64A256.256 256.256 0 0 1 544 702.08V896h128a32 32 0 1 1 0 64H352a32 32 0 1 1 0-64h128zm224-448V128H320v320a192 192 0 1 0 384 0zm64 0h24.576a32 32 0 0 0 30.656-22.784l45.824-152.768A12.8 12.8 0 0 0 856.768 256H768v192zm-512 0V256h-88.768a12.8 12.8 0 0 0-12.288 16.448l45.824 152.768A32 32 0 0 0 231.424 448H256z"
}, null, -1);
const _hoisted_3$B = [
  _hoisted_2$N
];
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$13, _hoisted_3$B);
}
var trophy = /* @__PURE__ */ _export_sfc$1(_sfc_main$1s, [["render", _sfc_render$_]]);
const _sfc_main$1r = defineComponent({
  name: "TurnOff"
});
const _hoisted_1$12 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$M = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M329.956 257.138a254.862 254.862 0 0 0 0 509.724h364.088a254.862 254.862 0 0 0 0-509.724H329.956zm0-72.818h364.088a327.68 327.68 0 1 1 0 655.36H329.956a327.68 327.68 0 1 1 0-655.36z"
}, null, -1);
const _hoisted_3$A = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M329.956 621.227a109.227 109.227 0 1 0 0-218.454 109.227 109.227 0 0 0 0 218.454zm0 72.817a182.044 182.044 0 1 1 0-364.088 182.044 182.044 0 0 1 0 364.088z"
}, null, -1);
const _hoisted_4$e = [
  _hoisted_2$M,
  _hoisted_3$A
];
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$12, _hoisted_4$e);
}
var turnOff = /* @__PURE__ */ _export_sfc$1(_sfc_main$1r, [["render", _sfc_render$Z]]);
const _sfc_main$1q = defineComponent({
  name: "Umbrella"
});
const _hoisted_1$11 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$L = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M320 768a32 32 0 1 1 64 0 64 64 0 0 0 128 0V512H64a448 448 0 1 1 896 0H576v256a128 128 0 1 1-256 0zm570.688-320a384.128 384.128 0 0 0-757.376 0h757.376z"
}, null, -1);
const _hoisted_3$z = [
  _hoisted_2$L
];
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$11, _hoisted_3$z);
}
var umbrella = /* @__PURE__ */ _export_sfc$1(_sfc_main$1q, [["render", _sfc_render$Y]]);
const _sfc_main$1p = defineComponent({
  name: "Unlock"
});
const _hoisted_1$10 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$K = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M224 448a32 32 0 0 0-32 32v384a32 32 0 0 0 32 32h576a32 32 0 0 0 32-32V480a32 32 0 0 0-32-32H224zm0-64h576a96 96 0 0 1 96 96v384a96 96 0 0 1-96 96H224a96 96 0 0 1-96-96V480a96 96 0 0 1 96-96z"
}, null, -1);
const _hoisted_3$y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 544a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V576a32 32 0 0 1 32-32zm178.304-295.296A192.064 192.064 0 0 0 320 320v64h352l96 38.4V448H256V320a256 256 0 0 1 493.76-95.104l-59.456 23.808z"
}, null, -1);
const _hoisted_4$d = [
  _hoisted_2$K,
  _hoisted_3$y
];
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$10, _hoisted_4$d);
}
var unlock = /* @__PURE__ */ _export_sfc$1(_sfc_main$1p, [["render", _sfc_render$X]]);
const _sfc_main$1o = defineComponent({
  name: "UploadFilled"
});
const _hoisted_1$$ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$J = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M544 864V672h128L512 480 352 672h128v192H320v-1.6c-5.376.32-10.496 1.6-16 1.6A240 240 0 0 1 64 624c0-123.136 93.12-223.488 212.608-237.248A239.808 239.808 0 0 1 512 192a239.872 239.872 0 0 1 235.456 194.752c119.488 13.76 212.48 114.112 212.48 237.248a240 240 0 0 1-240 240c-5.376 0-10.56-1.28-16-1.6v1.6H544z"
}, null, -1);
const _hoisted_3$x = [
  _hoisted_2$J
];
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$$, _hoisted_3$x);
}
var uploadFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$1o, [["render", _sfc_render$W]]);
const _sfc_main$1n = defineComponent({
  name: "Upload"
});
const _hoisted_1$_ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$I = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 832h704a32 32 0 1 1 0 64H160a32 32 0 1 1 0-64zm384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248L544 253.696z"
}, null, -1);
const _hoisted_3$w = [
  _hoisted_2$I
];
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$_, _hoisted_3$w);
}
var upload = /* @__PURE__ */ _export_sfc$1(_sfc_main$1n, [["render", _sfc_render$V]]);
const _sfc_main$1m = defineComponent({
  name: "UserFilled"
});
const _hoisted_1$Z = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$H = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M288 320a224 224 0 1 0 448 0 224 224 0 1 0-448 0zm544 608H160a32 32 0 0 1-32-32v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 0 1-32 32z"
}, null, -1);
const _hoisted_3$v = [
  _hoisted_2$H
];
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$Z, _hoisted_3$v);
}
var userFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$1m, [["render", _sfc_render$U]]);
const _sfc_main$1l = defineComponent({
  name: "User"
});
const _hoisted_1$Y = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$G = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512zm320 320v-96a96 96 0 0 0-96-96H288a96 96 0 0 0-96 96v96a32 32 0 1 1-64 0v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 1 1-64 0z"
}, null, -1);
const _hoisted_3$u = [
  _hoisted_2$G
];
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$Y, _hoisted_3$u);
}
var user = /* @__PURE__ */ _export_sfc$1(_sfc_main$1l, [["render", _sfc_render$T]]);
const _sfc_main$1k = defineComponent({
  name: "Van"
});
const _hoisted_1$X = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$F = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128.896 736H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32h576a32 32 0 0 1 32 32v96h164.544a32 32 0 0 1 31.616 27.136l54.144 352A32 32 0 0 1 922.688 736h-91.52a144 144 0 1 1-286.272 0H415.104a144 144 0 1 1-286.272 0zm23.36-64a143.872 143.872 0 0 1 239.488 0H568.32c17.088-25.6 42.24-45.376 71.744-55.808V256H128v416h24.256zm655.488 0h77.632l-19.648-128H704v64.896A144 144 0 0 1 807.744 672zm48.128-192-14.72-96H704v96h151.872zM688 832a80 80 0 1 0 0-160 80 80 0 0 0 0 160zm-416 0a80 80 0 1 0 0-160 80 80 0 0 0 0 160z"
}, null, -1);
const _hoisted_3$t = [
  _hoisted_2$F
];
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$X, _hoisted_3$t);
}
var van = /* @__PURE__ */ _export_sfc$1(_sfc_main$1k, [["render", _sfc_render$S]]);
const _sfc_main$1j = defineComponent({
  name: "VideoCameraFilled"
});
const _hoisted_1$W = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$E = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m768 576 192-64v320l-192-64v96a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V480a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v96zM192 768v64h384v-64H192zm192-480a160 160 0 0 1 320 0 160 160 0 0 1-320 0zm64 0a96 96 0 1 0 192.064-.064A96 96 0 0 0 448 288zm-320 32a128 128 0 1 1 256.064.064A128 128 0 0 1 128 320zm64 0a64 64 0 1 0 128 0 64 64 0 0 0-128 0z"
}, null, -1);
const _hoisted_3$s = [
  _hoisted_2$E
];
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$W, _hoisted_3$s);
}
var videoCameraFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$1j, [["render", _sfc_render$R]]);
const _sfc_main$1i = defineComponent({
  name: "VideoCamera"
});
const _hoisted_1$V = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$D = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 768V256H128v512h576zm64-416 192-96v512l-192-96v128a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V224a32 32 0 0 1 32-32h640a32 32 0 0 1 32 32v128zm0 71.552v176.896l128 64V359.552l-128 64zM192 320h192v64H192v-64z"
}, null, -1);
const _hoisted_3$r = [
  _hoisted_2$D
];
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$V, _hoisted_3$r);
}
var videoCamera = /* @__PURE__ */ _export_sfc$1(_sfc_main$1i, [["render", _sfc_render$Q]]);
const _sfc_main$1h = defineComponent({
  name: "VideoPause"
});
const _hoisted_1$U = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$C = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768zm-96-544q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32zm192 0q32 0 32 32v256q0 32-32 32t-32-32V384q0-32 32-32z"
}, null, -1);
const _hoisted_3$q = [
  _hoisted_2$C
];
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$U, _hoisted_3$q);
}
var videoPause = /* @__PURE__ */ _export_sfc$1(_sfc_main$1h, [["render", _sfc_render$P]]);
const _sfc_main$1g = defineComponent({
  name: "VideoPlay"
});
const _hoisted_1$T = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$B = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768zm-48-247.616L668.608 512 464 375.616v272.768zm10.624-342.656 249.472 166.336a48 48 0 0 1 0 79.872L474.624 718.272A48 48 0 0 1 400 678.336V345.6a48 48 0 0 1 74.624-39.936z"
}, null, -1);
const _hoisted_3$p = [
  _hoisted_2$B
];
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$T, _hoisted_3$p);
}
var videoPlay = /* @__PURE__ */ _export_sfc$1(_sfc_main$1g, [["render", _sfc_render$O]]);
const _sfc_main$1f = defineComponent({
  name: "View"
});
const _hoisted_1$S = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$A = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1);
const _hoisted_3$o = [
  _hoisted_2$A
];
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$S, _hoisted_3$o);
}
var view = /* @__PURE__ */ _export_sfc$1(_sfc_main$1f, [["render", _sfc_render$N]]);
const _sfc_main$1e = defineComponent({
  name: "WalletFilled"
});
const _hoisted_1$R = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$z = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M688 512a112 112 0 1 0 0 224h208v160H128V352h768v160H688zm32 160h-32a48 48 0 0 1 0-96h32a48 48 0 0 1 0 96zm-80-544 128 160H384l256-160z"
}, null, -1);
const _hoisted_3$n = [
  _hoisted_2$z
];
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$R, _hoisted_3$n);
}
var walletFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$1e, [["render", _sfc_render$M]]);
const _sfc_main$1d = defineComponent({
  name: "Wallet"
});
const _hoisted_1$Q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$y = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M640 288h-64V128H128v704h384v32a32 32 0 0 0 32 32H96a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32h512a32 32 0 0 1 32 32v192z"
}, null, -1);
const _hoisted_3$m = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M128 320v512h768V320H128zm-32-64h832a32 32 0 0 1 32 32v576a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V288a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_4$c = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M704 640a64 64 0 1 1 0-128 64 64 0 0 1 0 128z"
}, null, -1);
const _hoisted_5$a = [
  _hoisted_2$y,
  _hoisted_3$m,
  _hoisted_4$c
];
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$Q, _hoisted_5$a);
}
var wallet = /* @__PURE__ */ _export_sfc$1(_sfc_main$1d, [["render", _sfc_render$L]]);
const _sfc_main$1c = defineComponent({
  name: "WarningFilled"
});
const _hoisted_1$P = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$x = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
}, null, -1);
const _hoisted_3$l = [
  _hoisted_2$x
];
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$P, _hoisted_3$l);
}
var warningFilled = /* @__PURE__ */ _export_sfc$1(_sfc_main$1c, [["render", _sfc_render$K]]);
const _sfc_main$1b = defineComponent({
  name: "Warning"
});
const _hoisted_1$O = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$w = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 832a384 384 0 0 0 0-768 384 384 0 0 0 0 768zm48-176a48 48 0 1 1-96 0 48 48 0 0 1 96 0zm-48-464a32 32 0 0 1 32 32v288a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_3$k = [
  _hoisted_2$w
];
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$O, _hoisted_3$k);
}
var warning = /* @__PURE__ */ _export_sfc$1(_sfc_main$1b, [["render", _sfc_render$J]]);
const _sfc_main$1a = defineComponent({
  name: "Watch"
});
const _hoisted_1$N = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$v = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 768a256 256 0 1 0 0-512 256 256 0 0 0 0 512zm0 64a320 320 0 1 1 0-640 320 320 0 0 1 0 640z"
}, null, -1);
const _hoisted_3$j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 352a32 32 0 0 1 32 32v160a32 32 0 0 1-64 0V384a32 32 0 0 1 32-32z"
}, null, -1);
const _hoisted_4$b = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 512h128q32 0 32 32t-32 32H480q-32 0-32-32t32-32zm128-256V128H416v128h-64V64h320v192h-64zM416 768v128h192V768h64v192H352V768h64z"
}, null, -1);
const _hoisted_5$9 = [
  _hoisted_2$v,
  _hoisted_3$j,
  _hoisted_4$b
];
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$N, _hoisted_5$9);
}
var watch = /* @__PURE__ */ _export_sfc$1(_sfc_main$1a, [["render", _sfc_render$I]]);
const _sfc_main$19 = defineComponent({
  name: "Watermelon"
});
const _hoisted_1$M = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$u = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m683.072 600.32-43.648 162.816-61.824-16.512 53.248-198.528L576 493.248l-158.4 158.4-45.248-45.248 158.4-158.4-55.616-55.616-198.528 53.248-16.512-61.824 162.816-43.648L282.752 200A384 384 0 0 0 824 741.248L683.072 600.32zm231.552 141.056a448 448 0 1 1-632-632l632 632z"
}, null, -1);
const _hoisted_3$i = [
  _hoisted_2$u
];
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$M, _hoisted_3$i);
}
var watermelon = /* @__PURE__ */ _export_sfc$1(_sfc_main$19, [["render", _sfc_render$H]]);
const _sfc_main$18 = defineComponent({
  name: "WindPower"
});
const _hoisted_1$L = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$t = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 64q32 0 32 32v832q0 32-32 32t-32-32V96q0-32 32-32zm416 354.624 128-11.584V168.96l-128-11.52v261.12zm-64 5.824V151.552L320 134.08V160h-64V64l616.704 56.064A96 96 0 0 1 960 215.68v144.64a96 96 0 0 1-87.296 95.616L256 512V224h64v217.92l192-17.472zm256-23.232 98.88-8.96A32 32 0 0 0 896 360.32V215.68a32 32 0 0 0-29.12-31.872l-98.88-8.96v226.368z"
}, null, -1);
const _hoisted_3$h = [
  _hoisted_2$t
];
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$L, _hoisted_3$h);
}
var windPower = /* @__PURE__ */ _export_sfc$1(_sfc_main$18, [["render", _sfc_render$G]]);
const _sfc_main$17 = defineComponent({
  name: "ZoomIn"
});
const _hoisted_1$K = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$s = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
}, null, -1);
const _hoisted_3$g = [
  _hoisted_2$s
];
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$K, _hoisted_3$g);
}
var zoomIn = /* @__PURE__ */ _export_sfc$1(_sfc_main$17, [["render", _sfc_render$F]]);
const _sfc_main$16 = defineComponent({
  name: "ZoomOut"
});
const _hoisted_1$J = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$r = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
}, null, -1);
const _hoisted_3$f = [
  _hoisted_2$r
];
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$J, _hoisted_3$f);
}
var zoomOut = /* @__PURE__ */ _export_sfc$1(_sfc_main$16, [["render", _sfc_render$E]]);
const wrapperKey = Symbol();
const propKey = "__elPropsReservedKey";
function buildProp(option, key2) {
  if (!isObject$1(option) || !!option[propKey])
    return option;
  const { values, required, default: defaultValue, type, validator } = option;
  const _validator = values || validator ? (val) => {
    let valid = false;
    let allowedValues = [];
    if (values) {
      allowedValues = Array.from(values);
      if (hasOwn(option, "default")) {
        allowedValues.push(defaultValue);
      }
      valid || (valid = allowedValues.includes(val));
    }
    if (validator)
      valid || (valid = validator(val));
    if (!valid && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
      warn$1(`Invalid prop: validation failed${key2 ? ` for prop "${key2}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
    }
    return valid;
  } : void 0;
  const prop = {
    type: isObject$1(type) && Object.getOwnPropertySymbols(type).includes(wrapperKey) ? type[wrapperKey] : type,
    required: !!required,
    validator: _validator,
    [propKey]: true
  };
  if (hasOwn(option, "default"))
    prop.default = defaultValue;
  return prop;
}
const buildProps = (props2) => fromPairs(Object.entries(props2).map(([key2, option]) => [
  key2,
  buildProp(option, key2)
]));
const definePropType = (val) => ({ [wrapperKey]: val });
const iconPropType = definePropType([
  String,
  Object,
  Function
]);
const CloseComponents = {
  Close: close
};
const ValidateComponentsMap = {
  validating: loading,
  success: circleCheck,
  error: circleClose
};
const withInstall = (main2, extra) => {
  main2.install = (app) => {
    for (const comp of [main2, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key2, comp] of Object.entries(extra)) {
      main2[key2] = comp;
    }
  }
  return main2;
};
const withNoopInstall = (component) => {
  component.install = NOOP;
  return component;
};
class ElementPlusError extends Error {
  constructor(m2) {
    super(m2);
    this.name = "ElementPlusError";
  }
}
function throwError(scope, m2) {
  throw new ElementPlusError(`[${scope}] ${m2}`);
}
function debugWarn(scope, message2) {
}
function addUnit(value, defaultUnit = "px") {
  if (!value)
    return "";
  if (isString(value)) {
    return value;
  } else if (isNumber(value)) {
    return `${value}${defaultUnit}`;
  }
}
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
};
const datePickTypes = [
  "year",
  "month",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange"
];
const UPDATE_MODEL_EVENT = "update:modelValue";
const CHANGE_EVENT = "change";
const INPUT_EVENT = "input";
const componentSizes = ["", "default", "small", "large"];
const componentSizeMap = {
  large: 40,
  default: 32,
  small: 24
};
const getComponentSize = (size = "default") => {
  return componentSizeMap[size || "default"];
};
const isValidComponentSize = (val) => ["", ...componentSizes].includes(val);
const isValidDatePickType = (val) => [...datePickTypes].includes(val);
var PatchFlags = /* @__PURE__ */ ((PatchFlags2) => {
  PatchFlags2[PatchFlags2["TEXT"] = 1] = "TEXT";
  PatchFlags2[PatchFlags2["CLASS"] = 2] = "CLASS";
  PatchFlags2[PatchFlags2["STYLE"] = 4] = "STYLE";
  PatchFlags2[PatchFlags2["PROPS"] = 8] = "PROPS";
  PatchFlags2[PatchFlags2["FULL_PROPS"] = 16] = "FULL_PROPS";
  PatchFlags2[PatchFlags2["HYDRATE_EVENTS"] = 32] = "HYDRATE_EVENTS";
  PatchFlags2[PatchFlags2["STABLE_FRAGMENT"] = 64] = "STABLE_FRAGMENT";
  PatchFlags2[PatchFlags2["KEYED_FRAGMENT"] = 128] = "KEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["UNKEYED_FRAGMENT"] = 256] = "UNKEYED_FRAGMENT";
  PatchFlags2[PatchFlags2["NEED_PATCH"] = 512] = "NEED_PATCH";
  PatchFlags2[PatchFlags2["DYNAMIC_SLOTS"] = 1024] = "DYNAMIC_SLOTS";
  PatchFlags2[PatchFlags2["HOISTED"] = -1] = "HOISTED";
  PatchFlags2[PatchFlags2["BAIL"] = -2] = "BAIL";
  return PatchFlags2;
})(PatchFlags || {});
const unique = (arr) => [...new Set(arr)];
const castArray = (arr) => {
  if (!arr && arr !== 0)
    return [];
  return Array.isArray(arr) ? arr : [arr];
};
const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
const isKorean = (text2) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text2);
const generateId = () => Math.floor(Math.random() * 1e4);
const mutable = (val) => val;
const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
const LISTENER_PREFIX = /^on[A-Z]/;
const useAttrs = (params = {}) => {
  const { excludeListeners = false, excludeKeys = [] } = params;
  const allExcludeKeys = excludeKeys.concat(DEFAULT_EXCLUDE_KEYS);
  const instance = getCurrentInstance();
  if (!instance) {
    return computed(() => ({}));
  }
  return computed(() => {
    var _a2;
    return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key2]) => !allExcludeKeys.includes(key2) && !(excludeListeners && LISTENER_PREFIX.test(key2))));
  });
};
const buttonGroupContextKey = Symbol("buttonGroupContextKey");
const configProviderContextKey = Symbol();
const dialogInjectionKey = Symbol("dialogInjectionKey");
const formContextKey = Symbol("formContextKey");
const formItemContextKey = Symbol("formItemContextKey");
const elPaginationKey = Symbol("elPaginationKey");
const radioGroupKey = Symbol("radioGroupKey");
const scrollbarContextKey = Symbol("scrollbarContextKey");
const uploadContextKey = Symbol("uploadContextKey");
const POPPER_INJECTION_KEY = Symbol("popper");
const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
const useProp = (name) => {
  const vm = getCurrentInstance();
  return computed(() => {
    var _a2, _b2;
    return (_b2 = (_a2 = vm.proxy) == null ? void 0 : _a2.$props[name]) != null ? _b2 : void 0;
  });
};
const globalConfig = ref();
function useGlobalConfig(key2, defaultValue = void 0) {
  const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
  if (key2) {
    return computed(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = config.value) == null ? void 0 : _a2[key2]) != null ? _b2 : defaultValue;
    });
  } else {
    return config;
  }
}
const useSizeProp = buildProp({
  type: String,
  values: componentSizes,
  required: false
});
const useSize = (fallback, ignore = {}) => {
  const emptyRef = ref(void 0);
  const size = ignore.prop ? emptyRef : useProp("size");
  const globalConfig2 = ignore.global ? emptyRef : useGlobalConfig("size");
  const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
  const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
  return computed(() => size.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
};
const useDisabled$1 = (fallback) => {
  const disabled = useProp("disabled");
  const form = inject(formContextKey, void 0);
  return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
};
const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
  watch$1(() => unref(condition), (val) => {
  }, {
    immediate: true
  });
};
const useDraggable = (targetRef, dragRef, draggable) => {
  let transform2 = {
    offsetX: 0,
    offsetY: 0
  };
  const onMousedown = (e2) => {
    const downX = e2.clientX;
    const downY = e2.clientY;
    const { offsetX, offsetY } = transform2;
    const targetRect = targetRef.value.getBoundingClientRect();
    const targetLeft = targetRect.left;
    const targetTop = targetRect.top;
    const targetWidth = targetRect.width;
    const targetHeight = targetRect.height;
    const clientWidth = document.documentElement.clientWidth;
    const clientHeight = document.documentElement.clientHeight;
    const minLeft = -targetLeft + offsetX;
    const minTop = -targetTop + offsetY;
    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
    const maxTop = clientHeight - targetTop - targetHeight + offsetY;
    const onMousemove = (e22) => {
      const moveX = Math.min(Math.max(offsetX + e22.clientX - downX, minLeft), maxLeft);
      const moveY = Math.min(Math.max(offsetY + e22.clientY - downY, minTop), maxTop);
      transform2 = {
        offsetX: moveX,
        offsetY: moveY
      };
      targetRef.value.style.transform = `translate(${addUnit(moveX)}, ${addUnit(moveY)})`;
    };
    const onMouseup = () => {
      document.removeEventListener("mousemove", onMousemove);
      document.removeEventListener("mouseup", onMouseup);
    };
    document.addEventListener("mousemove", onMousemove);
    document.addEventListener("mouseup", onMouseup);
  };
  const onDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.addEventListener("mousedown", onMousedown);
    }
  };
  const offDraggable = () => {
    if (dragRef.value && targetRef.value) {
      dragRef.value.removeEventListener("mousedown", onMousedown);
    }
  };
  onMounted(() => {
    watchEffect(() => {
      if (draggable.value) {
        onDraggable();
      } else {
        offDraggable();
      }
    });
  });
  onBeforeUnmount(() => {
    offDraggable();
  });
};
const useFocus = (el) => {
  return {
    focus: () => {
      var _a2, _b2;
      (_b2 = (_a2 = el.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b2.call(_a2);
    }
  };
};
const useFormItem = () => {
  const form = inject(formContextKey, void 0);
  const formItem = inject(formItemContextKey, void 0);
  return {
    form,
    formItem
  };
};
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_2, key2) => {
  var _a2;
  return `${(_a2 = option == null ? void 0 : option[key2]) != null ? _a2 : `{${key2}}`}`;
});
const buildLocaleContext = (locale) => {
  const lang = computed(() => unref(locale).name);
  const localeRef = isRef(locale) ? locale : ref(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(locale)
  };
};
const useLocale = () => {
  const locale = useGlobalConfig("locale");
  return buildLocaleContext(computed(() => locale.value || English));
};
const useLockscreen = (trigger2) => {
  if (!isRef(trigger2)) {
    throwError("[useLockscreen]", "You need to pass a ref param to this function");
  }
  if (!isClient || hasClass(document.body, "el-popup-parent--hidden")) {
    return;
  }
  let scrollBarWidth2 = 0;
  let withoutHiddenClass = false;
  let bodyPaddingRight = "0";
  let computedBodyPaddingRight = 0;
  const cleanup = () => {
    removeClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      document.body.style.paddingRight = bodyPaddingRight;
    }
  };
  watch$1(trigger2, (val) => {
    if (!val) {
      cleanup();
      return;
    }
    withoutHiddenClass = !hasClass(document.body, "el-popup-parent--hidden");
    if (withoutHiddenClass) {
      bodyPaddingRight = document.body.style.paddingRight;
      computedBodyPaddingRight = Number.parseInt(getStyle(document.body, "paddingRight"), 10);
    }
    scrollBarWidth2 = getScrollBarWidth();
    const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
    const bodyOverflowY = getStyle(document.body, "overflowY");
    if (scrollBarWidth2 > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarWidth2}px`;
    }
    addClass(document.body, "el-popup-parent--hidden");
  });
  onScopeDispose(() => cleanup());
};
const modalStack = [];
const closeModal = (e2) => {
  if (modalStack.length === 0)
    return;
  if (e2.code === EVENT_CODE.esc) {
    e2.stopPropagation();
    const topModal = modalStack[modalStack.length - 1];
    topModal.handleClose();
  }
};
const useModal = (instance, visibleRef) => {
  watch$1(visibleRef, (val) => {
    if (val) {
      modalStack.push(instance);
    } else {
      modalStack.splice(modalStack.indexOf(instance), 1);
    }
  });
};
if (isClient)
  useEventListener(document, "keydown", closeModal);
const _prop = buildProp({
  type: definePropType(Boolean),
  default: null
});
const _event = buildProp({
  type: definePropType(Function)
});
const createModelToggleComposable = (name) => {
  const useModelToggleProps2 = {
    [name]: _prop,
    [`onUpdate:${name}`]: _event
  };
  const useModelToggleEmits2 = [`update:${name}`];
  const useModelToggle2 = ({
    indicator,
    shouldHideWhenRouteChanges,
    shouldProceed,
    onShow,
    onHide
  }) => {
    const instance = getCurrentInstance();
    const props2 = instance.props;
    const { emit } = instance;
    const updateEventKey = `update:${name}`;
    const hasUpdateHandler = computed(() => isFunction(props2[`onUpdate:${name}`]));
    const isModelBindingAbsent = computed(() => props2[name] === null);
    const doShow = () => {
      if (indicator.value === true) {
        return;
      }
      indicator.value = true;
      if (isFunction(onShow)) {
        onShow();
      }
    };
    const doHide = () => {
      if (indicator.value === false) {
        return;
      }
      indicator.value = false;
      if (isFunction(onHide)) {
        onHide();
      }
    };
    const show = () => {
      if (props2.disabled === true || isFunction(shouldProceed) && !shouldProceed())
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, true);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doShow();
      }
    };
    const hide2 = () => {
      if (props2.disabled === true || !isClient)
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, false);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doHide();
      }
    };
    const onChange = (val) => {
      if (!isBoolean(val))
        return;
      if (props2.disabled && val) {
        if (hasUpdateHandler.value) {
          emit(updateEventKey, false);
        }
      } else if (indicator.value !== val) {
        if (val) {
          doShow();
        } else {
          doHide();
        }
      }
    };
    const toggle = () => {
      if (indicator.value) {
        hide2();
      } else {
        show();
      }
    };
    watch$1(() => props2[name], onChange);
    if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
      watch$1(() => __spreadValues({}, instance.proxy.$route), () => {
        if (shouldHideWhenRouteChanges.value && indicator.value) {
          hide2();
        }
      });
    }
    onMounted(() => {
      onChange(props2[name]);
    });
    return {
      hide: hide2,
      show,
      toggle
    };
  };
  return {
    useModelToggle: useModelToggle2,
    useModelToggleProps: useModelToggleProps2,
    useModelToggleEmits: useModelToggleEmits2
  };
};
const useRestoreActive = (toggle, initialFocus) => {
  let previousActive;
  watch$1(() => toggle.value, (val) => {
    var _a2, _b2;
    if (val) {
      previousActive = document.activeElement;
      if (isRef(initialFocus)) {
        (_b2 = (_a2 = initialFocus.value).focus) == null ? void 0 : _b2.call(_a2);
      }
    } else {
      {
        previousActive.focus();
      }
    }
  });
};
const useSameTarget = (handleClick) => {
  if (!handleClick) {
    return { onClick: NOOP, onMousedown: NOOP, onMouseup: NOOP };
  }
  let mousedownTarget = false;
  let mouseupTarget = false;
  const onClick2 = (e2) => {
    if (mousedownTarget && mouseupTarget) {
      handleClick(e2);
    }
    mousedownTarget = mouseupTarget = false;
  };
  const onMousedown = (e2) => {
    mousedownTarget = e2.target === e2.currentTarget;
  };
  const onMouseup = (e2) => {
    mouseupTarget = e2.target === e2.currentTarget;
  };
  return { onClick: onClick2, onMousedown, onMouseup };
};
function useTimeout() {
  let timeoutHandle;
  const registerTimeout = (fn2, delay) => {
    cancelTimeout();
    timeoutHandle = window.setTimeout(fn2, delay);
  };
  const cancelTimeout = () => window.clearTimeout(timeoutHandle);
  tryOnScopeDispose(() => cancelTimeout());
  return {
    registerTimeout,
    cancelTimeout
  };
}
const defaultIdInjection = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
};
const ID_INJECTION_KEY = Symbol("elIdInjection");
const useId = (deterministicId) => {
  const idInjection = inject(ID_INJECTION_KEY, defaultIdInjection);
  const idRef = computed(() => unref(deterministicId) || `el-id-${idInjection.prefix}-${idInjection.current++}`);
  return idRef;
};
const useEscapeKeydown = (handler) => {
  const cachedHandler = (e2) => {
    const event = e2;
    if (event.key === EVENT_CODE.esc) {
      handler == null ? void 0 : handler(event);
    }
  };
  onMounted(() => {
    on(document, "keydown", cachedHandler);
  });
  onBeforeUnmount(() => {
    off(document, "keydown", cachedHandler);
  });
};
let cachedContainer;
const POPPER_CONTAINER_ID = `el-popper-container-${generateId()}`;
const POPPER_CONTAINER_SELECTOR = `#${POPPER_CONTAINER_ID}`;
const createContainer = () => {
  const container = document.createElement("div");
  container.id = POPPER_CONTAINER_ID;
  document.body.appendChild(container);
  return container;
};
const usePopperContainer = () => {
  onBeforeMount(() => {
    if (!isClient)
      return;
    if (!cachedContainer || !document.body.querySelector(POPPER_CONTAINER_SELECTOR)) {
      cachedContainer = createContainer();
    }
  });
};
const useDelayedToggleProps = buildProps({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  }
});
const useDelayedToggle = ({
  showAfter,
  hideAfter,
  open: open2,
  close: close2
}) => {
  const { registerTimeout } = useTimeout();
  const onOpen = () => {
    registerTimeout(() => {
      open2();
    }, unref(showAfter));
  };
  const onClose = () => {
    registerTimeout(() => {
      close2();
    }, unref(hideAfter));
  };
  return {
    onOpen,
    onClose
  };
};
const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
const useForwardRef = (forwardRef) => {
  const setForwardRef = (el) => {
    forwardRef.value = el;
  };
  provide(FORWARD_REF_INJECTION_KEY, {
    setForwardRef
  });
};
const useForwardRefDirective = (setForwardRef) => {
  return {
    mounted(el) {
      setForwardRef(el);
    },
    updated(el) {
      setForwardRef(el);
    },
    unmounted() {
      setForwardRef(null);
    }
  };
};
const defaultNamespace = "el";
const statePrefix = "is-";
const _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;
  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }
  if (element) {
    cls += `__${element}`;
  }
  if (modifier) {
    cls += `--${modifier}`;
  }
  return cls;
};
const useNamespace = (block) => {
  const globalConfig2 = useGlobalConfig("namespace");
  const namespace = computed(() => globalConfig2.value || defaultNamespace);
  const b2 = (blockSuffix = "") => _bem(unref(namespace), block, blockSuffix, "", "");
  const e2 = (element) => element ? _bem(unref(namespace), block, "", element, "") : "";
  const m2 = (modifier) => modifier ? _bem(unref(namespace), block, "", "", modifier) : "";
  const be = (blockSuffix, element) => blockSuffix && element ? _bem(unref(namespace), block, blockSuffix, element, "") : "";
  const em = (element, modifier) => element && modifier ? _bem(unref(namespace), block, "", element, modifier) : "";
  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(unref(namespace), block, blockSuffix, "", modifier) : "";
  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(unref(namespace), block, blockSuffix, element, modifier) : "";
  const is2 = (name, ...args) => {
    const state = args.length >= 1 ? args[0] : true;
    return name && state ? `${statePrefix}${name}` : "";
  };
  return {
    namespace,
    b: b2,
    e: e2,
    m: m2,
    be,
    em,
    bm,
    bem,
    is: is2
  };
};
const zIndex = ref(0);
const useZIndex = () => {
  const initialZIndex = useGlobalConfig("zIndex", 2e3);
  const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
  const nextZIndex = () => {
    zIndex.value++;
    return currentZIndex.value;
  };
  return {
    initialZIndex,
    currentZIndex,
    nextZIndex
  };
};
var _export_sfc = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props2) {
    target[key2] = val;
  }
  return target;
};
const iconProps = buildProps({
  size: {
    type: definePropType([Number, String])
  },
  color: {
    type: String
  }
});
const __default__$e = {
  name: "ElIcon",
  inheritAttrs: false
};
const _sfc_main$15 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$e), {
  props: iconProps,
  setup(__props) {
    const props2 = __props;
    const ns = useNamespace("icon");
    const style = computed(() => {
      if (!props2.size && !props2.color)
        return {};
      return {
        fontSize: isUndefined(props2.size) ? void 0 : addUnit(props2.size),
        "--color": props2.color
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("i", mergeProps({
        class: unref(ns).b(),
        style: unref(style)
      }, _ctx.$attrs), [
        renderSlot(_ctx.$slots, "default")
      ], 16);
    };
  }
}));
var Icon$1 = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const ElIcon = withInstall(Icon$1);
let hiddenTextarea = void 0;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
  var _a2;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea);
  }
  const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height = hiddenTextarea.scrollHeight;
  const result = {};
  if (boxSizing === "border-box") {
    height = height + borderSize;
  } else if (boxSizing === "content-box") {
    height = height - paddingSize;
  }
  hiddenTextarea.value = "";
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
  if (isNumber(minRows)) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = `${minHeight}px`;
  }
  if (isNumber(maxRows)) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = `${height}px`;
  (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
  hiddenTextarea = void 0;
  return result;
}
const inputProps = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: definePropType([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: definePropType([Boolean, Object]),
    default: false
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  placeholder: {
    type: String
  },
  form: {
    type: String,
    default: ""
  },
  readonly: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  showWordLimit: {
    type: Boolean,
    default: false
  },
  suffixIcon: {
    type: iconPropType,
    default: ""
  },
  prefixIcon: {
    type: iconPropType,
    default: ""
  },
  label: {
    type: String
  },
  tabindex: {
    type: [Number, String]
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  inputStyle: {
    type: definePropType([Object, Array, String]),
    default: () => mutable({})
  }
});
const inputEmits = {
  [UPDATE_MODEL_EVENT]: (value) => isString(value),
  input: (value) => isString(value),
  change: (value) => isString(value),
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent,
  clear: () => true,
  mouseleave: (evt) => evt instanceof MouseEvent,
  mouseenter: (evt) => evt instanceof MouseEvent,
  keydown: (evt) => evt instanceof Event,
  compositionstart: (evt) => evt instanceof CompositionEvent,
  compositionupdate: (evt) => evt instanceof CompositionEvent,
  compositionend: (evt) => evt instanceof CompositionEvent
};
const _hoisted_1$I = ["type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
const _hoisted_2$q = ["tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const __default__$d = {
  name: "ElInput",
  inheritAttrs: false
};
const _sfc_main$14 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$d), {
  props: inputProps,
  emits: inputEmits,
  setup(__props, { expose, emit }) {
    const props2 = __props;
    const PENDANT_MAP = {
      suffix: "append",
      prefix: "prepend"
    };
    const instance = getCurrentInstance();
    const rawAttrs = useAttrs$1();
    const slots = useSlots();
    const attrs = useAttrs();
    const { form, formItem } = useFormItem();
    const inputSize = useSize();
    const inputDisabled = useDisabled$1();
    const nsInput = useNamespace("input");
    const nsTextarea = useNamespace("textarea");
    const input = shallowRef();
    const textarea = shallowRef();
    const focused = ref(false);
    const hovering = ref(false);
    const isComposing = ref(false);
    const passwordVisible = ref(false);
    const textareaCalcStyle = shallowRef(props2.inputStyle);
    const _ref = computed(() => input.value || textarea.value);
    const needStatusIcon = computed(() => {
      var _a2;
      return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
    });
    const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
    const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
    const passwordIcon = computed(() => passwordVisible.value ? view : hide$2);
    const containerStyle = computed(() => [
      rawAttrs.style,
      props2.inputStyle
    ]);
    const textareaStyle = computed(() => [
      props2.inputStyle,
      textareaCalcStyle.value,
      { resize: props2.resize }
    ]);
    const nativeInputValue = computed(() => isNil(props2.modelValue) ? "" : String(props2.modelValue));
    const showClear = computed(() => props2.clearable && !inputDisabled.value && !props2.readonly && !!nativeInputValue.value && (focused.value || hovering.value));
    const showPwdVisible = computed(() => props2.showPassword && !inputDisabled.value && !props2.readonly && (!!nativeInputValue.value || focused.value));
    const isWordLimitVisible = computed(() => props2.showWordLimit && !!attrs.value.maxlength && (props2.type === "text" || props2.type === "textarea") && !inputDisabled.value && !props2.readonly && !props2.showPassword);
    const textLength = computed(() => Array.from(nativeInputValue.value).length);
    const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
    const suffixVisible = computed(() => !!slots.suffix || !!props2.suffixIcon || showClear.value || props2.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
    const resizeTextarea = () => {
      const { type, autosize } = props2;
      if (!isClient || type !== "textarea")
        return;
      if (autosize) {
        const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
        const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
        textareaCalcStyle.value = __spreadValues({}, calcTextareaHeight(textarea.value, minRows, maxRows));
      } else {
        textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textarea.value).minHeight
        };
      }
    };
    const setNativeInputValue = () => {
      const input2 = _ref.value;
      if (!input2 || input2.value === nativeInputValue.value)
        return;
      input2.value = nativeInputValue.value;
    };
    const calcIconOffset = (place2) => {
      const { el } = instance.vnode;
      if (!el)
        return;
      const elList = Array.from(el.querySelectorAll(`.${nsInput.e(place2)}`));
      const target = elList.find((item) => item.parentNode === el);
      if (!target)
        return;
      const pendant = PENDANT_MAP[place2];
      if (slots[pendant]) {
        target.style.transform = `translateX(${place2 === "suffix" ? "-" : ""}${el.querySelector(`.${nsInput.be("group", pendant)}`).offsetWidth}px)`;
      } else {
        target.removeAttribute("style");
      }
    };
    const updateIconOffset = () => {
      calcIconOffset("prefix");
      calcIconOffset("suffix");
    };
    const handleInput = async (event) => {
      const { value } = event.target;
      if (isComposing.value)
        return;
      if (value === nativeInputValue.value)
        return;
      emit(UPDATE_MODEL_EVENT, value);
      emit("input", value);
      await nextTick$1();
      setNativeInputValue();
    };
    const handleChange = (event) => {
      emit("change", event.target.value);
    };
    const handleCompositionStart = (event) => {
      emit("compositionstart", event);
      isComposing.value = true;
    };
    const handleCompositionUpdate = (event) => {
      var _a2;
      emit("compositionupdate", event);
      const text2 = (_a2 = event.target) == null ? void 0 : _a2.value;
      const lastCharacter = text2[text2.length - 1] || "";
      isComposing.value = !isKorean(lastCharacter);
    };
    const handleCompositionEnd = (event) => {
      emit("compositionend", event);
      if (isComposing.value) {
        isComposing.value = false;
        handleInput(event);
      }
    };
    const handlePasswordVisible = () => {
      passwordVisible.value = !passwordVisible.value;
      focus();
    };
    const focus = async () => {
      var _a2;
      await nextTick$1();
      (_a2 = _ref.value) == null ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
    };
    const handleFocus = (event) => {
      focused.value = true;
      emit("focus", event);
    };
    const handleBlur = (event) => {
      var _a2;
      focused.value = false;
      emit("blur", event);
      if (props2.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
      }
    };
    const handleMouseLeave = (evt) => {
      hovering.value = false;
      emit("mouseleave", evt);
    };
    const handleMouseEnter = (evt) => {
      hovering.value = true;
      emit("mouseenter", evt);
    };
    const handleKeydown = (evt) => {
      emit("keydown", evt);
    };
    const select2 = () => {
      var _a2;
      (_a2 = _ref.value) == null ? void 0 : _a2.select();
    };
    const clear2 = () => {
      emit(UPDATE_MODEL_EVENT, "");
      emit("change", "");
      emit("clear");
      emit("input", "");
    };
    watch$1(() => props2.modelValue, () => {
      var _a2;
      nextTick$1(() => resizeTextarea());
      if (props2.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
      }
    });
    watch$1(nativeInputValue, () => setNativeInputValue());
    watch$1(() => props2.type, async () => {
      await nextTick$1();
      setNativeInputValue();
      resizeTextarea();
      updateIconOffset();
    });
    const innerSuffixRef = ref();
    const innerPrefixRef = ref();
    const inputStyleInner = ref({});
    const getSuffixOrPrefixWidth = (slotElm, defaultVal) => {
      if (slotElm.value) {
        const slotElmWidth = slotElm.value.offsetWidth;
        return slotElmWidth > 0 ? slotElmWidth + 16 : defaultVal;
      }
      return defaultVal;
    };
    const setInputPadding = () => {
      inputStyleInner.value = __spreadValues({
        paddingRight: `${getSuffixOrPrefixWidth(innerSuffixRef, 0)}px`,
        paddingLeft: `${getSuffixOrPrefixWidth(innerPrefixRef, 11)}px`
      }, props2.inputStyle);
    };
    watch$1(showClear, () => {
      nextTick$1(() => {
        setInputPadding();
      });
    });
    onMounted(async () => {
      setInputPadding();
      setNativeInputValue();
      updateIconOffset();
      await nextTick$1();
      resizeTextarea();
    });
    onUpdated(async () => {
      await nextTick$1();
      updateIconOffset();
    });
    expose({
      input,
      textarea,
      ref: _ref,
      textareaStyle,
      autosize: toRef(props2, "autosize"),
      focus,
      blur,
      select: select2,
      clear: clear2,
      resizeTextarea
    });
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass([
          _ctx.type === "textarea" ? unref(nsTextarea).b() : unref(nsInput).b(),
          unref(nsInput).m(unref(inputSize)),
          unref(nsInput).is("disabled", unref(inputDisabled)),
          unref(nsInput).is("exceed", unref(inputExceed)),
          {
            [unref(nsInput).b("group")]: _ctx.$slots.prepend || _ctx.$slots.append,
            [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
            [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend,
            [unref(nsInput).m("prefix")]: _ctx.$slots.prefix || _ctx.prefixIcon,
            [unref(nsInput).m("suffix")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
            [unref(nsInput).m("suffix--password-clear")]: unref(showClear) && unref(showPwdVisible)
          },
          _ctx.$attrs.class
        ]),
        style: normalizeStyle$1(unref(containerStyle)),
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }, [
        createCommentVNode(" input "),
        _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createCommentVNode(" prepend slot "),
          _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(nsInput).be("group", "prepend"))
          }, [
            renderSlot(_ctx.$slots, "prepend")
          ], 2)) : createCommentVNode("v-if", true),
          createElementVNode("input", mergeProps({
            ref_key: "input",
            ref: input,
            class: unref(nsInput).e("inner")
          }, unref(attrs), {
            type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
            disabled: unref(inputDisabled),
            readonly: _ctx.readonly,
            autocomplete: _ctx.autocomplete,
            tabindex: _ctx.tabindex,
            "aria-label": _ctx.label,
            placeholder: _ctx.placeholder,
            style: inputStyleInner.value,
            onCompositionstart: handleCompositionStart,
            onCompositionupdate: handleCompositionUpdate,
            onCompositionend: handleCompositionEnd,
            onInput: handleInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onChange: handleChange,
            onKeydown: handleKeydown
          }), null, 16, _hoisted_1$I),
          createCommentVNode(" prefix slot "),
          _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass(unref(nsInput).e("prefix"))
          }, [
            createElementVNode("span", {
              ref_key: "innerPrefixRef",
              ref: innerPrefixRef,
              class: normalizeClass(unref(nsInput).e("prefix-inner"))
            }, [
              renderSlot(_ctx.$slots, "prefix"),
              _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(nsInput).e("icon"))
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true)
            ], 2)
          ], 2)) : createCommentVNode("v-if", true),
          createCommentVNode(" suffix slot "),
          unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
            key: 2,
            class: normalizeClass(unref(nsInput).e("suffix"))
          }, [
            createElementVNode("span", {
              ref_key: "innerSuffixRef",
              ref: innerSuffixRef,
              class: normalizeClass(unref(nsInput).e("suffix-inner"))
            }, [
              !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                renderSlot(_ctx.$slots, "suffix"),
                _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("icon"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 64)) : createCommentVNode("v-if", true),
              unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                key: 1,
                class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
                }, ["prevent"])),
                onClick: clear2
              }, {
                default: withCtx(() => [
                  createVNode$1(unref(circleClose))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true),
              unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                key: 2,
                class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                onClick: handlePasswordVisible
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true),
              unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                key: 3,
                class: normalizeClass(unref(nsInput).e("count"))
              }, [
                createElementVNode("span", {
                  class: normalizeClass(unref(nsInput).e("count-inner"))
                }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)
              ], 2)) : createCommentVNode("v-if", true)
            ], 2),
            unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass([
                unref(nsInput).e("icon"),
                unref(nsInput).e("validateIcon"),
                unref(nsInput).is("loading", unref(validateState) === "validating")
              ])
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", true)
          ], 2)) : createCommentVNode("v-if", true),
          createCommentVNode(" append slot "),
          _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
            key: 3,
            class: normalizeClass(unref(nsInput).be("group", "append"))
          }, [
            renderSlot(_ctx.$slots, "append")
          ], 2)) : createCommentVNode("v-if", true)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createCommentVNode(" textarea "),
          createElementVNode("textarea", mergeProps({
            ref_key: "textarea",
            ref: textarea,
            class: unref(nsTextarea).e("inner")
          }, unref(attrs), {
            tabindex: _ctx.tabindex,
            disabled: unref(inputDisabled),
            readonly: _ctx.readonly,
            autocomplete: _ctx.autocomplete,
            style: unref(textareaStyle),
            "aria-label": _ctx.label,
            placeholder: _ctx.placeholder,
            onCompositionstart: handleCompositionStart,
            onCompositionupdate: handleCompositionUpdate,
            onCompositionend: handleCompositionEnd,
            onInput: handleInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onChange: handleChange,
            onKeydown: handleKeydown
          }), null, 16, _hoisted_2$q),
          unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref(nsInput).e("count"))
          }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)) : createCommentVNode("v-if", true)
        ], 64))
      ], 38)), [
        [vShow, _ctx.type !== "hidden"]
      ]);
    };
  }
}));
var Input$1 = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const ElInput = withInstall(Input$1);
const BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};
const renderThumbStyle = ({ move, size, bar }) => ({
  [bar.size]: size,
  transform: `translate${bar.axis}(${move}%)`
});
const thumbProps = buildProps({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: true
  },
  always: Boolean
});
const COMPONENT_NAME$3 = "Thumb";
const _sfc_main$13 = defineComponent({
  name: COMPONENT_NAME$3,
  props: thumbProps,
  setup(props2) {
    const scrollbar = inject(scrollbarContextKey);
    const ns = useNamespace("scrollbar");
    if (!scrollbar)
      throwError(COMPONENT_NAME$3, "can not inject scrollbar context");
    const instance = ref();
    const thumb = ref();
    const thumbState = ref({});
    const visible = ref(false);
    let cursorDown = false;
    let cursorLeave = false;
    let originalOnSelectStart = isClient ? document.onselectstart : null;
    const bar = computed(() => BAR_MAP[props2.vertical ? "vertical" : "horizontal"]);
    const thumbStyle = computed(() => renderThumbStyle({
      size: props2.size,
      move: props2.move,
      bar: bar.value
    }));
    const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar.wrapElement[bar.value.scrollSize] / props2.ratio / thumb.value[bar.value.offset]);
    const clickThumbHandler = (e2) => {
      var _a2;
      e2.stopPropagation();
      if (e2.ctrlKey || [1, 2].includes(e2.button))
        return;
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
      startDrag(e2);
      const el = e2.currentTarget;
      if (!el)
        return;
      thumbState.value[bar.value.axis] = el[bar.value.offset] - (e2[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
    };
    const clickTrackHandler = (e2) => {
      if (!thumb.value || !instance.value || !scrollbar.wrapElement)
        return;
      const offset2 = Math.abs(e2.target.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]);
      const thumbHalf = thumb.value[bar.value.offset] / 2;
      const thumbPositionPercentage = (offset2 - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };
    const startDrag = (e2) => {
      e2.stopImmediatePropagation();
      cursorDown = true;
      document.addEventListener("mousemove", mouseMoveDocumentHandler);
      document.addEventListener("mouseup", mouseUpDocumentHandler);
      originalOnSelectStart = document.onselectstart;
      document.onselectstart = () => false;
    };
    const mouseMoveDocumentHandler = (e2) => {
      if (!instance.value || !thumb.value)
        return;
      if (cursorDown === false)
        return;
      const prevPage = thumbState.value[bar.value.axis];
      if (!prevPage)
        return;
      const offset2 = (instance.value.getBoundingClientRect()[bar.value.direction] - e2[bar.value.client]) * -1;
      const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      const thumbPositionPercentage = (offset2 - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar.wrapElement[bar.value.scrollSize] / 100;
    };
    const mouseUpDocumentHandler = () => {
      cursorDown = false;
      thumbState.value[bar.value.axis] = 0;
      document.removeEventListener("mousemove", mouseMoveDocumentHandler);
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
      restoreOnselectstart();
      if (cursorLeave)
        visible.value = false;
    };
    const mouseMoveScrollbarHandler = () => {
      cursorLeave = false;
      visible.value = !!props2.size;
    };
    const mouseLeaveScrollbarHandler = () => {
      cursorLeave = true;
      visible.value = cursorDown;
    };
    onBeforeUnmount(() => {
      restoreOnselectstart();
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
    });
    const restoreOnselectstart = () => {
      if (document.onselectstart !== originalOnSelectStart)
        document.onselectstart = originalOnSelectStart;
    };
    useEventListener(toRef(scrollbar, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
    useEventListener(toRef(scrollbar, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
    return {
      ns,
      instance,
      thumb,
      bar,
      thumbStyle,
      visible,
      clickTrackHandler,
      clickThumbHandler
    };
  }
});
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: _ctx.ns.b("fade")
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        ref: "instance",
        class: normalizeClass([_ctx.ns.e("bar"), _ctx.ns.is(_ctx.bar.key)]),
        onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.clickTrackHandler && _ctx.clickTrackHandler(...args))
      }, [
        createElementVNode("div", {
          ref: "thumb",
          class: normalizeClass(_ctx.ns.e("thumb")),
          style: normalizeStyle$1(_ctx.thumbStyle),
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.clickThumbHandler && _ctx.clickThumbHandler(...args))
        }, null, 38)
      ], 34), [
        [vShow, _ctx.always || _ctx.visible]
      ])
    ]),
    _: 1
  }, 8, ["name"]);
}
var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$D], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const barProps = buildProps({
  always: {
    type: Boolean,
    default: true
  },
  width: {
    type: String,
    default: ""
  },
  height: {
    type: String,
    default: ""
  },
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
});
const _sfc_main$12 = defineComponent({
  components: {
    Thumb
  },
  props: barProps,
  setup(props2) {
    const moveX = ref(0);
    const moveY = ref(0);
    const GAP = 4;
    const handleScroll = (wrap) => {
      if (wrap) {
        const offsetHeight = wrap.offsetHeight - GAP;
        const offsetWidth = wrap.offsetWidth - GAP;
        moveY.value = wrap.scrollTop * 100 / offsetHeight * props2.ratioY;
        moveX.value = wrap.scrollLeft * 100 / offsetWidth * props2.ratioX;
      }
    };
    return {
      handleScroll,
      moveX,
      moveY
    };
  }
});
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_thumb = resolveComponent("thumb");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode$1(_component_thumb, {
      move: _ctx.moveX,
      ratio: _ctx.ratioX,
      size: _ctx.width,
      always: _ctx.always
    }, null, 8, ["move", "ratio", "size", "always"]),
    createVNode$1(_component_thumb, {
      move: _ctx.moveY,
      ratio: _ctx.ratioY,
      size: _ctx.height,
      vertical: "",
      always: _ctx.always
    }, null, 8, ["move", "ratio", "size", "always"])
  ], 64);
}
var Bar = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$C], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const scrollbarProps = buildProps({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: {
    type: Boolean,
    default: false
  },
  wrapStyle: {
    type: definePropType([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: {
    type: Boolean,
    default: false
  },
  minSize: {
    type: Number,
    default: 20
  }
});
const scrollbarEmits = {
  scroll: ({
    scrollTop,
    scrollLeft
  }) => isNumber(scrollTop) && isNumber(scrollLeft)
};
const _sfc_main$11 = defineComponent({
  name: "ElScrollbar",
  components: {
    Bar
  },
  props: scrollbarProps,
  emits: scrollbarEmits,
  setup(props2, { emit }) {
    const ns = useNamespace("scrollbar");
    let stopResizeObserver = void 0;
    let stopResizeListener = void 0;
    const scrollbar$ = ref();
    const wrap$ = ref();
    const resize$ = ref();
    const sizeWidth = ref("0");
    const sizeHeight = ref("0");
    const barRef = ref();
    const moveX = ref(0);
    const moveY = ref(0);
    const ratioY = ref(1);
    const ratioX = ref(1);
    const GAP = 4;
    const style = computed(() => {
      const style2 = {};
      if (props2.height)
        style2.height = addUnit(props2.height);
      if (props2.maxHeight)
        style2.maxHeight = addUnit(props2.maxHeight);
      return [props2.wrapStyle, style2];
    });
    const handleScroll = () => {
      var _a2;
      if (wrap$.value) {
        (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
        emit("scroll", {
          scrollTop: wrap$.value.scrollTop,
          scrollLeft: wrap$.value.scrollLeft
        });
      }
    };
    function scrollTo(arg1, arg2) {
      if (isObject$1(arg1)) {
        wrap$.value.scrollTo(arg1);
      } else if (isNumber(arg1) && isNumber(arg2)) {
        wrap$.value.scrollTo(arg1, arg2);
      }
    }
    const setScrollTop = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap$.value.scrollTop = value;
    };
    const setScrollLeft = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap$.value.scrollLeft = value;
    };
    const update2 = () => {
      if (!wrap$.value)
        return;
      const offsetHeight = wrap$.value.offsetHeight - GAP;
      const offsetWidth = wrap$.value.offsetWidth - GAP;
      const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight;
      const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth;
      const height = Math.max(originalHeight, props2.minSize);
      const width = Math.max(originalWidth, props2.minSize);
      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
      sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
      sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
    };
    watch$1(() => props2.noresize, (noresize) => {
      if (noresize) {
        stopResizeObserver == null ? void 0 : stopResizeObserver();
        stopResizeListener == null ? void 0 : stopResizeListener();
      } else {
        ({ stop: stopResizeObserver } = useResizeObserver(resize$, update2));
        stopResizeListener = useEventListener("resize", update2);
      }
    }, { immediate: true });
    watch$1(() => [props2.maxHeight, props2.height], () => {
      if (!props2.native)
        nextTick$1(() => {
          var _a2;
          update2();
          if (wrap$.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
          }
        });
    });
    provide(scrollbarContextKey, reactive({
      scrollbarElement: scrollbar$,
      wrapElement: wrap$
    }));
    onMounted(() => {
      if (!props2.native)
        nextTick$1(() => update2());
    });
    onUpdated(() => update2());
    return {
      ns,
      scrollbar$,
      wrap$,
      resize$,
      barRef,
      moveX,
      moveY,
      ratioX,
      ratioY,
      sizeWidth,
      sizeHeight,
      style,
      update: update2,
      handleScroll,
      scrollTo,
      setScrollTop,
      setScrollLeft
    };
  }
});
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_bar = resolveComponent("bar");
  return openBlock(), createElementBlock("div", {
    ref: "scrollbar$",
    class: normalizeClass(_ctx.ns.b())
  }, [
    createElementVNode("div", {
      ref: "wrap$",
      class: normalizeClass([
        _ctx.wrapClass,
        _ctx.ns.e("wrap"),
        { [_ctx.ns.em("wrap", "hidden-default")]: !_ctx.native }
      ]),
      style: normalizeStyle$1(_ctx.style),
      onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
        ref: "resize$",
        class: normalizeClass([_ctx.ns.e("view"), _ctx.viewClass]),
        style: normalizeStyle$1(_ctx.viewStyle)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]))
    ], 38),
    !_ctx.native ? (openBlock(), createBlock(_component_bar, {
      key: 0,
      ref: "barRef",
      height: _ctx.sizeHeight,
      width: _ctx.sizeWidth,
      always: _ctx.always,
      "ratio-x": _ctx.ratioX,
      "ratio-y": _ctx.ratioY
    }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
  ], 2);
}
var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$B], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const ElScrollbar = withInstall(Scrollbar);
const __default__$c = {
  name: "ElPopperRoot",
  inheritAttrs: false
};
const _sfc_main$10 = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$c), {
  setup(__props, { expose }) {
    const triggerRef2 = ref();
    const popperInstanceRef = ref();
    const contentRef = ref();
    const referenceRef = ref();
    const popperProvides = {
      triggerRef: triggerRef2,
      popperInstanceRef,
      contentRef,
      referenceRef
    };
    expose(popperProvides);
    provide(POPPER_INJECTION_KEY, popperProvides);
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
}));
var Popper = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const usePopperArrowProps = buildProps({
  arrowOffset: {
    type: Number,
    default: 5
  }
});
const __default__$b = {
  name: "ElPopperArrow",
  inheritAttrs: false
};
const _sfc_main$$ = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$b), {
  props: usePopperArrowProps,
  setup(__props, { expose }) {
    const props2 = __props;
    const ns = useNamespace("popper");
    const { arrowOffset, arrowRef } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
    watch$1(() => props2.arrowOffset, (val) => {
      arrowOffset.value = val;
    });
    onBeforeUnmount(() => {
      arrowRef.value = void 0;
    });
    expose({
      arrowRef
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        ref_key: "arrowRef",
        ref: arrowRef,
        class: normalizeClass(unref(ns).e("arrow")),
        "data-popper-arrow": ""
      }, null, 2);
    };
  }
}));
var ElPopperArrow = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const NAME = "ElOnlyChild";
const OnlyChild = defineComponent({
  name: NAME,
  setup(_2, {
    slots,
    attrs
  }) {
    var _a2;
    const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
    const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
    return () => {
      var _a22;
      const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
      if (!defaultSlot)
        return null;
      if (defaultSlot.length > 1) {
        return null;
      }
      const firstLegitNode = findFirstLegitChild(defaultSlot);
      if (!firstLegitNode) {
        return null;
      }
      return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
    };
  }
});
function findFirstLegitChild(node) {
  if (!node)
    return null;
  const children2 = node;
  for (const child of children2) {
    if (isObject$1(child)) {
      switch (child.type) {
        case Comment:
          continue;
        case Text:
          return wrapTextContent(child);
        case "svg":
          return wrapTextContent(child);
        case Fragment:
          return findFirstLegitChild(child.children);
        default:
          return child;
      }
    }
    return wrapTextContent(child);
  }
  return null;
}
function wrapTextContent(s2) {
  return createVNode$1("span", {
    "class": "el-only-child__content"
  }, [s2]);
}
const usePopperTriggerProps = buildProps({
  virtualRef: {
    type: definePropType(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  onBlur: Function,
  onContextmenu: Function,
  id: String,
  open: Boolean
});
const __default__$a = {
  name: "ElPopperTrigger",
  inheritAttrs: false
};
const _sfc_main$_ = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$a), {
  props: usePopperTriggerProps,
  setup(__props, { expose }) {
    const props2 = __props;
    const { triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
    useForwardRef(triggerRef2);
    onMounted(() => {
      watch$1(() => props2.virtualRef, (virtualEl) => {
        if (virtualEl) {
          triggerRef2.value = unrefElement(virtualEl);
        }
      }, {
        immediate: true
      });
      watch$1(() => triggerRef2.value, (el, prevEl) => {
        if (isElement$1(el)) {
          [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ].forEach((eventName) => {
            var _a2;
            const handler = props2[eventName];
            if (handler) {
              el.addEventListener(eventName.slice(2).toLowerCase(), handler);
              (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
            }
          });
        }
      }, {
        immediate: true
      });
    });
    expose({
      triggerRef: triggerRef2
    });
    return (_ctx, _cache) => {
      return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
        "aria-describedby": _ctx.open ? _ctx.id : void 0
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-describedby"])) : createCommentVNode("v-if", true);
    };
  }
}));
var ElPopperTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property2) {
        style2[property2] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent2, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent2.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent2.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox2 = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox2 && css2.willChange === "filter" || isFirefox2 && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$12, value, max$12) {
  return max(min$12, min(value, max$12));
}
function withinMaxClamp(min3, value, max3) {
  var v2 = within(min3, value, max3);
  return v2 > max3 ? max3 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len2 = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len2] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len2];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min3 = paddingObject[minProp];
  var max3 = clientSize - arrowRect[len2] - paddingObject[maxProp];
  var center2 = clientSize / 2 - arrowRect[len2] / 2 + centerToReference;
  var offset2 = within(min3, center2, max3);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center2, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y = _ref.y;
  var win = window;
  var dpr2 = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr2) / dpr2 || 0,
    y: round(y * dpr2) / dpr2 || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y
  }) : {
    x: x2,
    y
  };
  x2 = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y
  }) : {
    x: x2,
    y
  };
  x2 = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y + "px)" : "translate3d(" + x2 + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element) {
  var win = getWindow(element);
  var html2 = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html2.clientWidth;
  var height = html2.clientHeight;
  var x2 = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html2 = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html2).direction === "rtl") {
    x2 += max(html2.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len2 = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len2] / 2 - element[len2] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len2] / 2 - element[len2] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len2 = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len2] > popperRect[len2]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance2 = _ref[1];
  skidding = skidding || 0;
  distance2 = (distance2 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance2,
    y: skidding
  } : {
    x: skidding,
    y: distance2
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len2 = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$12 = offset2 + overflow[mainSide];
    var max$12 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len2] / 2 : 0;
    var minLen = variation === start ? referenceRect[len2] : popperRect[len2];
    var maxLen = variation === start ? -popperRect[len2] : -referenceRect[len2];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len2], arrowRect[len2]);
    var minOffset = isBasePlacement ? referenceRect[len2] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len2] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const POSITIONING_STRATEGIES = ["fixed", "absolute"];
const usePopperCoreConfigProps = buildProps({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: definePropType(Array),
    default: () => []
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: placements,
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: POSITIONING_STRATEGIES,
    default: "absolute"
  }
});
const usePopperContentProps = buildProps(__spreadProps(__spreadValues({}, usePopperCoreConfigProps), {
  style: { type: definePropType([String, Array, Object]) },
  className: { type: definePropType([String, Array, Object]) },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: true
  },
  pure: Boolean,
  popperClass: {
    type: definePropType([String, Array, Object])
  },
  popperStyle: {
    type: definePropType([String, Array, Object])
  },
  referenceEl: {
    type: definePropType(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  zIndex: Number
}));
const buildPopperOptions = (props2, arrowProps) => {
  const { placement, strategy, popperOptions: popperOptions2 } = props2;
  const options = __spreadProps(__spreadValues({
    placement,
    strategy
  }, popperOptions2), {
    modifiers: genModifiers(props2)
  });
  attachArrow(options, arrowProps);
  deriveExtraModifiers(options, popperOptions2 == null ? void 0 : popperOptions2.modifiers);
  return options;
};
const unwrapMeasurableEl = ($el) => {
  if (!isClient)
    return;
  return unrefElement($el);
};
function genModifiers(options) {
  const { offset: offset2, gpuAcceleration, fallbackPlacements } = options;
  return [
    {
      name: "offset",
      options: {
        offset: [0, offset2 != null ? offset2 : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration,
        adaptive: gpuAcceleration
      }
    }
  ];
}
function attachArrow(options, { arrowEl, arrowOffset }) {
  options.modifiers.push({
    name: "arrow",
    options: {
      element: arrowEl,
      padding: arrowOffset != null ? arrowOffset : 5
    }
  });
}
function deriveExtraModifiers(options, modifiers) {
  if (modifiers) {
    options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
  }
}
const __default__$9 = {
  name: "ElPopperContent"
};
const _sfc_main$Z = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$9), {
  props: usePopperContentProps,
  emits: ["mouseenter", "mouseleave"],
  setup(__props, { expose }) {
    const props2 = __props;
    const { popperInstanceRef, contentRef, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
    const { nextZIndex } = useZIndex();
    const ns = useNamespace("popper");
    const popperContentRef = ref();
    const arrowRef = ref();
    const arrowOffset = ref();
    provide(POPPER_CONTENT_INJECTION_KEY, {
      arrowRef,
      arrowOffset
    });
    const contentZIndex = ref(props2.zIndex || nextZIndex());
    const computedReference = computed(() => unwrapMeasurableEl(props2.referenceEl) || unref(triggerRef2));
    const contentStyle = computed(() => [{ zIndex: unref(contentZIndex) }, props2.popperStyle]);
    const contentClass = computed(() => [
      ns.b(),
      ns.is("pure", props2.pure),
      ns.is(props2.effect),
      props2.popperClass
    ]);
    const createPopperInstance = ({ referenceEl, popperContentEl, arrowEl }) => {
      const options = buildPopperOptions(props2, {
        arrowEl,
        arrowOffset: unref(arrowOffset)
      });
      return createPopper(referenceEl, popperContentEl, options);
    };
    const updatePopper = () => {
      var _a2;
      (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.update();
      contentZIndex.value = props2.zIndex || contentZIndex.value || nextZIndex();
    };
    const togglePopperAlive = () => {
      var _a2, _b2;
      const monitorable = { name: "eventListeners", enabled: props2.visible };
      (_b2 = (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.setOptions) == null ? void 0 : _b2.call(_a2, (options) => __spreadProps(__spreadValues({}, options), {
        modifiers: [...options.modifiers || [], monitorable]
      }));
      updatePopper();
    };
    onMounted(() => {
      let updateHandle;
      watch$1(computedReference, (referenceEl) => {
        var _a2;
        updateHandle == null ? void 0 : updateHandle();
        const popperInstance = unref(popperInstanceRef);
        (_a2 = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a2.call(popperInstance);
        if (referenceEl) {
          const popperContentEl = unref(popperContentRef);
          contentRef.value = popperContentEl;
          popperInstanceRef.value = createPopperInstance({
            referenceEl,
            popperContentEl,
            arrowEl: unref(arrowRef)
          });
          updateHandle = watch$1(() => referenceEl.getBoundingClientRect(), () => updatePopper(), {
            immediate: true
          });
        } else {
          popperInstanceRef.value = void 0;
        }
      }, {
        immediate: true
      });
      watch$1(() => props2.visible, togglePopperAlive, { immediate: true });
      watch$1(() => buildPopperOptions(props2, {
        arrowEl: unref(arrowRef),
        arrowOffset: unref(arrowOffset)
      }), (option) => {
        var _a2;
        return (_a2 = popperInstanceRef.value) == null ? void 0 : _a2.setOptions(option);
      });
    });
    expose({
      popperContentRef,
      popperInstanceRef,
      updatePopper,
      contentStyle
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "popperContentRef",
        ref: popperContentRef,
        style: normalizeStyle$1(unref(contentStyle)),
        class: normalizeClass(unref(contentClass)),
        role: "tooltip",
        onMouseenter: _cache[0] || (_cache[0] = (e2) => _ctx.$emit("mouseenter", e2)),
        onMouseleave: _cache[1] || (_cache[1] = (e2) => _ctx.$emit("mouseleave", e2))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 38);
    };
  }
}));
var ElPopperContent = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
function useDeprecateAppendToBody(scope, from) {
  const vm = getCurrentInstance();
  const compatTeleported = computed(() => {
    return isBoolean(vm.props[from]) ? vm.props[from] : vm.props.teleported;
  });
  useDeprecated({
    scope,
    from,
    replacement: "teleported",
    version: "2.1.0",
    ref: "https://element-plus.org/en-US/component/tooltip.html#attributes"
  }, computed(() => isBoolean(vm.props[from])));
  return {
    compatTeleported
  };
}
const ElPopper = withInstall(Popper);
const _sfc_main$Y = defineComponent({
  name: "ElVisuallyHidden",
  props: {
    style: {
      type: [String, Object, Array]
    }
  },
  setup(props2) {
    return {
      computedStyle: computed(() => {
        return [
          props2.style,
          {
            position: "absolute",
            border: 0,
            width: 1,
            height: 1,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            wordWrap: "normal"
          }
        ];
      })
    };
  }
});
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, { style: _ctx.computedStyle }), [
    renderSlot(_ctx.$slots, "default")
  ], 16);
}
var ElVisuallyHidden = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$A], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/visual-hidden/src/visual-hidden.vue"]]);
const useTooltipContentProps = buildProps(__spreadProps(__spreadValues(__spreadValues({}, useDelayedToggleProps), usePopperContentProps), {
  appendTo: {
    type: definePropType([String, Object]),
    default: POPPER_CONTAINER_SELECTOR
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: false
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: definePropType(Boolean),
    default: null
  },
  transition: {
    type: String,
    default: "el-fade-in-linear"
  },
  teleported: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean
  }
}));
const useTooltipTriggerProps = buildProps(__spreadProps(__spreadValues({}, usePopperTriggerProps), {
  disabled: Boolean,
  trigger: {
    type: definePropType([String, Array]),
    default: "hover"
  }
}));
const useTooltipProps = buildProps({
  openDelay: {
    type: Number
  },
  visibleArrow: {
    type: Boolean,
    default: void 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  showArrow: {
    type: Boolean,
    default: true
  }
});
const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
const _sfc_main$X = defineComponent({
  name: "ElTooltipContent",
  components: {
    ElPopperContent,
    ElVisuallyHidden
  },
  inheritAttrs: false,
  props: useTooltipContentProps,
  setup(props2) {
    const contentRef = ref(null);
    const intermediateOpen = ref(false);
    const entering = ref(false);
    const leaving = ref(false);
    const destroyed = ref(false);
    const {
      controlled,
      id,
      open: open2,
      trigger: trigger2,
      onClose,
      onOpen,
      onShow,
      onHide,
      onBeforeShow,
      onBeforeHide
    } = inject(TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = computed(() => {
      return props2.persistent;
    });
    onBeforeUnmount(() => {
      destroyed.value = true;
    });
    const shouldRender = computed(() => {
      return unref(persistentRef) ? true : unref(open2);
    });
    const shouldShow = computed(() => {
      return props2.disabled ? false : unref(open2);
    });
    const contentStyle = computed(() => {
      var _a2;
      return (_a2 = props2.style) != null ? _a2 : {};
    });
    const ariaHidden = computed(() => !unref(open2));
    useEscapeKeydown(onClose);
    const onTransitionLeave = () => {
      onHide();
    };
    const stopWhenControlled = () => {
      if (unref(controlled))
        return true;
    };
    const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
      if (props2.enterable && unref(trigger2) === "hover") {
        onOpen();
      }
    });
    const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
      if (unref(trigger2) === "hover") {
        onClose();
      }
    });
    const onBeforeEnter = () => {
      var _a2, _b2;
      (_b2 = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b2.call(_a2);
      onBeforeShow == null ? void 0 : onBeforeShow();
    };
    const onBeforeLeave = () => {
      onBeforeHide == null ? void 0 : onBeforeHide();
    };
    const onAfterShow = () => {
      onShow();
    };
    let stopHandle;
    watch$1(() => unref(open2), (val) => {
      if (val) {
        stopHandle = onClickOutside(computed(() => {
          var _a2;
          return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
        }), () => {
          if (unref(controlled))
            return;
          const $trigger = unref(trigger2);
          if ($trigger !== "hover") {
            onClose();
          }
        });
      } else {
        stopHandle == null ? void 0 : stopHandle();
      }
    }, {
      flush: "post"
    });
    return {
      ariaHidden,
      entering,
      leaving,
      id,
      intermediateOpen,
      contentStyle,
      contentRef,
      destroyed,
      shouldRender,
      shouldShow,
      open: open2,
      onAfterShow,
      onBeforeEnter,
      onBeforeLeave,
      onContentEnter,
      onContentLeave,
      onTransitionLeave
    };
  }
});
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_visually_hidden = resolveComponent("el-visually-hidden");
  const _component_el_popper_content = resolveComponent("el-popper-content");
  return openBlock(), createBlock(Teleport, {
    disabled: !_ctx.teleported,
    to: _ctx.appendTo
  }, [
    createVNode$1(Transition, {
      name: _ctx.transition,
      onAfterLeave: _ctx.onTransitionLeave,
      onBeforeEnter: _ctx.onBeforeEnter,
      onAfterEnter: _ctx.onAfterShow,
      onBeforeLeave: _ctx.onBeforeLeave
    }, {
      default: withCtx(() => [
        _ctx.shouldRender ? withDirectives((openBlock(), createBlock(_component_el_popper_content, mergeProps({
          key: 0,
          ref: "contentRef"
        }, _ctx.$attrs, {
          "aria-hidden": _ctx.ariaHidden,
          "boundaries-padding": _ctx.boundariesPadding,
          "fallback-placements": _ctx.fallbackPlacements,
          "gpu-acceleration": _ctx.gpuAcceleration,
          offset: _ctx.offset,
          placement: _ctx.placement,
          "popper-options": _ctx.popperOptions,
          strategy: _ctx.strategy,
          effect: _ctx.effect,
          enterable: _ctx.enterable,
          pure: _ctx.pure,
          "popper-class": _ctx.popperClass,
          "popper-style": [_ctx.popperStyle, _ctx.contentStyle],
          "reference-el": _ctx.referenceEl,
          visible: _ctx.shouldShow,
          "z-index": _ctx.zIndex,
          onMouseenter: _ctx.onContentEnter,
          onMouseleave: _ctx.onContentLeave
        }), {
          default: withCtx(() => [
            createCommentVNode(" Workaround bug #6378 "),
            !_ctx.destroyed ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              renderSlot(_ctx.$slots, "default"),
              createVNode$1(_component_el_visually_hidden, {
                id: _ctx.id,
                role: "tooltip"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.ariaLabel), 1)
                ]),
                _: 1
              }, 8, ["id"])
            ], 64)) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16, ["aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "visible", "z-index", "onMouseenter", "onMouseleave"])), [
          [vShow, _ctx.shouldShow]
        ]) : createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["name", "onAfterLeave", "onBeforeEnter", "onAfterEnter", "onBeforeLeave"])
  ], 8, ["disabled", "to"]);
}
var ElTooltipContent = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$z], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const isTriggerType = (trigger2, type) => {
  if (isArray(trigger2)) {
    return trigger2.includes(type);
  }
  return trigger2 === type;
};
const whenTrigger = (trigger2, type, handler) => {
  return (e2) => {
    isTriggerType(unref(trigger2), type) && handler(e2);
  };
};
const _sfc_main$W = defineComponent({
  name: "ElTooltipTrigger",
  components: {
    ElPopperTrigger
  },
  props: useTooltipTriggerProps,
  setup(props2) {
    const ns = useNamespace("tooltip");
    const { controlled, id, open: open2, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
    const triggerRef2 = ref(null);
    const stopWhenControlledOrDisabled = () => {
      if (unref(controlled) || props2.disabled) {
        return true;
      }
    };
    const trigger2 = toRef(props2, "trigger");
    const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
    const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
    const onClick2 = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e2) => {
      if (e2.button === 0) {
        onToggle(e2);
      }
    }));
    const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
    const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
    const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e2) => {
      e2.preventDefault();
      onToggle(e2);
    }));
    const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e2) => {
      const { code } = e2;
      if (code === EVENT_CODE.enter || code === EVENT_CODE.space) {
        onToggle(e2);
      }
    });
    return {
      onBlur,
      onContextMenu,
      onFocus,
      onMouseenter,
      onMouseleave,
      onClick: onClick2,
      onKeydown,
      open: open2,
      id,
      triggerRef: triggerRef2,
      ns
    };
  }
});
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popper_trigger = resolveComponent("el-popper-trigger");
  return openBlock(), createBlock(_component_el_popper_trigger, {
    id: _ctx.id,
    "virtual-ref": _ctx.virtualRef,
    open: _ctx.open,
    "virtual-triggering": _ctx.virtualTriggering,
    class: normalizeClass(_ctx.ns.e("trigger")),
    onBlur: _ctx.onBlur,
    onClick: _ctx.onClick,
    onContextmenu: _ctx.onContextMenu,
    onFocus: _ctx.onFocus,
    onMouseenter: _ctx.onMouseenter,
    onMouseleave: _ctx.onMouseleave,
    onKeydown: _ctx.onKeydown
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
}
var ElTooltipTrigger = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$y], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const { useModelToggleProps, useModelToggle, useModelToggleEmits } = createModelToggleComposable("visible");
const _sfc_main$V = defineComponent({
  name: "ElTooltip",
  components: {
    ElPopper,
    ElPopperArrow,
    ElTooltipContent,
    ElTooltipTrigger
  },
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, useModelToggleProps), useTooltipContentProps), useTooltipTriggerProps), usePopperArrowProps), useTooltipProps),
  emits: [...useModelToggleEmits, "before-show", "before-hide", "show", "hide"],
  setup(props2, { emit }) {
    usePopperContainer();
    const compatShowAfter = computed(() => {
      if (!isUndefined(props2.openDelay))
        ;
      return props2.openDelay || props2.showAfter;
    });
    const compatShowArrow = computed(() => {
      if (!isUndefined(props2.visibleArrow))
        ;
      return isBoolean(props2.visibleArrow) ? props2.visibleArrow : props2.showArrow;
    });
    const id = useId();
    const popperRef = ref(null);
    const updatePopper = () => {
      var _a2;
      const popperComponent = unref(popperRef);
      if (popperComponent) {
        (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
      }
    };
    const open2 = ref(false);
    const { show, hide: hide2 } = useModelToggle({
      indicator: open2
    });
    const { onOpen, onClose } = useDelayedToggle({
      showAfter: compatShowAfter,
      hideAfter: toRef(props2, "hideAfter"),
      open: show,
      close: hide2
    });
    const controlled = computed(() => isBoolean(props2.visible));
    provide(TOOLTIP_INJECTION_KEY, {
      controlled,
      id,
      open: readonly(open2),
      trigger: toRef(props2, "trigger"),
      onOpen,
      onClose,
      onToggle: () => {
        if (unref(open2)) {
          onClose();
        } else {
          onOpen();
        }
      },
      onShow: () => {
        emit("show");
      },
      onHide: () => {
        emit("hide");
      },
      onBeforeShow: () => {
        emit("before-show");
      },
      onBeforeHide: () => {
        emit("before-hide");
      },
      updatePopper
    });
    watch$1(() => props2.disabled, (disabled) => {
      if (disabled && open2.value) {
        open2.value = false;
      }
    });
    return {
      compatShowAfter,
      compatShowArrow,
      popperRef,
      open: open2,
      hide: hide2,
      updatePopper,
      onOpen,
      onClose
    };
  }
});
const _hoisted_1$H = ["innerHTML"];
const _hoisted_2$p = { key: 1 };
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip_trigger = resolveComponent("el-tooltip-trigger");
  const _component_el_popper_arrow = resolveComponent("el-popper-arrow");
  const _component_el_tooltip_content = resolveComponent("el-tooltip-content");
  const _component_el_popper = resolveComponent("el-popper");
  return openBlock(), createBlock(_component_el_popper, { ref: "popperRef" }, {
    default: withCtx(() => [
      createVNode$1(_component_el_tooltip_trigger, {
        disabled: _ctx.disabled,
        trigger: _ctx.trigger,
        "virtual-ref": _ctx.virtualRef,
        "virtual-triggering": _ctx.virtualTriggering
      }, {
        default: withCtx(() => [
          _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["disabled", "trigger", "virtual-ref", "virtual-triggering"]),
      createVNode$1(_component_el_tooltip_content, {
        "aria-label": _ctx.ariaLabel,
        "boundaries-padding": _ctx.boundariesPadding,
        content: _ctx.content,
        disabled: _ctx.disabled,
        effect: _ctx.effect,
        enterable: _ctx.enterable,
        "fallback-placements": _ctx.fallbackPlacements,
        "hide-after": _ctx.hideAfter,
        "gpu-acceleration": _ctx.gpuAcceleration,
        offset: _ctx.offset,
        persistent: _ctx.persistent,
        "popper-class": _ctx.popperClass,
        "popper-style": _ctx.popperStyle,
        placement: _ctx.placement,
        "popper-options": _ctx.popperOptions,
        pure: _ctx.pure,
        "raw-content": _ctx.rawContent,
        "reference-el": _ctx.referenceEl,
        "show-after": _ctx.compatShowAfter,
        strategy: _ctx.strategy,
        teleported: _ctx.teleported,
        transition: _ctx.transition,
        "z-index": _ctx.zIndex,
        "append-to": _ctx.appendTo
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "content", {}, () => [
            _ctx.rawContent ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: _ctx.content
            }, null, 8, _hoisted_1$H)) : (openBlock(), createElementBlock("span", _hoisted_2$p, toDisplayString(_ctx.content), 1))
          ]),
          _ctx.compatShowArrow ? (openBlock(), createBlock(_component_el_popper_arrow, {
            key: 0,
            "arrow-offset": _ctx.arrowOffset
          }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "show-after", "strategy", "teleported", "transition", "z-index", "append-to"])
    ]),
    _: 3
  }, 512);
}
var Tooltip$1 = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$x], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const ElTooltip = withInstall(Tooltip$1);
const buttonTypes = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
];
const buttonNativeTypes = ["button", "submit", "reset"];
const buttonProps = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  type: {
    type: String,
    values: buttonTypes,
    default: ""
  },
  icon: {
    type: iconPropType,
    default: ""
  },
  nativeType: {
    type: String,
    values: buttonNativeTypes,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: iconPropType,
    default: () => loading
  },
  plain: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  }
});
const buttonEmits = {
  click: (evt) => evt instanceof MouseEvent
};
function bound01(n, max3) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max3 === 360 ? n : Math.min(max3, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max3), 10) / 100;
  }
  if (Math.abs(n - max3) < 1e-6) {
    return 1;
  }
  if (max3 === 360) {
    n = (n < 0 ? n % max3 + max3 : n % max3) / parseFloat(String(max3));
  } else {
    n = n % max3 / parseFloat(String(max3));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}
function rgbToRgb(r, g, b2) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r, g, b2) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b2 = bound01(b2, 255);
  var max3 = Math.max(r, g, b2);
  var min3 = Math.min(r, g, b2);
  var h2 = 0;
  var s2 = 0;
  var l2 = (max3 + min3) / 2;
  if (max3 === min3) {
    s2 = 0;
    h2 = 0;
  } else {
    var d2 = max3 - min3;
    s2 = l2 > 0.5 ? d2 / (2 - max3 - min3) : d2 / (max3 + min3);
    switch (max3) {
      case r:
        h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
        break;
      case g:
        h2 = (b2 - r) / d2 + 2;
        break;
      case b2:
        h2 = (r - g) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, l: l2 };
}
function hue2rgb(p2, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p2 + (q - p2) * (6 * t);
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p2 + (q - p2) * (2 / 3 - t) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  var r;
  var g;
  var b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g = l2;
    b2 = l2;
    r = l2;
  } else {
    var q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q;
    r = hue2rgb(p2, q, h2 + 1 / 3);
    g = hue2rgb(p2, q, h2);
    b2 = hue2rgb(p2, q, h2 - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b2 * 255 };
}
function rgbToHsv(r, g, b2) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b2 = bound01(b2, 255);
  var max3 = Math.max(r, g, b2);
  var min3 = Math.min(r, g, b2);
  var h2 = 0;
  var v2 = max3;
  var d2 = max3 - min3;
  var s2 = max3 === 0 ? 0 : d2 / max3;
  if (max3 === min3) {
    h2 = 0;
  } else {
    switch (max3) {
      case r:
        h2 = (g - b2) / d2 + (g < b2 ? 6 : 0);
        break;
      case g:
        h2 = (b2 - r) / d2 + 2;
        break;
      case b2:
        h2 = (r - g) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i = Math.floor(h2);
  var f = h2 - i;
  var p2 = v2 * (1 - s2);
  var q = v2 * (1 - f * s2);
  var t = v2 * (1 - (1 - f) * s2);
  var mod = i % 6;
  var r = [v2, q, p2, p2, t, v2][mod];
  var g = [t, v2, v2, q, p2, p2][mod];
  var b2 = [p2, p2, t, v2, v2, q][mod];
  return { r: r * 255, g: g * 255, b: b2 * 255 };
}
function rgbToHex(r, g, b2, allow3Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b2, a2, allow4Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b2).toString(16)),
    pad2(convertDecimalToHex(a2))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color2) {
  return {
    r: color2 >> 16,
    g: (color2 & 65280) >> 8,
    b: color2 & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color2) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok = false;
  var format2 = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb = rgbToRgb(color2.r, color2.g, color2.b);
      ok = true;
      format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s2 = convertToPercentage(color2.s);
      v2 = convertToPercentage(color2.v);
      rgb = hsvToRgb(color2.h, s2, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s2 = convertToPercentage(color2.s);
      l2 = convertToPercentage(color2.l);
      rgb = hslToRgb(color2.h, s2, l2);
      ok = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a2 = color2.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok,
    format: color2.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named = false;
  if (names[color2]) {
    color2 = names[color2];
    named = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color2);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color2);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color2) {
  return Boolean(matchers.CSS_UNIT.exec(String(color2)));
}
var TinyColor = function() {
  function TinyColor2(color2, opts) {
    if (color2 === void 0) {
      color2 = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a2;
    if (color2 instanceof TinyColor2) {
      return color2;
    }
    if (typeof color2 === "number") {
      color2 = numberInputToObject(color2);
    }
    this.originalInput = color2;
    var rgb = inputToRGB(color2);
    this.originalInput = color2;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R;
    var G;
    var B;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R = RsRGB / 12.92;
    } else {
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G = GsRGB / 12.92;
    } else {
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B = BsRGB / 12.92;
    } else {
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s2 = Math.round(hsv.s * 100);
    var v2 = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s2 = Math.round(hsl.s * 100);
    var l2 = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r = Math.round(this.r);
    var g = Math.round(this.g);
    var b2 = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b2, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b2, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x2) {
      return "".concat(Math.round(bound01(x2, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x2) {
      return Math.round(bound01(x2, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
      var _b2 = _a2[_i], key2 = _b2[0], value = _b2[1];
      if (hex === value) {
        return key2;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format2) {
    var formatSet = Boolean(format2);
    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color2, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color2).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s2 = hsv.s;
    var v2 = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg = this.toRgb();
    var bg = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg.r + (fg.r - bg.r) * fg.a,
      g: bg.g + (fg.g - bg.g) * fg.a,
      b: bg.b + (fg.b - bg.b) * fg.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result = [this];
    var increment = 360 / n;
    for (var i = 1; i < n; i++) {
      result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color2) {
    return this.toRgbString() === new TinyColor2(color2).toRgbString();
  };
  return TinyColor2;
}();
function darken(color2, amount = 20) {
  return color2.mix("#141414", amount).toString();
}
function useButtonCustomStyle(props2) {
  const _disabled = useDisabled$1();
  return computed(() => {
    let styles2 = {};
    const buttonColor = props2.color;
    if (buttonColor) {
      const color2 = new TinyColor(buttonColor);
      const activeBgColor = props2.dark ? color2.tint(20).toString() : darken(color2, 20);
      if (props2.plain) {
        styles2 = {
          "--el-button-bg-color": props2.dark ? darken(color2, 90) : color2.tint(90).toString(),
          "--el-button-text-color": buttonColor,
          "--el-button-border-color": props2.dark ? darken(color2, 50) : color2.tint(50).toString(),
          "--el-button-hover-text-color": "var(--el-color-white)",
          "--el-button-hover-bg-color": buttonColor,
          "--el-button-hover-border-color": buttonColor,
          "--el-button-active-bg-color": activeBgColor,
          "--el-button-active-text-color": "var(--el-color-white)",
          "--el-button-active-border-color": activeBgColor
        };
        if (_disabled.value) {
          styles2["--el-button-disabled-bg-color"] = props2.dark ? darken(color2, 90) : color2.tint(90).toString();
          styles2["--el-button-disabled-text-color"] = props2.dark ? darken(color2, 50) : color2.tint(50).toString();
          styles2["--el-button-disabled-border-color"] = props2.dark ? darken(color2, 80) : color2.tint(80).toString();
        }
      } else {
        const hoverBgColor = props2.dark ? darken(color2, 30) : color2.tint(30).toString();
        const textColor = color2.isDark() ? "var(--el-color-white)" : "var(--el-color-black)";
        styles2 = {
          "--el-button-bg-color": buttonColor,
          "--el-button-text-color": textColor,
          "--el-button-border-color": buttonColor,
          "--el-button-hover-bg-color": hoverBgColor,
          "--el-button-hover-text-color": textColor,
          "--el-button-hover-border-color": hoverBgColor,
          "--el-button-active-bg-color": activeBgColor,
          "--el-button-active-border-color": activeBgColor
        };
        if (_disabled.value) {
          const disabledButtonColor = props2.dark ? darken(color2, 50) : color2.tint(50).toString();
          styles2["--el-button-disabled-bg-color"] = disabledButtonColor;
          styles2["--el-button-disabled-text-color"] = props2.dark ? "rgba(255, 255, 255, 0.5)" : "var(--el-color-white)";
          styles2["--el-button-disabled-border-color"] = disabledButtonColor;
        }
      }
    }
    return styles2;
  });
}
const _hoisted_1$G = ["disabled", "autofocus", "type"];
const __default__$8 = {
  name: "ElButton"
};
const _sfc_main$U = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$8), {
  props: buttonProps,
  emits: buttonEmits,
  setup(__props, { expose, emit }) {
    const props2 = __props;
    const slots = useSlots();
    const buttonGroupContext = inject(buttonGroupContextKey, void 0);
    const globalConfig2 = useGlobalConfig("button");
    const ns = useNamespace("button");
    const { form } = useFormItem();
    const _size = useSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
    const _disabled = useDisabled$1();
    const _ref = ref();
    const _type = computed(() => props2.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
    const autoInsertSpace = computed(() => {
      var _a2, _b2, _c2;
      return (_c2 = (_b2 = props2.autoInsertSpace) != null ? _b2 : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c2 : false;
    });
    const shouldAddSpace = computed(() => {
      var _a2;
      const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
        const slot = defaultSlot[0];
        if ((slot == null ? void 0 : slot.type) === Text) {
          const text2 = slot.children;
          return /^\p{Unified_Ideograph}{2}$/u.test(text2.trim());
        }
      }
      return false;
    });
    const buttonStyle = useButtonCustomStyle(props2);
    const handleClick = (evt) => {
      if (props2.nativeType === "reset") {
        form == null ? void 0 : form.resetFields();
      }
      emit("click", evt);
    };
    expose({
      ref: _ref,
      size: _size,
      type: _type,
      disabled: _disabled,
      shouldAddSpace
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        ref_key: "_ref",
        ref: _ref,
        class: normalizeClass([
          unref(ns).b(),
          unref(ns).m(unref(_type)),
          unref(ns).m(unref(_size)),
          unref(ns).is("disabled", unref(_disabled)),
          unref(ns).is("loading", _ctx.loading),
          unref(ns).is("plain", _ctx.plain),
          unref(ns).is("round", _ctx.round),
          unref(ns).is("circle", _ctx.circle)
        ]),
        disabled: unref(_disabled) || _ctx.loading,
        autofocus: _ctx.autofocus,
        type: _ctx.nativeType,
        style: normalizeStyle$1(unref(buttonStyle)),
        onClick: handleClick
      }, [
        _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
            key: 1,
            class: normalizeClass(unref(ns).is("loading"))
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 2112)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
          default: withCtx(() => [
            _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : createCommentVNode("v-if", true),
        _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass({ [unref(ns).em("text", "expand")]: unref(shouldAddSpace) })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)) : createCommentVNode("v-if", true)
      ], 14, _hoisted_1$G);
    };
  }
}));
var Button$1 = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const buttonGroupProps = {
  size: buttonProps.size,
  type: buttonProps.type
};
const __default__$7 = {
  name: "ElButtonGroup"
};
const _sfc_main$T = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$7), {
  props: buttonGroupProps,
  setup(__props) {
    const props2 = __props;
    provide(buttonGroupContextKey, reactive({
      size: toRef(props2, "size"),
      type: toRef(props2, "type")
    }));
    const ns = useNamespace("button");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(`${unref(ns).b("group")}`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
}));
var ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const ElButton = withInstall(Button$1, {
  ButtonGroup
});
withNoopInstall(ButtonGroup);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var dayjs_min = { exports: {} };
(function(module2, exports2) {
  !function(t, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t = 1e3, e2 = 6e4, n = 36e5, r = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f = "month", h2 = "quarter", c = "year", d2 = "date", $2 = "Invalid Date", l2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m2 = function(t2, e3, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e3 ? t2 : "" + Array(e3 + 1 - r2.length).join(n2) + t2;
    }, g = { s: m2, z: function(t2) {
      var e3 = -t2.utcOffset(), n2 = Math.abs(e3), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r2, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t2(e3, n2) {
      if (e3.date() < n2.date())
        return -t2(n2, e3);
      var r2 = 12 * (n2.year() - e3.year()) + (n2.month() - e3.month()), i2 = e3.clone().add(r2, f), s3 = n2 - i2 < 0, u3 = e3.clone().add(r2 + (s3 ? -1 : 1), f);
      return +(-(r2 + (n2 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f, y: c, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === void 0;
    } }, v2 = "en", D2 = {};
    D2[v2] = M2;
    var p2 = function(t2) {
      return t2 instanceof _2;
    }, S2 = function t2(e3, n2, r2) {
      var i2;
      if (!e3)
        return v2;
      if (typeof e3 == "string") {
        var s3 = e3.toLowerCase();
        D2[s3] && (i2 = s3), n2 && (D2[s3] = n2, i2 = s3);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t2(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i2 = a3;
      }
      return !r2 && i2 && (v2 = i2), i2 || !r2 && v2;
    }, w2 = function(t2, e3) {
      if (p2(t2))
        return t2.clone();
      var n2 = typeof e3 == "object" ? e3 : {};
      return n2.date = t2, n2.args = arguments, new _2(n2);
    }, O2 = g;
    O2.l = S2, O2.i = p2, O2.w = function(t2, e3) {
      return w2(t2, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t2) {
        this.$L = S2(t2.locale, null, true), this.parse(t2);
      }
      var m3 = M3.prototype;
      return m3.parse = function(t2) {
        this.$d = function(t3) {
          var e3 = t3.date, n2 = t3.utc;
          if (e3 === null)
            return new Date(NaN);
          if (O2.u(e3))
            return new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if (typeof e3 == "string" && !/Z$/i.test(e3)) {
            var r2 = e3.match(l2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s3 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m3.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m3.$utils = function() {
        return O2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === $2);
      }, m3.isSame = function(t2, e3) {
        var n2 = w2(t2);
        return this.startOf(e3) <= n2 && n2 <= this.endOf(e3);
      }, m3.isAfter = function(t2, e3) {
        return w2(t2) < this.startOf(e3);
      }, m3.isBefore = function(t2, e3) {
        return this.endOf(e3) < w2(t2);
      }, m3.$g = function(t2, e3, n2) {
        return O2.u(t2) ? this[e3] : this.set(n2, t2);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t2, e3) {
        var n2 = this, r2 = !!O2.u(e3) || e3, h3 = O2.p(t2), $3 = function(t3, e4) {
          var i2 = O2.w(n2.$u ? Date.UTC(n2.$y, e4, t3) : new Date(n2.$y, e4, t3), n2);
          return r2 ? i2 : i2.endOf(a2);
        }, l3 = function(t3, e4) {
          return O2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n2);
        }, y2 = this.$W, M4 = this.$M, m4 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c:
            return r2 ? $3(1, 0) : $3(31, 11);
          case f:
            return r2 ? $3(1, M4) : $3(0, M4 + 1);
          case o2:
            var v3 = this.$locale().weekStart || 0, D3 = (y2 < v3 ? y2 + 7 : y2) - v3;
            return $3(r2 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return l3(g2 + "Hours", 0);
          case u2:
            return l3(g2 + "Minutes", 1);
          case s2:
            return l3(g2 + "Seconds", 2);
          case i:
            return l3(g2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m3.$set = function(t2, e3) {
        var n2, o3 = O2.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $3 = (n2 = {}, n2[a2] = h3 + "Date", n2[d2] = h3 + "Date", n2[f] = h3 + "Month", n2[c] = h3 + "FullYear", n2[u2] = h3 + "Hours", n2[s2] = h3 + "Minutes", n2[i] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o3], l3 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === f || o3 === c) {
          var y2 = this.clone().set(d2, 1);
          y2.$d[$3](l3), y2.init(), this.$d = y2.set(d2, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          $3 && this.$d[$3](l3);
        return this.init(), this;
      }, m3.set = function(t2, e3) {
        return this.clone().$set(t2, e3);
      }, m3.get = function(t2) {
        return this[O2.p(t2)]();
      }, m3.add = function(r2, h3) {
        var d3, $3 = this;
        r2 = Number(r2);
        var l3 = O2.p(h3), y2 = function(t2) {
          var e3 = w2($3);
          return O2.w(e3.date(e3.date() + Math.round(t2 * r2)), $3);
        };
        if (l3 === f)
          return this.set(f, this.$M + r2);
        if (l3 === c)
          return this.set(c, this.$y + r2);
        if (l3 === a2)
          return y2(1);
        if (l3 === o2)
          return y2(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n, d3[i] = t, d3)[l3] || 1, m4 = this.$d.getTime() + r2 * M4;
        return O2.w(m4, this);
      }, m3.subtract = function(t2, e3) {
        return this.add(-1 * t2, e3);
      }, m3.format = function(t2) {
        var e3 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $2;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n2.weekdays, f2 = n2.months, h3 = function(t3, n3, i3, s4) {
          return t3 && (t3[n3] || t3(e3, r2)) || i3[n3].substr(0, s4);
        }, c2 = function(t3) {
          return O2.s(s3 % 12 || 12, t3, "0");
        }, d3 = n2.meridiem || function(t3, e4, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n2.monthsShort, a3, f2, 3), MMMM: h3(f2, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o3, 2), ddd: h3(n2.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c2(1), hh: c2(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y, function(t3, e4) {
          return e4 || l3[t3] || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r2, d3, $3) {
        var l3, y2 = O2.p(d3), M4 = w2(r2), m4 = (M4.utcOffset() - this.utcOffset()) * e2, g2 = this - M4, v3 = O2.m(this, M4);
        return v3 = (l3 = {}, l3[c] = v3 / 12, l3[f] = v3, l3[h2] = v3 / 3, l3[o2] = (g2 - m4) / 6048e5, l3[a2] = (g2 - m4) / 864e5, l3[u2] = g2 / n, l3[s2] = g2 / e2, l3[i] = g2 / t, l3)[y2] || g2, $3 ? v3 : O2.a(v3);
      }, m3.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t2, e3) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S2(t2, e3, true);
        return r2 && (n2.$L = r2), n2;
      }, m3.clone = function() {
        return O2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), b2 = _2.prototype;
    return w2.prototype = b2, [["$ms", r], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f], ["$y", c], ["$D", d2]].forEach(function(t2) {
      b2[t2[1]] = function(e3) {
        return this.$g(e3, t2[0], t2[1]);
      };
    }), w2.extend = function(t2, e3) {
      return t2.$i || (t2(e3, _2, w2), t2.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t2) {
      return w2(1e3 * t2);
    }, w2.en = D2[v2], w2.Ls = D2, w2.p = {}, w2;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
var localeData$1 = { exports: {} };
(function(module2, exports2) {
  !function(n, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    return function(n, e2, t) {
      var r = e2.prototype, o2 = function(n2) {
        return n2 && (n2.indexOf ? n2 : n2.s);
      }, u2 = function(n2, e3, t2, r2, u3) {
        var i2 = n2.name ? n2 : n2.$locale(), a3 = o2(i2[e3]), s3 = o2(i2[t2]), f = a3 || s3.map(function(n3) {
          return n3.substr(0, r2);
        });
        if (!u3)
          return f;
        var d2 = i2.weekStart;
        return f.map(function(n3, e4) {
          return f[(e4 + (d2 || 0)) % 7];
        });
      }, i = function() {
        return t.Ls[t.locale()];
      }, a2 = function(n2, e3) {
        return n2.formats[e3] || function(n3) {
          return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e4, t2) {
            return e4 || t2.slice(1);
          });
        }(n2.formats[e3.toUpperCase()]);
      }, s2 = function() {
        var n2 = this;
        return { months: function(e3) {
          return e3 ? e3.format("MMMM") : u2(n2, "months");
        }, monthsShort: function(e3) {
          return e3 ? e3.format("MMM") : u2(n2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n2.$locale().weekStart || 0;
        }, weekdays: function(e3) {
          return e3 ? e3.format("dddd") : u2(n2, "weekdays");
        }, weekdaysMin: function(e3) {
          return e3 ? e3.format("dd") : u2(n2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e3) {
          return e3 ? e3.format("ddd") : u2(n2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e3) {
          return a2(n2.$locale(), e3);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return s2.bind(this)();
      }, t.localeData = function() {
        var n2 = i();
        return { firstDayOfWeek: function() {
          return n2.weekStart || 0;
        }, weekdays: function() {
          return t.weekdays();
        }, weekdaysShort: function() {
          return t.weekdaysShort();
        }, weekdaysMin: function() {
          return t.weekdaysMin();
        }, months: function() {
          return t.months();
        }, monthsShort: function() {
          return t.monthsShort();
        }, longDateFormat: function(e3) {
          return a2(n2, e3);
        }, meridiem: n2.meridiem, ordinal: n2.ordinal };
      }, t.months = function() {
        return u2(i(), "months");
      }, t.monthsShort = function() {
        return u2(i(), "monthsShort", "months", 3);
      }, t.weekdays = function(n2) {
        return u2(i(), "weekdays", null, null, n2);
      }, t.weekdaysShort = function(n2) {
        return u2(i(), "weekdaysShort", "weekdays", 3, n2);
      }, t.weekdaysMin = function(n2) {
        return u2(i(), "weekdaysMin", "weekdays", 2, n2);
      };
    };
  });
})(localeData$1);
var localeData = localeData$1.exports;
var customParseFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(t, e2) {
    module2.exports = e2();
  }(commonjsGlobal, function() {
    var t = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, e2 = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^\s\d-_:/()]+/, o2 = {}, s2 = function(t2) {
      return (t2 = +t2) + (t2 > 68 ? 1900 : 2e3);
    };
    var a2 = function(t2) {
      return function(e3) {
        this[t2] = +e3;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(t2) {
      (this.zone || (this.zone = {})).offset = function(t3) {
        if (!t3)
          return 0;
        if (t3 === "Z")
          return 0;
        var e3 = t3.match(/([+-]|\d\d)/g), n2 = 60 * e3[1] + (+e3[2] || 0);
        return n2 === 0 ? 0 : e3[0] === "+" ? -n2 : n2;
      }(t2);
    }], u2 = function(t2) {
      var e3 = o2[t2];
      return e3 && (e3.indexOf ? e3 : e3.s.concat(e3.f));
    }, h2 = function(t2, e3) {
      var n2, r2 = o2.meridiem;
      if (r2) {
        for (var i2 = 1; i2 <= 24; i2 += 1)
          if (t2.indexOf(r2(i2, 0, e3)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = t2 === (e3 ? "pm" : "PM");
      return n2;
    }, d2 = { A: [i, function(t2) {
      this.afternoon = h2(t2, false);
    }], a: [i, function(t2) {
      this.afternoon = h2(t2, true);
    }], S: [/\d/, function(t2) {
      this.milliseconds = 100 * +t2;
    }], SS: [n, function(t2) {
      this.milliseconds = 10 * +t2;
    }], SSS: [/\d{3}/, function(t2) {
      this.milliseconds = +t2;
    }], s: [r, a2("seconds")], ss: [r, a2("seconds")], m: [r, a2("minutes")], mm: [r, a2("minutes")], H: [r, a2("hours")], h: [r, a2("hours")], HH: [r, a2("hours")], hh: [r, a2("hours")], D: [r, a2("day")], DD: [n, a2("day")], Do: [i, function(t2) {
      var e3 = o2.ordinal, n2 = t2.match(/\d+/);
      if (this.day = n2[0], e3)
        for (var r2 = 1; r2 <= 31; r2 += 1)
          e3(r2).replace(/\[|\]/g, "") === t2 && (this.day = r2);
    }], M: [r, a2("month")], MM: [n, a2("month")], MMM: [i, function(t2) {
      var e3 = u2("months"), n2 = (u2("monthsShort") || e3.map(function(t3) {
        return t3.substr(0, 3);
      })).indexOf(t2) + 1;
      if (n2 < 1)
        throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [i, function(t2) {
      var e3 = u2("months").indexOf(t2) + 1;
      if (e3 < 1)
        throw new Error();
      this.month = e3 % 12 || e3;
    }], Y: [/[+-]?\d+/, a2("year")], YY: [n, function(t2) {
      this.year = s2(t2);
    }], YYYY: [/\d{4}/, a2("year")], Z: f, ZZ: f };
    function c(n2) {
      var r2, i2;
      r2 = n2, i2 = o2 && o2.formats;
      for (var s3 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(e3, n3, r3) {
        var o3 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || t[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(t2, e4, n4) {
          return e4 || n4.slice(1);
        });
      })).match(e2), a3 = s3.length, f2 = 0; f2 < a3; f2 += 1) {
        var u3 = s3[f2], h3 = d2[u3], c2 = h3 && h3[0], l2 = h3 && h3[1];
        s3[f2] = l2 ? { regex: c2, parser: l2 } : u3.replace(/^\[|\]$/g, "");
      }
      return function(t2) {
        for (var e3 = {}, n3 = 0, r3 = 0; n3 < a3; n3 += 1) {
          var i3 = s3[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var o3 = i3.regex, f3 = i3.parser, u4 = t2.substr(r3), h4 = o3.exec(u4)[0];
            f3.call(e3, h4), t2 = t2.replace(h4, "");
          }
        }
        return function(t3) {
          var e4 = t3.afternoon;
          if (e4 !== void 0) {
            var n4 = t3.hours;
            e4 ? n4 < 12 && (t3.hours += 12) : n4 === 12 && (t3.hours = 0), delete t3.afternoon;
          }
        }(e3), e3;
      };
    }
    return function(t2, e3, n2) {
      n2.p.customParseFormat = true, t2 && t2.parseTwoDigitYear && (s2 = t2.parseTwoDigitYear);
      var r2 = e3.prototype, i2 = r2.parse;
      r2.parse = function(t3) {
        var e4 = t3.date, r3 = t3.utc, s3 = t3.args;
        this.$u = r3;
        var a3 = s3[1];
        if (typeof a3 == "string") {
          var f2 = s3[2] === true, u3 = s3[3] === true, h3 = f2 || u3, d3 = s3[2];
          u3 && (d3 = s3[2]), o2 = this.$locale(), !f2 && d3 && (o2 = n2.Ls[d3]), this.$d = function(t4, e5, n3) {
            try {
              if (["x", "X"].indexOf(e5) > -1)
                return new Date((e5 === "X" ? 1e3 : 1) * t4);
              var r4 = c(e5)(t4), i3 = r4.year, o3 = r4.month, s4 = r4.day, a4 = r4.hours, f3 = r4.minutes, u4 = r4.seconds, h4 = r4.milliseconds, d4 = r4.zone, l3 = new Date(), m3 = s4 || (i3 || o3 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y2 = 0;
              i3 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
              var p2 = a4 || 0, v2 = f3 || 0, D2 = u4 || 0, g = h4 || 0;
              return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g + 60 * d4.offset * 1e3)) : n3 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g)) : new Date(M3, Y2, m3, p2, v2, D2, g);
            } catch (t5) {
              return new Date("");
            }
          }(e4, a3, r3), this.init(), d3 && d3 !== true && (this.$L = this.locale(d3).$L), h3 && e4 != this.format(a3) && (this.$d = new Date("")), o2 = {};
        } else if (a3 instanceof Array)
          for (var l2 = a3.length, m2 = 1; m2 <= l2; m2 += 1) {
            s3[1] = a3[m2 - 1];
            var M2 = n2.apply(this, s3);
            if (M2.isValid()) {
              this.$d = M2.$d, this.$L = M2.$L, this.init();
              break;
            }
            m2 === l2 && (this.$d = new Date(""));
          }
        else
          i2.call(this, t3);
      };
    };
  });
})(customParseFormat$1);
var customParseFormat = customParseFormat$1.exports;
const DEFAULT_FORMATS_TIME = "HH:mm:ss";
const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
const DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  week: "gggg[w]ww",
  year: "YYYY",
  month: "YYYY-MM",
  datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  monthrange: "YYYY-MM",
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};
const timePickerDefaultProps = {
  id: {
    type: [Array, String]
  },
  name: {
    type: [Array, String],
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: {
    type: String
  },
  valueFormat: {
    type: String
  },
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: [String, Object],
    default: circleClose
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: [String, Object],
    default: ""
  },
  size: {
    type: String,
    validator: isValidComponentSize
  },
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: Object,
    default: () => ({})
  },
  modelValue: {
    type: [Date, Array, String, Number],
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: [Date, Array]
  },
  defaultTime: {
    type: [Date, Array]
  },
  isRange: {
    type: Boolean,
    default: false
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
};
const dateEquals = function(a2, b2) {
  const aIsDate = a2 instanceof Date;
  const bIsDate = b2 instanceof Date;
  if (aIsDate && bIsDate) {
    return a2.getTime() === b2.getTime();
  }
  if (!aIsDate && !bIsDate) {
    return a2 === b2;
  }
  return false;
};
const valueEquals = function(a2, b2) {
  const aIsArray = Array.isArray(a2);
  const bIsArray = Array.isArray(b2);
  if (aIsArray && bIsArray) {
    if (a2.length !== b2.length) {
      return false;
    }
    return a2.every((item, index2) => dateEquals(item, b2[index2]));
  }
  if (!aIsArray && !bIsArray) {
    return dateEquals(a2, b2);
  }
  return false;
};
const parser = function(date, format2, lang) {
  const day = isEmpty(format2) || format2 === "x" ? dayjs(date).locale(lang) : dayjs(date, format2).locale(lang);
  return day.isValid() ? day : void 0;
};
const formatter = function(date, format2, lang) {
  if (isEmpty(format2))
    return date;
  if (format2 === "x")
    return +date;
  return dayjs(date).locale(lang).format(format2);
};
const _sfc_main$S = defineComponent({
  name: "Picker",
  components: {
    ElInput,
    ElTooltip,
    ElIcon
  },
  props: timePickerDefaultProps,
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur",
    "calendar-change",
    "panel-change",
    "visible-change"
  ],
  setup(props2, ctx) {
    const { lang } = useLocale();
    const nsDate = useNamespace("date");
    const nsInput = useNamespace("input");
    const nsRange = useNamespace("range");
    const elForm = inject(formContextKey, {});
    const elFormItem = inject(formItemContextKey, {});
    const elPopperOptions = inject("ElPopperOptions", {});
    const refPopper = ref();
    const inputRef = ref();
    const pickerVisible = ref(false);
    const pickerActualVisible = ref(false);
    const valueOnOpen = ref(null);
    watch$1(pickerVisible, (val) => {
      var _a2;
      if (!val) {
        userInput.value = null;
        nextTick$1(() => {
          emitChange(props2.modelValue);
        });
        ctx.emit("blur");
        blurInput();
        props2.validateEvent && ((_a2 = elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "blur").catch((err) => debugWarn()));
      } else {
        valueOnOpen.value = props2.modelValue;
      }
    });
    const emitChange = (val, isClear) => {
      var _a2;
      if (isClear || !valueEquals(val, valueOnOpen.value)) {
        ctx.emit("change", val);
        props2.validateEvent && ((_a2 = elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn()));
      }
    };
    const emitInput = (val) => {
      if (!valueEquals(props2.modelValue, val)) {
        let formatValue;
        if (Array.isArray(val)) {
          formatValue = val.map((_2) => formatter(_2, props2.valueFormat, lang.value));
        } else if (val) {
          formatValue = formatter(val, props2.valueFormat, lang.value);
        }
        ctx.emit("update:modelValue", val ? formatValue : val, lang.value);
      }
    };
    const refInput = computed(() => {
      if (inputRef.value) {
        const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
        return Array.from(_r.querySelectorAll("input"));
      }
      return [];
    });
    const refStartInput = computed(() => {
      return refInput == null ? void 0 : refInput.value[0];
    });
    const refEndInput = computed(() => {
      return refInput == null ? void 0 : refInput.value[1];
    });
    const setSelectionRange = (start2, end2, pos) => {
      const _inputs = refInput.value;
      if (!_inputs.length)
        return;
      if (!pos || pos === "min") {
        _inputs[0].setSelectionRange(start2, end2);
        _inputs[0].focus();
      } else if (pos === "max") {
        _inputs[1].setSelectionRange(start2, end2);
        _inputs[1].focus();
      }
    };
    const onPick = (date = "", visible = false) => {
      pickerVisible.value = visible;
      let result;
      if (Array.isArray(date)) {
        result = date.map((_2) => _2.toDate());
      } else {
        result = date ? date.toDate() : date;
      }
      userInput.value = null;
      emitInput(result);
    };
    const onBeforeShow = () => {
      pickerActualVisible.value = true;
    };
    const onShow = () => {
      ctx.emit("visible-change", true);
    };
    const onHide = () => {
      pickerActualVisible.value = false;
      ctx.emit("visible-change", false);
    };
    const focus = (focusStartInput = true) => {
      let input = refStartInput.value;
      if (!focusStartInput && isRangeInput.value) {
        input = refEndInput.value;
      }
      if (input) {
        input.focus();
      }
    };
    const handleFocus = (e2) => {
      if (props2.readonly || pickerDisabled.value || pickerVisible.value)
        return;
      pickerVisible.value = true;
      ctx.emit("focus", e2);
    };
    const handleBlur = () => {
      var _a2;
      (_a2 = refPopper.value) == null ? void 0 : _a2.onClose();
      blurInput();
    };
    const pickerDisabled = computed(() => {
      return props2.disabled || elForm.disabled;
    });
    const parsedValue = computed(() => {
      let result;
      if (valueIsEmpty.value) {
        if (pickerOptions.value.getDefaultValue) {
          result = pickerOptions.value.getDefaultValue();
        }
      } else {
        if (Array.isArray(props2.modelValue)) {
          result = props2.modelValue.map((_2) => parser(_2, props2.valueFormat, lang.value));
        } else {
          result = parser(props2.modelValue, props2.valueFormat, lang.value);
        }
      }
      if (pickerOptions.value.getRangeAvailableTime) {
        const availableResult = pickerOptions.value.getRangeAvailableTime(result);
        if (!isEqual(availableResult, result)) {
          result = availableResult;
          emitInput(Array.isArray(result) ? result.map((_2) => _2.toDate()) : result.toDate());
        }
      }
      if (Array.isArray(result) && result.some((_2) => !_2)) {
        result = [];
      }
      return result;
    });
    const displayValue = computed(() => {
      if (!pickerOptions.value.panelReady)
        return;
      const formattedValue = formatDayjsToString(parsedValue.value);
      if (Array.isArray(userInput.value)) {
        return [
          userInput.value[0] || formattedValue && formattedValue[0] || "",
          userInput.value[1] || formattedValue && formattedValue[1] || ""
        ];
      } else if (userInput.value !== null) {
        return userInput.value;
      }
      if (!isTimePicker.value && valueIsEmpty.value)
        return;
      if (!pickerVisible.value && valueIsEmpty.value)
        return;
      if (formattedValue) {
        return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
      }
      return "";
    });
    const isTimeLikePicker = computed(() => props2.type.includes("time"));
    const isTimePicker = computed(() => props2.type.startsWith("time"));
    const isDatesPicker = computed(() => props2.type === "dates");
    const triggerIcon = computed(() => props2.prefixIcon || (isTimeLikePicker.value ? clock : calendar));
    const showClose = ref(false);
    const onClearIconClick = (event) => {
      if (props2.readonly || pickerDisabled.value)
        return;
      if (showClose.value) {
        event.stopPropagation();
        emitInput(null);
        emitChange(null, true);
        showClose.value = false;
        pickerVisible.value = false;
        pickerOptions.value.handleClear && pickerOptions.value.handleClear();
      }
    };
    const valueIsEmpty = computed(() => {
      return !props2.modelValue || Array.isArray(props2.modelValue) && !props2.modelValue.length;
    });
    const onMouseEnter = () => {
      if (props2.readonly || pickerDisabled.value)
        return;
      if (!valueIsEmpty.value && props2.clearable) {
        showClose.value = true;
      }
    };
    const onMouseLeave = () => {
      showClose.value = false;
    };
    const isRangeInput = computed(() => {
      return props2.type.includes("range");
    });
    const pickerSize = useSize();
    const popperPaneRef = computed(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = refPopper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b2.contentRef;
    });
    const popperEl = computed(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = unref(refPopper)) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b2.contentRef;
    });
    const actualInputRef = computed(() => {
      var _a2;
      if (unref(isRangeInput)) {
        return unref(inputRef);
      }
      return (_a2 = unref(inputRef)) == null ? void 0 : _a2.$el;
    });
    onClickOutside(actualInputRef, (e2) => {
      const unrefedPopperEl = unref(popperEl);
      const inputEl = unref(actualInputRef);
      if (unrefedPopperEl && (e2.target === unrefedPopperEl || e2.composedPath().includes(unrefedPopperEl)) || e2.target === inputEl || e2.composedPath().includes(inputEl))
        return;
      pickerVisible.value = false;
    });
    const userInput = ref(null);
    const handleChange = () => {
      if (userInput.value) {
        const value = parseUserInputToDayjs(displayValue.value);
        if (value) {
          if (isValidValue(value)) {
            emitInput(Array.isArray(value) ? value.map((_2) => _2.toDate()) : value.toDate());
            userInput.value = null;
          }
        }
      }
      if (userInput.value === "") {
        emitInput(null);
        emitChange(null);
        userInput.value = null;
      }
    };
    const blurInput = () => {
      refInput.value.forEach((input) => input.blur());
    };
    const parseUserInputToDayjs = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.parseUserInput(value);
    };
    const formatDayjsToString = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.formatToString(value);
    };
    const isValidValue = (value) => {
      return pickerOptions.value.isValidValue(value);
    };
    const handleKeydown = (event) => {
      const code = event.code;
      if (code === EVENT_CODE.esc) {
        pickerVisible.value = false;
        event.stopPropagation();
        return;
      }
      if (code === EVENT_CODE.tab) {
        if (!isRangeInput.value) {
          handleChange();
          pickerVisible.value = false;
          event.stopPropagation();
        } else {
          setTimeout(() => {
            if (!refInput.value.includes(document.activeElement)) {
              pickerVisible.value = false;
              blurInput();
            }
          }, 0);
        }
        return;
      }
      if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
        if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
          handleChange();
          pickerVisible.value = false;
        }
        event.stopPropagation();
        return;
      }
      if (userInput.value) {
        event.stopPropagation();
        return;
      }
      if (pickerOptions.value.handleKeydown) {
        pickerOptions.value.handleKeydown(event);
      }
    };
    const onUserInput = (e2) => {
      userInput.value = e2;
    };
    const handleStartInput = (event) => {
      if (userInput.value) {
        userInput.value = [event.target.value, userInput.value[1]];
      } else {
        userInput.value = [event.target.value, null];
      }
    };
    const handleEndInput = (event) => {
      if (userInput.value) {
        userInput.value = [userInput.value[0], event.target.value];
      } else {
        userInput.value = [null, event.target.value];
      }
    };
    const handleStartChange = () => {
      const value = parseUserInputToDayjs(userInput.value && userInput.value[0]);
      if (value && value.isValid()) {
        userInput.value = [formatDayjsToString(value), displayValue.value[1]];
        const newValue = [value, parsedValue.value && parsedValue.value[1]];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const handleEndChange = () => {
      const value = parseUserInputToDayjs(userInput.value && userInput.value[1]);
      if (value && value.isValid()) {
        userInput.value = [displayValue.value[0], formatDayjsToString(value)];
        const newValue = [parsedValue.value && parsedValue.value[0], value];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const pickerOptions = ref({});
    const onSetPickerOption = (e2) => {
      pickerOptions.value[e2[0]] = e2[1];
      pickerOptions.value.panelReady = true;
    };
    const onCalendarChange = (e2) => {
      ctx.emit("calendar-change", e2);
    };
    const onPanelChange = (value, mode, view2) => {
      ctx.emit("panel-change", value, mode, view2);
    };
    provide("EP_PICKER_BASE", {
      props: props2
    });
    return {
      nsDate,
      nsInput,
      nsRange,
      elPopperOptions,
      isDatesPicker,
      handleEndChange,
      handleStartChange,
      handleStartInput,
      handleEndInput,
      onUserInput,
      handleChange,
      handleKeydown,
      popperPaneRef,
      onClickOutside,
      pickerSize,
      isRangeInput,
      onMouseLeave,
      onMouseEnter,
      onClearIconClick,
      showClose,
      triggerIcon,
      onPick,
      handleFocus,
      handleBlur,
      pickerVisible,
      pickerActualVisible,
      displayValue,
      parsedValue,
      setSelectionRange,
      refPopper,
      inputRef,
      pickerDisabled,
      onSetPickerOption,
      onCalendarChange,
      onPanelChange,
      focus,
      onShow,
      onBeforeShow,
      onHide
    };
  }
});
const _hoisted_1$F = ["id", "name", "placeholder", "value", "disabled", "readonly"];
const _hoisted_2$o = ["id", "name", "placeholder", "value", "disabled", "readonly"];
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createBlock(_component_el_tooltip, mergeProps({
    ref: "refPopper",
    visible: _ctx.pickerVisible,
    "onUpdate:visible": _cache[17] || (_cache[17] = ($event) => _ctx.pickerVisible = $event),
    effect: "light",
    pure: "",
    trigger: "click"
  }, _ctx.$attrs, {
    "append-to-body": "",
    transition: `${_ctx.nsDate.namespace.value}-zoom-in-top`,
    "popper-class": [`${_ctx.nsDate.namespace.value}-picker__popper`, _ctx.popperClass],
    "popper-options": _ctx.elPopperOptions,
    "fallback-placements": ["bottom", "top", "right", "left"],
    "gpu-acceleration": false,
    "stop-popper-mouse-event": false,
    "hide-after": 0,
    persistent: "",
    onBeforeShow: _ctx.onBeforeShow,
    onShow: _ctx.onShow,
    onHide: _ctx.onHide
  }), {
    default: withCtx(() => [
      !_ctx.isRangeInput ? (openBlock(), createBlock(_component_el_input, {
        key: 0,
        id: _ctx.id,
        ref: "inputRef",
        "model-value": _ctx.displayValue,
        name: _ctx.name,
        size: _ctx.pickerSize,
        disabled: _ctx.pickerDisabled,
        placeholder: _ctx.placeholder,
        class: normalizeClass([_ctx.nsDate.b("editor"), _ctx.nsDate.bm("editor", _ctx.type), _ctx.$attrs.class]),
        style: normalizeStyle$1(_ctx.$attrs.style),
        readonly: !_ctx.editable || _ctx.readonly || _ctx.isDatesPicker || _ctx.type === "week",
        onInput: _ctx.onUserInput,
        onFocus: _ctx.handleFocus,
        onKeydown: _ctx.handleKeydown,
        onChange: _ctx.handleChange,
        onMouseenter: _ctx.onMouseEnter,
        onMouseleave: _ctx.onMouseLeave,
        onClick: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop"]))
      }, {
        prefix: withCtx(() => [
          _ctx.triggerIcon ? (openBlock(), createBlock(_component_el_icon, {
            key: 0,
            class: normalizeClass(_ctx.nsInput.e("icon")),
            onClick: _ctx.handleFocus
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.triggerIcon)))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
        ]),
        suffix: withCtx(() => [
          _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
            key: 0,
            class: normalizeClass(`${_ctx.nsInput.e("icon")} clear-icon`),
            onClick: _ctx.onClearIconClick
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
            ]),
            _: 1
          }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
        ]),
        _: 1
      }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "onInput", "onFocus", "onKeydown", "onChange", "onMouseenter", "onMouseleave"])) : (openBlock(), createElementBlock("div", {
        key: 1,
        ref: "inputRef",
        class: normalizeClass([
          _ctx.nsDate.b("editor"),
          _ctx.nsDate.bm("editor", _ctx.type),
          _ctx.nsInput.e("inner"),
          _ctx.nsDate.is("disabled", _ctx.pickerDisabled),
          _ctx.nsDate.is("active", _ctx.pickerVisible),
          _ctx.nsRange.b("editor"),
          _ctx.pickerSize ? _ctx.nsRange.bm("editor", _ctx.pickerSize) : "",
          _ctx.$attrs.class
        ]),
        style: normalizeStyle$1(_ctx.$attrs.style),
        onClick: _cache[7] || (_cache[7] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
        onMouseenter: _cache[8] || (_cache[8] = (...args) => _ctx.onMouseEnter && _ctx.onMouseEnter(...args)),
        onMouseleave: _cache[9] || (_cache[9] = (...args) => _ctx.onMouseLeave && _ctx.onMouseLeave(...args)),
        onKeydown: _cache[10] || (_cache[10] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
      }, [
        _ctx.triggerIcon ? (openBlock(), createBlock(_component_el_icon, {
          key: 0,
          class: normalizeClass([_ctx.nsInput.e("icon"), _ctx.nsRange.e("icon")]),
          onClick: _ctx.handleFocus
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.triggerIcon)))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
        createElementVNode("input", {
          id: _ctx.id && _ctx.id[0],
          autocomplete: "off",
          name: _ctx.name && _ctx.name[0],
          placeholder: _ctx.startPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[0],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: normalizeClass(_ctx.nsRange.b("input")),
          onInput: _cache[1] || (_cache[1] = (...args) => _ctx.handleStartInput && _ctx.handleStartInput(...args)),
          onChange: _cache[2] || (_cache[2] = (...args) => _ctx.handleStartChange && _ctx.handleStartChange(...args)),
          onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args))
        }, null, 42, _hoisted_1$F),
        renderSlot(_ctx.$slots, "range-separator", {}, () => [
          createElementVNode("span", {
            class: normalizeClass(_ctx.nsRange.b("separator"))
          }, toDisplayString(_ctx.rangeSeparator), 3)
        ]),
        createElementVNode("input", {
          id: _ctx.id && _ctx.id[1],
          autocomplete: "off",
          name: _ctx.name && _ctx.name[1],
          placeholder: _ctx.endPlaceholder,
          value: _ctx.displayValue && _ctx.displayValue[1],
          disabled: _ctx.pickerDisabled,
          readonly: !_ctx.editable || _ctx.readonly,
          class: normalizeClass(_ctx.nsRange.b("input")),
          onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
          onInput: _cache[5] || (_cache[5] = (...args) => _ctx.handleEndInput && _ctx.handleEndInput(...args)),
          onChange: _cache[6] || (_cache[6] = (...args) => _ctx.handleEndChange && _ctx.handleEndChange(...args))
        }, null, 42, _hoisted_2$o),
        _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
          key: 1,
          class: normalizeClass([
            _ctx.nsInput.e("icon"),
            _ctx.nsRange.e("close-icon"),
            {
              [_ctx.nsRange.e("close-icon--hidden")]: !_ctx.showClose
            }
          ]),
          onClick: _ctx.onClearIconClick
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
      ], 38))
    ]),
    content: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {
        visible: _ctx.pickerVisible,
        actualVisible: _ctx.pickerActualVisible,
        parsedValue: _ctx.parsedValue,
        format: _ctx.format,
        unlinkPanels: _ctx.unlinkPanels,
        type: _ctx.type,
        defaultValue: _ctx.defaultValue,
        onPick: _cache[11] || (_cache[11] = (...args) => _ctx.onPick && _ctx.onPick(...args)),
        onSelectRange: _cache[12] || (_cache[12] = (...args) => _ctx.setSelectionRange && _ctx.setSelectionRange(...args)),
        onSetPickerOption: _cache[13] || (_cache[13] = (...args) => _ctx.onSetPickerOption && _ctx.onSetPickerOption(...args)),
        onCalendarChange: _cache[14] || (_cache[14] = (...args) => _ctx.onCalendarChange && _ctx.onCalendarChange(...args)),
        onPanelChange: _cache[15] || (_cache[15] = (...args) => _ctx.onPanelChange && _ctx.onPanelChange(...args)),
        onMousedown: _cache[16] || (_cache[16] = withModifiers(() => {
        }, ["stop"]))
      })
    ]),
    _: 3
  }, 16, ["visible", "transition", "popper-class", "popper-options", "onBeforeShow", "onShow", "onHide"]);
}
var CommonPicker = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$w], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);
const nodeList = /* @__PURE__ */ new Map();
let startClick;
if (isClient) {
  document.addEventListener("mousedown", (e2) => startClick = e2);
  document.addEventListener("mouseup", (e2) => {
    for (const handlers2 of nodeList.values()) {
      for (const { documentHandler } of handlers2) {
        documentHandler(e2, startClick);
      }
    }
  });
}
function createDocumentHandler(el, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (isElement$1(binding.arg)) {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
const ClickOutside = {
  beforeMount(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    nodeList.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    const handlers2 = nodeList.get(el);
    const oldHandlerIndex = handlers2.findIndex((item) => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };
    if (oldHandlerIndex >= 0) {
      handlers2.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers2.push(newHandler);
    }
  },
  unmounted(el) {
    nodeList.delete(el);
  }
};
var RepeatClick = {
  beforeMount(el, binding) {
    let interval = null;
    let startTime;
    const handler = () => binding.value && binding.value();
    const clear2 = () => {
      if (Date.now() - startTime < 100) {
        handler();
      }
      clearInterval(interval);
      interval = null;
    };
    on(el, "mousedown", (e2) => {
      if (e2.button !== 0)
        return;
      startTime = Date.now();
      once(document, "mouseup", clear2);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
};
var D = false, o, p, m, u, d, M, l, w, x, E, F, _, h, A, X;
function a() {
  if (!D) {
    D = true;
    var e2 = navigator.userAgent, n = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e2), i = /(Mac OS X)|(Windows)|(Linux)/.exec(e2);
    if (_ = /\b(iPhone|iP[ao]d)/.exec(e2), h = /\b(iP[ao]d)/.exec(e2), E = /Android/i.exec(e2), A = /FBAN\/\w+;/i.exec(e2), X = /Mobile/i.exec(e2), F = !!/Win64/.exec(e2), n) {
      o = n[1] ? parseFloat(n[1]) : n[5] ? parseFloat(n[5]) : NaN, o && document && document.documentMode && (o = document.documentMode);
      var r = /(?:Trident\/(\d+.\d+))/.exec(e2);
      M = r ? parseFloat(r[1]) + 4 : o, p = n[2] ? parseFloat(n[2]) : NaN, m = n[3] ? parseFloat(n[3]) : NaN, u = n[4] ? parseFloat(n[4]) : NaN, u ? (n = /(?:Chrome\/(\d+\.\d+))/.exec(e2), d = n && n[1] ? parseFloat(n[1]) : NaN) : d = NaN;
    } else
      o = p = m = d = u = NaN;
    if (i) {
      if (i[1]) {
        var t = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e2);
        l = t ? parseFloat(t[1].replace("_", ".")) : true;
      } else
        l = false;
      w = !!i[2], x = !!i[3];
    } else
      l = w = x = false;
  }
}
var v = { ie: function() {
  return a() || o;
}, ieCompatibilityMode: function() {
  return a() || M > o;
}, ie64: function() {
  return v.ie() && F;
}, firefox: function() {
  return a() || p;
}, opera: function() {
  return a() || m;
}, webkit: function() {
  return a() || u;
}, safari: function() {
  return v.webkit();
}, chrome: function() {
  return a() || d;
}, windows: function() {
  return a() || w;
}, osx: function() {
  return a() || l;
}, linux: function() {
  return a() || x;
}, iphone: function() {
  return a() || _;
}, mobile: function() {
  return a() || _ || h || E || X;
}, nativeApp: function() {
  return a() || A;
}, android: function() {
  return a() || E;
}, ipad: function() {
  return a() || h;
} }, b = v;
var s = !!(typeof window < "u" && window.document && window.document.createElement), Y = { canUseDOM: s, canUseWorkers: typeof Worker < "u", canUseEventListeners: s && !!(window.addEventListener || window.attachEvent), canUseViewport: s && !!window.screen, isInWorker: !s }, N = Y;
var O;
N.canUseDOM && (O = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== true);
function L(e2, n) {
  if (!N.canUseDOM || n && !("addEventListener" in document))
    return false;
  var i = "on" + e2, r = i in document;
  if (!r) {
    var t = document.createElement("div");
    t.setAttribute(i, "return;"), r = typeof t[i] == "function";
  }
  return !r && O && e2 === "wheel" && (r = document.implementation.hasFeature("Events.wheel", "3.0")), r;
}
var I = L;
var P = 10, T = 40, U = 800;
function S(e2) {
  var n = 0, i = 0, r = 0, t = 0;
  return "detail" in e2 && (i = e2.detail), "wheelDelta" in e2 && (i = -e2.wheelDelta / 120), "wheelDeltaY" in e2 && (i = -e2.wheelDeltaY / 120), "wheelDeltaX" in e2 && (n = -e2.wheelDeltaX / 120), "axis" in e2 && e2.axis === e2.HORIZONTAL_AXIS && (n = i, i = 0), r = n * P, t = i * P, "deltaY" in e2 && (t = e2.deltaY), "deltaX" in e2 && (r = e2.deltaX), (r || t) && e2.deltaMode && (e2.deltaMode == 1 ? (r *= T, t *= T) : (r *= U, t *= U)), r && !n && (n = r < 1 ? -1 : 1), t && !i && (i = t < 1 ? -1 : 1), { spinX: n, spinY: i, pixelX: r, pixelY: t };
}
S.getEventType = function() {
  return b.firefox() ? "DOMMouseScroll" : I("wheel") ? "wheel" : "mousewheel";
};
var W = S;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const mousewheel = function(element, callback) {
  if (element && element.addEventListener) {
    const fn2 = function(event) {
      const normalized = W(event);
      callback && Reflect.apply(callback, this, [event, normalized]);
    };
    if (isFirefox()) {
      element.addEventListener("DOMMouseScroll", fn2);
    } else {
      element.onmousewheel = fn2;
    }
  }
};
const Mousewheel = {
  beforeMount(el, binding) {
    mousewheel(el, binding.value);
  }
};
const makeList = (total, method, methodFunc) => {
  const arr = [];
  const disabledArr = method && methodFunc();
  for (let i = 0; i < total; i++) {
    arr[i] = disabledArr ? disabledArr.includes(i) : false;
  }
  return arr;
};
const makeAvailableArr = (list2) => {
  return list2.map((_2, index2) => !_2 ? index2 : _2).filter((_2) => _2 !== true);
};
const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
  const getHoursList = (role, compare2) => {
    return makeList(24, disabledHours, () => disabledHours(role, compare2));
  };
  const getMinutesList = (hour, role, compare2) => {
    return makeList(60, disabledMinutes, () => disabledMinutes(hour, role, compare2));
  };
  const getSecondsList = (hour, minute, role, compare2) => {
    return makeList(60, disabledSeconds, () => disabledSeconds(hour, minute, role, compare2));
  };
  return {
    getHoursList,
    getMinutesList,
    getSecondsList
  };
};
const getAvailableArrs = (disabledHours, disabledMinutes, disabledSeconds) => {
  const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
  const getAvailableHours = (role, compare2) => {
    return makeAvailableArr(getHoursList(role, compare2));
  };
  const getAvailableMinutes = (hour, role, compare2) => {
    return makeAvailableArr(getMinutesList(hour, role, compare2));
  };
  const getAvailableSeconds = (hour, minute, role, compare2) => {
    return makeAvailableArr(getSecondsList(hour, minute, role, compare2));
  };
  return {
    getAvailableHours,
    getAvailableMinutes,
    getAvailableSeconds
  };
};
const useOldValue = (props2) => {
  const oldValue = ref(props2.parsedValue);
  watch$1(() => props2.visible, (val) => {
    if (!val) {
      oldValue.value = props2.parsedValue;
    }
  });
  return oldValue;
};
const _sfc_main$R = defineComponent({
  directives: {
    repeatClick: RepeatClick
  },
  components: {
    ElScrollbar,
    ElIcon,
    ArrowUp: arrowUp,
    ArrowDown: arrowDown
  },
  props: {
    role: {
      type: String,
      required: true
    },
    spinnerDate: {
      type: Object,
      required: true
    },
    showSeconds: {
      type: Boolean,
      default: true
    },
    arrowControl: Boolean,
    amPmMode: {
      type: String,
      default: ""
    },
    disabledHours: {
      type: Function
    },
    disabledMinutes: {
      type: Function
    },
    disabledSeconds: {
      type: Function
    }
  },
  emits: ["change", "select-range", "set-option"],
  setup(props2, ctx) {
    const ns = useNamespace("time");
    let isScrolling = false;
    const debouncedResetScroll = debounce$1((type) => {
      isScrolling = false;
      adjustCurrentSpinner(type);
    }, 200);
    const currentScrollbar = ref(null);
    const listHoursRef = ref(null);
    const listMinutesRef = ref(null);
    const listSecondsRef = ref(null);
    const listRefsMap = {
      hours: listHoursRef,
      minutes: listMinutesRef,
      seconds: listSecondsRef
    };
    const spinnerItems = computed(() => {
      const arr = ["hours", "minutes", "seconds"];
      return props2.showSeconds ? arr : arr.slice(0, 2);
    });
    const hours = computed(() => {
      return props2.spinnerDate.hour();
    });
    const minutes = computed(() => {
      return props2.spinnerDate.minute();
    });
    const seconds = computed(() => {
      return props2.spinnerDate.second();
    });
    const timePartsMap = computed(() => ({
      hours,
      minutes,
      seconds
    }));
    const hoursList = computed(() => {
      return getHoursList(props2.role);
    });
    const minutesList = computed(() => {
      return getMinutesList(hours.value, props2.role);
    });
    const secondsList = computed(() => {
      return getSecondsList(hours.value, minutes.value, props2.role);
    });
    const listMap = computed(() => ({
      hours: hoursList,
      minutes: minutesList,
      seconds: secondsList
    }));
    const arrowHourList = computed(() => {
      const hour = hours.value;
      return [
        hour > 0 ? hour - 1 : void 0,
        hour,
        hour < 23 ? hour + 1 : void 0
      ];
    });
    const arrowMinuteList = computed(() => {
      const minute = minutes.value;
      return [
        minute > 0 ? minute - 1 : void 0,
        minute,
        minute < 59 ? minute + 1 : void 0
      ];
    });
    const arrowSecondList = computed(() => {
      const second = seconds.value;
      return [
        second > 0 ? second - 1 : void 0,
        second,
        second < 59 ? second + 1 : void 0
      ];
    });
    const arrowListMap = computed(() => ({
      hours: arrowHourList,
      minutes: arrowMinuteList,
      seconds: arrowSecondList
    }));
    const getAmPmFlag = (hour) => {
      const shouldShowAmPm = !!props2.amPmMode;
      if (!shouldShowAmPm)
        return "";
      const isCapital = props2.amPmMode === "A";
      let content = hour < 12 ? " am" : " pm";
      if (isCapital)
        content = content.toUpperCase();
      return content;
    };
    const emitSelectRange = (type) => {
      if (type === "hours") {
        ctx.emit("select-range", 0, 2);
      } else if (type === "minutes") {
        ctx.emit("select-range", 3, 5);
      } else if (type === "seconds") {
        ctx.emit("select-range", 6, 8);
      }
      currentScrollbar.value = type;
    };
    const adjustCurrentSpinner = (type) => {
      adjustSpinner(type, timePartsMap.value[type].value);
    };
    const adjustSpinners = () => {
      adjustCurrentSpinner("hours");
      adjustCurrentSpinner("minutes");
      adjustCurrentSpinner("seconds");
    };
    const getScrollbarElement = (el) => el.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);
    const adjustSpinner = (type, value) => {
      if (props2.arrowControl)
        return;
      const el = listRefsMap[type];
      if (el && el.$el) {
        getScrollbarElement(el.$el).scrollTop = Math.max(0, value * typeItemHeight(type));
      }
    };
    const typeItemHeight = (type) => {
      const el = listRefsMap[type];
      return el.$el.querySelector("li").offsetHeight;
    };
    const onIncreaseClick = () => {
      scrollDown(1);
    };
    const onDecreaseClick = () => {
      scrollDown(-1);
    };
    const scrollDown = (step) => {
      if (!currentScrollbar.value) {
        emitSelectRange("hours");
      }
      const label = currentScrollbar.value;
      let now2 = timePartsMap.value[label].value;
      const total = currentScrollbar.value === "hours" ? 24 : 60;
      now2 = (now2 + step + total) % total;
      modifyDateField(label, now2);
      adjustSpinner(label, now2);
      nextTick$1(() => emitSelectRange(currentScrollbar.value));
    };
    const modifyDateField = (type, value) => {
      const list2 = listMap.value[type].value;
      const isDisabled = list2[value];
      if (isDisabled)
        return;
      switch (type) {
        case "hours":
          ctx.emit("change", props2.spinnerDate.hour(value).minute(minutes.value).second(seconds.value));
          break;
        case "minutes":
          ctx.emit("change", props2.spinnerDate.hour(hours.value).minute(value).second(seconds.value));
          break;
        case "seconds":
          ctx.emit("change", props2.spinnerDate.hour(hours.value).minute(minutes.value).second(value));
          break;
      }
    };
    const handleClick = (type, { value, disabled }) => {
      if (!disabled) {
        modifyDateField(type, value);
        emitSelectRange(type);
        adjustSpinner(type, value);
      }
    };
    const handleScroll = (type) => {
      isScrolling = true;
      debouncedResetScroll(type);
      const value = Math.min(Math.round((getScrollbarElement(listRefsMap[type].$el).scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === "hours" ? 23 : 59);
      modifyDateField(type, value);
    };
    const scrollBarHeight = (type) => {
      return listRefsMap[type].$el.offsetHeight;
    };
    const bindScrollEvent = () => {
      const bindFunction = (type) => {
        if (listRefsMap[type] && listRefsMap[type].$el) {
          getScrollbarElement(listRefsMap[type].$el).onscroll = () => {
            handleScroll(type);
          };
        }
      };
      bindFunction("hours");
      bindFunction("minutes");
      bindFunction("seconds");
    };
    onMounted(() => {
      nextTick$1(() => {
        !props2.arrowControl && bindScrollEvent();
        adjustSpinners();
        if (props2.role === "start")
          emitSelectRange("hours");
      });
    });
    const setRef = (scrollbar, type) => {
      listRefsMap[type] = scrollbar;
    };
    ctx.emit("set-option", [`${props2.role}_scrollDown`, scrollDown]);
    ctx.emit("set-option", [`${props2.role}_emitSelectRange`, emitSelectRange]);
    const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props2.disabledHours, props2.disabledMinutes, props2.disabledSeconds);
    watch$1(() => props2.spinnerDate, () => {
      if (isScrolling)
        return;
      adjustSpinners();
    });
    return {
      ns,
      setRef,
      spinnerItems,
      currentScrollbar,
      hours,
      minutes,
      seconds,
      hoursList,
      minutesList,
      arrowHourList,
      arrowMinuteList,
      arrowSecondList,
      getAmPmFlag,
      emitSelectRange,
      adjustCurrentSpinner,
      typeItemHeight,
      listHoursRef,
      listMinutesRef,
      listSecondsRef,
      onIncreaseClick,
      onDecreaseClick,
      handleClick,
      secondsList,
      timePartsMap,
      arrowListMap,
      listMap
    };
  }
});
const _hoisted_1$E = ["onClick"];
const _hoisted_2$n = ["onMouseenter"];
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_arrow_up = resolveComponent("arrow-up");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_arrow_down = resolveComponent("arrow-down");
  const _directive_repeat_click = resolveDirective("repeat-click");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.ns.b("spinner"), { "has-seconds": _ctx.showSeconds }])
  }, [
    !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.spinnerItems, (item) => {
      return openBlock(), createBlock(_component_el_scrollbar, {
        key: item,
        ref_for: true,
        ref: (scollbar) => _ctx.setRef(scollbar, item),
        class: normalizeClass(_ctx.ns.be("spinner", "wrapper")),
        "wrap-style": "max-height: inherit;",
        "view-class": _ctx.ns.be("spinner", "list"),
        noresize: "",
        tag: "ul",
        onMouseenter: ($event) => _ctx.emitSelectRange(item),
        onMousemove: ($event) => _ctx.adjustCurrentSpinner(item)
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listMap[item].value, (disabled, key2) => {
            return openBlock(), createElementBlock("li", {
              key: key2,
              class: normalizeClass([
                _ctx.ns.be("spinner", "item"),
                _ctx.ns.is("active", key2 === _ctx.timePartsMap[item].value),
                _ctx.ns.is("disabled", disabled)
              ]),
              onClick: ($event) => _ctx.handleClick(item, { value: key2, disabled })
            }, [
              item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key2 % 12 || 12 : key2)).slice(-2)) + toDisplayString(_ctx.getAmPmFlag(key2)), 1)
              ], 2112)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(("0" + key2).slice(-2)), 1)
              ], 2112))
            ], 10, _hoisted_1$E);
          }), 128))
        ]),
        _: 2
      }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
    }), 128)) : createCommentVNode("v-if", true),
    _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.spinnerItems, (item) => {
      return openBlock(), createElementBlock("div", {
        key: item,
        class: normalizeClass([_ctx.ns.be("spinner", "wrapper"), _ctx.ns.is("arrow")]),
        onMouseenter: ($event) => _ctx.emitSelectRange(item)
      }, [
        withDirectives((openBlock(), createBlock(_component_el_icon, {
          class: normalizeClass(["arrow-up", _ctx.ns.be("spinner", "arrow")])
        }, {
          default: withCtx(() => [
            createVNode$1(_component_arrow_up)
          ]),
          _: 1
        }, 8, ["class"])), [
          [_directive_repeat_click, _ctx.onDecreaseClick]
        ]),
        withDirectives((openBlock(), createBlock(_component_el_icon, {
          class: normalizeClass(["arrow-down", _ctx.ns.be("spinner", "arrow")])
        }, {
          default: withCtx(() => [
            createVNode$1(_component_arrow_down)
          ]),
          _: 1
        }, 8, ["class"])), [
          [_directive_repeat_click, _ctx.onIncreaseClick]
        ]),
        createElementVNode("ul", {
          class: normalizeClass(_ctx.ns.be("spinner", "list"))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.arrowListMap[item].value, (time2, key2) => {
            return openBlock(), createElementBlock("li", {
              key: key2,
              class: normalizeClass([
                _ctx.ns.be("spinner", "item"),
                _ctx.ns.is("active", time2 === _ctx.timePartsMap[item].value),
                _ctx.ns.is("disabled", _ctx.listMap[item].value[time2])
              ])
            }, [
              typeof time2 === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? time2 % 12 || 12 : time2)).slice(-2)) + toDisplayString(_ctx.getAmPmFlag(time2)), 1)
                ], 2112)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(("0" + time2).slice(-2)), 1)
                ], 2112))
              ], 2112)) : createCommentVNode("v-if", true)
            ], 2);
          }), 128))
        ], 2)
      ], 42, _hoisted_2$n);
    }), 128)) : createCommentVNode("v-if", true)
  ], 2);
}
var TimeSpinner = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$v], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);
const _sfc_main$Q = defineComponent({
  components: {
    TimeSpinner
  },
  props: {
    visible: Boolean,
    actualVisible: {
      type: Boolean,
      default: void 0
    },
    datetimeRole: {
      type: String
    },
    parsedValue: {
      type: [Object, String]
    },
    format: {
      type: String,
      default: ""
    }
  },
  emits: ["pick", "select-range", "set-picker-option"],
  setup(props2, ctx) {
    const ns = useNamespace("time");
    const { t, lang } = useLocale();
    const selectionRange = ref([0, 2]);
    const oldValue = useOldValue(props2);
    const transitionName = computed(() => {
      return isUndefined(props2.actualVisible) ? `${ns.namespace.value}-zoom-in-top` : "";
    });
    const showSeconds = computed(() => {
      return props2.format.includes("ss");
    });
    const amPmMode = computed(() => {
      if (props2.format.includes("A"))
        return "A";
      if (props2.format.includes("a"))
        return "a";
      return "";
    });
    const isValidValue = (_date) => {
      const parsedDate = dayjs(_date).locale(lang.value);
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate.isSame(result);
    };
    const handleCancel = () => {
      ctx.emit("pick", oldValue.value, false);
    };
    const handleConfirm = (visible = false, first = false) => {
      if (first)
        return;
      ctx.emit("pick", props2.parsedValue, visible);
    };
    const handleChange = (_date) => {
      if (!props2.visible) {
        return;
      }
      const result = getRangeAvailableTime(_date).millisecond(0);
      ctx.emit("pick", result, true);
    };
    const setSelectionRange = (start2, end2) => {
      ctx.emit("select-range", start2, end2);
      selectionRange.value = [start2, end2];
    };
    const changeSelectionRange = (step) => {
      const list2 = [0, 3].concat(showSeconds.value ? [6] : []);
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list2.indexOf(selectionRange.value[0]);
      const next2 = (index2 + step + list2.length) % list2.length;
      timePickerOptions["start_emitSelectRange"](mapping[next2]);
    };
    const handleKeydown = (event) => {
      const code = event.code;
      if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
        const step = code === EVENT_CODE.left ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }
      if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
        const step = code === EVENT_CODE.up ? -1 : 1;
        timePickerOptions["start_scrollDown"](step);
        event.preventDefault();
        return;
      }
    };
    const getRangeAvailableTime = (date) => {
      const availableMap = {
        hour: getAvailableHours,
        minute: getAvailableMinutes,
        second: getAvailableSeconds
      };
      let result = date;
      ["hour", "minute", "second"].forEach((_2) => {
        if (availableMap[_2]) {
          let availableArr;
          const method = availableMap[_2];
          if (_2 === "minute") {
            availableArr = method(result.hour(), props2.datetimeRole);
          } else if (_2 === "second") {
            availableArr = method(result.hour(), result.minute(), props2.datetimeRole);
          } else {
            availableArr = method(props2.datetimeRole);
          }
          if (availableArr && availableArr.length && !availableArr.includes(result[_2]())) {
            result = result[_2](availableArr[0]);
          }
        }
      });
      return result;
    };
    const parseUserInput = (value) => {
      if (!value)
        return null;
      return dayjs(value, props2.format).locale(lang.value);
    };
    const formatToString = (value) => {
      if (!value)
        return null;
      return value.format(props2.format);
    };
    const getDefaultValue = () => {
      return dayjs(defaultValue).locale(lang.value);
    };
    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    ctx.emit("set-picker-option", [
      "getRangeAvailableTime",
      getRangeAvailableTime
    ]);
    ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
    const timePickerOptions = {};
    const onSetOption = (e2) => {
      timePickerOptions[e2[0]] = e2[1];
    };
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      arrowControl,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      defaultValue
    } = pickerBase.props;
    const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = getAvailableArrs(disabledHours, disabledMinutes, disabledSeconds);
    return {
      ns,
      transitionName,
      arrowControl,
      onSetOption,
      t,
      handleConfirm,
      handleChange,
      setSelectionRange,
      amPmMode,
      showSeconds,
      handleCancel,
      disabledHours,
      disabledMinutes,
      disabledSeconds
    };
  }
});
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_time_spinner = resolveComponent("time-spinner");
  return openBlock(), createBlock(Transition, { name: _ctx.transitionName }, {
    default: withCtx(() => [
      _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.ns.b("panel"))
      }, [
        createElementVNode("div", {
          class: normalizeClass([_ctx.ns.be("panel", "content"), { "has-seconds": _ctx.showSeconds }])
        }, [
          createVNode$1(_component_time_spinner, {
            ref: "spinner",
            role: _ctx.datetimeRole || "start",
            "arrow-control": _ctx.arrowControl,
            "show-seconds": _ctx.showSeconds,
            "am-pm-mode": _ctx.amPmMode,
            "spinner-date": _ctx.parsedValue,
            "disabled-hours": _ctx.disabledHours,
            "disabled-minutes": _ctx.disabledMinutes,
            "disabled-seconds": _ctx.disabledSeconds,
            onChange: _ctx.handleChange,
            onSetOption: _ctx.onSetOption,
            onSelectRange: _ctx.setSelectionRange
          }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange", "onSetOption", "onSelectRange"])
        ], 2),
        createElementVNode("div", {
          class: normalizeClass(_ctx.ns.be("panel", "footer"))
        }, [
          createElementVNode("button", {
            type: "button",
            class: normalizeClass([_ctx.ns.be("panel", "btn"), "cancel"]),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
          }, toDisplayString(_ctx.t("el.datepicker.cancel")), 3),
          createElementVNode("button", {
            type: "button",
            class: normalizeClass([_ctx.ns.be("panel", "btn"), "confirm"]),
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleConfirm())
          }, toDisplayString(_ctx.t("el.datepicker.confirm")), 3)
        ], 2)
      ], 2)) : createCommentVNode("v-if", true)
    ]),
    _: 1
  }, 8, ["name"]);
}
var TimePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$u], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);
const rangeArr = (n) => Array.from(Array.from({ length: n }).keys());
const extractDateFormat = (format2) => {
  return format2.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};
const extractTimeFormat = (format2) => {
  return format2.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};
const useCheckboxProps = {
  modelValue: {
    type: [Boolean, Number, String],
    default: () => void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  tabindex: [String, Number],
  size: String
};
const useCheckboxGroup = () => {
  const elForm = inject(formContextKey, {});
  const elFormItem = inject(formItemContextKey, {});
  const checkboxGroup = inject("CheckboxGroup", {});
  const isGroup = computed(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup");
  const elFormItemSize = computed(() => {
    return elFormItem.size;
  });
  return {
    isGroup,
    checkboxGroup,
    elForm,
    elFormItemSize,
    elFormItem
  };
};
const useModel = (props2) => {
  const selfModel = ref(false);
  const { emit } = getCurrentInstance();
  const { isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitExceeded = ref(false);
  const model = computed({
    get() {
      var _a2, _b2;
      return isGroup.value ? (_a2 = checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b2 = props2.modelValue) != null ? _b2 : selfModel.value;
    },
    set(val) {
      var _a2;
      if (isGroup.value && Array.isArray(val)) {
        isLimitExceeded.value = checkboxGroup.max !== void 0 && val.length > checkboxGroup.max.value;
        isLimitExceeded.value === false && ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a2.call(checkboxGroup, val));
      } else {
        emit(UPDATE_MODEL_EVENT, val);
        selfModel.value = val;
      }
    }
  });
  return {
    model,
    isLimitExceeded
  };
};
const useCheckboxStatus = (props2, { model }) => {
  const { isGroup, checkboxGroup } = useCheckboxGroup();
  const focus = ref(false);
  const size = useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, { prop: true });
  const isChecked = computed(() => {
    const value = model.value;
    if (toTypeString(value) === "[object Boolean]") {
      return value;
    } else if (Array.isArray(value)) {
      return value.includes(props2.label);
    } else if (value !== null && value !== void 0) {
      return value === props2.trueLabel;
    } else {
      return !!value;
    }
  });
  const checkboxSize = useSize(computed(() => {
    var _a2;
    return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a2.value : void 0;
  }));
  return {
    isChecked,
    focus,
    size,
    checkboxSize
  };
};
const useDisabled = (props2, {
  model,
  isChecked
}) => {
  const { elForm, isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitDisabled = computed(() => {
    var _a2, _b2;
    const max3 = (_a2 = checkboxGroup.max) == null ? void 0 : _a2.value;
    const min3 = (_b2 = checkboxGroup.min) == null ? void 0 : _b2.value;
    return !!(max3 || min3) && model.value.length >= max3 && !isChecked.value || model.value.length <= min3 && isChecked.value;
  });
  const isDisabled = computed(() => {
    var _a2, _b2;
    const disabled = props2.disabled || elForm.disabled;
    return (_b2 = isGroup.value ? ((_a2 = checkboxGroup.disabled) == null ? void 0 : _a2.value) || disabled || isLimitDisabled.value : props2.disabled || elForm.disabled) != null ? _b2 : false;
  });
  return {
    isDisabled,
    isLimitDisabled
  };
};
const setStoreValue = (props2, { model }) => {
  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props2.label)) {
      model.value.push(props2.label);
    } else {
      model.value = props2.trueLabel || true;
    }
  }
  props2.checked && addToStore();
};
const useEvent$1 = (props2, { isLimitExceeded }) => {
  const { elFormItem } = useCheckboxGroup();
  const { emit } = getCurrentInstance();
  function handleChange(e2) {
    var _a2, _b2;
    if (isLimitExceeded.value)
      return;
    const target = e2.target;
    const value = target.checked ? (_a2 = props2.trueLabel) != null ? _a2 : true : (_b2 = props2.falseLabel) != null ? _b2 : false;
    emit("change", value, e2);
  }
  watch$1(() => props2.modelValue, () => {
    var _a2;
    (_a2 = elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
  });
  return {
    handleChange
  };
};
const useCheckbox = (props2) => {
  const { model, isLimitExceeded } = useModel(props2);
  const { focus, size, isChecked, checkboxSize } = useCheckboxStatus(props2, {
    model
  });
  const { isDisabled } = useDisabled(props2, { model, isChecked });
  const { handleChange } = useEvent$1(props2, { isLimitExceeded });
  setStoreValue(props2, { model });
  return {
    isChecked,
    isDisabled,
    checkboxSize,
    model,
    handleChange,
    focus,
    size
  };
};
const _sfc_main$P = defineComponent({
  name: "ElCheckbox",
  props: {
    modelValue: {
      type: [Number, String, Boolean],
      default: () => void 0
    },
    label: {
      type: [String, Boolean, Number, Object]
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
      type: String,
      default: void 0
    },
    trueLabel: {
      type: [String, Number],
      default: void 0
    },
    falseLabel: {
      type: [String, Number],
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    controls: {
      type: String,
      default: void 0
    },
    border: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    tabindex: [String, Number]
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2) {
    const ns = useNamespace("checkbox");
    return __spreadValues({
      ns
    }, useCheckbox(props2));
  }
});
const _hoisted_1$D = ["id", "aria-controls"];
const _hoisted_2$m = ["tabindex", "role", "aria-checked"];
const _hoisted_3$e = ["aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_4$a = ["aria-hidden", "disabled", "value", "name", "tabindex"];
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    id: _ctx.id,
    class: normalizeClass([
      _ctx.ns.b(),
      _ctx.ns.m(_ctx.checkboxSize),
      _ctx.ns.is("disabled", _ctx.isDisabled),
      _ctx.ns.is("bordered", _ctx.border),
      _ctx.ns.is("checked", _ctx.isChecked)
    ]),
    "aria-controls": _ctx.indeterminate ? _ctx.controls : null
  }, [
    createElementVNode("span", {
      class: normalizeClass([
        _ctx.ns.e("input"),
        _ctx.ns.is("disabled", _ctx.isDisabled),
        _ctx.ns.is("checked", _ctx.isChecked),
        _ctx.ns.is("indeterminate", _ctx.indeterminate),
        _ctx.ns.is("focus", _ctx.focus)
      ]),
      tabindex: _ctx.indeterminate ? 0 : void 0,
      role: _ctx.indeterminate ? "checkbox" : void 0,
      "aria-checked": _ctx.indeterminate ? "mixed" : false
    }, [
      createElementVNode("span", {
        class: normalizeClass(_ctx.ns.e("inner"))
      }, null, 2),
      _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
        key: 0,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
        class: normalizeClass(_ctx.ns.e("original")),
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        name: _ctx.name,
        tabindex: _ctx.tabindex,
        disabled: _ctx.isDisabled,
        "true-value": _ctx.trueLabel,
        "false-value": _ctx.falseLabel,
        onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
        onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
      }, null, 42, _hoisted_3$e)), [
        [vModelCheckbox, _ctx.model]
      ]) : withDirectives((openBlock(), createElementBlock("input", {
        key: 1,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
        class: normalizeClass(_ctx.ns.e("original")),
        type: "checkbox",
        "aria-hidden": _ctx.indeterminate ? "true" : "false",
        disabled: _ctx.isDisabled,
        value: _ctx.label,
        name: _ctx.name,
        tabindex: _ctx.tabindex,
        onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
        onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
        onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
      }, null, 42, _hoisted_4$a)), [
        [vModelCheckbox, _ctx.model]
      ])
    ], 10, _hoisted_2$m),
    _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(_ctx.ns.e("label"))
    }, [
      renderSlot(_ctx.$slots, "default"),
      !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ], 2112)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$D);
}
var Checkbox$1 = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$t], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const _sfc_main$O = defineComponent({
  name: "ElCheckboxButton",
  props: useCheckboxProps,
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2) {
    const { focus, isChecked, isDisabled, size, model, handleChange } = useCheckbox(props2);
    const { checkboxGroup } = useCheckboxGroup();
    const ns = useNamespace("checkbox");
    const activeStyle = computed(() => {
      var _a2, _b2, _c2, _d;
      const fillValue = (_b2 = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b2 : "";
      return {
        backgroundColor: fillValue,
        borderColor: fillValue,
        color: (_d = (_c2 = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c2.value) != null ? _d : "",
        boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : null
      };
    });
    return {
      focus,
      isChecked,
      isDisabled,
      model,
      handleChange,
      activeStyle,
      size,
      ns
    };
  }
});
const _hoisted_1$C = ["aria-checked", "aria-disabled"];
const _hoisted_2$l = ["name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_3$d = ["name", "tabindex", "disabled", "value"];
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass([
      _ctx.ns.b("button"),
      _ctx.ns.bm("button", _ctx.size),
      _ctx.ns.is("disabled", _ctx.isDisabled),
      _ctx.ns.is("checked", _ctx.isChecked),
      _ctx.ns.is("focus", _ctx.focus)
    ]),
    role: "checkbox",
    "aria-checked": _ctx.isChecked,
    "aria-disabled": _ctx.isDisabled
  }, [
    _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
      key: 0,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
      class: normalizeClass(_ctx.ns.be("button", "original")),
      type: "checkbox",
      name: _ctx.name,
      tabindex: _ctx.tabindex,
      disabled: _ctx.isDisabled,
      "true-value": _ctx.trueLabel,
      "false-value": _ctx.falseLabel,
      onChange: _cache[1] || (_cache[1] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.focus = true),
      onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.focus = false)
    }, null, 42, _hoisted_2$l)), [
      [vModelCheckbox, _ctx.model]
    ]) : withDirectives((openBlock(), createElementBlock("input", {
      key: 1,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.model = $event),
      class: normalizeClass(_ctx.ns.be("button", "original")),
      type: "checkbox",
      name: _ctx.name,
      tabindex: _ctx.tabindex,
      disabled: _ctx.isDisabled,
      value: _ctx.label,
      onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onFocus: _cache[6] || (_cache[6] = ($event) => _ctx.focus = true),
      onBlur: _cache[7] || (_cache[7] = ($event) => _ctx.focus = false)
    }, null, 42, _hoisted_3$d)), [
      [vModelCheckbox, _ctx.model]
    ]),
    _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
      key: 2,
      class: normalizeClass(_ctx.ns.be("button", "inner")),
      style: normalizeStyle$1(_ctx.isChecked ? _ctx.activeStyle : null)
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 6)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$C);
}
var CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$s], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const _sfc_main$N = defineComponent({
  name: "ElCheckboxGroup",
  props: {
    modelValue: {
      type: Array,
      default: () => []
    },
    disabled: Boolean,
    min: {
      type: Number,
      default: void 0
    },
    max: {
      type: Number,
      default: void 0
    },
    size: {
      type: String,
      validator: isValidComponentSize
    },
    fill: {
      type: String,
      default: void 0
    },
    textColor: {
      type: String,
      default: void 0
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  emits: [UPDATE_MODEL_EVENT, "change"],
  setup(props2, { emit, slots }) {
    const { elFormItem } = useCheckboxGroup();
    const checkboxGroupSize = useSize();
    const ns = useNamespace("checkbox");
    const changeEvent = (value) => {
      emit(UPDATE_MODEL_EVENT, value);
      nextTick$1(() => {
        emit("change", value);
      });
    };
    const modelValue = computed({
      get() {
        return props2.modelValue;
      },
      set(val) {
        changeEvent(val);
      }
    });
    provide("CheckboxGroup", __spreadProps(__spreadValues({
      name: "ElCheckboxGroup",
      modelValue
    }, toRefs(props2)), {
      checkboxGroupSize,
      changeEvent
    }));
    watch$1(() => props2.modelValue, () => {
      var _a2;
      (_a2 = elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
    });
    return () => {
      return h$1(props2.tag, {
        class: ns.b("group"),
        role: "group",
        "aria-label": "checkbox-group"
      }, [renderSlot(slots, "default")]);
    };
  }
});
var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const ElCheckbox = withInstall(Checkbox$1, {
  CheckboxButton,
  CheckboxGroup
});
withNoopInstall(CheckboxButton);
const ElCheckboxGroup$1 = withNoopInstall(CheckboxGroup);
const radioPropsBase = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  label: {
    type: [String, Number, Boolean],
    default: ""
  }
});
const radioProps = buildProps(__spreadProps(__spreadValues({}, radioPropsBase), {
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  name: {
    type: String,
    default: ""
  },
  border: Boolean
}));
const radioEmits = {
  [UPDATE_MODEL_EVENT]: (val) => isString(val) || isNumber(val) || isBoolean(val),
  change: (val) => isString(val) || isNumber(val) || isBoolean(val)
};
const useRadio = (props2, emit) => {
  const radioRef = ref();
  const radioGroup = inject(radioGroupKey, void 0);
  const isGroup = computed(() => !!radioGroup);
  const modelValue = computed({
    get() {
      return isGroup.value ? radioGroup.modelValue : props2.modelValue;
    },
    set(val) {
      if (isGroup.value) {
        radioGroup.changeEvent(val);
      } else {
        emit(UPDATE_MODEL_EVENT, val);
      }
      radioRef.value.checked = props2.modelValue === props2.label;
    }
  });
  const size = useSize(computed(() => radioGroup == null ? void 0 : radioGroup.size));
  const disabled = useDisabled$1(computed(() => radioGroup == null ? void 0 : radioGroup.disabled));
  const focus = ref(false);
  const tabIndex = computed(() => {
    return disabled.value || isGroup.value && modelValue.value !== props2.label ? -1 : 0;
  });
  return {
    radioRef,
    isGroup,
    radioGroup,
    focus,
    size,
    disabled,
    tabIndex,
    modelValue
  };
};
const _sfc_main$M = defineComponent({
  name: "ElRadio",
  props: radioProps,
  emits: radioEmits,
  setup(props2, { emit }) {
    const ns = useNamespace("radio");
    const { radioRef, isGroup, focus, size, disabled, tabIndex, modelValue } = useRadio(props2, emit);
    function handleChange() {
      nextTick$1(() => emit("change", modelValue.value));
    }
    return {
      ns,
      focus,
      isGroup,
      modelValue,
      tabIndex,
      size,
      disabled,
      radioRef,
      handleChange
    };
  }
});
const _hoisted_1$B = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$k = ["value", "name", "disabled"];
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass([
      _ctx.ns.b(),
      _ctx.ns.is("disabled", _ctx.disabled),
      _ctx.ns.is("focus", _ctx.focus),
      _ctx.ns.is("bordered", _ctx.border),
      _ctx.ns.is("checked", _ctx.modelValue === _ctx.label),
      _ctx.ns.m(_ctx.size)
    ]),
    role: "radio",
    "aria-checked": _ctx.modelValue === _ctx.label,
    "aria-disabled": _ctx.disabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.modelValue = _ctx.disabled ? _ctx.modelValue : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    createElementVNode("span", {
      class: normalizeClass([
        _ctx.ns.e("input"),
        _ctx.ns.is("disabled", _ctx.disabled),
        _ctx.ns.is("checked", _ctx.modelValue === _ctx.label)
      ])
    }, [
      createElementVNode("span", {
        class: normalizeClass(_ctx.ns.e("inner"))
      }, null, 2),
      withDirectives(createElementVNode("input", {
        ref: "radioRef",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.modelValue = $event),
        class: normalizeClass(_ctx.ns.e("original")),
        value: _ctx.label,
        type: "radio",
        "aria-hidden": "true",
        name: _ctx.name,
        disabled: _ctx.disabled,
        tabindex: "-1",
        onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
        onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false),
        onChange: _cache[3] || (_cache[3] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
      }, null, 42, _hoisted_2$k), [
        [vModelRadio, _ctx.modelValue]
      ])
    ], 2),
    createElementVNode("span", {
      class: normalizeClass(_ctx.ns.e("label")),
      onKeydown: _cache[4] || (_cache[4] = withModifiers(() => {
      }, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 34)
  ], 42, _hoisted_1$B);
}
var Radio$1 = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$r], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const radioButtonProps = buildProps(__spreadProps(__spreadValues({}, radioPropsBase), {
  name: {
    type: String,
    default: ""
  }
}));
const _sfc_main$L = defineComponent({
  name: "ElRadioButton",
  props: radioButtonProps,
  setup(props2, { emit }) {
    const ns = useNamespace("radio");
    const {
      radioRef,
      isGroup,
      focus,
      size,
      disabled,
      tabIndex,
      modelValue,
      radioGroup
    } = useRadio(props2, emit);
    const activeStyle = computed(() => {
      return {
        backgroundColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
        borderColor: (radioGroup == null ? void 0 : radioGroup.fill) || "",
        boxShadow: (radioGroup == null ? void 0 : radioGroup.fill) ? `-1px 0 0 0 ${radioGroup.fill}` : "",
        color: (radioGroup == null ? void 0 : radioGroup.textColor) || ""
      };
    });
    return {
      ns,
      isGroup,
      size,
      disabled,
      tabIndex,
      modelValue,
      focus,
      activeStyle,
      radioRef
    };
  }
});
const _hoisted_1$A = ["aria-checked", "aria-disabled", "tabindex"];
const _hoisted_2$j = ["value", "name", "disabled"];
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass([
      _ctx.ns.b("button"),
      _ctx.ns.is("active", _ctx.modelValue === _ctx.label),
      _ctx.ns.is("disabled", _ctx.disabled),
      _ctx.ns.is("focus", _ctx.focus),
      _ctx.ns.bm("button", _ctx.size)
    ]),
    role: "radio",
    "aria-checked": _ctx.modelValue === _ctx.label,
    "aria-disabled": _ctx.disabled,
    tabindex: _ctx.tabIndex,
    onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.modelValue = _ctx.disabled ? _ctx.modelValue : _ctx.label, ["stop", "prevent"]), ["space"]))
  }, [
    withDirectives(createElementVNode("input", {
      ref: "radioRef",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.modelValue = $event),
      class: normalizeClass(_ctx.ns.be("button", "original-radio")),
      value: _ctx.label,
      type: "radio",
      name: _ctx.name,
      disabled: _ctx.disabled,
      tabindex: "-1",
      onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.focus = true),
      onBlur: _cache[2] || (_cache[2] = ($event) => _ctx.focus = false)
    }, null, 42, _hoisted_2$j), [
      [vModelRadio, _ctx.modelValue]
    ]),
    createElementVNode("span", {
      class: normalizeClass(_ctx.ns.be("button", "inner")),
      style: normalizeStyle$1(_ctx.modelValue === _ctx.label ? _ctx.activeStyle : {}),
      onKeydown: _cache[3] || (_cache[3] = withModifiers(() => {
      }, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 38)
  ], 42, _hoisted_1$A);
}
var RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$q], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const radioGroupProps = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: [String, Number, Boolean],
    default: ""
  },
  fill: {
    type: String,
    default: ""
  },
  textColor: {
    type: String,
    default: ""
  }
});
const radioGroupEmits = radioEmits;
const _sfc_main$K = defineComponent({
  name: "ElRadioGroup",
  props: radioGroupProps,
  emits: radioGroupEmits,
  setup(props2, ctx) {
    const ns = useNamespace("radio");
    const radioGroupRef = ref();
    const { formItem } = useFormItem();
    const changeEvent = (value) => {
      ctx.emit(UPDATE_MODEL_EVENT, value);
      nextTick$1(() => ctx.emit("change", value));
    };
    const handleKeydown = (e2) => {
      if (!radioGroupRef.value)
        return;
      const target = e2.target;
      const className = target.nodeName === "INPUT" ? "[type=radio]" : "[role=radio]";
      const radios = radioGroupRef.value.querySelectorAll(className);
      const length2 = radios.length;
      const index2 = Array.from(radios).indexOf(target);
      const roleRadios = radioGroupRef.value.querySelectorAll("[role=radio]");
      let nextIndex = null;
      switch (e2.code) {
        case EVENT_CODE.left:
        case EVENT_CODE.up:
          e2.stopPropagation();
          e2.preventDefault();
          nextIndex = index2 === 0 ? length2 - 1 : index2 - 1;
          break;
        case EVENT_CODE.right:
        case EVENT_CODE.down:
          e2.stopPropagation();
          e2.preventDefault();
          nextIndex = index2 === length2 - 1 ? 0 : index2 + 1;
          break;
      }
      if (nextIndex === null)
        return;
      roleRadios[nextIndex].click();
      roleRadios[nextIndex].focus();
    };
    onMounted(() => {
      const radios = radioGroupRef.value.querySelectorAll("[type=radio]");
      const firstLabel = radios[0];
      if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
        firstLabel.tabIndex = 0;
      }
    });
    provide(radioGroupKey, reactive(__spreadProps(__spreadValues({}, toRefs(props2)), {
      changeEvent
    })));
    watch$1(() => props2.modelValue, () => formItem == null ? void 0 : formItem.validate("change").catch((err) => debugWarn()));
    return {
      ns,
      radioGroupRef,
      handleKeydown
    };
  }
});
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "radioGroupRef",
    class: normalizeClass(_ctx.ns.b("group")),
    role: "radiogroup",
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeydown && _ctx.handleKeydown(...args))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34);
}
var RadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$p], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
const ElRadio = withInstall(Radio$1, {
  RadioButton,
  RadioGroup
});
const ElRadioGroup = withNoopInstall(RadioGroup);
withNoopInstall(RadioButton);
var NodeContent = defineComponent({
  name: "NodeContent",
  setup() {
    const ns = useNamespace("cascader-node");
    return {
      ns
    };
  },
  render() {
    const { ns } = this;
    const { node, panel } = this.$parent;
    const { data, label } = node;
    const { renderLabelFn } = panel;
    return h$1("span", { class: ns.e("label") }, renderLabelFn ? renderLabelFn({ node, data }) : label);
  }
});
const CASCADER_PANEL_INJECTION_KEY = Symbol();
const _sfc_main$J = defineComponent({
  name: "ElCascaderNode",
  components: {
    ElCheckbox,
    ElRadio,
    NodeContent,
    ElIcon,
    Check: check,
    Loading: loading,
    ArrowRight: arrowRight
  },
  props: {
    node: {
      type: Object,
      required: true
    },
    menuId: String
  },
  emits: ["expand"],
  setup(props2, { emit }) {
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const ns = useNamespace("cascader-node");
    const isHoverMenu = computed(() => panel.isHoverMenu);
    const multiple = computed(() => panel.config.multiple);
    const checkStrictly = computed(() => panel.config.checkStrictly);
    const checkedNodeId = computed(() => {
      var _a2;
      return (_a2 = panel.checkedNodes[0]) == null ? void 0 : _a2.uid;
    });
    const isDisabled = computed(() => props2.node.isDisabled);
    const isLeaf2 = computed(() => props2.node.isLeaf);
    const expandable = computed(() => checkStrictly.value && !isLeaf2.value || !isDisabled.value);
    const inExpandingPath = computed(() => isInPath(panel.expandingNode));
    const inCheckedPath = computed(() => checkStrictly.value && panel.checkedNodes.some(isInPath));
    const isInPath = (node) => {
      var _a2;
      const { level, uid: uid2 } = props2.node;
      return ((_a2 = node == null ? void 0 : node.pathNodes[level - 1]) == null ? void 0 : _a2.uid) === uid2;
    };
    const doExpand = () => {
      if (inExpandingPath.value)
        return;
      panel.expandNode(props2.node);
    };
    const doCheck = (checked2) => {
      const { node } = props2;
      if (checked2 === node.checked)
        return;
      panel.handleCheckChange(node, checked2);
    };
    const doLoad = () => {
      panel.lazyLoad(props2.node, () => {
        if (!isLeaf2.value)
          doExpand();
      });
    };
    const handleHoverExpand = (e2) => {
      if (!isHoverMenu.value)
        return;
      handleExpand();
      !isLeaf2.value && emit("expand", e2);
    };
    const handleExpand = () => {
      const { node } = props2;
      if (!expandable.value || node.loading)
        return;
      node.loaded ? doExpand() : doLoad();
    };
    const handleClick = () => {
      if (isHoverMenu.value && !isLeaf2.value)
        return;
      if (isLeaf2.value && !isDisabled.value && !checkStrictly.value && !multiple.value) {
        handleCheck(true);
      } else {
        handleExpand();
      }
    };
    const handleSelectCheck = (checked2) => {
      if (checkStrictly.value) {
        doCheck(checked2);
        if (props2.node.loaded) {
          doExpand();
        }
      } else {
        handleCheck(checked2);
      }
    };
    const handleCheck = (checked2) => {
      if (!props2.node.loaded) {
        doLoad();
      } else {
        doCheck(checked2);
        !checkStrictly.value && doExpand();
      }
    };
    return {
      panel,
      isHoverMenu,
      multiple,
      checkStrictly,
      checkedNodeId,
      isDisabled,
      isLeaf: isLeaf2,
      expandable,
      inExpandingPath,
      inCheckedPath,
      ns,
      handleHoverExpand,
      handleExpand,
      handleClick,
      handleCheck,
      handleSelectCheck
    };
  }
});
const _hoisted_1$z = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"];
const _hoisted_2$i = /* @__PURE__ */ createElementVNode("span", null, null, -1);
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_radio = resolveComponent("el-radio");
  const _component_check = resolveComponent("check");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_node_content = resolveComponent("node-content");
  const _component_loading = resolveComponent("loading");
  const _component_arrow_right = resolveComponent("arrow-right");
  return openBlock(), createElementBlock("li", {
    id: `${_ctx.menuId}-${_ctx.node.uid}`,
    role: "menuitem",
    "aria-haspopup": !_ctx.isLeaf,
    "aria-owns": _ctx.isLeaf ? null : _ctx.menuId,
    "aria-expanded": _ctx.inExpandingPath,
    tabindex: _ctx.expandable ? -1 : void 0,
    class: normalizeClass([
      _ctx.ns.b(),
      _ctx.ns.is("selectable", _ctx.checkStrictly),
      _ctx.ns.is("active", _ctx.node.checked),
      _ctx.ns.is("disabled", !_ctx.expandable),
      _ctx.inExpandingPath && "in-active-path",
      _ctx.inCheckedPath && "in-checked-path"
    ]),
    onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.handleHoverExpand && _ctx.handleHoverExpand(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    createCommentVNode(" prefix "),
    _ctx.multiple ? (openBlock(), createBlock(_component_el_checkbox, {
      key: 0,
      "model-value": _ctx.node.checked,
      indeterminate: _ctx.node.indeterminate,
      disabled: _ctx.isDisabled,
      onClick: _cache[0] || (_cache[0] = withModifiers(() => {
      }, ["stop"])),
      "onUpdate:modelValue": _ctx.handleSelectCheck
    }, null, 8, ["model-value", "indeterminate", "disabled", "onUpdate:modelValue"])) : _ctx.checkStrictly ? (openBlock(), createBlock(_component_el_radio, {
      key: 1,
      "model-value": _ctx.checkedNodeId,
      label: _ctx.node.uid,
      disabled: _ctx.isDisabled,
      "onUpdate:modelValue": _ctx.handleSelectCheck,
      onClick: _cache[1] || (_cache[1] = withModifiers(() => {
      }, ["stop"]))
    }, {
      default: withCtx(() => [
        createCommentVNode("\n        Add an empty element to avoid render label,\n        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485\n      "),
        _hoisted_2$i
      ]),
      _: 1
    }, 8, ["model-value", "label", "disabled", "onUpdate:modelValue"])) : _ctx.isLeaf && _ctx.node.checked ? (openBlock(), createBlock(_component_el_icon, {
      key: 2,
      class: normalizeClass(_ctx.ns.e("prefix"))
    }, {
      default: withCtx(() => [
        createVNode$1(_component_check)
      ]),
      _: 1
    }, 8, ["class"])) : createCommentVNode("v-if", true),
    createCommentVNode(" content "),
    createVNode$1(_component_node_content),
    createCommentVNode(" postfix "),
    !_ctx.isLeaf ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      _ctx.node.loading ? (openBlock(), createBlock(_component_el_icon, {
        key: 0,
        class: normalizeClass([_ctx.ns.is("loading"), _ctx.ns.e("postfix")])
      }, {
        default: withCtx(() => [
          createVNode$1(_component_loading)
        ]),
        _: 1
      }, 8, ["class"])) : (openBlock(), createBlock(_component_el_icon, {
        key: 1,
        class: normalizeClass(["arrow-right", _ctx.ns.e("postfix")])
      }, {
        default: withCtx(() => [
          createVNode$1(_component_arrow_right)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 2112)) : createCommentVNode("v-if", true)
  ], 42, _hoisted_1$z);
}
var ElCascaderNode = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$o], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
const _sfc_main$I = defineComponent({
  name: "ElCascaderMenu",
  components: {
    Loading: loading,
    ElIcon,
    ElScrollbar,
    ElCascaderNode
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: {
      type: Number,
      required: true
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const ns = useNamespace("cascader-menu");
    const { t } = useLocale();
    const id = generateId();
    let activeNode = null;
    let hoverTimer = null;
    const panel = inject(CASCADER_PANEL_INJECTION_KEY);
    const hoverZone = ref(null);
    const isEmpty2 = computed(() => !props2.nodes.length);
    const isLoading = computed(() => !panel.initialLoaded);
    const menuId = computed(() => `cascader-menu-${id}-${props2.index}`);
    const handleExpand = (e2) => {
      activeNode = e2.target;
    };
    const handleMouseMove = (e2) => {
      if (!panel.isHoverMenu || !activeNode || !hoverZone.value)
        return;
      if (activeNode.contains(e2.target)) {
        clearHoverTimer();
        const el = instance.vnode.el;
        const { left: left2 } = el.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = el;
        const startX = e2.clientX - left2;
        const top2 = activeNode.offsetTop;
        const bottom2 = top2 + activeNode.offsetHeight;
        hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top2} L${offsetWidth} 0 V${top2} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom2} L${offsetWidth} ${offsetHeight} V${bottom2} Z" />
        `;
      } else if (!hoverTimer) {
        hoverTimer = window.setTimeout(clearHoverZone, panel.config.hoverThreshold);
      }
    };
    const clearHoverTimer = () => {
      if (!hoverTimer)
        return;
      clearTimeout(hoverTimer);
      hoverTimer = null;
    };
    const clearHoverZone = () => {
      if (!hoverZone.value)
        return;
      hoverZone.value.innerHTML = "";
      clearHoverTimer();
    };
    return {
      ns,
      panel,
      hoverZone,
      isEmpty: isEmpty2,
      isLoading,
      menuId,
      t,
      handleExpand,
      handleMouseMove,
      clearHoverZone
    };
  }
});
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_node = resolveComponent("el-cascader-node");
  const _component_loading = resolveComponent("loading");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  return openBlock(), createBlock(_component_el_scrollbar, {
    key: _ctx.menuId,
    tag: "ul",
    role: "menu",
    class: normalizeClass(_ctx.ns.b()),
    "wrap-class": _ctx.ns.e("wrap"),
    "view-class": [_ctx.ns.e("list"), _ctx.ns.is("empty", _ctx.isEmpty)],
    onMousemove: _ctx.handleMouseMove,
    onMouseleave: _ctx.clearHoverZone
  }, {
    default: withCtx(() => {
      var _a2;
      return [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodes, (node) => {
          return openBlock(), createBlock(_component_el_cascader_node, {
            key: node.uid,
            node,
            "menu-id": _ctx.menuId,
            onExpand: _ctx.handleExpand
          }, null, 8, ["node", "menu-id", "onExpand"]);
        }), 128)),
        _ctx.isLoading ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.e("empty-text"))
        }, [
          createVNode$1(_component_el_icon, {
            size: "14",
            class: normalizeClass(_ctx.ns.is("loading"))
          }, {
            default: withCtx(() => [
              createVNode$1(_component_loading)
            ]),
            _: 1
          }, 8, ["class"]),
          createTextVNode(" " + toDisplayString(_ctx.t("el.cascader.loading")), 1)
        ], 2)) : _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.ns.e("empty-text"))
        }, toDisplayString(_ctx.t("el.cascader.noData")), 3)) : ((_a2 = _ctx.panel) == null ? void 0 : _a2.isHoverMenu) ? (openBlock(), createElementBlock("svg", {
          key: 2,
          ref: "hoverZone",
          class: normalizeClass(_ctx.ns.e("hover-zone"))
        }, null, 2)) : createCommentVNode("v-if", true)
      ];
    }),
    _: 1
  }, 8, ["class", "wrap-class", "view-class", "onMousemove", "onMouseleave"]);
}
var ElCascaderMenu = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$n], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
var ExpandTrigger = /* @__PURE__ */ ((ExpandTrigger2) => {
  ExpandTrigger2["CLICK"] = "click";
  ExpandTrigger2["HOVER"] = "hover";
  return ExpandTrigger2;
})(ExpandTrigger || {});
let uid = 0;
const calculatePathNodes = (node) => {
  const nodes = [node];
  let { parent: parent2 } = node;
  while (parent2) {
    nodes.unshift(parent2);
    parent2 = parent2.parent;
  }
  return nodes;
};
class Node {
  constructor(data, config, parent2, root2 = false) {
    this.data = data;
    this.config = config;
    this.parent = parent2;
    this.root = root2;
    this.uid = uid++;
    this.checked = false;
    this.indeterminate = false;
    this.loading = false;
    const { value: valueKey, label: labelKey, children: childrenKey } = config;
    const childrenData = data[childrenKey];
    const pathNodes = calculatePathNodes(this);
    this.level = root2 ? 0 : parent2 ? parent2.level + 1 : 1;
    this.value = data[valueKey];
    this.label = data[labelKey];
    this.pathNodes = pathNodes;
    this.pathValues = pathNodes.map((node) => node.value);
    this.pathLabels = pathNodes.map((node) => node.label);
    this.childrenData = childrenData;
    this.children = (childrenData || []).map((child) => new Node(child, config, this));
    this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
  }
  get isDisabled() {
    const { data, parent: parent2, config } = this;
    const { disabled, checkStrictly } = config;
    const isDisabled = isFunction(disabled) ? disabled(data, this) : !!data[disabled];
    return isDisabled || !checkStrictly && (parent2 == null ? void 0 : parent2.isDisabled);
  }
  get isLeaf() {
    const { data, config, childrenData, loaded } = this;
    const { lazy, leaf } = config;
    const isLeaf2 = isFunction(leaf) ? leaf(data, this) : data[leaf];
    return isUndefined(isLeaf2) ? lazy && !loaded ? false : !(Array.isArray(childrenData) && childrenData.length) : !!isLeaf2;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(childData) {
    const { childrenData, children: children2 } = this;
    const node = new Node(childData, this.config, this);
    if (Array.isArray(childrenData)) {
      childrenData.push(childData);
    } else {
      this.childrenData = [childData];
    }
    children2.push(node);
    return node;
  }
  calcText(allLevels, separator) {
    const text2 = allLevels ? this.pathLabels.join(separator) : this.label;
    this.text = text2;
    return text2;
  }
  broadcast(event, ...args) {
    const handlerName = `onParent${capitalize(event)}`;
    this.children.forEach((child) => {
      if (child) {
        child.broadcast(event, ...args);
        child[handlerName] && child[handlerName](...args);
      }
    });
  }
  emit(event, ...args) {
    const { parent: parent2 } = this;
    const handlerName = `onChild${capitalize(event)}`;
    if (parent2) {
      parent2[handlerName] && parent2[handlerName](...args);
      parent2.emit(event, ...args);
    }
  }
  onParentCheck(checked2) {
    if (!this.isDisabled) {
      this.setCheckState(checked2);
    }
  }
  onChildCheck() {
    const { children: children2 } = this;
    const validChildren = children2.filter((child) => !child.isDisabled);
    const checked2 = validChildren.length ? validChildren.every((child) => child.checked) : false;
    this.setCheckState(checked2);
  }
  setCheckState(checked2) {
    const totalNum = this.children.length;
    const checkedNum = this.children.reduce((c, p2) => {
      const num = p2.checked ? 1 : p2.indeterminate ? 0.5 : 0;
      return c + num;
    }, 0);
    this.checked = this.loaded && this.children.every((child) => child.loaded && child.checked) && checked2;
    this.indeterminate = this.loaded && checkedNum !== totalNum && checkedNum > 0;
  }
  doCheck(checked2) {
    if (this.checked === checked2)
      return;
    const { checkStrictly, multiple } = this.config;
    if (checkStrictly || !multiple) {
      this.checked = checked2;
    } else {
      this.broadcast("check", checked2);
      this.setCheckState(checked2);
      this.emit("check");
    }
  }
}
const flatNodes = (nodes, leafOnly) => {
  return nodes.reduce((res, node) => {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }
    return res;
  }, []);
};
class Store {
  constructor(data, config) {
    this.config = config;
    const nodes = (data || []).map((nodeData) => new Node(nodeData, this.config));
    this.nodes = nodes;
    this.allNodes = flatNodes(nodes, false);
    this.leafNodes = flatNodes(nodes, true);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(leafOnly) {
    return leafOnly ? this.leafNodes : this.allNodes;
  }
  appendNode(nodeData, parentNode2) {
    const node = parentNode2 ? parentNode2.appendChild(nodeData) : new Node(nodeData, this.config);
    if (!parentNode2)
      this.nodes.push(node);
    this.allNodes.push(node);
    node.isLeaf && this.leafNodes.push(node);
  }
  appendNodes(nodeDataList, parentNode2) {
    nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode2));
  }
  getNodeByValue(value, leafOnly = false) {
    if (!value && value !== 0)
      return null;
    const node = this.getFlattedNodes(leafOnly).find((node2) => isEqual(node2.value, value) || isEqual(node2.pathValues, value));
    return node || null;
  }
  getSameNode(node) {
    if (!node)
      return null;
    const node_ = this.getFlattedNodes(false).find(({ value, level }) => isEqual(node.value, value) && node.level === level);
    return node_ || null;
  }
}
const CommonProps = {
  modelValue: [Number, String, Array],
  options: {
    type: Array,
    default: () => []
  },
  props: {
    type: Object,
    default: () => ({})
  }
};
const DefaultProps = {
  expandTrigger: ExpandTrigger.CLICK,
  multiple: false,
  checkStrictly: false,
  emitPath: true,
  lazy: false,
  lazyLoad: NOOP,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500
};
const useCascaderConfig = (props2) => {
  return computed(() => __spreadValues(__spreadValues({}, DefaultProps), props2.props));
};
const getMenuIndex = (el) => {
  if (!el)
    return 0;
  const pieces = el.id.split("-");
  return Number(pieces[pieces.length - 2]);
};
const checkNode = (el) => {
  if (!el)
    return;
  const input = el.querySelector("input");
  if (input) {
    input.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};
const sortByOriginalOrder = (oldNodes, newNodes) => {
  const newNodesCopy = newNodes.slice(0);
  const newIds = newNodesCopy.map((node) => node.uid);
  const res = oldNodes.reduce((acc, item) => {
    const index2 = newIds.indexOf(item.uid);
    if (index2 > -1) {
      acc.push(item);
      newNodesCopy.splice(index2, 1);
      newIds.splice(index2, 1);
    }
    return acc;
  }, []);
  res.push(...newNodesCopy);
  return res;
};
const _sfc_main$H = defineComponent({
  name: "ElCascaderPanel",
  components: {
    ElCascaderMenu
  },
  props: __spreadProps(__spreadValues({}, CommonProps), {
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function
  }),
  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "close", "expand-change"],
  setup(props2, { emit, slots }) {
    let manualChecked = false;
    const ns = useNamespace("cascader");
    const config = useCascaderConfig(props2);
    let store = null;
    const initialLoaded = ref(true);
    const menuList = ref([]);
    const checkedValue = ref(null);
    const menus = ref([]);
    const expandingNode = ref(null);
    const checkedNodes = ref([]);
    const isHoverMenu = computed(() => config.value.expandTrigger === ExpandTrigger.HOVER);
    const renderLabelFn = computed(() => props2.renderLabel || slots.default);
    const initStore = () => {
      const { options } = props2;
      const cfg = config.value;
      manualChecked = false;
      store = new Store(options, cfg);
      menus.value = [store.getNodes()];
      if (cfg.lazy && isEmpty(props2.options)) {
        initialLoaded.value = false;
        lazyLoad(void 0, (list2) => {
          if (list2) {
            store = new Store(list2, cfg);
            menus.value = [store.getNodes()];
          }
          initialLoaded.value = true;
          syncCheckedValue(false, true);
        });
      } else {
        syncCheckedValue(false, true);
      }
    };
    const lazyLoad = (node, cb) => {
      const cfg = config.value;
      node = node || new Node({}, cfg, void 0, true);
      node.loading = true;
      const resolve = (dataList) => {
        const _node = node;
        const parent2 = _node.root ? null : _node;
        dataList && (store == null ? void 0 : store.appendNodes(dataList, parent2));
        _node.loading = false;
        _node.loaded = true;
        _node.childrenData = _node.childrenData || [];
        cb && cb(dataList);
      };
      cfg.lazyLoad(node, resolve);
    };
    const expandNode = (node, silent) => {
      var _a2;
      const { level } = node;
      const newMenus = menus.value.slice(0, level);
      let newExpandingNode;
      if (node.isLeaf) {
        newExpandingNode = node.pathNodes[level - 2];
      } else {
        newExpandingNode = node;
        newMenus.push(node.children);
      }
      if (((_a2 = expandingNode.value) == null ? void 0 : _a2.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {
        expandingNode.value = node;
        menus.value = newMenus;
        !silent && emit("expand-change", (node == null ? void 0 : node.pathValues) || []);
      }
    };
    const handleCheckChange = (node, checked2, emitClose = true) => {
      const { checkStrictly, multiple } = config.value;
      const oldNode = checkedNodes.value[0];
      manualChecked = true;
      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));
      node.doCheck(checked2);
      calculateCheckedValue();
      emitClose && !multiple && !checkStrictly && emit("close");
      !emitClose && !multiple && !checkStrictly && expandParentNode(node);
    };
    const expandParentNode = (node) => {
      if (!node)
        return;
      node = node.parent;
      expandParentNode(node);
      node && expandNode(node);
    };
    const getFlattedNodes = (leafOnly) => {
      return store == null ? void 0 : store.getFlattedNodes(leafOnly);
    };
    const getCheckedNodes = (leafOnly) => {
      var _a2;
      return (_a2 = getFlattedNodes(leafOnly)) == null ? void 0 : _a2.filter((node) => node.checked !== false);
    };
    const clearCheckedNodes = () => {
      checkedNodes.value.forEach((node) => node.doCheck(false));
      calculateCheckedValue();
    };
    const calculateCheckedValue = () => {
      var _a2;
      const { checkStrictly, multiple } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = getCheckedNodes(!checkStrictly);
      const nodes = sortByOriginalOrder(oldNodes, newNodes);
      const values = nodes.map((node) => node.valueByOption);
      checkedNodes.value = nodes;
      checkedValue.value = multiple ? values : (_a2 = values[0]) != null ? _a2 : null;
    };
    const syncCheckedValue = (loaded = false, forced = false) => {
      const { modelValue } = props2;
      const { lazy, multiple, checkStrictly } = config.value;
      const leafOnly = !checkStrictly;
      if (!initialLoaded.value || manualChecked || !forced && isEqual(modelValue, checkedValue.value))
        return;
      if (lazy && !loaded) {
        const values = unique(flattenDeep(castArray(modelValue)));
        const nodes = values.map((val) => store == null ? void 0 : store.getNodeByValue(val)).filter((node) => !!node && !node.loaded && !node.loading);
        if (nodes.length) {
          nodes.forEach((node) => {
            lazyLoad(node, () => syncCheckedValue(false, forced));
          });
        } else {
          syncCheckedValue(true, forced);
        }
      } else {
        const values = multiple ? castArray(modelValue) : [modelValue];
        const nodes = unique(values.map((val) => store == null ? void 0 : store.getNodeByValue(val, leafOnly)));
        syncMenuState(nodes, false);
        checkedValue.value = modelValue;
      }
    };
    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
      const { checkStrictly } = config.value;
      const oldNodes = checkedNodes.value;
      const newNodes = newCheckedNodes.filter((node) => !!node && (checkStrictly || node.isLeaf));
      const oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);
      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];
      if (newExpandingNode) {
        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
      } else {
        expandingNode.value = null;
      }
      oldNodes.forEach((node) => node.doCheck(false));
      newNodes.forEach((node) => node.doCheck(true));
      checkedNodes.value = newNodes;
      nextTick$1(scrollToExpandingNode);
    };
    const scrollToExpandingNode = () => {
      if (!isClient)
        return;
      menuList.value.forEach((menu2) => {
        const menuElement = menu2 == null ? void 0 : menu2.$el;
        if (menuElement) {
          const container = menuElement.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);
          const activeNode = menuElement.querySelector(`.${ns.b("node")}.${ns.is("active")}`) || menuElement.querySelector(`.${ns.b("node")}.in-active-path`);
          scrollIntoView(container, activeNode);
        }
      });
    };
    const handleKeyDown = (e2) => {
      const target = e2.target;
      const { code } = e2;
      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down: {
          e2.preventDefault();
          const distance2 = code === EVENT_CODE.up ? -1 : 1;
          focusNode(getSibling(target, distance2, `.${ns.b("node")}[tabindex="-1"]`));
          break;
        }
        case EVENT_CODE.left: {
          e2.preventDefault();
          const preMenu = menuList.value[getMenuIndex(target) - 1];
          const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(`.${ns.b("node")}[aria-expanded="true"]`);
          focusNode(expandedNode);
          break;
        }
        case EVENT_CODE.right: {
          e2.preventDefault();
          const nextMenu = menuList.value[getMenuIndex(target) + 1];
          const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(`.${ns.b("node")}[tabindex="-1"]`);
          focusNode(firstNode);
          break;
        }
        case EVENT_CODE.enter:
          checkNode(target);
          break;
        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          emit("close");
          break;
      }
    };
    provide(CASCADER_PANEL_INJECTION_KEY, reactive({
      config,
      expandingNode,
      checkedNodes,
      isHoverMenu,
      initialLoaded,
      renderLabelFn,
      lazyLoad,
      expandNode,
      handleCheckChange
    }));
    watch$1([config, () => props2.options], initStore, {
      deep: true,
      immediate: true
    });
    watch$1(() => props2.modelValue, () => {
      manualChecked = false;
      syncCheckedValue();
    });
    watch$1(checkedValue, (val) => {
      if (!isEqual(val, props2.modelValue)) {
        emit(UPDATE_MODEL_EVENT, val);
        emit(CHANGE_EVENT, val);
      }
    });
    onBeforeUpdate(() => menuList.value = []);
    onMounted(() => !isEmpty(props2.modelValue) && syncCheckedValue());
    return {
      ns,
      menuList,
      menus,
      checkedNodes,
      handleKeyDown,
      handleCheckChange,
      getFlattedNodes,
      getCheckedNodes,
      clearCheckedNodes,
      calculateCheckedValue,
      scrollToExpandingNode
    };
  }
});
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_cascader_menu = resolveComponent("el-cascader-menu");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.ns.b("panel"), _ctx.ns.is("bordered", _ctx.border)]),
    onKeydown: _cache[0] || (_cache[0] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, (menu2, index2) => {
      return openBlock(), createBlock(_component_el_cascader_menu, {
        key: index2,
        ref_for: true,
        ref: (item) => _ctx.menuList[index2] = item,
        index: index2,
        nodes: [...menu2]
      }, null, 8, ["index", "nodes"]);
    }), 128))
  ], 34);
}
var CascaderPanel = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$m], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
CascaderPanel.install = (app) => {
  app.component(CascaderPanel.name, CascaderPanel);
};
const _CascaderPanel = CascaderPanel;
const tagProps = buildProps({
  closable: Boolean,
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  hit: Boolean,
  disableTransitions: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: componentSizes,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
});
const tagEmits = {
  close: (evt) => evt instanceof MouseEvent,
  click: (evt) => evt instanceof MouseEvent
};
const __default__$6 = {
  name: "ElTag"
};
const _sfc_main$G = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$6), {
  props: tagProps,
  emits: tagEmits,
  setup(__props, { emit }) {
    const props2 = __props;
    const tagSize = useSize();
    const ns = useNamespace("tag");
    const classes2 = computed(() => {
      const { type, hit, effect: effect2, closable, round: round2 } = props2;
      return [
        ns.b(),
        ns.is("closable", closable),
        ns.m(type),
        ns.m(tagSize.value),
        ns.m(effect2),
        ns.is("hit", hit),
        ns.is("round", round2)
      ];
    });
    const handleClose = (event) => {
      event.stopPropagation();
      emit("close", event);
    };
    const handleClick = (event) => {
      emit("click", event);
    };
    return (_ctx, _cache) => {
      return !_ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(unref(classes2)),
        style: normalizeStyle$1({ backgroundColor: _ctx.color }),
        onClick: handleClick
      }, [
        createElementVNode("span", {
          class: normalizeClass(unref(ns).e("content"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2),
        _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
          key: 0,
          class: normalizeClass(unref(ns).e("close")),
          onClick: handleClose
        }, {
          default: withCtx(() => [
            createVNode$1(unref(close))
          ]),
          _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", true)
      ], 6)) : (openBlock(), createBlock(Transition, {
        key: 1,
        name: `${unref(ns).namespace.value}-zoom-in-center`
      }, {
        default: withCtx(() => [
          createElementVNode("span", {
            class: normalizeClass(unref(classes2)),
            style: normalizeStyle$1({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            createElementVNode("span", {
              class: normalizeClass(unref(ns).e("content"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns).e("close")),
              onClick: handleClose
            }, {
              default: withCtx(() => [
                createVNode$1(unref(close))
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", true)
          ], 6)
        ]),
        _: 3
      }, 8, ["name"]));
    };
  }
}));
var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const ElTag = withInstall(Tag);
const DEFAULT_INPUT_HEIGHT = 40;
const INPUT_HEIGHT_MAP = {
  large: 36,
  default: 32,
  small: 28
};
const popperOptions = {
  modifiers: [
    {
      name: "arrowPosition",
      enabled: true,
      phase: "main",
      fn: ({ state }) => {
        const { modifiersData, placement } = state;
        if (["right", "left", "bottom", "top"].includes(placement))
          return;
        modifiersData.arrow.x = 35;
      },
      requires: ["arrow"]
    }
  ]
};
const COMPONENT_NAME$2 = "ElCascader";
const _sfc_main$F = defineComponent({
  name: COMPONENT_NAME$2,
  components: {
    ElCascaderPanel: _CascaderPanel,
    ElInput,
    ElTooltip,
    ElScrollbar,
    ElTag,
    ElIcon,
    CircleClose: circleClose,
    Check: check,
    ArrowDown: arrowDown
  },
  directives: {
    Clickoutside: ClickOutside
  },
  props: __spreadProps(__spreadValues({}, CommonProps), {
    size: {
      type: String,
      validator: isValidComponentSize
    },
    placeholder: {
      type: String
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    filterMethod: {
      type: Function,
      default: (node, keyword) => node.text.includes(keyword)
    },
    separator: {
      type: String,
      default: " / "
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    collapseTags: Boolean,
    collapseTagsTooltip: {
      type: Boolean,
      default: false
    },
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: () => true
    },
    popperClass: {
      type: String,
      default: ""
    },
    popperAppendToBody: {
      type: Boolean,
      default: void 0
    },
    teleported: useTooltipContentProps.teleported,
    tagType: __spreadProps(__spreadValues({}, tagProps.type), { default: "info" })
  }),
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "focus",
    "blur",
    "visible-change",
    "expand-change",
    "remove-tag"
  ],
  setup(props2, { emit }) {
    let inputInitialHeight = 0;
    let pressDeleteCount = 0;
    const { compatTeleported } = useDeprecateAppendToBody(COMPONENT_NAME$2, "popperAppendToBody");
    const nsCascader = useNamespace("cascader");
    const nsInput = useNamespace("input");
    const { t } = useLocale();
    const elForm = inject(formContextKey, {});
    const elFormItem = inject(formItemContextKey, {});
    const tooltipRef = ref(null);
    const input = ref(null);
    const tagWrapper = ref(null);
    const panel = ref(null);
    const suggestionPanel = ref(null);
    const popperVisible = ref(false);
    const inputHover = ref(false);
    const filtering = ref(false);
    const inputValue = ref("");
    const searchInputValue = ref("");
    const presentTags = ref([]);
    const allPresentTags = ref([]);
    const suggestions = ref([]);
    const isOnComposition = ref(false);
    const isDisabled = computed(() => props2.disabled || elForm.disabled);
    const inputPlaceholder = computed(() => props2.placeholder || t("el.cascader.placeholder"));
    const realSize = useSize();
    const tagSize = computed(() => ["small"].includes(realSize.value) ? "small" : "default");
    const multiple = computed(() => !!props2.props.multiple);
    const readonly2 = computed(() => !props2.filterable || multiple.value);
    const searchKeyword = computed(() => multiple.value ? searchInputValue.value : inputValue.value);
    const checkedNodes = computed(() => {
      var _a2;
      return ((_a2 = panel.value) == null ? void 0 : _a2.checkedNodes) || [];
    });
    const clearBtnVisible = computed(() => {
      if (!props2.clearable || isDisabled.value || filtering.value || !inputHover.value)
        return false;
      return !!checkedNodes.value.length;
    });
    const presentText = computed(() => {
      const { showAllLevels, separator } = props2;
      const nodes = checkedNodes.value;
      return nodes.length ? multiple.value ? " " : nodes[0].calcText(showAllLevels, separator) : "";
    });
    const checkedValue = computed({
      get() {
        return props2.modelValue;
      },
      set(val) {
        var _a2;
        emit(UPDATE_MODEL_EVENT, val);
        emit(CHANGE_EVENT, val);
        (_a2 = elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
      }
    });
    const popperPaneRef = computed(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b2.contentRef;
    });
    const togglePopperVisible = (visible) => {
      var _a2, _b2, _c2;
      if (isDisabled.value)
        return;
      visible = visible != null ? visible : !popperVisible.value;
      if (visible !== popperVisible.value) {
        popperVisible.value = visible;
        (_b2 = (_a2 = input.value) == null ? void 0 : _a2.input) == null ? void 0 : _b2.setAttribute("aria-expanded", `${visible}`);
        if (visible) {
          updatePopperPosition();
          nextTick$1((_c2 = panel.value) == null ? void 0 : _c2.scrollToExpandingNode);
        } else if (props2.filterable) {
          const { value } = presentText;
          inputValue.value = value;
          searchInputValue.value = value;
        }
        emit("visible-change", visible);
      }
    };
    const updatePopperPosition = () => {
      nextTick$1(() => {
        var _a2;
        (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper();
      });
    };
    const hideSuggestionPanel = () => {
      filtering.value = false;
    };
    const genTag2 = (node) => {
      const { showAllLevels, separator } = props2;
      return {
        node,
        key: node.uid,
        text: node.calcText(showAllLevels, separator),
        hitState: false,
        closable: !isDisabled.value && !node.isDisabled,
        isCollapseTag: false
      };
    };
    const deleteTag = (tag) => {
      var _a2;
      const node = tag.node;
      node.doCheck(false);
      (_a2 = panel.value) == null ? void 0 : _a2.calculateCheckedValue();
      emit("remove-tag", node.valueByOption);
    };
    const calculatePresentTags = () => {
      if (!multiple.value)
        return;
      const nodes = checkedNodes.value;
      const tags = [];
      const allTags = [];
      nodes.forEach((node) => allTags.push(genTag2(node)));
      allPresentTags.value = allTags;
      if (nodes.length) {
        const [first, ...rest] = nodes;
        const restCount = rest.length;
        tags.push(genTag2(first));
        if (restCount) {
          if (props2.collapseTags) {
            tags.push({
              key: -1,
              text: `+ ${restCount}`,
              closable: false,
              isCollapseTag: true
            });
          } else {
            rest.forEach((node) => tags.push(genTag2(node)));
          }
        }
      }
      presentTags.value = tags;
    };
    const calculateSuggestions = () => {
      var _a2, _b2;
      const { filterMethod, showAllLevels, separator } = props2;
      const res = (_b2 = (_a2 = panel.value) == null ? void 0 : _a2.getFlattedNodes(!props2.props.checkStrictly)) == null ? void 0 : _b2.filter((node) => {
        if (node.isDisabled)
          return false;
        node.calcText(showAllLevels, separator);
        return filterMethod(node, searchKeyword.value);
      });
      if (multiple.value) {
        presentTags.value.forEach((tag) => {
          tag.hitState = false;
        });
        allPresentTags.value.forEach((tag) => {
          tag.hitState = false;
        });
      }
      filtering.value = true;
      suggestions.value = res;
      updatePopperPosition();
    };
    const focusFirstNode = () => {
      var _a2;
      let firstNode;
      if (filtering.value && suggestionPanel.value) {
        firstNode = suggestionPanel.value.$el.querySelector(`.${nsCascader.e("suggestion-item")}`);
      } else {
        firstNode = (_a2 = panel.value) == null ? void 0 : _a2.$el.querySelector(`.${nsCascader.b("node")}[tabindex="-1"]`);
      }
      if (firstNode) {
        firstNode.focus();
        !filtering.value && firstNode.click();
      }
    };
    const updateStyle2 = () => {
      var _a2, _b2;
      const inputInner = (_a2 = input.value) == null ? void 0 : _a2.input;
      const tagWrapperEl = tagWrapper.value;
      const suggestionPanelEl = (_b2 = suggestionPanel.value) == null ? void 0 : _b2.$el;
      if (!isClient || !inputInner)
        return;
      if (suggestionPanelEl) {
        const suggestionList = suggestionPanelEl.querySelector(`.${nsCascader.e("suggestion-list")}`);
        suggestionList.style.minWidth = `${inputInner.offsetWidth}px`;
      }
      if (tagWrapperEl) {
        const { offsetHeight } = tagWrapperEl;
        const height = presentTags.value.length > 0 ? `${Math.max(offsetHeight + 6, inputInitialHeight)}px` : `${inputInitialHeight}px`;
        inputInner.style.height = height;
        updatePopperPosition();
      }
    };
    const getCheckedNodes = (leafOnly) => {
      var _a2;
      return (_a2 = panel.value) == null ? void 0 : _a2.getCheckedNodes(leafOnly);
    };
    const handleExpandChange = (value) => {
      updatePopperPosition();
      emit("expand-change", value);
    };
    const handleComposition = (event) => {
      var _a2;
      const text2 = (_a2 = event.target) == null ? void 0 : _a2.value;
      if (event.type === "compositionend") {
        isOnComposition.value = false;
        nextTick$1(() => handleInput(text2));
      } else {
        const lastCharacter = text2[text2.length - 1] || "";
        isOnComposition.value = !isKorean(lastCharacter);
      }
    };
    const handleKeyDown = (e2) => {
      if (isOnComposition.value)
        return;
      switch (e2.code) {
        case EVENT_CODE.enter:
          togglePopperVisible();
          break;
        case EVENT_CODE.down:
          togglePopperVisible(true);
          nextTick$1(focusFirstNode);
          e2.preventDefault();
          break;
        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          togglePopperVisible(false);
          break;
      }
    };
    const handleClear = () => {
      var _a2;
      (_a2 = panel.value) == null ? void 0 : _a2.clearCheckedNodes();
      togglePopperVisible(false);
    };
    const handleSuggestionClick = (node) => {
      var _a2, _b2;
      const { checked: checked2 } = node;
      if (multiple.value) {
        (_a2 = panel.value) == null ? void 0 : _a2.handleCheckChange(node, !checked2, false);
      } else {
        !checked2 && ((_b2 = panel.value) == null ? void 0 : _b2.handleCheckChange(node, true, false));
        togglePopperVisible(false);
      }
    };
    const handleSuggestionKeyDown = (e2) => {
      const target = e2.target;
      const { code } = e2;
      switch (code) {
        case EVENT_CODE.up:
        case EVENT_CODE.down: {
          const distance2 = code === EVENT_CODE.up ? -1 : 1;
          focusNode(getSibling(target, distance2, `.${nsCascader.e("suggestion-item")}[tabindex="-1"]`));
          break;
        }
        case EVENT_CODE.enter:
          target.click();
          break;
        case EVENT_CODE.esc:
        case EVENT_CODE.tab:
          togglePopperVisible(false);
          break;
      }
    };
    const handleDelete = () => {
      const tags = presentTags.value;
      const lastTag = tags[tags.length - 1];
      pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
      if (!lastTag || !pressDeleteCount)
        return;
      if (lastTag.hitState) {
        deleteTag(lastTag);
      } else {
        lastTag.hitState = true;
      }
    };
    const handleFilter = debounce$1(() => {
      const { value } = searchKeyword;
      if (!value)
        return;
      const passed = props2.beforeFilter(value);
      if (isPromise(passed)) {
        passed.then(calculateSuggestions).catch(() => {
        });
      } else if (passed !== false) {
        calculateSuggestions();
      } else {
        hideSuggestionPanel();
      }
    }, props2.debounce);
    const handleInput = (val, e2) => {
      !popperVisible.value && togglePopperVisible(true);
      if (e2 == null ? void 0 : e2.isComposing)
        return;
      val ? handleFilter() : hideSuggestionPanel();
    };
    watch$1(filtering, updatePopperPosition);
    watch$1([checkedNodes, isDisabled], calculatePresentTags);
    watch$1(presentTags, () => {
      nextTick$1(() => updateStyle2());
    });
    watch$1(presentText, (val) => inputValue.value = val, { immediate: true });
    onMounted(() => {
      var _a2;
      const inputEl = (_a2 = input.value) == null ? void 0 : _a2.$el;
      inputInitialHeight = (inputEl == null ? void 0 : inputEl.offsetHeight) || INPUT_HEIGHT_MAP[realSize.value] || DEFAULT_INPUT_HEIGHT;
      addResizeListener(inputEl, updateStyle2);
    });
    onBeforeUnmount(() => {
      var _a2;
      removeResizeListener((_a2 = input.value) == null ? void 0 : _a2.$el, updateStyle2);
    });
    return {
      popperOptions,
      tooltipRef,
      popperPaneRef,
      input,
      tagWrapper,
      panel,
      suggestionPanel,
      popperVisible,
      inputHover,
      inputPlaceholder,
      filtering,
      presentText,
      checkedValue,
      inputValue,
      searchInputValue,
      presentTags,
      allPresentTags,
      suggestions,
      isDisabled,
      isOnComposition,
      realSize,
      tagSize,
      multiple,
      readonly: readonly2,
      clearBtnVisible,
      compatTeleported,
      nsCascader,
      nsInput,
      t,
      togglePopperVisible,
      hideSuggestionPanel,
      deleteTag,
      focusFirstNode,
      getCheckedNodes,
      handleExpandChange,
      handleKeyDown,
      handleComposition,
      handleClear,
      handleSuggestionClick,
      handleSuggestionKeyDown,
      handleDelete,
      handleInput
    };
  }
});
const _hoisted_1$y = { key: 0 };
const _hoisted_2$h = { class: "el-cascader__collapse-tags" };
const _hoisted_3$c = ["placeholder"];
const _hoisted_4$9 = ["onClick"];
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_circle_close = resolveComponent("circle-close");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_arrow_down = resolveComponent("arrow-down");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _component_el_cascader_panel = resolveComponent("el-cascader-panel");
  const _component_check = resolveComponent("check");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createBlock(_component_el_tooltip, {
    ref: "tooltipRef",
    visible: _ctx.popperVisible,
    "onUpdate:visible": _cache[17] || (_cache[17] = ($event) => _ctx.popperVisible = $event),
    teleported: _ctx.compatTeleported,
    "popper-class": [_ctx.nsCascader.e("dropdown"), _ctx.popperClass],
    "popper-options": _ctx.popperOptions,
    "fallback-placements": [
      "bottom-start",
      "bottom",
      "top-start",
      "top",
      "right",
      "left"
    ],
    "stop-popper-mouse-event": false,
    "gpu-acceleration": false,
    placement: "bottom-start",
    transition: `${_ctx.nsCascader.namespace.value}-zoom-in-top`,
    effect: "light",
    pure: "",
    persistent: "",
    onHide: _ctx.hideSuggestionPanel
  }, {
    default: withCtx(() => [
      withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass([
          _ctx.nsCascader.b(),
          _ctx.nsCascader.m(_ctx.realSize),
          _ctx.nsCascader.is("disabled", _ctx.isDisabled),
          _ctx.$attrs.class
        ]),
        style: normalizeStyle$1(_ctx.$attrs.style),
        onClick: _cache[11] || (_cache[11] = () => _ctx.togglePopperVisible(_ctx.readonly ? void 0 : true)),
        onKeydown: _cache[12] || (_cache[12] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args)),
        onMouseenter: _cache[13] || (_cache[13] = ($event) => _ctx.inputHover = true),
        onMouseleave: _cache[14] || (_cache[14] = ($event) => _ctx.inputHover = false)
      }, [
        createVNode$1(_component_el_input, {
          ref: "input",
          modelValue: _ctx.inputValue,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.inputValue = $event),
          placeholder: _ctx.inputPlaceholder,
          readonly: _ctx.readonly,
          disabled: _ctx.isDisabled,
          "validate-event": false,
          size: _ctx.realSize,
          class: normalizeClass(_ctx.nsCascader.is("focus", _ctx.popperVisible)),
          onCompositionstart: _ctx.handleComposition,
          onCompositionupdate: _ctx.handleComposition,
          onCompositionend: _ctx.handleComposition,
          onFocus: _cache[2] || (_cache[2] = (e2) => _ctx.$emit("focus", e2)),
          onBlur: _cache[3] || (_cache[3] = (e2) => _ctx.$emit("blur", e2)),
          onInput: _ctx.handleInput
        }, {
          suffix: withCtx(() => [
            _ctx.clearBtnVisible ? (openBlock(), createBlock(_component_el_icon, {
              key: "clear",
              class: normalizeClass([_ctx.nsInput.e("icon"), "icon-circle-close"]),
              onClick: withModifiers(_ctx.handleClear, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode$1(_component_circle_close)
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : (openBlock(), createBlock(_component_el_icon, {
              key: "arrow-down",
              class: normalizeClass([
                _ctx.nsInput.e("icon"),
                "icon-arrow-down",
                _ctx.nsCascader.is("reverse", _ctx.popperVisible)
              ]),
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.togglePopperVisible(), ["stop"]))
            }, {
              default: withCtx(() => [
                createVNode$1(_component_arrow_down)
              ]),
              _: 1
            }, 8, ["class"]))
          ]),
          _: 1
        }, 8, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput"]),
        _ctx.multiple ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "tagWrapper",
          class: normalizeClass(_ctx.nsCascader.e("tags"))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.presentTags, (tag) => {
            return openBlock(), createBlock(_component_el_tag, {
              key: tag.key,
              type: _ctx.tagType,
              size: _ctx.tagSize,
              hit: tag.hitState,
              closable: tag.closable,
              "disable-transitions": "",
              onClose: ($event) => _ctx.deleteTag(tag)
            }, {
              default: withCtx(() => [
                tag.isCollapseTag === false ? (openBlock(), createElementBlock("span", _hoisted_1$y, toDisplayString(tag.text), 1)) : (openBlock(), createBlock(_component_el_tooltip, {
                  key: 1,
                  teleported: false,
                  disabled: _ctx.popperVisible || !_ctx.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  effect: "light"
                }, {
                  default: withCtx(() => [
                    createElementVNode("span", null, toDisplayString(tag.text), 1)
                  ]),
                  content: withCtx(() => [
                    createElementVNode("div", _hoisted_2$h, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.allPresentTags, (tag2, idx) => {
                        return openBlock(), createElementBlock("div", {
                          key: idx,
                          class: "el-cascader__collapse-tag"
                        }, [
                          (openBlock(), createBlock(_component_el_tag, {
                            key: tag2.key,
                            class: "in-tooltip",
                            type: _ctx.tagType,
                            size: _ctx.tagSize,
                            hit: tag2.hitState,
                            closable: tag2.closable,
                            "disable-transitions": "",
                            onClose: ($event) => _ctx.deleteTag(tag2)
                          }, {
                            default: withCtx(() => [
                              createElementVNode("span", null, toDisplayString(tag2.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["type", "size", "hit", "closable", "onClose"]))
                        ]);
                      }), 128))
                    ])
                  ]),
                  _: 2
                }, 1032, ["disabled"]))
              ]),
              _: 2
            }, 1032, ["type", "size", "hit", "closable", "onClose"]);
          }), 128)),
          _ctx.filterable && !_ctx.isDisabled ? withDirectives((openBlock(), createElementBlock("input", {
            key: 0,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.searchInputValue = $event),
            type: "text",
            class: normalizeClass(_ctx.nsCascader.e("search-input")),
            placeholder: _ctx.presentText ? "" : _ctx.inputPlaceholder,
            onInput: _cache[5] || (_cache[5] = (e2) => _ctx.handleInput(_ctx.searchInputValue, e2)),
            onClick: _cache[6] || (_cache[6] = withModifiers(($event) => _ctx.togglePopperVisible(true), ["stop"])),
            onKeydown: _cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleDelete && _ctx.handleDelete(...args), ["delete"])),
            onCompositionstart: _cache[8] || (_cache[8] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
            onCompositionupdate: _cache[9] || (_cache[9] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
            onCompositionend: _cache[10] || (_cache[10] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args))
          }, null, 42, _hoisted_3$c)), [
            [vModelText, _ctx.searchInputValue]
          ]) : createCommentVNode("v-if", true)
        ], 2)) : createCommentVNode("v-if", true)
      ], 38)), [
        [_directive_clickoutside, () => _ctx.togglePopperVisible(false), _ctx.popperPaneRef]
      ])
    ]),
    content: withCtx(() => [
      withDirectives(createVNode$1(_component_el_cascader_panel, {
        ref: "panel",
        modelValue: _ctx.checkedValue,
        "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.checkedValue = $event),
        options: _ctx.options,
        props: _ctx.props,
        border: false,
        "render-label": _ctx.$slots.default,
        onExpandChange: _ctx.handleExpandChange,
        onClose: _cache[16] || (_cache[16] = ($event) => _ctx.$nextTick(() => _ctx.togglePopperVisible(false)))
      }, null, 8, ["modelValue", "options", "props", "render-label", "onExpandChange"]), [
        [vShow, !_ctx.filtering]
      ]),
      _ctx.filterable ? withDirectives((openBlock(), createBlock(_component_el_scrollbar, {
        key: 0,
        ref: "suggestionPanel",
        tag: "ul",
        class: normalizeClass(_ctx.nsCascader.e("suggestion-panel")),
        "view-class": _ctx.nsCascader.e("suggestion-list"),
        onKeydown: _ctx.handleSuggestionKeyDown
      }, {
        default: withCtx(() => [
          _ctx.suggestions.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.suggestions, (item) => {
            return openBlock(), createElementBlock("li", {
              key: item.uid,
              class: normalizeClass([
                _ctx.nsCascader.e("suggestion-item"),
                _ctx.nsCascader.is("checked", item.checked)
              ]),
              tabindex: -1,
              onClick: ($event) => _ctx.handleSuggestionClick(item)
            }, [
              createElementVNode("span", null, toDisplayString(item.text), 1),
              item.checked ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
                default: withCtx(() => [
                  createVNode$1(_component_check)
                ]),
                _: 1
              })) : createCommentVNode("v-if", true)
            ], 10, _hoisted_4$9);
          }), 128)) : renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
            createElementVNode("li", {
              class: normalizeClass(_ctx.nsCascader.e("empty-text"))
            }, toDisplayString(_ctx.t("el.cascader.noMatch")), 3)
          ])
        ]),
        _: 3
      }, 8, ["class", "view-class", "onKeydown"])), [
        [vShow, _ctx.filtering]
      ]) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["visible", "teleported", "popper-class", "popper-options", "transition", "onHide"]);
}
var Cascader$1 = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$l], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/index.vue"]]);
Cascader$1.install = (app) => {
  app.component(Cascader$1.name, Cascader$1);
};
const _Cascader = Cascader$1;
const ElCascader = _Cascader;
var advancedFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e2, t, r) {
      var n = t.prototype, s2 = n.format;
      r.en.ordinal = function(e3) {
        var t2 = ["th", "st", "nd", "rd"], r2 = e3 % 100;
        return "[" + e3 + (t2[(r2 - 20) % 10] || t2[r2] || t2[0]) + "]";
      }, n.format = function(e3) {
        var t2 = this, r2 = this.$locale();
        if (!this.isValid())
          return s2.bind(this)(e3);
        var n2 = this.$utils(), a2 = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
          switch (e4) {
            case "Q":
              return Math.ceil((t2.$M + 1) / 3);
            case "Do":
              return r2.ordinal(t2.$D);
            case "gggg":
              return t2.weekYear();
            case "GGGG":
              return t2.isoWeekYear();
            case "wo":
              return r2.ordinal(t2.week(), "W");
            case "w":
            case "ww":
              return n2.s(t2.week(), e4 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return n2.s(t2.isoWeek(), e4 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return n2.s(String(t2.$H === 0 ? 24 : t2.$H), e4 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t2.$d.getTime() / 1e3);
            case "x":
              return t2.$d.getTime();
            case "z":
              return "[" + t2.offsetName() + "]";
            case "zzz":
              return "[" + t2.offsetName("long") + "]";
            default:
              return e4;
          }
        });
        return s2.bind(this)(a2);
      };
    };
  });
})(advancedFormat$1);
var advancedFormat = advancedFormat$1.exports;
var weekOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    var e2 = "week", t = "year";
    return function(i, n, r) {
      var f = n.prototype;
      f.week = function(i2) {
        if (i2 === void 0 && (i2 = null), i2 !== null)
          return this.add(7 * (i2 - this.week()), "day");
        var n2 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f2 = r(this).startOf(t).add(1, t).date(n2), s2 = r(this).endOf(e2);
          if (f2.isBefore(s2))
            return 1;
        }
        var a2 = r(this).startOf(t).date(n2).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a2, e2, true);
        return o2 < 0 ? r(this).startOf("week").week() : Math.ceil(o2);
      }, f.weeks = function(e3) {
        return e3 === void 0 && (e3 = null), this.week(e3);
      };
    };
  });
})(weekOfYear$1);
var weekOfYear = weekOfYear$1.exports;
var weekYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e2, t) {
      t.prototype.weekYear = function() {
        var e3 = this.month(), t2 = this.week(), n = this.year();
        return t2 === 1 && e3 === 11 ? n + 1 : e3 === 0 && t2 >= 52 ? n - 1 : n;
      };
    };
  });
})(weekYear$1);
var weekYear = weekYear$1.exports;
var dayOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e2, t, n) {
      t.prototype.dayOfYear = function(e3) {
        var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
        return e3 == null ? t2 : this.add(e3 - t2, "day");
      };
    };
  });
})(dayOfYear$1);
var dayOfYear = dayOfYear$1.exports;
var isSameOrAfter$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e2, t) {
      t.prototype.isSameOrAfter = function(e3, t2) {
        return this.isSame(e3, t2) || this.isAfter(e3, t2);
      };
    };
  });
})(isSameOrAfter$1);
var isSameOrAfter = isSameOrAfter$1.exports;
var isSameOrBefore$1 = { exports: {} };
(function(module2, exports2) {
  !function(e2, i) {
    module2.exports = i();
  }(commonjsGlobal, function() {
    return function(e2, i) {
      i.prototype.isSameOrBefore = function(e3, i2) {
        return this.isSame(e3, i2) || this.isBefore(e3, i2);
      };
    };
  });
})(isSameOrBefore$1);
var isSameOrBefore = isSameOrBefore$1.exports;
const ROOT_PICKER_INJECTION_KEY = Symbol();
var ElDatePickerCell = defineComponent({
  name: "ElDatePickerCell",
  props: buildProps({
    cell: {
      type: definePropType(Object)
    }
  }),
  setup(props2) {
    const picker = inject(ROOT_PICKER_INJECTION_KEY);
    return () => {
      const cell = props2.cell;
      if (picker == null ? void 0 : picker.ctx.slots.default) {
        const list2 = picker.ctx.slots.default(cell).filter((item) => {
          return item.patchFlag !== -2 && item.type.toString() !== "Symbol(Comment)";
        });
        if (list2.length) {
          return list2;
        }
      }
      return h$1("div", {
        class: "el-date-table-cell"
      }, [
        h$1("span", {
          class: "el-date-table-cell__text"
        }, [cell == null ? void 0 : cell.text])
      ]);
    };
  }
});
const _sfc_main$E = defineComponent({
  components: {
    ElDatePickerCell
  },
  props: {
    date: {
      type: Object
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    parsedValue: {
      type: [Object, Array]
    },
    selectionMode: {
      type: String,
      default: "day"
    },
    showWeekNumber: {
      type: Boolean,
      default: false
    },
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],
  setup(props2, ctx) {
    const { t, lang } = useLocale();
    const lastRow = ref(null);
    const lastColumn = ref(null);
    const tableRows = ref([[], [], [], [], [], []]);
    const firstDayOfWeek = props2.date.$locale().weekStart || 7;
    const WEEKS_CONSTANT = props2.date.locale("en").localeData().weekdaysShort().map((_2) => _2.toLowerCase());
    const offsetDay = computed(() => {
      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
    });
    const startDate = computed(() => {
      const startDayOfMonth = props2.date.startOf("month");
      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
    });
    const WEEKS = computed(() => {
      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
    });
    const rows = computed(() => {
      var _a2;
      const startOfMonth = props2.date.startOf("month");
      const startOfMonthDay = startOfMonth.day() || 7;
      const dateCountOfMonth = startOfMonth.daysInMonth();
      const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
      const offset2 = offsetDay.value;
      const rows_ = tableRows.value;
      let count2 = 1;
      const selectedDate = props2.selectionMode === "dates" ? castArray(props2.parsedValue) : [];
      const calNow = dayjs().locale(lang.value).startOf("day");
      for (let i = 0; i < 6; i++) {
        const row = rows_[i];
        if (props2.showWeekNumber) {
          if (!row[0]) {
            row[0] = {
              type: "week",
              text: startDate.value.add(i * 7 + 1, "day").week()
            };
          }
        }
        for (let j = 0; j < 7; j++) {
          let cell = row[props2.showWeekNumber ? j + 1 : j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }
          const index2 = i * 7 + j;
          const calTime = startDate.value.add(index2 - offset2, "day");
          cell.dayjs = calTime;
          cell.date = calTime.toDate();
          cell.timestamp = calTime.valueOf();
          cell.type = "normal";
          const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
          cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "day") && calEndDate && calTime.isSameOrBefore(calEndDate, "day") || props2.minDate && calTime.isSameOrBefore(props2.minDate, "day") && calEndDate && calTime.isSameOrAfter(calEndDate, "day");
          if ((_a2 = props2.minDate) == null ? void 0 : _a2.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "day");
            cell.end = props2.minDate && calTime.isSame(props2.minDate, "day");
          } else {
            cell.start = props2.minDate && calTime.isSame(props2.minDate, "day");
            cell.end = calEndDate && calTime.isSame(calEndDate, "day");
          }
          const isToday = calTime.isSame(calNow, "day");
          if (isToday) {
            cell.type = "today";
          }
          if (i >= 0 && i <= 1) {
            const numberOfDaysFromPreviousMonth = startOfMonthDay + offset2 < 0 ? 7 + startOfMonthDay + offset2 : startOfMonthDay + offset2;
            if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count2++;
            } else {
              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;
              cell.type = "prev-month";
            }
          } else {
            if (count2 <= dateCountOfMonth) {
              cell.text = count2++;
            } else {
              cell.text = count2++ - dateCountOfMonth;
              cell.type = "next-month";
            }
          }
          const cellDate = calTime.toDate();
          cell.selected = selectedDate.find((_2) => _2.valueOf() === calTime.valueOf());
          cell.isSelected = !!cell.selected;
          cell.isCurrent = isCurrent(cell);
          cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
          cell.customClass = props2.cellClassName && props2.cellClassName(cellDate);
          row[props2.showWeekNumber ? j + 1 : j] = cell;
        }
        if (props2.selectionMode === "week") {
          const start2 = props2.showWeekNumber ? 1 : 0;
          const end2 = props2.showWeekNumber ? 7 : 6;
          const isActive = isWeekActive(row[start2 + 1]);
          row[start2].inRange = isActive;
          row[start2].start = isActive;
          row[end2].inRange = isActive;
          row[end2].end = isActive;
        }
      }
      return rows_;
    });
    const isCurrent = (cell) => {
      return props2.selectionMode === "day" && (cell.type === "normal" || cell.type === "today") && cellMatchesDate(cell, props2.parsedValue);
    };
    const cellMatchesDate = (cell, date) => {
      if (!date)
        return false;
      return dayjs(date).locale(lang.value).isSame(props2.date.date(Number(cell.text)), "day");
    };
    const getCellClasses = (cell) => {
      const classes2 = [];
      if ((cell.type === "normal" || cell.type === "today") && !cell.disabled) {
        classes2.push("available");
        if (cell.type === "today") {
          classes2.push("today");
        }
      } else {
        classes2.push(cell.type);
      }
      if (isCurrent(cell)) {
        classes2.push("current");
      }
      if (cell.inRange && (cell.type === "normal" || cell.type === "today" || props2.selectionMode === "week")) {
        classes2.push("in-range");
        if (cell.start) {
          classes2.push("start-date");
        }
        if (cell.end) {
          classes2.push("end-date");
        }
      }
      if (cell.disabled) {
        classes2.push("disabled");
      }
      if (cell.selected) {
        classes2.push("selected");
      }
      if (cell.customClass) {
        classes2.push(cell.customClass);
      }
      return classes2.join(" ");
    };
    const getDateOfCell = (row, column) => {
      const offsetFromStart = row * 7 + (column - (props2.showWeekNumber ? 1 : 0)) - offsetDay.value;
      return startDate.value.add(offsetFromStart, "day");
    };
    const handleMouseMove = (event) => {
      if (!props2.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "SPAN") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit("changerange", {
          selecting: true,
          endDate: getDateOfCell(row, column)
        });
      }
    };
    const handleClick = (event) => {
      let target = event.target;
      while (target) {
        if (target.tagName === "TD") {
          break;
        }
        target = target.parentNode;
      }
      if (!target || target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      const cell = rows.value[row][column];
      if (cell.disabled || cell.type === "week")
        return;
      const newDate = getDateOfCell(row, column);
      if (props2.selectionMode === "range") {
        if (!props2.rangeState.selecting) {
          ctx.emit("pick", { minDate: newDate, maxDate: null });
          ctx.emit("select", true);
        } else {
          if (newDate >= props2.minDate) {
            ctx.emit("pick", { minDate: props2.minDate, maxDate: newDate });
          } else {
            ctx.emit("pick", { minDate: newDate, maxDate: props2.minDate });
          }
          ctx.emit("select", false);
        }
      } else if (props2.selectionMode === "day") {
        ctx.emit("pick", newDate);
      } else if (props2.selectionMode === "week") {
        const weekNumber = newDate.week();
        const value = `${newDate.year()}w${weekNumber}`;
        ctx.emit("pick", {
          year: newDate.year(),
          week: weekNumber,
          value,
          date: newDate.startOf("week")
        });
      } else if (props2.selectionMode === "dates") {
        const newValue = cell.selected ? castArray(props2.parsedValue).filter((_2) => _2.valueOf() !== newDate.valueOf()) : castArray(props2.parsedValue).concat([newDate]);
        ctx.emit("pick", newValue);
      }
    };
    const isWeekActive = (cell) => {
      if (props2.selectionMode !== "week")
        return false;
      let newDate = props2.date.startOf("day");
      if (cell.type === "prev-month") {
        newDate = newDate.subtract(1, "month");
      }
      if (cell.type === "next-month") {
        newDate = newDate.add(1, "month");
      }
      newDate = newDate.date(Number.parseInt(cell.text, 10));
      if (props2.parsedValue && !Array.isArray(props2.parsedValue)) {
        const dayOffset = (props2.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
        const weekDate = props2.parsedValue.subtract(dayOffset, "day");
        return weekDate.isSame(newDate, "day");
      }
      return false;
    };
    return {
      handleMouseMove,
      t,
      rows,
      isWeekActive,
      getCellClasses,
      WEEKS,
      handleClick
    };
  }
});
const _hoisted_1$x = { key: 0 };
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_date_picker_cell = resolveComponent("el-date-picker-cell");
  return openBlock(), createElementBlock("table", {
    cellspacing: "0",
    cellpadding: "0",
    class: normalizeClass(["el-date-table", { "is-week-mode": _ctx.selectionMode === "week" }]),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    createElementVNode("tbody", null, [
      createElementVNode("tr", null, [
        _ctx.showWeekNumber ? (openBlock(), createElementBlock("th", _hoisted_1$x, toDisplayString(_ctx.t("el.datepicker.week")), 1)) : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.WEEKS, (week, key2) => {
          return openBlock(), createElementBlock("th", { key: key2 }, toDisplayString(_ctx.t("el.datepicker.weeks." + week)), 1);
        }), 128))
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, key2) => {
        return openBlock(), createElementBlock("tr", {
          key: key2,
          class: normalizeClass(["el-date-table__row", { current: _ctx.isWeekActive(row[1]) }])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
            return openBlock(), createElementBlock("td", {
              key: key_,
              class: normalizeClass(_ctx.getCellClasses(cell))
            }, [
              createVNode$1(_component_el_date_picker_cell, { cell }, null, 8, ["cell"])
            ], 2);
          }), 128))
        ], 2);
      }), 128))
    ])
  ], 34);
}
var DateTable = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$k], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);
const datesInMonth = (year, month, lang) => {
  const firstDay = dayjs().locale(lang).startOf("month").month(month).year(year);
  const numOfDays = firstDay.daysInMonth();
  return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
};
const _sfc_main$D = defineComponent({
  props: {
    disabledDate: {
      type: Function
    },
    selectionMode: {
      type: String,
      default: "month"
    },
    minDate: {
      type: Object
    },
    maxDate: {
      type: Object
    },
    date: {
      type: Object
    },
    parsedValue: {
      type: Object
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false
      })
    }
  },
  emits: ["changerange", "pick", "select"],
  setup(props2, ctx) {
    const { t, lang } = useLocale();
    const months = ref(props2.date.locale("en").localeData().monthsShort().map((_2) => _2.toLowerCase()));
    const tableRows = ref([[], [], []]);
    const lastRow = ref(null);
    const lastColumn = ref(null);
    const rows = computed(() => {
      var _a2;
      const rows2 = tableRows.value;
      const now2 = dayjs().locale(lang.value).startOf("month");
      for (let i = 0; i < 3; i++) {
        const row = rows2[i];
        for (let j = 0; j < 4; j++) {
          let cell = row[j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false
            };
          }
          cell.type = "normal";
          const index2 = i * 4 + j;
          const calTime = props2.date.startOf("year").month(index2);
          const calEndDate = props2.rangeState.endDate || props2.maxDate || props2.rangeState.selecting && props2.minDate;
          cell.inRange = props2.minDate && calTime.isSameOrAfter(props2.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month") || props2.minDate && calTime.isSameOrBefore(props2.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month");
          if ((_a2 = props2.minDate) == null ? void 0 : _a2.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime.isSame(calEndDate, "month");
            cell.end = props2.minDate && calTime.isSame(props2.minDate, "month");
          } else {
            cell.start = props2.minDate && calTime.isSame(props2.minDate, "month");
            cell.end = calEndDate && calTime.isSame(calEndDate, "month");
          }
          const isToday = now2.isSame(calTime);
          if (isToday) {
            cell.type = "today";
          }
          cell.text = index2;
          const cellDate = calTime.toDate();
          cell.disabled = props2.disabledDate && props2.disabledDate(cellDate);
          row[j] = cell;
        }
      }
      return rows2;
    });
    const getCellStyle = (cell) => {
      const style = {};
      const year = props2.date.year();
      const today = new Date();
      const month = cell.text;
      style.disabled = props2.disabledDate ? datesInMonth(year, month, lang.value).every(props2.disabledDate) : false;
      style.current = castArray(props2.parsedValue).findIndex((date) => date.year() === year && date.month() === month) >= 0;
      style.today = today.getFullYear() === year && today.getMonth() === month;
      if (cell.inRange) {
        style["in-range"] = true;
        if (cell.start) {
          style["start-date"] = true;
        }
        if (cell.end) {
          style["end-date"] = true;
        }
      }
      return style;
    };
    const handleMouseMove = (event) => {
      if (!props2.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        ctx.emit("changerange", {
          selecting: true,
          endDate: props2.date.startOf("year").month(row * 4 + column)
        });
      }
    };
    const handleMonthTableClick = (event) => {
      let target = event.target;
      if (target.tagName === "A") {
        target = target.parentNode.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      if (hasClass(target, "disabled"))
        return;
      const column = target.cellIndex;
      const row = target.parentNode.rowIndex;
      const month = row * 4 + column;
      const newDate = props2.date.startOf("year").month(month);
      if (props2.selectionMode === "range") {
        if (!props2.rangeState.selecting) {
          ctx.emit("pick", { minDate: newDate, maxDate: null });
          ctx.emit("select", true);
        } else {
          if (newDate >= props2.minDate) {
            ctx.emit("pick", { minDate: props2.minDate, maxDate: newDate });
          } else {
            ctx.emit("pick", { minDate: newDate, maxDate: props2.minDate });
          }
          ctx.emit("select", false);
        }
      } else {
        ctx.emit("pick", month);
      }
    };
    return {
      handleMouseMove,
      handleMonthTableClick,
      rows,
      getCellStyle,
      t,
      months
    };
  }
});
const _hoisted_1$w = { class: "cell" };
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    class: "el-month-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMonthTableClick && _ctx.handleMonthTableClick(...args)),
    onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseMove && _ctx.handleMouseMove(...args))
  }, [
    createElementVNode("tbody", null, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.rows, (row, key2) => {
        return openBlock(), createElementBlock("tr", { key: key2 }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
            return openBlock(), createElementBlock("td", {
              key: key_,
              class: normalizeClass(_ctx.getCellStyle(cell))
            }, [
              createElementVNode("div", null, [
                createElementVNode("a", _hoisted_1$w, toDisplayString(_ctx.t("el.datepicker.months." + _ctx.months[cell.text])), 1)
              ])
            ], 2);
          }), 128))
        ]);
      }), 128))
    ])
  ], 32);
}
var MonthTable = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$j], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);
const datesInYear = (year, lang) => {
  const firstDay = dayjs(String(year)).locale(lang).startOf("year");
  const lastDay = firstDay.endOf("year");
  const numOfDays = lastDay.dayOfYear();
  return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
};
const _sfc_main$C = defineComponent({
  props: {
    disabledDate: {
      type: Function
    },
    parsedValue: {
      type: Object
    },
    date: {
      type: Object
    }
  },
  emits: ["pick"],
  setup(props2, ctx) {
    const { lang } = useLocale();
    const startYear = computed(() => {
      return Math.floor(props2.date.year() / 10) * 10;
    });
    const getCellStyle = (year) => {
      const style = {};
      const today = dayjs().locale(lang.value);
      style.disabled = props2.disabledDate ? datesInYear(year, lang.value).every(props2.disabledDate) : false;
      style.current = castArray(props2.parsedValue).findIndex((_2) => _2.year() === year) >= 0;
      style.today = today.year() === year;
      return style;
    };
    const handleYearTableClick = (event) => {
      const target = event.target;
      if (target.tagName === "A") {
        if (hasClass(target.parentNode, "disabled"))
          return;
        const year = target.textContent || target.innerText;
        ctx.emit("pick", Number(year));
      }
    };
    return {
      startYear,
      getCellStyle,
      handleYearTableClick
    };
  }
});
const _hoisted_1$v = { class: "cell" };
const _hoisted_2$g = { class: "cell" };
const _hoisted_3$b = { class: "cell" };
const _hoisted_4$8 = { class: "cell" };
const _hoisted_5$8 = { class: "cell" };
const _hoisted_6$6 = { class: "cell" };
const _hoisted_7$4 = { class: "cell" };
const _hoisted_8$4 = { class: "cell" };
const _hoisted_9$4 = { class: "cell" };
const _hoisted_10$3 = { class: "cell" };
const _hoisted_11$2 = /* @__PURE__ */ createElementVNode("td", null, null, -1);
const _hoisted_12$2 = /* @__PURE__ */ createElementVNode("td", null, null, -1);
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("table", {
    class: "el-year-table",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleYearTableClick && _ctx.handleYearTableClick(...args))
  }, [
    createElementVNode("tbody", null, [
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 0)])
        }, [
          createElementVNode("a", _hoisted_1$v, toDisplayString(_ctx.startYear), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 1)])
        }, [
          createElementVNode("a", _hoisted_2$g, toDisplayString(_ctx.startYear + 1), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 2)])
        }, [
          createElementVNode("a", _hoisted_3$b, toDisplayString(_ctx.startYear + 2), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 3)])
        }, [
          createElementVNode("a", _hoisted_4$8, toDisplayString(_ctx.startYear + 3), 1)
        ], 2)
      ]),
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 4)])
        }, [
          createElementVNode("a", _hoisted_5$8, toDisplayString(_ctx.startYear + 4), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 5)])
        }, [
          createElementVNode("a", _hoisted_6$6, toDisplayString(_ctx.startYear + 5), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 6)])
        }, [
          createElementVNode("a", _hoisted_7$4, toDisplayString(_ctx.startYear + 6), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 7)])
        }, [
          createElementVNode("a", _hoisted_8$4, toDisplayString(_ctx.startYear + 7), 1)
        ], 2)
      ]),
      createElementVNode("tr", null, [
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 8)])
        }, [
          createElementVNode("a", _hoisted_9$4, toDisplayString(_ctx.startYear + 8), 1)
        ], 2),
        createElementVNode("td", {
          class: normalizeClass(["available", _ctx.getCellStyle(_ctx.startYear + 9)])
        }, [
          createElementVNode("a", _hoisted_10$3, toDisplayString(_ctx.startYear + 9), 1)
        ], 2),
        _hoisted_11$2,
        _hoisted_12$2
      ])
    ])
  ]);
}
var YearTable = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$i], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);
const timeWithinRange = (_2, __, ___) => true;
const _sfc_main$B = defineComponent({
  components: {
    DateTable,
    ElInput,
    ElButton,
    ElIcon,
    TimePickPanel,
    MonthTable,
    YearTable,
    DArrowLeft: dArrowLeft,
    ArrowLeft: arrowLeft,
    DArrowRight: dArrowRight,
    ArrowRight: arrowRight
  },
  directives: { clickoutside: ClickOutside },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    parsedValue: {
      type: [Object, Array]
    },
    format: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option", "panel-change"],
  setup(props2, ctx) {
    const { t, lang } = useLocale();
    const pickerBase = inject("EP_PICKER_BASE");
    const popper2 = inject(TOOLTIP_INJECTION_KEY);
    const {
      shortcuts,
      disabledDate,
      cellClassName,
      defaultTime,
      arrowControl
    } = pickerBase.props;
    const defaultValue = toRef(pickerBase.props, "defaultValue");
    const innerDate = ref(dayjs().locale(lang.value));
    const defaultTimeD = computed(() => {
      return dayjs(defaultTime).locale(lang.value);
    });
    const month = computed(() => {
      return innerDate.value.month();
    });
    const year = computed(() => {
      return innerDate.value.year();
    });
    const selectableRange = ref([]);
    const userInputDate = ref(null);
    const userInputTime = ref(null);
    const checkDateWithinRange = (date) => {
      return selectableRange.value.length > 0 ? timeWithinRange(date, selectableRange.value, props2.format || "HH:mm:ss") : true;
    };
    const formatEmit = (emitDayjs) => {
      if (defaultTime && !visibleTime.value) {
        return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      if (showTime.value)
        return emitDayjs.millisecond(0);
      return emitDayjs.startOf("day");
    };
    const emit = (value, ...args) => {
      if (!value) {
        ctx.emit("pick", value, ...args);
      } else if (Array.isArray(value)) {
        const dates = value.map(formatEmit);
        ctx.emit("pick", dates, ...args);
      } else {
        ctx.emit("pick", formatEmit(value), ...args);
      }
      userInputDate.value = null;
      userInputTime.value = null;
    };
    const handleDatePick = (value) => {
      if (selectionMode.value === "day") {
        let newDate = props2.parsedValue ? props2.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
        if (!checkDateWithinRange(newDate)) {
          newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
        }
        innerDate.value = newDate;
        emit(newDate, showTime.value);
      } else if (selectionMode.value === "week") {
        emit(value.date);
      } else if (selectionMode.value === "dates") {
        emit(value, true);
      }
    };
    const prevMonth_ = () => {
      innerDate.value = innerDate.value.subtract(1, "month");
      handlePanelChange("month");
    };
    const nextMonth_ = () => {
      innerDate.value = innerDate.value.add(1, "month");
      handlePanelChange("month");
    };
    const prevYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.subtract(10, "year");
      } else {
        innerDate.value = innerDate.value.subtract(1, "year");
      }
      handlePanelChange("year");
    };
    const nextYear_ = () => {
      if (currentView.value === "year") {
        innerDate.value = innerDate.value.add(10, "year");
      } else {
        innerDate.value = innerDate.value.add(1, "year");
      }
      handlePanelChange("year");
    };
    const currentView = ref("date");
    const yearLabel = computed(() => {
      const yearTranslation = t("el.datepicker.year");
      if (currentView.value === "year") {
        const startYear = Math.floor(year.value / 10) * 10;
        if (yearTranslation) {
          return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
        }
        return `${startYear} - ${startYear + 9}`;
      }
      return `${year.value} ${yearTranslation}`;
    });
    const handleShortcutClick = (shortcut) => {
      const shortcutValue = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValue) {
        emit(dayjs(shortcutValue).locale(lang.value));
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };
    const selectionMode = computed(() => {
      if (["week", "month", "year", "dates"].includes(props2.type)) {
        return props2.type;
      }
      return "day";
    });
    watch$1(() => selectionMode.value, (val) => {
      if (["month", "year"].includes(val)) {
        currentView.value = val;
        return;
      }
      currentView.value = "date";
    }, { immediate: true });
    watch$1(() => currentView.value, () => {
      popper2 == null ? void 0 : popper2.updatePopper();
    });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const handleMonthPick = (month2) => {
      innerDate.value = innerDate.value.startOf("month").month(month2);
      if (selectionMode.value === "month") {
        emit(innerDate.value);
      } else {
        currentView.value = "date";
      }
      handlePanelChange("month");
    };
    const handleYearPick = (year2) => {
      if (selectionMode.value === "year") {
        innerDate.value = innerDate.value.startOf("year").year(year2);
        emit(innerDate.value);
      } else {
        innerDate.value = innerDate.value.year(year2);
        currentView.value = "month";
      }
      handlePanelChange("year");
    };
    const showMonthPicker = () => {
      currentView.value = "month";
    };
    const showYearPicker = () => {
      currentView.value = "year";
    };
    const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
    const footerVisible = computed(() => {
      return showTime.value || selectionMode.value === "dates";
    });
    const onConfirm = () => {
      if (selectionMode.value === "dates") {
        emit(props2.parsedValue);
      } else {
        let result = props2.parsedValue;
        if (!result) {
          const defaultTimeD2 = dayjs(defaultTime).locale(lang.value);
          const defaultValueD = getDefaultValue();
          result = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
        }
        innerDate.value = result;
        emit(result);
      }
    };
    const changeToNow = () => {
      const now2 = dayjs().locale(lang.value);
      const nowDate = now2.toDate();
      if ((!disabledDate || !disabledDate(nowDate)) && checkDateWithinRange(nowDate)) {
        innerDate.value = dayjs().locale(lang.value);
        emit(innerDate.value);
      }
    };
    const timeFormat = computed(() => {
      return extractTimeFormat(props2.format);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(props2.format);
    });
    const visibleTime = computed(() => {
      if (userInputTime.value)
        return userInputTime.value;
      if (!props2.parsedValue && !defaultValue.value)
        return;
      return (props2.parsedValue || innerDate.value).format(timeFormat.value);
    });
    const visibleDate = computed(() => {
      if (userInputDate.value)
        return userInputDate.value;
      if (!props2.parsedValue && !defaultValue.value)
        return;
      return (props2.parsedValue || innerDate.value).format(dateFormat.value);
    });
    const timePickerVisible = ref(false);
    const onTimePickerInputFocus = () => {
      timePickerVisible.value = true;
    };
    const handleTimePickClose = () => {
      timePickerVisible.value = false;
    };
    const handleTimePick = (value, visible, first) => {
      const newDate = props2.parsedValue ? props2.parsedValue.hour(value.hour()).minute(value.minute()).second(value.second()) : value;
      innerDate.value = newDate;
      emit(innerDate.value, true);
      if (!first) {
        timePickerVisible.value = visible;
      }
    };
    const handleVisibleTimeChange = (value) => {
      const newDate = dayjs(value, timeFormat.value).locale(lang.value);
      if (newDate.isValid() && checkDateWithinRange(newDate)) {
        innerDate.value = newDate.year(innerDate.value.year()).month(innerDate.value.month()).date(innerDate.value.date());
        userInputTime.value = null;
        timePickerVisible.value = false;
        emit(innerDate.value, true);
      }
    };
    const handleVisibleDateChange = (value) => {
      const newDate = dayjs(value, dateFormat.value).locale(lang.value);
      if (newDate.isValid()) {
        if (disabledDate && disabledDate(newDate.toDate())) {
          return;
        }
        innerDate.value = newDate.hour(innerDate.value.hour()).minute(innerDate.value.minute()).second(innerDate.value.second());
        userInputDate.value = null;
        emit(innerDate.value, true);
      }
    };
    const isValidValue = (date) => {
      return dayjs.isDayjs(date) && date.isValid() && (disabledDate ? !disabledDate(date.toDate()) : true);
    };
    const formatToString = (value) => {
      if (selectionMode.value === "dates") {
        return value.map((_2) => _2.format(props2.format));
      }
      return value.format(props2.format);
    };
    const parseUserInput = (value) => {
      return dayjs(value, props2.format).locale(lang.value);
    };
    const getDefaultValue = () => {
      const parseDate2 = dayjs(defaultValue.value).locale(lang.value);
      if (!defaultValue.value) {
        const defaultTimeDValue = defaultTimeD.value;
        return dayjs().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
      }
      return parseDate2;
    };
    const handleKeydown = (event) => {
      const { code, keyCode } = event;
      const list2 = [
        EVENT_CODE.up,
        EVENT_CODE.down,
        EVENT_CODE.left,
        EVENT_CODE.right
      ];
      if (props2.visible && !timePickerVisible.value) {
        if (list2.includes(code)) {
          handleKeyControl(keyCode);
          event.stopPropagation();
          event.preventDefault();
        }
        if (code === EVENT_CODE.enter && userInputDate.value === null && userInputTime.value === null) {
          emit(innerDate, false);
        }
      }
    };
    const handleKeyControl = (keyCode) => {
      const mapping = {
        year: {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date, step) => date.setFullYear(date.getFullYear() + step)
        },
        month: {
          38: -4,
          40: 4,
          37: -1,
          39: 1,
          offset: (date, step) => date.setMonth(date.getMonth() + step)
        },
        week: {
          38: -1,
          40: 1,
          37: -1,
          39: 1,
          offset: (date, step) => date.setDate(date.getDate() + step * 7)
        },
        day: {
          38: -7,
          40: 7,
          37: -1,
          39: 1,
          offset: (date, step) => date.setDate(date.getDate() + step)
        }
      };
      const newDate = innerDate.value.toDate();
      while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
        const map2 = mapping[selectionMode.value];
        map2.offset(newDate, map2[keyCode]);
        if (disabledDate && disabledDate(newDate)) {
          continue;
        }
        const result = dayjs(newDate).locale(lang.value);
        innerDate.value = result;
        ctx.emit("pick", result, true);
        break;
      }
    };
    const handlePanelChange = (mode) => {
      ctx.emit("panel-change", innerDate.value.toDate(), mode, currentView.value);
    };
    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
    watch$1(() => defaultValue.value, (val) => {
      if (val) {
        innerDate.value = getDefaultValue();
      }
    }, { immediate: true });
    watch$1(() => props2.parsedValue, (val) => {
      if (val) {
        if (selectionMode.value === "dates")
          return;
        if (Array.isArray(val))
          return;
        innerDate.value = val;
      } else {
        innerDate.value = getDefaultValue();
      }
    }, { immediate: true });
    return {
      handleTimePick,
      handleTimePickClose,
      onTimePickerInputFocus,
      timePickerVisible,
      visibleTime,
      visibleDate,
      showTime,
      changeToNow,
      onConfirm,
      footerVisible,
      handleYearPick,
      showMonthPicker,
      showYearPicker,
      handleMonthPick,
      hasShortcuts,
      shortcuts,
      arrowControl,
      disabledDate,
      cellClassName,
      selectionMode,
      handleShortcutClick,
      prevYear_,
      nextYear_,
      prevMonth_,
      nextMonth_,
      innerDate,
      t,
      yearLabel,
      currentView,
      month,
      handleDatePick,
      handleVisibleTimeChange,
      handleVisibleDateChange,
      timeFormat,
      userInputTime,
      userInputDate
    };
  }
});
const _hoisted_1$u = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$f = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$a = ["onClick"];
const _hoisted_4$7 = { class: "el-picker-panel__body" };
const _hoisted_5$7 = {
  key: 0,
  class: "el-date-picker__time-header"
};
const _hoisted_6$5 = { class: "el-date-picker__editor-wrap" };
const _hoisted_7$3 = { class: "el-date-picker__editor-wrap" };
const _hoisted_8$3 = ["aria-label"];
const _hoisted_9$3 = ["aria-label"];
const _hoisted_10$2 = ["aria-label"];
const _hoisted_11$1 = ["aria-label"];
const _hoisted_12$1 = { class: "el-picker-panel__content" };
const _hoisted_13$1 = { class: "el-picker-panel__footer" };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_time_pick_panel = resolveComponent("time-pick-panel");
  const _component_d_arrow_left = resolveComponent("d-arrow-left");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_arrow_left = resolveComponent("arrow-left");
  const _component_d_arrow_right = resolveComponent("d-arrow-right");
  const _component_arrow_right = resolveComponent("arrow-right");
  const _component_date_table = resolveComponent("date-table");
  const _component_year_table = resolveComponent("year-table");
  const _component_month_table = resolveComponent("month-table");
  const _component_el_button = resolveComponent("el-button");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
        "has-time": _ctx.showTime
      }
    ]])
  }, [
    createElementVNode("div", _hoisted_1$u, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$f, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key2) => {
          return openBlock(), createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$a);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$7, [
        _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_5$7, [
          createElementVNode("span", _hoisted_6$5, [
            createVNode$1(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectDate"),
              "model-value": _ctx.visibleDate,
              size: "small",
              onInput: _cache[0] || (_cache[0] = (val) => _ctx.userInputDate = val),
              onChange: _ctx.handleVisibleDateChange
            }, null, 8, ["placeholder", "model-value", "onChange"])
          ]),
          withDirectives((openBlock(), createElementBlock("span", _hoisted_7$3, [
            createVNode$1(_component_el_input, {
              placeholder: _ctx.t("el.datepicker.selectTime"),
              "model-value": _ctx.visibleTime,
              size: "small",
              onFocus: _ctx.onTimePickerInputFocus,
              onInput: _cache[1] || (_cache[1] = (val) => _ctx.userInputTime = val),
              onChange: _ctx.handleVisibleTimeChange
            }, null, 8, ["placeholder", "model-value", "onFocus", "onChange"]),
            createVNode$1(_component_time_pick_panel, {
              visible: _ctx.timePickerVisible,
              format: _ctx.timeFormat,
              "time-arrow-control": _ctx.arrowControl,
              "parsed-value": _ctx.innerDate,
              onPick: _ctx.handleTimePick
            }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
          ])), [
            [_directive_clickoutside, _ctx.handleTimePickClose]
          ])
        ])) : createCommentVNode("v-if", true),
        withDirectives(createElementVNode("div", {
          class: normalizeClass(["el-date-picker__header", {
            "el-date-picker__header--bordered": _ctx.currentView === "year" || _ctx.currentView === "month"
          }])
        }, [
          createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevYear`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn d-arrow-left",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.prevYear_ && _ctx.prevYear_(...args))
          }, [
            createVNode$1(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode$1(_component_d_arrow_left)
              ]),
              _: 1
            })
          ], 8, _hoisted_8$3),
          withDirectives(createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.prevMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__prev-btn arrow-left",
            onClick: _cache[3] || (_cache[3] = (...args) => _ctx.prevMonth_ && _ctx.prevMonth_(...args))
          }, [
            createVNode$1(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode$1(_component_arrow_left)
              ]),
              _: 1
            })
          ], 8, _hoisted_9$3), [
            [vShow, _ctx.currentView === "date"]
          ]),
          createElementVNode("span", {
            role: "button",
            class: "el-date-picker__header-label",
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showYearPicker && _ctx.showYearPicker(...args))
          }, toDisplayString(_ctx.yearLabel), 1),
          withDirectives(createElementVNode("span", {
            role: "button",
            class: normalizeClass(["el-date-picker__header-label", { active: _ctx.currentView === "month" }]),
            onClick: _cache[5] || (_cache[5] = (...args) => _ctx.showMonthPicker && _ctx.showMonthPicker(...args))
          }, toDisplayString(_ctx.t(`el.datepicker.month${_ctx.month + 1}`)), 3), [
            [vShow, _ctx.currentView === "date"]
          ]),
          createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextYear`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn d-arrow-right",
            onClick: _cache[6] || (_cache[6] = (...args) => _ctx.nextYear_ && _ctx.nextYear_(...args))
          }, [
            createVNode$1(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode$1(_component_d_arrow_right)
              ]),
              _: 1
            })
          ], 8, _hoisted_10$2),
          withDirectives(createElementVNode("button", {
            type: "button",
            "aria-label": _ctx.t(`el.datepicker.nextMonth`),
            class: "el-picker-panel__icon-btn el-date-picker__next-btn arrow-right",
            onClick: _cache[7] || (_cache[7] = (...args) => _ctx.nextMonth_ && _ctx.nextMonth_(...args))
          }, [
            createVNode$1(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode$1(_component_arrow_right)
              ]),
              _: 1
            })
          ], 8, _hoisted_11$1), [
            [vShow, _ctx.currentView === "date"]
          ])
        ], 2), [
          [vShow, _ctx.currentView !== "time"]
        ]),
        createElementVNode("div", _hoisted_12$1, [
          _ctx.currentView === "date" ? (openBlock(), createBlock(_component_date_table, {
            key: 0,
            "selection-mode": _ctx.selectionMode,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleDatePick
          }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true),
          _ctx.currentView === "year" ? (openBlock(), createBlock(_component_year_table, {
            key: 1,
            date: _ctx.innerDate,
            "disabled-date": _ctx.disabledDate,
            "parsed-value": _ctx.parsedValue,
            onPick: _ctx.handleYearPick
          }, null, 8, ["date", "disabled-date", "parsed-value", "onPick"])) : createCommentVNode("v-if", true),
          _ctx.currentView === "month" ? (openBlock(), createBlock(_component_month_table, {
            key: 2,
            date: _ctx.innerDate,
            "parsed-value": _ctx.parsedValue,
            "disabled-date": _ctx.disabledDate,
            onPick: _ctx.handleMonthPick
          }, null, 8, ["date", "parsed-value", "disabled-date", "onPick"])) : createCommentVNode("v-if", true)
        ])
      ])
    ]),
    withDirectives(createElementVNode("div", _hoisted_13$1, [
      withDirectives(createVNode$1(_component_el_button, {
        size: "small",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.changeToNow
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.now")), 1)
        ]),
        _: 1
      }, 8, ["onClick"]), [
        [vShow, _ctx.selectionMode !== "dates"]
      ]),
      createVNode$1(_component_el_button, {
        plain: "",
        size: "small",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.onConfirm
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])
    ], 512), [
      [vShow, _ctx.footerVisible && _ctx.currentView === "date"]
    ])
  ], 2);
}
var DatePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$h], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);
const _sfc_main$A = defineComponent({
  directives: { clickoutside: ClickOutside },
  components: {
    TimePickPanel,
    DateTable,
    ElInput,
    ElButton,
    ElIcon,
    DArrowLeft: dArrowLeft,
    ArrowLeft: arrowLeft,
    DArrowRight: dArrowRight,
    ArrowRight: arrowRight
  },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    },
    type: {
      type: String,
      required: true,
      validator: isValidDatePickType
    }
  },
  emits: ["pick", "set-picker-option", "calendar-change", "panel-change"],
  setup(props2, ctx) {
    const { t, lang } = useLocale();
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, "month"));
    const minDate = ref(null);
    const maxDate = ref(null);
    const dateUserInput = ref({
      min: null,
      max: null
    });
    const timeUserInput = ref({
      min: null,
      max: null
    });
    const leftLabel = computed(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
    });
    const rightLabel = computed(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
    });
    const leftYear = computed(() => {
      return leftDate.value.year();
    });
    const leftMonth = computed(() => {
      return leftDate.value.month();
    });
    const rightYear = computed(() => {
      return rightDate.value.year();
    });
    const rightMonth = computed(() => {
      return rightDate.value.month();
    });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const minVisibleDate = computed(() => {
      if (dateUserInput.value.min !== null)
        return dateUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(dateFormat.value);
      return "";
    });
    const maxVisibleDate = computed(() => {
      if (dateUserInput.value.max !== null)
        return dateUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(dateFormat.value);
      return "";
    });
    const minVisibleTime = computed(() => {
      if (timeUserInput.value.min !== null)
        return timeUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(timeFormat.value);
      return "";
    });
    const maxVisibleTime = computed(() => {
      if (timeUserInput.value.max !== null)
        return timeUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(timeFormat.value);
      return "";
    });
    const timeFormat = computed(() => {
      return extractTimeFormat(format2);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(format2);
    });
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props2.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
      handlePanelChange("year");
    };
    const leftPrevMonth = () => {
      leftDate.value = leftDate.value.subtract(1, "month");
      if (!props2.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
      handlePanelChange("month");
    };
    const rightNextYear = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "year");
      }
      handlePanelChange("year");
    };
    const rightNextMonth = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "month");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "month");
      }
      handlePanelChange("month");
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
      handlePanelChange("year");
    };
    const leftNextMonth = () => {
      leftDate.value = leftDate.value.add(1, "month");
      handlePanelChange("month");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
      handlePanelChange("year");
    };
    const rightPrevMonth = () => {
      rightDate.value = rightDate.value.subtract(1, "month");
      handlePanelChange("month");
    };
    const handlePanelChange = (mode) => {
      ctx.emit("panel-change", [leftDate.value.toDate(), rightDate.value.toDate()], mode);
    };
    const enableMonthArrow = computed(() => {
      const nextMonth = (leftMonth.value + 1) % 12;
      const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
      return props2.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
    });
    const enableYearArrow = computed(() => {
      return props2.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
    });
    const isValidValue = (value) => {
      return Array.isArray(value) && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };
    const rangeState = ref({
      endDate: null,
      selecting: false
    });
    const btnDisabled = computed(() => {
      return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidValue([minDate.value, maxDate.value]));
    });
    const handleChangeRange = (val) => {
      rangeState.value = val;
    };
    const onSelect = (selecting) => {
      rangeState.value.selecting = selecting;
      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };
    const showTime = computed(() => props2.type === "datetime" || props2.type === "datetimerange");
    const handleConfirm = (visible = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      }
    };
    const formatEmit = (emitDayjs, index2) => {
      if (!emitDayjs)
        return;
      if (defaultTime) {
        const defaultTimeD = dayjs(defaultTime[index2] || defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      return emitDayjs;
    };
    const handleRangePick = (val, close2 = true) => {
      const min_ = val.minDate;
      const max_ = val.maxDate;
      const minDate_ = formatEmit(min_, 0);
      const maxDate_ = formatEmit(max_, 1);
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      ctx.emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2 || showTime.value)
        return;
      handleConfirm();
    };
    const handleShortcutClick = (shortcut) => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValues) {
        ctx.emit("pick", [
          dayjs(shortcutValues[0]).locale(lang.value),
          dayjs(shortcutValues[1]).locale(lang.value)
        ]);
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };
    const minTimePickerVisible = ref(false);
    const maxTimePickerVisible = ref(false);
    const handleMinTimeClose = () => {
      minTimePickerVisible.value = false;
    };
    const handleMaxTimeClose = () => {
      maxTimePickerVisible.value = false;
    };
    const handleDateInput = (value, type) => {
      dateUserInput.value[type] = value;
      const parsedValueD = dayjs(value, dateFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (disabledDate && disabledDate(parsedValueD.toDate())) {
          return;
        }
        if (type === "min") {
          leftDate.value = parsedValueD;
          minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props2.unlinkPanels) {
            rightDate.value = parsedValueD.add(1, "month");
            maxDate.value = minDate.value.add(1, "month");
          }
        } else {
          rightDate.value = parsedValueD;
          maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props2.unlinkPanels) {
            leftDate.value = parsedValueD.subtract(1, "month");
            minDate.value = maxDate.value.subtract(1, "month");
          }
        }
      }
    };
    const handleDateChange = (_2, type) => {
      dateUserInput.value[type] = null;
    };
    const handleTimeInput = (value, type) => {
      timeUserInput.value[type] = value;
      const parsedValueD = dayjs(value, timeFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (type === "min") {
          minTimePickerVisible.value = true;
          minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
          }
        } else {
          maxTimePickerVisible.value = true;
          maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          rightDate.value = maxDate.value;
          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        }
      }
    };
    const handleTimeChange = (value, type) => {
      timeUserInput.value[type] = null;
      if (type === "min") {
        leftDate.value = minDate.value;
        minTimePickerVisible.value = false;
      } else {
        rightDate.value = maxDate.value;
        maxTimePickerVisible.value = false;
      }
    };
    const handleMinTimePick = (value, visible, first) => {
      if (timeUserInput.value.min)
        return;
      if (value) {
        leftDate.value = value;
        minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        minTimePickerVisible.value = visible;
      }
      if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
        maxDate.value = minDate.value;
        rightDate.value = value;
      }
    };
    const handleMaxTimePick = (value, visible, first) => {
      if (timeUserInput.value.max)
        return;
      if (value) {
        rightDate.value = value;
        maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        maxTimePickerVisible.value = visible;
      }
      if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
        minDate.value = maxDate.value;
      }
    };
    const handleClear = () => {
      leftDate.value = getDefaultValue()[0];
      rightDate.value = leftDate.value.add(1, "month");
      ctx.emit("pick", null);
    };
    const formatToString = (value) => {
      return Array.isArray(value) ? value.map((_2) => _2.format(format2)) : value.format(format2);
    };
    const parseUserInput = (value) => {
      return Array.isArray(value) ? value.map((_2) => dayjs(_2, format2).locale(lang.value)) : dayjs(value, format2).locale(lang.value);
    };
    const getDefaultValue = () => {
      let start2;
      if (Array.isArray(defaultValue.value)) {
        const left2 = dayjs(defaultValue.value[0]);
        let right2 = dayjs(defaultValue.value[1]);
        if (!props2.unlinkPanels) {
          right2 = left2.add(1, "month");
        }
        return [left2, right2];
      } else if (defaultValue.value) {
        start2 = dayjs(defaultValue.value);
      } else {
        start2 = dayjs();
      }
      start2 = start2.locale(lang.value);
      return [start2, start2.add(1, "month")];
    };
    ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
    ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    ctx.emit("set-picker-option", ["handleClear", handleClear]);
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      shortcuts,
      disabledDate,
      cellClassName,
      format: format2,
      defaultTime,
      arrowControl,
      clearable
    } = pickerBase.props;
    const defaultValue = toRef(pickerBase.props, "defaultValue");
    watch$1(() => defaultValue.value, (val) => {
      if (val) {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    watch$1(() => props2.parsedValue, (newVal) => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;
        if (props2.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const minDateMonth = minDate.value.month();
          const maxDateYear = maxDate.value.year();
          const maxDateMonth = maxDate.value.month();
          rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate.value.add(1, "month") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "month");
          if (maxDate.value) {
            rightDate.value = rightDate.value.hour(maxDate.value.hour()).minute(maxDate.value.minute()).second(maxDate.value.second());
          }
        }
      } else {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    return {
      shortcuts,
      disabledDate,
      cellClassName,
      minTimePickerVisible,
      maxTimePickerVisible,
      handleMinTimeClose,
      handleMaxTimeClose,
      handleShortcutClick,
      rangeState,
      minDate,
      maxDate,
      handleRangePick,
      onSelect,
      handleChangeRange,
      btnDisabled,
      enableYearArrow,
      enableMonthArrow,
      rightPrevMonth,
      rightPrevYear,
      rightNextMonth,
      rightNextYear,
      leftPrevMonth,
      leftPrevYear,
      leftNextMonth,
      leftNextYear,
      hasShortcuts,
      leftLabel,
      rightLabel,
      leftDate,
      rightDate,
      showTime,
      t,
      minVisibleDate,
      maxVisibleDate,
      minVisibleTime,
      maxVisibleTime,
      arrowControl,
      handleDateInput,
      handleDateChange,
      handleTimeInput,
      handleTimeChange,
      handleMinTimePick,
      handleMaxTimePick,
      handleClear,
      handleConfirm,
      timeFormat,
      clearable
    };
  }
});
const _hoisted_1$t = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$e = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$9 = ["onClick"];
const _hoisted_4$6 = { class: "el-picker-panel__body" };
const _hoisted_5$6 = {
  key: 0,
  class: "el-date-range-picker__time-header"
};
const _hoisted_6$4 = { class: "el-date-range-picker__editors-wrap" };
const _hoisted_7$2 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_8$2 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_9$2 = { class: "el-date-range-picker__editors-wrap is-right" };
const _hoisted_10$1 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_11 = { class: "el-date-range-picker__time-picker-wrap" };
const _hoisted_12 = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_13 = { class: "el-date-range-picker__header" };
const _hoisted_14 = ["disabled"];
const _hoisted_15 = ["disabled"];
const _hoisted_16 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_17 = { class: "el-date-range-picker__header" };
const _hoisted_18 = ["disabled"];
const _hoisted_19 = ["disabled"];
const _hoisted_20 = {
  key: 0,
  class: "el-picker-panel__footer"
};
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_time_pick_panel = resolveComponent("time-pick-panel");
  const _component_arrow_right = resolveComponent("arrow-right");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_d_arrow_left = resolveComponent("d-arrow-left");
  const _component_arrow_left = resolveComponent("arrow-left");
  const _component_d_arrow_right = resolveComponent("d-arrow-right");
  const _component_date_table = resolveComponent("date-table");
  const _component_el_button = resolveComponent("el-button");
  const _directive_clickoutside = resolveDirective("clickoutside");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-range-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts,
        "has-time": _ctx.showTime
      }
    ]])
  }, [
    createElementVNode("div", _hoisted_1$t, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$e, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key2) => {
          return openBlock(), createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$9);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$6, [
        _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
          createElementVNode("span", _hoisted_6$4, [
            createElementVNode("span", _hoisted_7$2, [
              createVNode$1(_component_el_input, {
                size: "small",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startDate"),
                class: "el-date-range-picker__editor",
                "model-value": _ctx.minVisibleDate,
                onInput: _cache[0] || (_cache[0] = (val) => _ctx.handleDateInput(val, "min")),
                onChange: _cache[1] || (_cache[1] = (val) => _ctx.handleDateChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"])
            ]),
            withDirectives((openBlock(), createElementBlock("span", _hoisted_8$2, [
              createVNode$1(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.startTime"),
                "model-value": _ctx.minVisibleTime,
                onFocus: _cache[2] || (_cache[2] = ($event) => _ctx.minTimePickerVisible = true),
                onInput: _cache[3] || (_cache[3] = (val) => _ctx.handleTimeInput(val, "min")),
                onChange: _cache[4] || (_cache[4] = (val) => _ctx.handleTimeChange(val, "min"))
              }, null, 8, ["disabled", "placeholder", "model-value"]),
              createVNode$1(_component_time_pick_panel, {
                visible: _ctx.minTimePickerVisible,
                format: _ctx.timeFormat,
                "datetime-role": "start",
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.leftDate,
                onPick: _ctx.handleMinTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ])), [
              [_directive_clickoutside, _ctx.handleMinTimeClose]
            ])
          ]),
          createElementVNode("span", null, [
            createVNode$1(_component_el_icon, null, {
              default: withCtx(() => [
                createVNode$1(_component_arrow_right)
              ]),
              _: 1
            })
          ]),
          createElementVNode("span", _hoisted_9$2, [
            createElementVNode("span", _hoisted_10$1, [
              createVNode$1(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endDate"),
                "model-value": _ctx.maxVisibleDate,
                readonly: !_ctx.minDate,
                onInput: _cache[5] || (_cache[5] = (val) => _ctx.handleDateInput(val, "max")),
                onChange: _cache[6] || (_cache[6] = (val) => _ctx.handleDateChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"])
            ]),
            withDirectives((openBlock(), createElementBlock("span", _hoisted_11, [
              createVNode$1(_component_el_input, {
                size: "small",
                class: "el-date-range-picker__editor",
                disabled: _ctx.rangeState.selecting,
                placeholder: _ctx.t("el.datepicker.endTime"),
                "model-value": _ctx.maxVisibleTime,
                readonly: !_ctx.minDate,
                onFocus: _cache[7] || (_cache[7] = ($event) => _ctx.minDate && (_ctx.maxTimePickerVisible = true)),
                onInput: _cache[8] || (_cache[8] = (val) => _ctx.handleTimeInput(val, "max")),
                onChange: _cache[9] || (_cache[9] = (val) => _ctx.handleTimeChange(val, "max"))
              }, null, 8, ["disabled", "placeholder", "model-value", "readonly"]),
              createVNode$1(_component_time_pick_panel, {
                "datetime-role": "end",
                visible: _ctx.maxTimePickerVisible,
                format: _ctx.timeFormat,
                "time-arrow-control": _ctx.arrowControl,
                "parsed-value": _ctx.rightDate,
                onPick: _ctx.handleMaxTimePick
              }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value", "onPick"])
            ])), [
              [_directive_clickoutside, _ctx.handleMaxTimeClose]
            ])
          ])
        ])) : createCommentVNode("v-if", true),
        createElementVNode("div", _hoisted_12, [
          createElementVNode("div", _hoisted_13, [
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-left",
              onClick: _cache[10] || (_cache[10] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_left)
                ]),
                _: 1
              })
            ]),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn arrow-left",
              onClick: _cache[11] || (_cache[11] = (...args) => _ctx.leftPrevMonth && _ctx.leftPrevMonth(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_arrow_left)
                ]),
                _: 1
              })
            ]),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-right"]),
              onClick: _cache[12] || (_cache[12] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_right)
                ]),
                _: 1
              })
            ], 10, _hoisted_14)) : createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn arrow-right"]),
              onClick: _cache[13] || (_cache[13] = (...args) => _ctx.leftNextMonth && _ctx.leftNextMonth(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_arrow_right)
                ]),
                _: 1
              })
            ], 10, _hoisted_15)) : createCommentVNode("v-if", true),
            createElementVNode("div", null, toDisplayString(_ctx.leftLabel), 1)
          ]),
          createVNode$1(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ]),
        createElementVNode("div", _hoisted_16, [
          createElementVNode("div", _hoisted_17, [
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-left"]),
              onClick: _cache[14] || (_cache[14] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_left)
                ]),
                _: 1
              })
            ], 10, _hoisted_18)) : createCommentVNode("v-if", true),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              disabled: !_ctx.enableMonthArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableMonthArrow }, "el-picker-panel__icon-btn arrow-left"]),
              onClick: _cache[15] || (_cache[15] = (...args) => _ctx.rightPrevMonth && _ctx.rightPrevMonth(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_arrow_left)
                ]),
                _: 1
              })
            ], 10, _hoisted_19)) : createCommentVNode("v-if", true),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-right",
              onClick: _cache[16] || (_cache[16] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_right)
                ]),
                _: 1
              })
            ]),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn arrow-right",
              onClick: _cache[17] || (_cache[17] = (...args) => _ctx.rightNextMonth && _ctx.rightNextMonth(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_arrow_right)
                ]),
                _: 1
              })
            ]),
            createElementVNode("div", null, toDisplayString(_ctx.rightLabel), 1)
          ]),
          createVNode$1(_component_date_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            "cell-class-name": _ctx.cellClassName,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ]),
    _ctx.showTime ? (openBlock(), createElementBlock("div", _hoisted_20, [
      _ctx.clearable ? (openBlock(), createBlock(_component_el_button, {
        key: 0,
        size: "small",
        type: "text",
        class: "el-picker-panel__link-btn",
        onClick: _ctx.handleClear
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.clear")), 1)
        ]),
        _: 1
      }, 8, ["onClick"])) : createCommentVNode("v-if", true),
      createVNode$1(_component_el_button, {
        plain: "",
        size: "small",
        class: "el-picker-panel__link-btn",
        disabled: _ctx.btnDisabled,
        onClick: _cache[18] || (_cache[18] = ($event) => _ctx.handleConfirm(false))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.t("el.datepicker.confirm")), 1)
        ]),
        _: 1
      }, 8, ["disabled"])
    ])) : createCommentVNode("v-if", true)
  ], 2);
}
var DateRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$g], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);
const _sfc_main$z = defineComponent({
  components: { MonthTable, ElIcon, DArrowLeft: dArrowLeft, DArrowRight: dArrowRight },
  props: {
    unlinkPanels: Boolean,
    parsedValue: {
      type: Array
    }
  },
  emits: ["pick", "set-picker-option"],
  setup(props2, ctx) {
    const { t, lang } = useLocale();
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, "year"));
    const hasShortcuts = computed(() => !!shortcuts.length);
    const handleShortcutClick = (shortcut) => {
      const shortcutValues = typeof shortcut.value === "function" ? shortcut.value() : shortcut.value;
      if (shortcutValues) {
        ctx.emit("pick", [
          dayjs(shortcutValues[0]).locale(lang.value),
          dayjs(shortcutValues[1]).locale(lang.value)
        ]);
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick(ctx);
      }
    };
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props2.unlinkPanels) {
        rightDate.value = rightDate.value.subtract(1, "year");
      }
    };
    const rightNextYear = () => {
      if (!props2.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
      }
      rightDate.value = rightDate.value.add(1, "year");
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
    };
    const leftLabel = computed(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const rightLabel = computed(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
    });
    const leftYear = computed(() => {
      return leftDate.value.year();
    });
    const rightYear = computed(() => {
      return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
    });
    const enableYearArrow = computed(() => {
      return props2.unlinkPanels && rightYear.value > leftYear.value + 1;
    });
    const minDate = ref(null);
    const maxDate = ref(null);
    const rangeState = ref({
      endDate: null,
      selecting: false
    });
    const handleChangeRange = (val) => {
      rangeState.value = val;
    };
    const handleRangePick = (val, close2 = true) => {
      const minDate_ = val.minDate;
      const maxDate_ = val.maxDate;
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2)
        return;
      handleConfirm();
    };
    const isValidValue = (value) => {
      return Array.isArray(value) && value && value[0] && value[1] && value[0].valueOf() <= value[1].valueOf();
    };
    const handleConfirm = (visible = false) => {
      if (isValidValue([minDate.value, maxDate.value])) {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      }
    };
    const onSelect = (selecting) => {
      rangeState.value.selecting = selecting;
      if (!selecting) {
        rangeState.value.endDate = null;
      }
    };
    const formatToString = (value) => {
      return value.map((_2) => _2.format(format2));
    };
    const getDefaultValue = () => {
      let start2;
      if (Array.isArray(defaultValue.value)) {
        const left2 = dayjs(defaultValue.value[0]);
        let right2 = dayjs(defaultValue.value[1]);
        if (!props2.unlinkPanels) {
          right2 = left2.add(1, "year");
        }
        return [left2, right2];
      } else if (defaultValue.value) {
        start2 = dayjs(defaultValue.value);
      } else {
        start2 = dayjs();
      }
      start2 = start2.locale(lang.value);
      return [start2, start2.add(1, "year")];
    };
    ctx.emit("set-picker-option", ["formatToString", formatToString]);
    const pickerBase = inject("EP_PICKER_BASE");
    const { shortcuts, disabledDate, format: format2 } = pickerBase.props;
    const defaultValue = toRef(pickerBase.props, "defaultValue");
    watch$1(() => defaultValue.value, (val) => {
      if (val) {
        const defaultArr = getDefaultValue();
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    watch$1(() => props2.parsedValue, (newVal) => {
      if (newVal && newVal.length === 2) {
        minDate.value = newVal[0];
        maxDate.value = newVal[1];
        leftDate.value = minDate.value;
        if (props2.unlinkPanels && maxDate.value) {
          const minDateYear = minDate.value.year();
          const maxDateYear = maxDate.value.year();
          rightDate.value = minDateYear === maxDateYear ? maxDate.value.add(1, "year") : maxDate.value;
        } else {
          rightDate.value = leftDate.value.add(1, "year");
        }
      } else {
        const defaultArr = getDefaultValue();
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = defaultArr[0];
        rightDate.value = defaultArr[1];
      }
    }, { immediate: true });
    return {
      shortcuts,
      disabledDate,
      onSelect,
      handleRangePick,
      rangeState,
      handleChangeRange,
      minDate,
      maxDate,
      enableYearArrow,
      leftLabel,
      rightLabel,
      leftNextYear,
      leftPrevYear,
      rightNextYear,
      rightPrevYear,
      t,
      leftDate,
      rightDate,
      hasShortcuts,
      handleShortcutClick
    };
  }
});
const _hoisted_1$s = { class: "el-picker-panel__body-wrapper" };
const _hoisted_2$d = {
  key: 0,
  class: "el-picker-panel__sidebar"
};
const _hoisted_3$8 = ["onClick"];
const _hoisted_4$5 = { class: "el-picker-panel__body" };
const _hoisted_5$5 = { class: "el-picker-panel__content el-date-range-picker__content is-left" };
const _hoisted_6$3 = { class: "el-date-range-picker__header" };
const _hoisted_7$1 = ["disabled"];
const _hoisted_8$1 = { class: "el-picker-panel__content el-date-range-picker__content is-right" };
const _hoisted_9$1 = { class: "el-date-range-picker__header" };
const _hoisted_10 = ["disabled"];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_d_arrow_left = resolveComponent("d-arrow-left");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_d_arrow_right = resolveComponent("d-arrow-right");
  const _component_month_table = resolveComponent("month-table");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["el-picker-panel el-date-range-picker", [
      {
        "has-sidebar": _ctx.$slots.sidebar || _ctx.hasShortcuts
      }
    ]])
  }, [
    createElementVNode("div", _hoisted_1$s, [
      renderSlot(_ctx.$slots, "sidebar", { class: "el-picker-panel__sidebar" }),
      _ctx.hasShortcuts ? (openBlock(), createElementBlock("div", _hoisted_2$d, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (shortcut, key2) => {
          return openBlock(), createElementBlock("button", {
            key: key2,
            type: "button",
            class: "el-picker-panel__shortcut",
            onClick: ($event) => _ctx.handleShortcutClick(shortcut)
          }, toDisplayString(shortcut.text), 9, _hoisted_3$8);
        }), 128))
      ])) : createCommentVNode("v-if", true),
      createElementVNode("div", _hoisted_4$5, [
        createElementVNode("div", _hoisted_5$5, [
          createElementVNode("div", _hoisted_6$3, [
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-left",
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.leftPrevYear && _ctx.leftPrevYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_left)
                ]),
                _: 1
              })
            ]),
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-right"]),
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.leftNextYear && _ctx.leftNextYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_right)
                ]),
                _: 1
              })
            ], 10, _hoisted_7$1)) : createCommentVNode("v-if", true),
            createElementVNode("div", null, toDisplayString(_ctx.leftLabel), 1)
          ]),
          createVNode$1(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.leftDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ]),
        createElementVNode("div", _hoisted_8$1, [
          createElementVNode("div", _hoisted_9$1, [
            _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              disabled: !_ctx.enableYearArrow,
              class: normalizeClass([{ "is-disabled": !_ctx.enableYearArrow }, "el-picker-panel__icon-btn d-arrow-left"]),
              onClick: _cache[2] || (_cache[2] = (...args) => _ctx.rightPrevYear && _ctx.rightPrevYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_left)
                ]),
                _: 1
              })
            ], 10, _hoisted_10)) : createCommentVNode("v-if", true),
            createElementVNode("button", {
              type: "button",
              class: "el-picker-panel__icon-btn d-arrow-right",
              onClick: _cache[3] || (_cache[3] = (...args) => _ctx.rightNextYear && _ctx.rightNextYear(...args))
            }, [
              createVNode$1(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode$1(_component_d_arrow_right)
                ]),
                _: 1
              })
            ]),
            createElementVNode("div", null, toDisplayString(_ctx.rightLabel), 1)
          ]),
          createVNode$1(_component_month_table, {
            "selection-mode": "range",
            date: _ctx.rightDate,
            "min-date": _ctx.minDate,
            "max-date": _ctx.maxDate,
            "range-state": _ctx.rangeState,
            "disabled-date": _ctx.disabledDate,
            onChangerange: _ctx.handleChangeRange,
            onPick: _ctx.handleRangePick,
            onSelect: _ctx.onSelect
          }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onPick", "onSelect"])
        ])
      ])
    ])
  ], 2);
}
var MonthRangePickPanel = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$f], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);
dayjs.extend(localeData);
dayjs.extend(advancedFormat);
dayjs.extend(customParseFormat);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(dayOfYear);
dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);
const getPanel = function(type) {
  if (type === "daterange" || type === "datetimerange") {
    return DateRangePickPanel;
  } else if (type === "monthrange") {
    return MonthRangePickPanel;
  }
  return DatePickPanel;
};
var DatePicker = defineComponent({
  name: "ElDatePicker",
  install: null,
  props: __spreadProps(__spreadValues({}, timePickerDefaultProps), {
    type: {
      type: String,
      default: "date"
    }
  }),
  emits: ["update:modelValue"],
  setup(props2, ctx) {
    provide("ElPopperOptions", props2.popperOptions);
    provide(ROOT_PICKER_INJECTION_KEY, {
      ctx
    });
    const commonPicker = ref(null);
    const refProps = __spreadProps(__spreadValues({}, props2), {
      focus: (focusStartInput = true) => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.focus(focusStartInput);
      }
    });
    ctx.expose(refProps);
    return () => {
      var _a2;
      const format2 = (_a2 = props2.format) != null ? _a2 : DEFAULT_FORMATS_DATEPICKER[props2.type] || DEFAULT_FORMATS_DATE;
      return h$1(CommonPicker, __spreadProps(__spreadValues({}, props2), {
        format: format2,
        type: props2.type,
        ref: commonPicker,
        "onUpdate:modelValue": (value) => ctx.emit("update:modelValue", value)
      }), {
        default: (scopedProps) => h$1(getPanel(props2.type), scopedProps),
        "range-separator": () => renderSlot(ctx.slots, "range-separator")
      });
    };
  }
});
const _DatePicker = DatePicker;
_DatePicker.install = (app) => {
  app.component(_DatePicker.name, _DatePicker);
};
const ElDatePicker = _DatePicker;
const overlayProps = buildProps({
  mask: {
    type: Boolean,
    default: true
  },
  customMaskEvent: {
    type: Boolean,
    default: false
  },
  overlayClass: {
    type: definePropType([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: definePropType([String, Number])
  }
});
const overlayEmits = {
  click: (evt) => evt instanceof MouseEvent
};
var Overlay = defineComponent({
  name: "ElOverlay",
  props: overlayProps,
  emits: overlayEmits,
  setup(props2, { slots, emit }) {
    const ns = useNamespace("overlay");
    const onMaskClick = (e2) => {
      emit("click", e2);
    };
    const { onClick: onClick2, onMousedown, onMouseup } = useSameTarget(props2.customMaskEvent ? void 0 : onMaskClick);
    return () => {
      return props2.mask ? createVNode$1("div", {
        class: [ns.b(), props2.overlayClass],
        style: {
          zIndex: props2.zIndex
        },
        onClick: onClick2,
        onMousedown,
        onMouseup
      }, [renderSlot(slots, "default")], PatchFlags.STYLE | PatchFlags.CLASS | PatchFlags.PROPS, ["onClick", "onMouseup", "onMousedown"]) : h$1("div", {
        class: props2.overlayClass,
        style: {
          zIndex: props2.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [renderSlot(slots, "default")]);
    };
  }
});
const ElOverlay = Overlay;
const dialogContentProps = buildProps({
  center: {
    type: Boolean,
    default: false
  },
  closeIcon: {
    type: iconPropType,
    default: ""
  },
  customClass: {
    type: String,
    default: ""
  },
  draggable: {
    type: Boolean,
    default: false
  },
  fullscreen: {
    type: Boolean,
    default: false
  },
  showClose: {
    type: Boolean,
    default: true
  },
  title: {
    type: String,
    default: ""
  }
});
const dialogContentEmits = {
  close: () => true
};
const _hoisted_1$r = ["aria-label"];
const __default__$5 = { name: "ElDialogContent" };
const _sfc_main$y = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$5), {
  props: dialogContentProps,
  emits: dialogContentEmits,
  setup(__props) {
    const { Close } = CloseComponents;
    const { dialogRef, headerRef, ns, style } = inject(dialogInjectionKey);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "dialogRef",
        ref: dialogRef,
        class: normalizeClass([
          unref(ns).b(),
          unref(ns).is("fullscreen", _ctx.fullscreen),
          unref(ns).is("draggable", _ctx.draggable),
          { [unref(ns).m("center")]: _ctx.center },
          _ctx.customClass
        ]),
        "aria-modal": "true",
        role: "dialog",
        "aria-label": _ctx.title || "dialog",
        style: normalizeStyle$1(unref(style)),
        onClick: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["stop"]))
      }, [
        createElementVNode("div", {
          ref_key: "headerRef",
          ref: headerRef,
          class: normalizeClass(unref(ns).e("header"))
        }, [
          renderSlot(_ctx.$slots, "title", {}, () => [
            createElementVNode("span", {
              class: normalizeClass(unref(ns).e("title"))
            }, toDisplayString(_ctx.title), 3)
          ])
        ], 2),
        createElementVNode("div", {
          class: normalizeClass(unref(ns).e("body"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2),
        _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(ns).e("footer"))
        }, [
          renderSlot(_ctx.$slots, "footer")
        ], 2)) : createCommentVNode("v-if", true),
        _ctx.showClose ? (openBlock(), createElementBlock("button", {
          key: 1,
          "aria-label": "close",
          class: normalizeClass(unref(ns).e("headerbtn")),
          type: "button",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
        }, [
          createVNode$1(unref(ElIcon), {
            class: normalizeClass(unref(ns).e("close"))
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.closeIcon || unref(Close))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 2)) : createCommentVNode("v-if", true)
      ], 14, _hoisted_1$r);
    };
  }
}));
var ElDialogContent = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
const dialogProps = buildProps(__spreadProps(__spreadValues({}, dialogContentProps), {
  appendToBody: {
    type: Boolean,
    default: false
  },
  beforeClose: {
    type: definePropType(Function)
  },
  destroyOnClose: {
    type: Boolean,
    default: false
  },
  closeOnClickModal: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  modal: {
    type: Boolean,
    default: true
  },
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: {
    type: Boolean,
    required: true
  },
  modalClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: {
    type: Boolean,
    default: false
  }
}));
const dialogEmits = {
  open: () => true,
  opened: () => true,
  close: () => true,
  closed: () => true,
  [UPDATE_MODEL_EVENT]: (value) => isBoolean(value),
  openAutoFocus: () => true,
  closeAutoFocus: () => true
};
const useDialog = (props2, targetRef) => {
  const instance = getCurrentInstance();
  const emit = instance.emit;
  const { nextZIndex } = useZIndex();
  let lastPosition = "";
  const visible = ref(false);
  const closed = ref(false);
  const rendered = ref(false);
  const zIndex2 = ref(props2.zIndex || nextZIndex());
  let openTimer = void 0;
  let closeTimer = void 0;
  const normalizeWidth = computed(() => isNumber(props2.width) ? `${props2.width}px` : props2.width);
  const style = computed(() => {
    const style2 = {};
    const varPrefix = `--el-dialog`;
    if (!props2.fullscreen) {
      if (props2.top) {
        style2[`${varPrefix}-margin-top`] = props2.top;
      }
      if (props2.width) {
        style2[`${varPrefix}-width`] = normalizeWidth.value;
      }
    }
    return style2;
  });
  function afterEnter() {
    emit("opened");
  }
  function afterLeave() {
    emit("closed");
    emit(UPDATE_MODEL_EVENT, false);
    if (props2.destroyOnClose) {
      rendered.value = false;
    }
  }
  function beforeLeave() {
    emit("close");
  }
  function open2() {
    closeTimer == null ? void 0 : closeTimer();
    openTimer == null ? void 0 : openTimer();
    if (props2.openDelay && props2.openDelay > 0) {
      ({ stop: openTimer } = useTimeoutFn(() => doOpen(), props2.openDelay));
    } else {
      doOpen();
    }
  }
  function close2() {
    openTimer == null ? void 0 : openTimer();
    closeTimer == null ? void 0 : closeTimer();
    if (props2.closeDelay && props2.closeDelay > 0) {
      ({ stop: closeTimer } = useTimeoutFn(() => doClose(), props2.closeDelay));
    } else {
      doClose();
    }
  }
  function handleClose() {
    function hide2(shouldCancel) {
      if (shouldCancel)
        return;
      closed.value = true;
      visible.value = false;
    }
    if (props2.beforeClose) {
      props2.beforeClose(hide2);
    } else {
      close2();
    }
  }
  function onModalClick() {
    if (props2.closeOnClickModal) {
      handleClose();
    }
  }
  function doOpen() {
    if (!isClient)
      return;
    visible.value = true;
  }
  function doClose() {
    visible.value = false;
  }
  if (props2.lockScroll) {
    useLockscreen(visible);
  }
  if (props2.closeOnPressEscape) {
    useModal({
      handleClose
    }, visible);
  }
  useRestoreActive(visible);
  watch$1(() => props2.modelValue, (val) => {
    if (val) {
      closed.value = false;
      open2();
      rendered.value = true;
      emit("open");
      zIndex2.value = props2.zIndex ? zIndex2.value++ : nextZIndex();
      nextTick$1(() => {
        if (targetRef.value) {
          targetRef.value.scrollTop = 0;
        }
      });
    } else {
      if (visible.value) {
        close2();
      }
    }
  });
  watch$1(() => props2.fullscreen, (val) => {
    if (!targetRef.value)
      return;
    if (val) {
      lastPosition = targetRef.value.style.transform;
      targetRef.value.style.transform = "";
    } else {
      targetRef.value.style.transform = lastPosition;
    }
  });
  onMounted(() => {
    if (props2.modelValue) {
      visible.value = true;
      rendered.value = true;
      open2();
    }
  });
  return {
    afterEnter,
    afterLeave,
    beforeLeave,
    handleClose,
    onModalClick,
    close: close2,
    doClose,
    closed,
    style,
    rendered,
    visible,
    zIndex: zIndex2
  };
};
const __default__$4 = {
  name: "ElDialog"
};
const _sfc_main$x = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$4), {
  props: dialogProps,
  emits: dialogEmits,
  setup(__props, { expose }) {
    const props2 = __props;
    const ns = useNamespace("dialog");
    const dialogRef = ref();
    const headerRef = ref();
    const {
      visible,
      style,
      rendered,
      zIndex: zIndex2,
      afterEnter,
      afterLeave,
      beforeLeave,
      handleClose,
      onModalClick
    } = useDialog(props2, dialogRef);
    provide(dialogInjectionKey, {
      dialogRef,
      headerRef,
      ns,
      rendered,
      style
    });
    const overlayEvent = useSameTarget(onModalClick);
    const draggable = computed(() => props2.draggable && !props2.fullscreen);
    useDraggable(dialogRef, headerRef, draggable);
    expose({
      visible
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, {
        to: "body",
        disabled: !_ctx.appendToBody
      }, [
        createVNode$1(Transition, {
          name: "dialog-fade",
          onAfterEnter: unref(afterEnter),
          onAfterLeave: unref(afterLeave),
          onBeforeLeave: unref(beforeLeave)
        }, {
          default: withCtx(() => [
            withDirectives(createVNode$1(unref(ElOverlay), {
              "custom-mask-event": "",
              mask: _ctx.modal,
              "overlay-class": _ctx.modalClass,
              "z-index": unref(zIndex2)
            }, {
              default: withCtx(() => [
                createElementVNode("div", {
                  class: normalizeClass(`${unref(ns).namespace.value}-overlay-dialog`),
                  onClick: _cache[0] || (_cache[0] = (...args) => unref(overlayEvent).onClick && unref(overlayEvent).onClick(...args)),
                  onMousedown: _cache[1] || (_cache[1] = (...args) => unref(overlayEvent).onMousedown && unref(overlayEvent).onMousedown(...args)),
                  onMouseup: _cache[2] || (_cache[2] = (...args) => unref(overlayEvent).onMouseup && unref(overlayEvent).onMouseup(...args))
                }, [
                  unref(rendered) ? (openBlock(), createBlock(ElDialogContent, {
                    key: 0,
                    "custom-class": _ctx.customClass,
                    center: _ctx.center,
                    "close-icon": _ctx.closeIcon,
                    draggable: unref(draggable),
                    fullscreen: _ctx.fullscreen,
                    "show-close": _ctx.showClose,
                    style: normalizeStyle$1(unref(style)),
                    title: _ctx.title,
                    onClose: unref(handleClose)
                  }, createSlots({
                    title: withCtx(() => [
                      renderSlot(_ctx.$slots, "title")
                    ]),
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "default")
                    ]),
                    _: 2
                  }, [
                    _ctx.$slots.footer ? {
                      name: "footer",
                      fn: withCtx(() => [
                        renderSlot(_ctx.$slots, "footer")
                      ])
                    } : void 0
                  ]), 1032, ["custom-class", "center", "close-icon", "draggable", "fullscreen", "show-close", "style", "title", "onClose"])) : createCommentVNode("v-if", true)
                ], 34)
              ]),
              _: 3
            }, 8, ["mask", "overlay-class", "z-index"]), [
              [vShow, unref(visible)]
            ])
          ]),
          _: 3
        }, 8, ["onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ], 8, ["disabled"]);
    };
  }
}));
var Dialog$1 = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
const ElDialog = withInstall(Dialog$1);
const inputNumberProps = buildProps({
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: {
    type: Boolean,
    default: false
  },
  max: {
    type: Number,
    default: Number.POSITIVE_INFINITY
  },
  min: {
    type: Number,
    default: Number.NEGATIVE_INFINITY
  },
  modelValue: {
    type: Number
  },
  disabled: {
    type: Boolean,
    default: false
  },
  size: {
    type: String,
    values: componentSizes
  },
  controls: {
    type: Boolean,
    default: true
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  name: String,
  label: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (val) => val >= 0 && val === Number.parseInt(`${val}`, 10)
  }
});
const inputNumberEmits = {
  change: (prev2, cur) => prev2 !== cur,
  blur: (e2) => e2 instanceof FocusEvent,
  focus: (e2) => e2 instanceof FocusEvent,
  input: (val) => isNumber(val),
  "update:modelValue": (val) => isNumber(val) || val === void 0
};
const _sfc_main$w = defineComponent({
  name: "ElInputNumber",
  components: {
    ElInput,
    ElIcon,
    ArrowUp: arrowUp,
    ArrowDown: arrowDown,
    Plus: plus,
    Minus: minus
  },
  directives: {
    RepeatClick
  },
  props: inputNumberProps,
  emits: inputNumberEmits,
  setup(props2, { emit }) {
    const input = ref();
    const data = reactive({
      currentValue: props2.modelValue,
      userInput: null
    });
    const { formItem } = useFormItem();
    const ns = useNamespace("input-number");
    const minDisabled = computed(() => ensurePrecision(props2.modelValue, -1) < props2.min);
    const maxDisabled = computed(() => ensurePrecision(props2.modelValue) > props2.max);
    const numPrecision = computed(() => {
      const stepPrecision = getPrecision2(props2.step);
      if (!isUndefined(props2.precision)) {
        if (stepPrecision > props2.precision)
          ;
        return props2.precision;
      } else {
        return Math.max(getPrecision2(props2.modelValue), stepPrecision);
      }
    });
    const controlsAtRight = computed(() => {
      return props2.controls && props2.controlsPosition === "right";
    });
    const inputNumberSize = useSize();
    const inputNumberDisabled = useDisabled$1();
    const displayValue = computed(() => {
      if (data.userInput !== null) {
        return data.userInput;
      }
      let currentValue = data.currentValue;
      if (isNumber(currentValue)) {
        if (Number.isNaN(currentValue))
          return "";
        if (!isUndefined(props2.precision)) {
          currentValue = currentValue.toFixed(props2.precision);
        }
      }
      return currentValue;
    });
    const toPrecision = (num, pre) => {
      if (isUndefined(pre))
        pre = numPrecision.value;
      return Number.parseFloat(`${Math.round(num * 10 ** pre) / 10 ** pre}`);
    };
    const getPrecision2 = (value) => {
      if (isUndefined(value))
        return 0;
      const valueString = value.toString();
      const dotPosition = valueString.indexOf(".");
      let precision = 0;
      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }
      return precision;
    };
    const ensurePrecision = (val, coefficient = 1) => {
      if (!isNumber(val))
        return data.currentValue;
      val = isNumber(val) ? val : Number.NaN;
      return toPrecision(val + props2.step * coefficient);
    };
    const increase = () => {
      if (inputNumberDisabled.value || maxDisabled.value)
        return;
      const value = props2.modelValue || 0;
      const newVal = ensurePrecision(value);
      setCurrentValue(newVal);
    };
    const decrease = () => {
      if (inputNumberDisabled.value || minDisabled.value)
        return;
      const value = props2.modelValue || 0;
      const newVal = ensurePrecision(value, -1);
      setCurrentValue(newVal);
    };
    const verifyValue = (value, update2) => {
      const { max: max3, min: min3, step, precision, stepStrictly } = props2;
      let newVal = Number(value);
      if (value === null) {
        newVal = Number.NaN;
      }
      if (!Number.isNaN(newVal)) {
        if (stepStrictly) {
          newVal = Math.round(newVal / step) * step;
        }
        if (!isUndefined(precision)) {
          newVal = toPrecision(newVal, precision);
        }
        if (newVal > max3 || newVal < min3) {
          newVal = newVal > max3 ? max3 : min3;
          update2 && emit("update:modelValue", newVal);
        }
      }
      return newVal;
    };
    const setCurrentValue = (value) => {
      var _a2;
      const oldVal = data.currentValue;
      let newVal = verifyValue(value);
      if (oldVal === newVal)
        return;
      if (Number.isNaN(newVal)) {
        newVal = void 0;
      }
      data.userInput = null;
      emit("update:modelValue", newVal);
      emit("input", newVal);
      emit("change", newVal, oldVal);
      (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
      data.currentValue = newVal;
    };
    const handleInput = (value) => {
      return data.userInput = value;
    };
    const handleInputChange = (value) => {
      const newVal = value !== "" ? Number(value) : "";
      if (isNumber(newVal) && !Number.isNaN(newVal) || value === "") {
        setCurrentValue(newVal);
      }
      data.userInput = null;
    };
    const focus = () => {
      var _a2, _b2;
      (_b2 = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b2.call(_a2);
    };
    const blur = () => {
      var _a2, _b2;
      (_b2 = (_a2 = input.value) == null ? void 0 : _a2.blur) == null ? void 0 : _b2.call(_a2);
    };
    const handleFocus = (event) => {
      emit("focus", event);
    };
    const handleBlur = (event) => {
      var _a2;
      emit("blur", event);
      (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
    };
    watch$1(() => props2.modelValue, (value) => {
      const newVal = verifyValue(value, true);
      data.currentValue = newVal;
      data.userInput = null;
    }, { immediate: true });
    onMounted(() => {
      var _a2;
      const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
      innerInput.setAttribute("role", "spinbutton");
      innerInput.setAttribute("aria-valuemax", String(props2.max));
      innerInput.setAttribute("aria-valuemin", String(props2.min));
      innerInput.setAttribute("aria-valuenow", String(data.currentValue));
      innerInput.setAttribute("aria-disabled", String(inputNumberDisabled.value));
      if (!isNumber(props2.modelValue)) {
        let val = Number(props2.modelValue);
        if (Number.isNaN(val)) {
          val = void 0;
        }
        emit("update:modelValue", val);
      }
    });
    onUpdated(() => {
      var _a2;
      const innerInput = (_a2 = input.value) == null ? void 0 : _a2.input;
      innerInput == null ? void 0 : innerInput.setAttribute("aria-valuenow", data.currentValue);
    });
    return {
      input,
      displayValue,
      handleInput,
      handleInputChange,
      controlsAtRight,
      decrease,
      increase,
      inputNumberSize,
      inputNumberDisabled,
      maxDisabled,
      minDisabled,
      focus,
      blur,
      handleFocus,
      handleBlur,
      ns
    };
  }
});
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_down = resolveComponent("arrow-down");
  const _component_minus = resolveComponent("minus");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_arrow_up = resolveComponent("arrow-up");
  const _component_plus = resolveComponent("plus");
  const _component_el_input = resolveComponent("el-input");
  const _directive_repeat_click = resolveDirective("repeat-click");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      _ctx.ns.b(),
      _ctx.ns.m(_ctx.inputNumberSize),
      _ctx.ns.is("disabled", _ctx.inputNumberDisabled),
      _ctx.ns.is("without-controls", !_ctx.controls),
      _ctx.ns.is("controls-right", _ctx.controlsAtRight)
    ]),
    onDragstart: _cache[2] || (_cache[2] = withModifiers(() => {
    }, ["prevent"]))
  }, [
    _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
      key: 0,
      role: "button",
      class: normalizeClass([_ctx.ns.e("decrease"), _ctx.ns.is("disabled", _ctx.minDisabled)]),
      onKeydown: _cache[0] || (_cache[0] = withKeys((...args) => _ctx.decrease && _ctx.decrease(...args), ["enter"]))
    }, [
      createVNode$1(_component_el_icon, null, {
        default: withCtx(() => [
          _ctx.controlsAtRight ? (openBlock(), createBlock(_component_arrow_down, { key: 0 })) : (openBlock(), createBlock(_component_minus, { key: 1 }))
        ]),
        _: 1
      })
    ], 34)), [
      [_directive_repeat_click, _ctx.decrease]
    ]) : createCommentVNode("v-if", true),
    _ctx.controls ? withDirectives((openBlock(), createElementBlock("span", {
      key: 1,
      role: "button",
      class: normalizeClass([_ctx.ns.e("increase"), _ctx.ns.is("disabled", _ctx.maxDisabled)]),
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.increase && _ctx.increase(...args), ["enter"]))
    }, [
      createVNode$1(_component_el_icon, null, {
        default: withCtx(() => [
          _ctx.controlsAtRight ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_plus, { key: 1 }))
        ]),
        _: 1
      })
    ], 34)), [
      [_directive_repeat_click, _ctx.increase]
    ]) : createCommentVNode("v-if", true),
    createVNode$1(_component_el_input, {
      ref: "input",
      type: "number",
      step: _ctx.step,
      "model-value": _ctx.displayValue,
      placeholder: _ctx.placeholder,
      disabled: _ctx.inputNumberDisabled,
      size: _ctx.inputNumberSize,
      max: _ctx.max,
      min: _ctx.min,
      name: _ctx.name,
      label: _ctx.label,
      "validate-event": false,
      onKeydown: [
        withKeys(withModifiers(_ctx.increase, ["prevent"]), ["up"]),
        withKeys(withModifiers(_ctx.decrease, ["prevent"]), ["down"])
      ],
      onBlur: _ctx.handleBlur,
      onFocus: _ctx.handleFocus,
      onInput: _ctx.handleInput,
      onChange: _ctx.handleInputChange
    }, null, 8, ["step", "model-value", "placeholder", "disabled", "size", "max", "min", "name", "label", "onKeydown", "onBlur", "onFocus", "onInput", "onChange"])
  ], 34);
}
var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
const ElInputNumber = withInstall(InputNumber);
const paginationPrevProps = {
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String,
    default: ""
  }
};
const _sfc_main$v = defineComponent({
  name: "ElPaginationPrev",
  components: {
    ElIcon,
    ArrowLeft: arrowLeft
  },
  props: paginationPrevProps,
  emits: ["click"],
  setup(props2) {
    const internalDisabled = computed(() => props2.disabled || props2.currentPage <= 1);
    return {
      internalDisabled
    };
  }
});
const _hoisted_1$q = ["disabled", "aria-disabled"];
const _hoisted_2$c = { key: 0 };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_left = resolveComponent("arrow-left");
  const _component_el_icon = resolveComponent("el-icon");
  return openBlock(), createElementBlock("button", {
    type: "button",
    class: "btn-prev",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }, [
    _ctx.prevText ? (openBlock(), createElementBlock("span", _hoisted_2$c, toDisplayString(_ctx.prevText), 1)) : (openBlock(), createBlock(_component_el_icon, { key: 1 }, {
      default: withCtx(() => [
        createVNode$1(_component_arrow_left)
      ]),
      _: 1
    }))
  ], 8, _hoisted_1$q);
}
var Prev = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$d], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);
const paginationNextProps = {
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String,
    default: ""
  }
};
const _sfc_main$u = defineComponent({
  name: "ElPaginationNext",
  components: {
    ElIcon,
    ArrowRight: arrowRight
  },
  props: paginationNextProps,
  emits: ["click"],
  setup(props2) {
    const internalDisabled = computed(() => props2.disabled || props2.currentPage === props2.pageCount || props2.pageCount === 0);
    return {
      internalDisabled
    };
  }
});
const _hoisted_1$p = ["disabled", "aria-disabled"];
const _hoisted_2$b = { key: 0 };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arrow_right = resolveComponent("arrow-right");
  const _component_el_icon = resolveComponent("el-icon");
  return openBlock(), createElementBlock("button", {
    type: "button",
    class: "btn-next",
    disabled: _ctx.internalDisabled,
    "aria-disabled": _ctx.internalDisabled,
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }, [
    _ctx.nextText ? (openBlock(), createElementBlock("span", _hoisted_2$b, toDisplayString(_ctx.nextText), 1)) : (openBlock(), createBlock(_component_el_icon, { key: 1 }, {
      default: withCtx(() => [
        createVNode$1(_component_arrow_right)
      ]),
      _: 1
    }))
  ], 8, _hoisted_1$p);
}
var Next = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$c], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);
const selectGroupKey = "ElSelectGroup";
const selectKey = "ElSelect";
function useOption(props2, states) {
  const select2 = inject(selectKey);
  const selectGroup = inject(selectGroupKey, { disabled: false });
  const isObject2 = computed(() => {
    return Object.prototype.toString.call(props2.value).toLowerCase() === "[object object]";
  });
  const itemSelected = computed(() => {
    if (!select2.props.multiple) {
      return isEqual2(props2.value, select2.props.modelValue);
    } else {
      return contains2(select2.props.modelValue, props2.value);
    }
  });
  const limitReached = computed(() => {
    if (select2.props.multiple) {
      const modelValue = select2.props.modelValue || [];
      return !itemSelected.value && modelValue.length >= select2.props.multipleLimit && select2.props.multipleLimit > 0;
    } else {
      return false;
    }
  });
  const currentLabel = computed(() => {
    return props2.label || (isObject2.value ? "" : props2.value);
  });
  const currentValue = computed(() => {
    return props2.value || props2.label || "";
  });
  const isDisabled = computed(() => {
    return props2.disabled || states.groupDisabled || limitReached.value;
  });
  const instance = getCurrentInstance();
  const contains2 = (arr = [], target) => {
    if (!isObject2.value) {
      return arr && arr.includes(target);
    } else {
      const valueKey = select2.props.valueKey;
      return arr && arr.some((item) => {
        return get(item, valueKey) === get(target, valueKey);
      });
    }
  };
  const isEqual2 = (a2, b2) => {
    if (!isObject2.value) {
      return a2 === b2;
    } else {
      const { valueKey } = select2.props;
      return get(a2, valueKey) === get(b2, valueKey);
    }
  };
  const hoverItem = () => {
    if (!props2.disabled && !selectGroup.disabled) {
      select2.hoverIndex = select2.optionsArray.indexOf(instance.proxy);
    }
  };
  watch$1(() => currentLabel.value, () => {
    if (!props2.created && !select2.props.remote)
      select2.setSelected();
  });
  watch$1(() => props2.value, (val, oldVal) => {
    const { remote, valueKey } = select2.props;
    if (!props2.created && !remote) {
      if (valueKey && typeof val === "object" && typeof oldVal === "object" && val[valueKey] === oldVal[valueKey]) {
        return;
      }
      select2.setSelected();
    }
  });
  watch$1(() => selectGroup.disabled, () => {
    states.groupDisabled = selectGroup.disabled;
  }, { immediate: true });
  const { queryChange } = toRaw(select2);
  watch$1(queryChange, (changes) => {
    const { query } = unref(changes);
    const regexp2 = new RegExp(escapeStringRegexp(query), "i");
    states.visible = regexp2.test(currentLabel.value) || props2.created;
    if (!states.visible) {
      select2.filteredOptionsCount--;
    }
  });
  return {
    select: select2,
    currentLabel,
    currentValue,
    itemSelected,
    isDisabled,
    hoverItem
  };
}
const _sfc_main$t = defineComponent({
  name: "ElOption",
  componentName: "ElOption",
  props: {
    value: {
      required: true,
      type: [String, Number, Boolean, Object]
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const ns = useNamespace("select");
    const states = reactive({
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    });
    const { currentLabel, itemSelected, isDisabled, select: select2, hoverItem } = useOption(props2, states);
    const { visible, hover } = toRefs(states);
    const vm = getCurrentInstance().proxy;
    const key2 = vm.value;
    select2.onOptionCreate(vm);
    onBeforeUnmount(() => {
      const { selected } = select2;
      const selectedOptions = select2.props.multiple ? selected : [selected];
      const doesSelected = selectedOptions.some((item) => {
        return item.value === vm.value;
      });
      if (select2.cachedOptions.get(key2) === vm && !doesSelected) {
        nextTick$1(() => {
          select2.cachedOptions.delete(key2);
        });
      }
      select2.onOptionDestroy(key2, vm);
    });
    function selectOptionClick() {
      if (props2.disabled !== true && states.groupDisabled !== true) {
        select2.handleOptionSelect(vm, true);
      }
    }
    return {
      ns,
      currentLabel,
      itemSelected,
      isDisabled,
      select: select2,
      hoverItem,
      visible,
      hover,
      selectOptionClick,
      states
    };
  }
});
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("li", {
    class: normalizeClass([
      _ctx.ns.be("dropdown", "item"),
      _ctx.ns.is("disabled", _ctx.isDisabled),
      {
        selected: _ctx.itemSelected,
        hover: _ctx.hover
      }
    ]),
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.hoverItem && _ctx.hoverItem(...args)),
    onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.selectOptionClick && _ctx.selectOptionClick(...args), ["stop"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createElementVNode("span", null, toDisplayString(_ctx.currentLabel), 1)
    ])
  ], 34)), [
    [vShow, _ctx.visible]
  ]);
}
var Option = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$b], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const _sfc_main$s = defineComponent({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const select2 = inject(selectKey);
    const ns = useNamespace("select");
    const popperClass = computed(() => select2.props.popperClass);
    const isMultiple = computed(() => select2.props.multiple);
    const isFitInputWidth = computed(() => select2.props.fitInputWidth);
    const minWidth = ref("");
    function updateMinWidth() {
      var _a2;
      minWidth.value = `${(_a2 = select2.selectWrapper) == null ? void 0 : _a2.getBoundingClientRect().width}px`;
    }
    onMounted(() => {
      updateMinWidth();
      addResizeListener(select2.selectWrapper, updateMinWidth);
    });
    onBeforeUnmount(() => {
      removeResizeListener(select2.selectWrapper, updateMinWidth);
    });
    return {
      ns,
      minWidth,
      popperClass,
      isMultiple,
      isFitInputWidth
    };
  }
});
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.ns.b("dropdown"), _ctx.ns.is("multiple", _ctx.isMultiple), _ctx.popperClass]),
    style: normalizeStyle$1({ [_ctx.isFitInputWidth ? "width" : "minWidth"]: _ctx.minWidth })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var ElSelectMenu = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$a], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
function useSelectStates(props2) {
  const { t } = useLocale();
  return reactive({
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    createdLabel: null,
    createdSelected: false,
    selected: props2.multiple ? [] : {},
    inputLength: 20,
    inputWidth: 0,
    initialInputHeight: 0,
    optionsCount: 0,
    filteredOptionsCount: 0,
    visible: false,
    softFocus: false,
    selectedLabel: "",
    hoverIndex: -1,
    query: "",
    previousQuery: null,
    inputHovering: false,
    cachedPlaceHolder: "",
    currentPlaceholder: t("el.select.placeholder"),
    menuVisibleOnFocus: false,
    isOnComposition: false,
    isSilentBlur: false,
    prefixWidth: 11,
    tagInMultiLine: false
  });
}
const useSelect = (props2, states, ctx) => {
  const { t } = useLocale();
  const ns = useNamespace("select");
  const reference2 = ref(null);
  const input = ref(null);
  const tooltipRef = ref(null);
  const tags = ref(null);
  const selectWrapper = ref(null);
  const scrollbar = ref(null);
  const hoverOption = ref(-1);
  const queryChange = shallowRef({ query: "" });
  const groupQueryChange = shallowRef("");
  const elForm = inject(formContextKey, {});
  const elFormItem = inject(formItemContextKey, {});
  const readonly2 = computed(() => !props2.filterable || props2.multiple || !states.visible);
  const selectDisabled = computed(() => props2.disabled || elForm.disabled);
  const showClose = computed(() => {
    const hasValue = props2.multiple ? Array.isArray(props2.modelValue) && props2.modelValue.length > 0 : props2.modelValue !== void 0 && props2.modelValue !== null && props2.modelValue !== "";
    const criteria = props2.clearable && !selectDisabled.value && states.inputHovering && hasValue;
    return criteria;
  });
  const iconComponent = computed(() => props2.remote && props2.filterable ? "" : props2.suffixIcon);
  const iconReverse = computed(() => ns.is("reverse", iconComponent.value && states.visible));
  const debounce$1$1 = computed(() => props2.remote ? 300 : 0);
  const emptyText = computed(() => {
    if (props2.loading) {
      return props2.loadingText || t("el.select.loading");
    } else {
      if (props2.remote && states.query === "" && states.options.size === 0)
        return false;
      if (props2.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {
        return props2.noMatchText || t("el.select.noMatch");
      }
      if (states.options.size === 0) {
        return props2.noDataText || t("el.select.noData");
      }
    }
    return null;
  });
  const optionsArray = computed(() => Array.from(states.options.values()));
  const cachedOptionsArray = computed(() => Array.from(states.cachedOptions.values()));
  const showNewOption = computed(() => {
    const hasExistingOption = optionsArray.value.filter((option) => {
      return !option.created;
    }).some((option) => {
      return option.currentLabel === states.query;
    });
    return props2.filterable && props2.allowCreate && states.query !== "" && !hasExistingOption;
  });
  const selectSize = useSize();
  const collapseTagSize = computed(() => ["small"].includes(selectSize.value) ? "small" : "default");
  const dropMenuVisible = computed({
    get() {
      return states.visible && emptyText.value !== false;
    },
    set(val) {
      states.visible = val;
    }
  });
  watch$1(() => selectDisabled.value, () => {
    nextTick$1(() => {
      resetInputHeight();
    });
  });
  watch$1(() => props2.placeholder, (val) => {
    states.cachedPlaceHolder = states.currentPlaceholder = val;
  });
  watch$1(() => props2.modelValue, (val, oldVal) => {
    var _a2;
    if (props2.multiple) {
      resetInputHeight();
      if (val && val.length > 0 || input.value && states.query !== "") {
        states.currentPlaceholder = "";
      } else {
        states.currentPlaceholder = states.cachedPlaceHolder;
      }
      if (props2.filterable && !props2.reserveKeyword) {
        states.query = "";
        handleQueryChange(states.query);
      }
    }
    setSelected();
    if (props2.filterable && !props2.multiple) {
      states.inputLength = 20;
    }
    if (!isEqual(val, oldVal)) {
      (_a2 = elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn());
    }
  }, {
    flush: "post",
    deep: true
  });
  watch$1(() => states.visible, (val) => {
    var _a2, _b2, _c2;
    if (!val) {
      input.value && input.value.blur();
      states.query = "";
      states.previousQuery = null;
      states.selectedLabel = "";
      states.inputLength = 20;
      states.menuVisibleOnFocus = false;
      resetHoverIndex();
      nextTick$1(() => {
        if (input.value && input.value.value === "" && states.selected.length === 0) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      });
      if (!props2.multiple) {
        if (states.selected) {
          if (props2.filterable && props2.allowCreate && states.createdSelected && states.createdLabel) {
            states.selectedLabel = states.createdLabel;
          } else {
            states.selectedLabel = states.selected.currentLabel;
          }
          if (props2.filterable)
            states.query = states.selectedLabel;
        }
        if (props2.filterable) {
          states.currentPlaceholder = states.cachedPlaceHolder;
        }
      }
    } else {
      (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b2.call(_a2);
      if (props2.filterable) {
        states.filteredOptionsCount = states.optionsCount;
        states.query = props2.remote ? "" : states.selectedLabel;
        if (props2.multiple) {
          (_c2 = input.value) == null ? void 0 : _c2.focus();
        } else {
          if (states.selectedLabel) {
            states.currentPlaceholder = `${states.selectedLabel}`;
            states.selectedLabel = "";
          }
        }
        handleQueryChange(states.query);
        if (!props2.multiple && !props2.remote) {
          queryChange.value.query = "";
          triggerRef(queryChange);
          triggerRef(groupQueryChange);
        }
      }
    }
    ctx.emit("visible-change", val);
  });
  watch$1(() => states.options.entries(), () => {
    var _a2, _b2, _c2;
    if (!isClient)
      return;
    (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b2.call(_a2);
    if (props2.multiple) {
      resetInputHeight();
    }
    const inputs = ((_c2 = selectWrapper.value) == null ? void 0 : _c2.querySelectorAll("input")) || [];
    if (!Array.from(inputs).includes(document.activeElement)) {
      setSelected();
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  }, {
    flush: "post"
  });
  watch$1(() => states.hoverIndex, (val) => {
    if (typeof val === "number" && val > -1) {
      hoverOption.value = optionsArray.value[val] || {};
    }
    optionsArray.value.forEach((option) => {
      option.hover = hoverOption.value === option;
    });
  });
  const resetInputHeight = () => {
    if (props2.collapseTags && !props2.filterable)
      return;
    nextTick$1(() => {
      var _a2, _b2;
      if (!reference2.value)
        return;
      const inputChildNodes = reference2.value.$el.childNodes;
      const input2 = Array.from(inputChildNodes).find((item) => item.tagName === "INPUT");
      const _tags = tags.value;
      const sizeInMap = states.initialInputHeight || getComponentSize(selectSize.value || elForm.size);
      input2.style.height = states.selected.length === 0 ? `${sizeInMap}px` : `${Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap)}px`;
      states.tagInMultiLine = Number.parseFloat(input2.style.height) >= sizeInMap;
      if (states.visible && emptyText.value !== false) {
        (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b2.call(_a2);
      }
    });
  };
  const handleQueryChange = (val) => {
    if (states.previousQuery === val || states.isOnComposition)
      return;
    if (states.previousQuery === null && (typeof props2.filterMethod === "function" || typeof props2.remoteMethod === "function")) {
      states.previousQuery = val;
      return;
    }
    states.previousQuery = val;
    nextTick$1(() => {
      var _a2, _b2;
      if (states.visible)
        (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b2.call(_a2);
    });
    states.hoverIndex = -1;
    if (props2.multiple && props2.filterable) {
      nextTick$1(() => {
        const length2 = input.value.value.length * 15 + 20;
        states.inputLength = props2.collapseTags ? Math.min(50, length2) : length2;
        managePlaceholder();
        resetInputHeight();
      });
    }
    if (props2.remote && typeof props2.remoteMethod === "function") {
      states.hoverIndex = -1;
      props2.remoteMethod(val);
    } else if (typeof props2.filterMethod === "function") {
      props2.filterMethod(val);
      triggerRef(groupQueryChange);
    } else {
      states.filteredOptionsCount = states.optionsCount;
      queryChange.value.query = val;
      triggerRef(queryChange);
      triggerRef(groupQueryChange);
    }
    if (props2.defaultFirstOption && (props2.filterable || props2.remote) && states.filteredOptionsCount) {
      checkDefaultFirstOption();
    }
  };
  const managePlaceholder = () => {
    if (states.currentPlaceholder !== "") {
      states.currentPlaceholder = input.value.value ? "" : states.cachedPlaceHolder;
    }
  };
  const checkDefaultFirstOption = () => {
    const optionsInDropdown = optionsArray.value.filter((n) => n.visible && !n.disabled && !n.states.groupDisabled);
    const userCreatedOption = optionsInDropdown.find((n) => n.created);
    const firstOriginOption = optionsInDropdown[0];
    states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);
  };
  const setSelected = () => {
    var _a2;
    if (!props2.multiple) {
      const option = getOption(props2.modelValue);
      if ((_a2 = option.props) == null ? void 0 : _a2.created) {
        states.createdLabel = option.props.value;
        states.createdSelected = true;
      } else {
        states.createdSelected = false;
      }
      states.selectedLabel = option.currentLabel;
      states.selected = option;
      if (props2.filterable)
        states.query = states.selectedLabel;
      return;
    } else {
      states.selectedLabel = "";
    }
    const result = [];
    if (Array.isArray(props2.modelValue)) {
      props2.modelValue.forEach((value) => {
        result.push(getOption(value));
      });
    }
    states.selected = result;
    nextTick$1(() => {
      resetInputHeight();
    });
  };
  const getOption = (value) => {
    let option;
    const isObjectValue = toRawType(value).toLowerCase() === "object";
    const isNull = toRawType(value).toLowerCase() === "null";
    const isUndefined2 = toRawType(value).toLowerCase() === "undefined";
    for (let i = states.cachedOptions.size - 1; i >= 0; i--) {
      const cachedOption = cachedOptionsArray.value[i];
      const isEqualValue = isObjectValue ? get(cachedOption, props2.valueKey) === get(value, props2.valueKey) : cachedOption.value === value;
      if (isEqualValue) {
        option = {
          value,
          currentLabel: cachedOption.currentLabel,
          isDisabled: cachedOption.isDisabled
        };
        break;
      }
    }
    if (option)
      return option;
    const label = isObjectValue ? value.label : !isNull && !isUndefined2 ? value : "";
    const newOption = {
      value,
      currentLabel: label
    };
    if (props2.multiple) {
      newOption.hitState = false;
    }
    return newOption;
  };
  const resetHoverIndex = () => {
    setTimeout(() => {
      const valueKey = props2.valueKey;
      if (!props2.multiple) {
        states.hoverIndex = optionsArray.value.findIndex((item) => {
          return getValueKey(item) === getValueKey(states.selected);
        });
      } else {
        if (states.selected.length > 0) {
          states.hoverIndex = Math.min.apply(null, states.selected.map((selected) => {
            return optionsArray.value.findIndex((item) => {
              return get(item, valueKey) === get(selected, valueKey);
            });
          }));
        } else {
          states.hoverIndex = -1;
        }
      }
    }, 300);
  };
  const handleResize = () => {
    var _a2, _b2;
    resetInputWidth();
    (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b2.call(_a2);
    if (props2.multiple && !props2.filterable)
      resetInputHeight();
  };
  const resetInputWidth = () => {
    var _a2;
    states.inputWidth = (_a2 = reference2.value) == null ? void 0 : _a2.$el.getBoundingClientRect().width;
  };
  const onInputChange = () => {
    if (props2.filterable && states.query !== states.selectedLabel) {
      states.query = states.selectedLabel;
      handleQueryChange(states.query);
    }
  };
  const debouncedOnInputChange = debounce$1(() => {
    onInputChange();
  }, debounce$1$1.value);
  const debouncedQueryChange = debounce$1((e2) => {
    handleQueryChange(e2.target.value);
  }, debounce$1$1.value);
  const emitChange = (val) => {
    if (!isEqual(props2.modelValue, val)) {
      ctx.emit(CHANGE_EVENT, val);
    }
  };
  const deletePrevTag = (e2) => {
    if (e2.target.value.length <= 0 && !toggleLastOptionHitState()) {
      const value = props2.modelValue.slice();
      value.pop();
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
    }
    if (e2.target.value.length === 1 && props2.modelValue.length === 0) {
      states.currentPlaceholder = states.cachedPlaceHolder;
    }
  };
  const deleteTag = (event, tag) => {
    const index2 = states.selected.indexOf(tag);
    if (index2 > -1 && !selectDisabled.value) {
      const value = props2.modelValue.slice();
      value.splice(index2, 1);
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      ctx.emit("remove-tag", tag.value);
    }
    event.stopPropagation();
  };
  const deleteSelected = (event) => {
    event.stopPropagation();
    const value = props2.multiple ? [] : "";
    if (typeof value !== "string") {
      for (const item of states.selected) {
        if (item.isDisabled)
          value.push(item.value);
      }
    }
    ctx.emit(UPDATE_MODEL_EVENT, value);
    emitChange(value);
    states.visible = false;
    ctx.emit("clear");
  };
  const handleOptionSelect = (option, byClick) => {
    var _a2;
    if (props2.multiple) {
      const value = (props2.modelValue || []).slice();
      const optionIndex = getValueIndex(value, option.value);
      if (optionIndex > -1) {
        value.splice(optionIndex, 1);
      } else if (props2.multipleLimit <= 0 || value.length < props2.multipleLimit) {
        value.push(option.value);
      }
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      if (option.created) {
        states.query = "";
        handleQueryChange("");
        states.inputLength = 20;
      }
      if (props2.filterable)
        (_a2 = input.value) == null ? void 0 : _a2.focus();
    } else {
      ctx.emit(UPDATE_MODEL_EVENT, option.value);
      emitChange(option.value);
      states.visible = false;
    }
    states.isSilentBlur = byClick;
    setSoftFocus();
    if (states.visible)
      return;
    nextTick$1(() => {
      scrollToOption(option);
    });
  };
  const getValueIndex = (arr = [], value) => {
    if (!isObject$1(value))
      return arr.indexOf(value);
    const valueKey = props2.valueKey;
    let index2 = -1;
    arr.some((item, i) => {
      if (get(item, valueKey) === get(value, valueKey)) {
        index2 = i;
        return true;
      }
      return false;
    });
    return index2;
  };
  const setSoftFocus = () => {
    states.softFocus = true;
    const _input = input.value || reference2.value;
    if (_input) {
      _input == null ? void 0 : _input.focus();
    }
  };
  const scrollToOption = (option) => {
    var _a2, _b2, _c2, _d, _e;
    const targetOption = Array.isArray(option) ? option[0] : option;
    let target = null;
    if (targetOption == null ? void 0 : targetOption.value) {
      const options = optionsArray.value.filter((item) => item.value === targetOption.value);
      if (options.length > 0) {
        target = options[0].$el;
      }
    }
    if (tooltipRef.value && target) {
      const menu2 = (_d = (_c2 = (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b2.contentRef) == null ? void 0 : _c2.querySelector) == null ? void 0 : _d.call(_c2, `.${ns.be("dropdown", "wrap")}`);
      if (menu2) {
        scrollIntoView(menu2, target);
      }
    }
    (_e = scrollbar.value) == null ? void 0 : _e.handleScroll();
  };
  const onOptionCreate = (vm) => {
    states.optionsCount++;
    states.filteredOptionsCount++;
    states.options.set(vm.value, vm);
    states.cachedOptions.set(vm.value, vm);
  };
  const onOptionDestroy = (key2, vm) => {
    if (states.options.get(key2) === vm) {
      states.optionsCount--;
      states.filteredOptionsCount--;
      states.options.delete(key2);
    }
  };
  const resetInputState = (e2) => {
    if (e2.code !== EVENT_CODE.backspace)
      toggleLastOptionHitState(false);
    states.inputLength = input.value.value.length * 15 + 20;
    resetInputHeight();
  };
  const toggleLastOptionHitState = (hit) => {
    if (!Array.isArray(states.selected))
      return;
    const option = states.selected[states.selected.length - 1];
    if (!option)
      return;
    if (hit === true || hit === false) {
      option.hitState = hit;
      return hit;
    }
    option.hitState = !option.hitState;
    return option.hitState;
  };
  const handleComposition = (event) => {
    const text2 = event.target.value;
    if (event.type === "compositionend") {
      states.isOnComposition = false;
      nextTick$1(() => handleQueryChange(text2));
    } else {
      const lastCharacter = text2[text2.length - 1] || "";
      states.isOnComposition = !isKorean(lastCharacter);
    }
  };
  const handleMenuEnter = () => {
    nextTick$1(() => scrollToOption(states.selected));
  };
  const handleFocus = (event) => {
    if (!states.softFocus) {
      if (props2.automaticDropdown || props2.filterable) {
        if (props2.filterable && !states.visible) {
          states.menuVisibleOnFocus = true;
        }
        states.visible = true;
      }
      ctx.emit("focus", event);
    } else {
      states.softFocus = false;
    }
  };
  const blur = () => {
    var _a2;
    states.visible = false;
    (_a2 = reference2.value) == null ? void 0 : _a2.blur();
  };
  const handleBlur = (event) => {
    nextTick$1(() => {
      if (states.isSilentBlur) {
        states.isSilentBlur = false;
      } else {
        ctx.emit("blur", event);
      }
    });
    states.softFocus = false;
  };
  const handleClearClick = (event) => {
    deleteSelected(event);
  };
  const handleClose = () => {
    states.visible = false;
  };
  const toggleMenu = () => {
    var _a2;
    if (props2.automaticDropdown)
      return;
    if (!selectDisabled.value) {
      if (states.menuVisibleOnFocus) {
        states.menuVisibleOnFocus = false;
      } else {
        states.visible = !states.visible;
      }
      if (states.visible) {
        (_a2 = input.value || reference2.value) == null ? void 0 : _a2.focus();
      }
    }
  };
  const selectOption = () => {
    if (!states.visible) {
      toggleMenu();
    } else {
      if (optionsArray.value[states.hoverIndex]) {
        handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);
      }
    }
  };
  const getValueKey = (item) => {
    return isObject$1(item.value) ? get(item.value, props2.valueKey) : item.value;
  };
  const optionsAllDisabled = computed(() => optionsArray.value.filter((option) => option.visible).every((option) => option.disabled));
  const navigateOptions = (direction) => {
    if (!states.visible) {
      states.visible = true;
      return;
    }
    if (states.options.size === 0 || states.filteredOptionsCount === 0)
      return;
    if (states.isOnComposition)
      return;
    if (!optionsAllDisabled.value) {
      if (direction === "next") {
        states.hoverIndex++;
        if (states.hoverIndex === states.options.size) {
          states.hoverIndex = 0;
        }
      } else if (direction === "prev") {
        states.hoverIndex--;
        if (states.hoverIndex < 0) {
          states.hoverIndex = states.options.size - 1;
        }
      }
      const option = optionsArray.value[states.hoverIndex];
      if (option.disabled === true || option.states.groupDisabled === true || !option.visible) {
        navigateOptions(direction);
      }
      nextTick$1(() => scrollToOption(hoverOption.value));
    }
  };
  return {
    optionsArray,
    selectSize,
    handleResize,
    debouncedOnInputChange,
    debouncedQueryChange,
    deletePrevTag,
    deleteTag,
    deleteSelected,
    handleOptionSelect,
    scrollToOption,
    readonly: readonly2,
    resetInputHeight,
    showClose,
    iconComponent,
    iconReverse,
    showNewOption,
    collapseTagSize,
    setSelected,
    managePlaceholder,
    selectDisabled,
    emptyText,
    toggleLastOptionHitState,
    resetInputState,
    handleComposition,
    onOptionCreate,
    onOptionDestroy,
    handleMenuEnter,
    handleFocus,
    blur,
    handleBlur,
    handleClearClick,
    handleClose,
    toggleMenu,
    selectOption,
    getValueKey,
    navigateOptions,
    dropMenuVisible,
    queryChange,
    groupQueryChange,
    reference: reference2,
    input,
    tooltipRef,
    tags,
    selectWrapper,
    scrollbar
  };
};
const COMPONENT_NAME$1 = "ElSelect";
const _sfc_main$r = defineComponent({
  name: COMPONENT_NAME$1,
  componentName: COMPONENT_NAME$1,
  components: {
    ElInput,
    ElSelectMenu,
    ElOption: Option,
    ElTag,
    ElScrollbar,
    ElTooltip,
    ElIcon
  },
  directives: { ClickOutside },
  props: {
    name: String,
    id: String,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: {
      type: String,
      validator: isValidComponentSize
    },
    effect: {
      type: String,
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: true
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: {
      type: Boolean,
      default: false
    },
    popperAppendToBody: {
      type: Boolean,
      default: void 0
    },
    teleported: useTooltipContentProps.teleported,
    persistent: {
      type: Boolean,
      default: true
    },
    clearIcon: {
      type: [String, Object],
      default: circleClose
    },
    fitInputWidth: {
      type: Boolean,
      default: false
    },
    suffixIcon: {
      type: [String, Object],
      default: arrowUp
    },
    tagType: __spreadProps(__spreadValues({}, tagProps.type), { default: "info" })
  },
  emits: [
    UPDATE_MODEL_EVENT,
    CHANGE_EVENT,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur"
  ],
  setup(props2, ctx) {
    const nsSelect = useNamespace("select");
    const nsInput = useNamespace("input");
    const { t } = useLocale();
    const states = useSelectStates(props2);
    const {
      optionsArray,
      selectSize,
      readonly: readonly2,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      setSelected,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconComponent,
      iconReverse,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      onOptionCreate,
      onOptionDestroy,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      reference: reference2,
      input,
      tooltipRef,
      tags,
      selectWrapper,
      scrollbar,
      queryChange,
      groupQueryChange
    } = useSelect(props2, states, ctx);
    const { focus } = useFocus(reference2);
    const {
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options,
      cachedOptions,
      optionsCount,
      prefixWidth,
      tagInMultiLine
    } = toRefs(states);
    const wrapperKls = computed(() => {
      const classList = [nsSelect.b()];
      const _selectSize = unref(selectSize);
      if (_selectSize) {
        classList.push(nsSelect.m(_selectSize));
      }
      if (props2.disabled) {
        classList.push(nsSelect.m("disabled"));
      }
      return classList;
    });
    const selectTagsStyle = computed(() => ({
      maxWidth: `${unref(inputWidth) - 32}px`,
      width: "100%"
    }));
    provide(selectKey, reactive({
      props: props2,
      options,
      optionsArray,
      cachedOptions,
      optionsCount,
      filteredOptionsCount,
      hoverIndex,
      handleOptionSelect,
      onOptionCreate,
      onOptionDestroy,
      selectWrapper,
      selected,
      setSelected,
      queryChange,
      groupQueryChange
    }));
    onMounted(() => {
      states.cachedPlaceHolder = currentPlaceholder.value = props2.placeholder || t("el.select.placeholder");
      if (props2.multiple && Array.isArray(props2.modelValue) && props2.modelValue.length > 0) {
        currentPlaceholder.value = "";
      }
      addResizeListener(selectWrapper.value, handleResize);
      if (reference2.value && reference2.value.$el) {
        const input2 = reference2.value.input;
        states.initialInputHeight = input2.getBoundingClientRect().height || getComponentSize(selectSize.value);
      }
      if (props2.remote && props2.multiple) {
        resetInputHeight();
      }
      nextTick$1(() => {
        if (!reference2.value)
          return;
        if (reference2.value.$el) {
          inputWidth.value = reference2.value.$el.getBoundingClientRect().width;
        }
        if (ctx.slots.prefix) {
          const inputChildNodes = reference2.value.$el.childNodes;
          const input2 = Array.from(inputChildNodes).find((item) => item.tagName === "INPUT");
          const prefix = reference2.value.$el.querySelector(`.${nsInput.e("prefix")}`);
          prefixWidth.value = Math.max(prefix.getBoundingClientRect().width + 5, 30);
          if (states.prefixWidth) {
            input2.style.paddingLeft = `${Math.max(states.prefixWidth, 30)}px`;
          }
        }
      });
      setSelected();
    });
    onBeforeUnmount(() => {
      removeResizeListener(selectWrapper.value, handleResize);
    });
    if (props2.multiple && !Array.isArray(props2.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, []);
    }
    if (!props2.multiple && Array.isArray(props2.modelValue)) {
      ctx.emit(UPDATE_MODEL_EVENT, "");
    }
    const popperPaneRef = computed(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = tooltipRef.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b2.contentRef;
    });
    const { compatTeleported } = useDeprecateAppendToBody(COMPONENT_NAME$1, "popperAppendToBody");
    return {
      tagInMultiLine,
      prefixWidth,
      selectSize,
      readonly: readonly2,
      handleResize,
      collapseTagSize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      inputWidth,
      selected,
      inputLength,
      filteredOptionsCount,
      visible,
      softFocus,
      selectedLabel,
      hoverIndex,
      query,
      inputHovering,
      currentPlaceholder,
      menuVisibleOnFocus,
      isOnComposition,
      isSilentBlur,
      options,
      resetInputHeight,
      managePlaceholder,
      showClose,
      selectDisabled,
      iconComponent,
      iconReverse,
      showNewOption,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      focus,
      reference: reference2,
      input,
      tooltipRef,
      popperPaneRef,
      tags,
      selectWrapper,
      scrollbar,
      wrapperKls,
      selectTagsStyle,
      compatTeleported,
      nsSelect
    };
  }
});
const _hoisted_1$o = { class: "select-trigger" };
const _hoisted_2$a = ["disabled", "autocomplete"];
const _hoisted_3$7 = { style: { "height": "100%", "display": "flex", "justify-content": "center", "align-items": "center" } };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_option = resolveComponent("el-option");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_select_menu = resolveComponent("el-select-menu");
  const _directive_click_outside = resolveDirective("click-outside");
  return withDirectives((openBlock(), createElementBlock("div", {
    ref: "selectWrapper",
    class: normalizeClass(_ctx.wrapperKls),
    onClick: _cache[24] || (_cache[24] = withModifiers((...args) => _ctx.toggleMenu && _ctx.toggleMenu(...args), ["stop"]))
  }, [
    createVNode$1(_component_el_tooltip, {
      ref: "tooltipRef",
      visible: _ctx.dropMenuVisible,
      "onUpdate:visible": _cache[23] || (_cache[23] = ($event) => _ctx.dropMenuVisible = $event),
      placement: "bottom-start",
      teleported: _ctx.compatTeleported,
      "popper-class": [_ctx.nsSelect.e("popper"), _ctx.popperClass],
      "fallback-placements": ["bottom-start", "top-start", "right", "left"],
      effect: _ctx.effect,
      pure: "",
      trigger: "click",
      transition: `${_ctx.nsSelect.namespace.value}-zoom-in-top`,
      "stop-popper-mouse-event": false,
      "gpu-acceleration": false,
      persistent: _ctx.persistent,
      onShow: _ctx.handleMenuEnter
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$o, [
          _ctx.multiple ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref: "tags",
            class: normalizeClass(_ctx.nsSelect.e("tags")),
            style: normalizeStyle$1(_ctx.selectTagsStyle)
          }, [
            _ctx.collapseTags && _ctx.selected.length ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass([
                _ctx.nsSelect.b("tags-wrapper"),
                { "has-prefix": _ctx.prefixWidth && _ctx.selected.length }
              ])
            }, [
              createVNode$1(_component_el_tag, {
                closable: !_ctx.selectDisabled && !_ctx.selected[0].isDisabled,
                size: _ctx.collapseTagSize,
                hit: _ctx.selected[0].hitState,
                type: _ctx.tagType,
                "disable-transitions": "",
                onClose: _cache[0] || (_cache[0] = ($event) => _ctx.deleteTag($event, _ctx.selected[0]))
              }, {
                default: withCtx(() => [
                  createElementVNode("span", {
                    class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                    style: normalizeStyle$1({ maxWidth: _ctx.inputWidth - 123 + "px" })
                  }, toDisplayString(_ctx.selected[0].currentLabel), 7)
                ]),
                _: 1
              }, 8, ["closable", "size", "hit", "type"]),
              _ctx.selected.length > 1 ? (openBlock(), createBlock(_component_el_tag, {
                key: 0,
                closable: false,
                size: _ctx.collapseTagSize,
                type: _ctx.tagType,
                "disable-transitions": ""
              }, {
                default: withCtx(() => [
                  _ctx.collapseTagsTooltip ? (openBlock(), createBlock(_component_el_tooltip, {
                    key: 0,
                    disabled: _ctx.dropMenuVisible,
                    "fallback-placements": ["bottom", "top", "right", "left"],
                    effect: _ctx.effect,
                    placement: "bottom",
                    teleported: false
                  }, {
                    default: withCtx(() => [
                      createElementVNode("span", {
                        class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                      }, "+ " + toDisplayString(_ctx.selected.length - 1), 3)
                    ]),
                    content: withCtx(() => [
                      createElementVNode("div", {
                        class: normalizeClass(_ctx.nsSelect.e("collapse-tags"))
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item, idx) => {
                          return openBlock(), createElementBlock("div", {
                            key: idx,
                            class: normalizeClass(_ctx.nsSelect.e("collapse-tag"))
                          }, [
                            (openBlock(), createBlock(_component_el_tag, {
                              key: _ctx.getValueKey(item),
                              class: "in-tooltip",
                              closable: !_ctx.selectDisabled && !item.isDisabled,
                              size: _ctx.collapseTagSize,
                              hit: item.hitState,
                              type: _ctx.tagType,
                              "disable-transitions": "",
                              style: { margin: "2px" },
                              onClose: ($event) => _ctx.deleteTag($event, item)
                            }, {
                              default: withCtx(() => [
                                createElementVNode("span", {
                                  class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                                  style: normalizeStyle$1({
                                    maxWidth: _ctx.inputWidth - 75 + "px"
                                  })
                                }, toDisplayString(item.currentLabel), 7)
                              ]),
                              _: 2
                            }, 1032, ["closable", "size", "hit", "type", "onClose"]))
                          ], 2);
                        }), 128))
                      ], 2)
                    ]),
                    _: 1
                  }, 8, ["disabled", "effect"])) : (openBlock(), createElementBlock("span", {
                    key: 1,
                    class: normalizeClass(_ctx.nsSelect.e("tags-text"))
                  }, "+ " + toDisplayString(_ctx.selected.length - 1), 3))
                ]),
                _: 1
              }, 8, ["size", "type"])) : createCommentVNode("v-if", true)
            ], 2)) : createCommentVNode("v-if", true),
            createCommentVNode(" <div> "),
            !_ctx.collapseTags ? (openBlock(), createBlock(Transition, {
              key: 1,
              onAfterLeave: _ctx.resetInputHeight
            }, {
              default: withCtx(() => [
                createElementVNode("span", {
                  class: normalizeClass([
                    _ctx.nsSelect.b("tags-wrapper"),
                    { "has-prefix": _ctx.prefixWidth && _ctx.selected.length }
                  ])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selected, (item) => {
                    return openBlock(), createBlock(_component_el_tag, {
                      key: _ctx.getValueKey(item),
                      closable: !_ctx.selectDisabled && !item.isDisabled,
                      size: _ctx.collapseTagSize,
                      hit: item.hitState,
                      type: _ctx.tagType,
                      "disable-transitions": "",
                      onClose: ($event) => _ctx.deleteTag($event, item)
                    }, {
                      default: withCtx(() => [
                        createElementVNode("span", {
                          class: normalizeClass(_ctx.nsSelect.e("tags-text")),
                          style: normalizeStyle$1({ maxWidth: _ctx.inputWidth - 75 + "px" })
                        }, toDisplayString(item.currentLabel), 7)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "hit", "type", "onClose"]);
                  }), 128))
                ], 2)
              ]),
              _: 1
            }, 8, ["onAfterLeave"])) : createCommentVNode("v-if", true),
            createCommentVNode(" </div> "),
            _ctx.filterable ? withDirectives((openBlock(), createElementBlock("input", {
              key: 2,
              ref: "input",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.query = $event),
              type: "text",
              class: normalizeClass([_ctx.nsSelect.e("input"), _ctx.nsSelect.is(_ctx.selectSize)]),
              disabled: _ctx.selectDisabled,
              autocomplete: _ctx.autocomplete,
              style: normalizeStyle$1({
                marginLeft: _ctx.prefixWidth && !_ctx.selected.length || _ctx.tagInMultiLine ? `${_ctx.prefixWidth}px` : "",
                flexGrow: 1,
                width: `${_ctx.inputLength / (_ctx.inputWidth - 32)}%`,
                maxWidth: `${_ctx.inputWidth - 42}px`
              }),
              onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
              onBlur: _cache[3] || (_cache[3] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
              onKeyup: _cache[4] || (_cache[4] = (...args) => _ctx.managePlaceholder && _ctx.managePlaceholder(...args)),
              onKeydown: [
                _cache[5] || (_cache[5] = (...args) => _ctx.resetInputState && _ctx.resetInputState(...args)),
                _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["prevent"]), ["down"])),
                _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["prevent"]), ["up"])),
                _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
                _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.selectOption && _ctx.selectOption(...args), ["stop", "prevent"]), ["enter"])),
                _cache[10] || (_cache[10] = withKeys((...args) => _ctx.deletePrevTag && _ctx.deletePrevTag(...args), ["delete"])),
                _cache[11] || (_cache[11] = withKeys(($event) => _ctx.visible = false, ["tab"]))
              ],
              onCompositionstart: _cache[12] || (_cache[12] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionupdate: _cache[13] || (_cache[13] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onCompositionend: _cache[14] || (_cache[14] = (...args) => _ctx.handleComposition && _ctx.handleComposition(...args)),
              onInput: _cache[15] || (_cache[15] = (...args) => _ctx.debouncedQueryChange && _ctx.debouncedQueryChange(...args))
            }, null, 46, _hoisted_2$a)), [
              [vModelText, _ctx.query]
            ]) : createCommentVNode("v-if", true)
          ], 6)) : createCommentVNode("v-if", true),
          createVNode$1(_component_el_input, {
            id: _ctx.id,
            ref: "reference",
            modelValue: _ctx.selectedLabel,
            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => _ctx.selectedLabel = $event),
            type: "text",
            placeholder: _ctx.currentPlaceholder,
            name: _ctx.name,
            autocomplete: _ctx.autocomplete,
            size: _ctx.selectSize,
            disabled: _ctx.selectDisabled,
            readonly: _ctx.readonly,
            "validate-event": false,
            class: normalizeClass([_ctx.nsSelect.is("focus", _ctx.visible)]),
            tabindex: _ctx.multiple && _ctx.filterable ? -1 : void 0,
            onFocus: _ctx.handleFocus,
            onBlur: _ctx.handleBlur,
            onInput: _ctx.debouncedOnInputChange,
            onPaste: _ctx.debouncedOnInputChange,
            onCompositionstart: _ctx.handleComposition,
            onCompositionupdate: _ctx.handleComposition,
            onCompositionend: _ctx.handleComposition,
            onKeydown: [
              _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.navigateOptions("next"), ["stop", "prevent"]), ["down"])),
              _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.navigateOptions("prev"), ["stop", "prevent"]), ["up"])),
              withKeys(withModifiers(_ctx.selectOption, ["stop", "prevent"]), ["enter"]),
              _cache[19] || (_cache[19] = withKeys(withModifiers(($event) => _ctx.visible = false, ["stop", "prevent"]), ["esc"])),
              _cache[20] || (_cache[20] = withKeys(($event) => _ctx.visible = false, ["tab"]))
            ],
            onMouseenter: _cache[21] || (_cache[21] = ($event) => _ctx.inputHovering = true),
            onMouseleave: _cache[22] || (_cache[22] = ($event) => _ctx.inputHovering = false)
          }, createSlots({
            suffix: withCtx(() => [
              _ctx.iconComponent ? withDirectives((openBlock(), createBlock(_component_el_icon, {
                key: 0,
                class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon"), _ctx.iconReverse])
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
                ]),
                _: 1
              }, 8, ["class"])), [
                [vShow, !_ctx.showClose]
              ]) : createCommentVNode("v-if", true),
              _ctx.showClose && _ctx.clearIcon ? (openBlock(), createBlock(_component_el_icon, {
                key: 1,
                class: normalizeClass([_ctx.nsSelect.e("caret"), _ctx.nsSelect.e("icon")]),
                onClick: _ctx.handleClearClick
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ]),
            _: 2
          }, [
            _ctx.$slots.prefix ? {
              name: "prefix",
              fn: withCtx(() => [
                createElementVNode("div", _hoisted_3$7, [
                  renderSlot(_ctx.$slots, "prefix")
                ])
              ])
            } : void 0
          ]), 1032, ["id", "modelValue", "placeholder", "name", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onInput", "onPaste", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown"])
        ])
      ]),
      content: withCtx(() => [
        createVNode$1(_component_el_select_menu, null, {
          default: withCtx(() => [
            withDirectives(createVNode$1(_component_el_scrollbar, {
              ref: "scrollbar",
              tag: "ul",
              "wrap-class": _ctx.nsSelect.be("dropdown", "wrap"),
              "view-class": _ctx.nsSelect.be("dropdown", "list"),
              class: normalizeClass([
                _ctx.nsSelect.is("empty", !_ctx.allowCreate && Boolean(_ctx.query) && _ctx.filteredOptionsCount === 0)
              ])
            }, {
              default: withCtx(() => [
                _ctx.showNewOption ? (openBlock(), createBlock(_component_el_option, {
                  key: 0,
                  value: _ctx.query,
                  created: true
                }, null, 8, ["value"])) : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8, ["wrap-class", "view-class", "class"]), [
              [vShow, _ctx.options.size > 0 && !_ctx.loading]
            ]),
            _ctx.emptyText && (!_ctx.allowCreate || _ctx.loading || _ctx.allowCreate && _ctx.options.size === 0) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.$slots.empty ? renderSlot(_ctx.$slots, "empty", { key: 0 }) : (openBlock(), createElementBlock("p", {
                key: 1,
                class: normalizeClass(_ctx.nsSelect.be("dropdown", "empty"))
              }, toDisplayString(_ctx.emptyText), 3))
            ], 2112)) : createCommentVNode("v-if", true)
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "effect", "transition", "persistent", "onShow"])
  ], 2)), [
    [_directive_click_outside, _ctx.handleClose, _ctx.popperPaneRef]
  ]);
}
var Select$1 = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$9], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const _sfc_main$q = defineComponent({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },
  setup(props2) {
    const ns = useNamespace("select");
    const visible = ref(true);
    const instance = getCurrentInstance();
    const children2 = ref([]);
    provide(selectGroupKey, reactive(__spreadValues({}, toRefs(props2))));
    const select2 = inject(selectKey);
    onMounted(() => {
      children2.value = flattedChildren(instance.subTree);
    });
    const flattedChildren = (node) => {
      const children22 = [];
      if (Array.isArray(node.children)) {
        node.children.forEach((child) => {
          var _a2;
          if (child.type && child.type.name === "ElOption" && child.component && child.component.proxy) {
            children22.push(child.component.proxy);
          } else if ((_a2 = child.children) == null ? void 0 : _a2.length) {
            children22.push(...flattedChildren(child));
          }
        });
      }
      return children22;
    };
    const { groupQueryChange } = toRaw(select2);
    watch$1(groupQueryChange, () => {
      visible.value = children2.value.some((option) => option.visible === true);
    });
    return {
      visible,
      ns
    };
  }
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("ul", {
    class: normalizeClass(_ctx.ns.be("group", "wrap"))
  }, [
    createElementVNode("li", {
      class: normalizeClass(_ctx.ns.be("group", "title"))
    }, toDisplayString(_ctx.label), 3),
    createElementVNode("li", null, [
      createElementVNode("ul", {
        class: normalizeClass(_ctx.ns.b("group"))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2)
    ])
  ], 2)), [
    [vShow, _ctx.visible]
  ]);
}
var OptionGroup = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$8], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const ElSelect = withInstall(Select$1, {
  Option,
  OptionGroup
});
const ElOption = withNoopInstall(Option);
withNoopInstall(OptionGroup);
const usePagination = () => inject(elPaginationKey, {});
const paginationSizesProps = buildProps({
  pageSize: {
    type: Number,
    required: true
  },
  pageSizes: {
    type: definePropType(Array),
    default: () => mutable([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  disabled: Boolean,
  size: {
    type: String,
    default: "default"
  }
});
const _sfc_main$p = defineComponent({
  name: "ElPaginationSizes",
  components: {
    ElSelect,
    ElOption
  },
  props: paginationSizesProps,
  emits: ["page-size-change"],
  setup(props2, { emit }) {
    const { t } = useLocale();
    const ns = useNamespace("pagination");
    const pagination = usePagination();
    const innerPageSize = ref(props2.pageSize);
    watch$1(() => props2.pageSizes, (newVal, oldVal) => {
      if (isEqual(newVal, oldVal))
        return;
      if (Array.isArray(newVal)) {
        const pageSize2 = newVal.includes(props2.pageSize) ? props2.pageSize : props2.pageSizes[0];
        emit("page-size-change", pageSize2);
      }
    });
    watch$1(() => props2.pageSize, (newVal) => {
      innerPageSize.value = newVal;
    });
    const innerPagesizes = computed(() => props2.pageSizes);
    function handleChange(val) {
      var _a2;
      if (val !== innerPageSize.value) {
        innerPageSize.value = val;
        (_a2 = pagination.handleSizeChange) == null ? void 0 : _a2.call(pagination, Number(val));
      }
    }
    return {
      ns,
      innerPagesizes,
      innerPageSize,
      t,
      handleChange
    };
  }
});
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = resolveComponent("el-option");
  const _component_el_select = resolveComponent("el-select");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.ns.e("sizes"))
  }, [
    createVNode$1(_component_el_select, {
      "model-value": _ctx.innerPageSize,
      disabled: _ctx.disabled,
      "popper-class": _ctx.popperClass,
      size: _ctx.size,
      onChange: _ctx.handleChange
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.innerPagesizes, (item) => {
          return openBlock(), createBlock(_component_el_option, {
            key: item,
            value: item,
            label: item + _ctx.t("el.pagination.pagesize")
          }, null, 8, ["value", "label"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["model-value", "disabled", "popper-class", "size", "onChange"])
  ], 2);
}
var Sizes = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);
const _sfc_main$o = defineComponent({
  name: "ElPaginationJumper",
  components: {
    ElInput
  },
  setup() {
    const { t } = useLocale();
    const ns = useNamespace("pagination");
    const { pageCount, disabled, currentPage: currentPage2, changeEvent } = usePagination();
    const userInput = ref();
    const innerValue = computed(() => {
      var _a2;
      return (_a2 = userInput.value) != null ? _a2 : currentPage2 == null ? void 0 : currentPage2.value;
    });
    function handleInput(val) {
      userInput.value = +val;
    }
    function handleChange(val) {
      val = Math.trunc(+val);
      changeEvent == null ? void 0 : changeEvent(+val);
      userInput.value = void 0;
    }
    return {
      ns,
      pageCount,
      disabled,
      innerValue,
      t,
      handleInput,
      handleChange
    };
  }
});
const _hoisted_1$n = ["disabled"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.ns.e("jump")),
    disabled: _ctx.disabled
  }, [
    createTextVNode(toDisplayString(_ctx.t("el.pagination.goto")) + " ", 1),
    createVNode$1(_component_el_input, {
      size: "small",
      class: normalizeClass([_ctx.ns.e("editor"), _ctx.ns.is("in-pagination")]),
      min: 1,
      max: _ctx.pageCount,
      disabled: _ctx.disabled,
      "model-value": _ctx.innerValue,
      type: "number",
      "onUpdate:modelValue": _ctx.handleInput,
      onChange: _ctx.handleChange
    }, null, 8, ["class", "max", "disabled", "model-value", "onUpdate:modelValue", "onChange"]),
    createTextVNode(" " + toDisplayString(_ctx.t("el.pagination.pageClassifier")), 1)
  ], 10, _hoisted_1$n);
}
var Jumper = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);
const paginationTotalProps = {
  total: {
    type: Number,
    default: 1e3
  }
};
const _sfc_main$n = defineComponent({
  name: "ElPaginationTotal",
  props: paginationTotalProps,
  setup() {
    const { t } = useLocale();
    const ns = useNamespace("pagination");
    const { disabled } = usePagination();
    return {
      t,
      ns,
      disabled
    };
  }
});
const _hoisted_1$m = ["disabled"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.ns.e("total")),
    disabled: _ctx.disabled
  }, toDisplayString(_ctx.t("el.pagination.total", {
    total: _ctx.total
  })), 11, _hoisted_1$m);
}
var Total = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);
const paginationPagerProps = {
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: true
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
};
const _sfc_main$m = defineComponent({
  name: "ElPaginationPager",
  components: {
    DArrowLeft: dArrowLeft,
    DArrowRight: dArrowRight,
    MoreFilled: moreFilled
  },
  props: paginationPagerProps,
  emits: ["change"],
  setup(props2, { emit }) {
    const nsPager = useNamespace("pager");
    const nsIcon = useNamespace("icon");
    const showPrevMore = ref(false);
    const showNextMore = ref(false);
    const quickPrevHover = ref(false);
    const quickNextHover = ref(false);
    const pagers = computed(() => {
      const pagerCount = props2.pagerCount;
      const halfPagerCount = (pagerCount - 1) / 2;
      const currentPage2 = Number(props2.currentPage);
      const pageCount = Number(props2.pageCount);
      let showPrevMore2 = false;
      let showNextMore2 = false;
      if (pageCount > pagerCount) {
        if (currentPage2 > pagerCount - halfPagerCount) {
          showPrevMore2 = true;
        }
        if (currentPage2 < pageCount - halfPagerCount) {
          showNextMore2 = true;
        }
      }
      const array = [];
      if (showPrevMore2 && !showNextMore2) {
        const startPage = pageCount - (pagerCount - 2);
        for (let i = startPage; i < pageCount; i++) {
          array.push(i);
        }
      } else if (!showPrevMore2 && showNextMore2) {
        for (let i = 2; i < pagerCount; i++) {
          array.push(i);
        }
      } else if (showPrevMore2 && showNextMore2) {
        const offset2 = Math.floor(pagerCount / 2) - 1;
        for (let i = currentPage2 - offset2; i <= currentPage2 + offset2; i++) {
          array.push(i);
        }
      } else {
        for (let i = 2; i < pageCount; i++) {
          array.push(i);
        }
      }
      return array;
    });
    watchEffect(() => {
      const halfPagerCount = (props2.pagerCount - 1) / 2;
      showPrevMore.value = false;
      showNextMore.value = false;
      if (props2.pageCount > props2.pagerCount) {
        if (props2.currentPage > props2.pagerCount - halfPagerCount) {
          showPrevMore.value = true;
        }
        if (props2.currentPage < props2.pageCount - halfPagerCount) {
          showNextMore.value = true;
        }
      }
    });
    function onMouseenter(direction) {
      if (props2.disabled)
        return;
      if (direction === "left") {
        quickPrevHover.value = true;
      } else {
        quickNextHover.value = true;
      }
    }
    function onEnter(e2) {
      const target = e2.target;
      if (target.tagName.toLowerCase() === "li" && Array.from(target.classList).includes("number")) {
        const newPage = Number(target.textContent);
        if (newPage !== props2.currentPage) {
          emit("change", newPage);
        }
      }
    }
    function onPagerClick(event) {
      const target = event.target;
      if (target.tagName.toLowerCase() === "ul" || props2.disabled) {
        return;
      }
      let newPage = Number(target.textContent);
      const pageCount = props2.pageCount;
      const currentPage2 = props2.currentPage;
      const pagerCountOffset = props2.pagerCount - 2;
      if (target.className.includes("more")) {
        if (target.className.includes("quickprev")) {
          newPage = currentPage2 - pagerCountOffset;
        } else if (target.className.includes("quicknext")) {
          newPage = currentPage2 + pagerCountOffset;
        }
      }
      if (!Number.isNaN(+newPage)) {
        if (newPage < 1) {
          newPage = 1;
        }
        if (newPage > pageCount) {
          newPage = pageCount;
        }
      }
      if (newPage !== currentPage2) {
        emit("change", newPage);
      }
    }
    return {
      showPrevMore,
      showNextMore,
      quickPrevHover,
      quickNextHover,
      pagers,
      nsPager,
      nsIcon,
      onMouseenter,
      onPagerClick,
      onEnter
    };
  }
});
const _hoisted_1$l = ["aria-current"];
const _hoisted_2$9 = ["aria-current"];
const _hoisted_3$6 = ["aria-current"];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_d_arrow_left = resolveComponent("d-arrow-left");
  const _component_more_filled = resolveComponent("more-filled");
  const _component_d_arrow_right = resolveComponent("d-arrow-right");
  return openBlock(), createElementBlock("ul", {
    class: normalizeClass(_ctx.nsPager.b()),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.onPagerClick && _ctx.onPagerClick(...args)),
    onKeyup: _cache[5] || (_cache[5] = withKeys((...args) => _ctx.onEnter && _ctx.onEnter(...args), ["enter"]))
  }, [
    _ctx.pageCount > 0 ? (openBlock(), createElementBlock("li", {
      key: 0,
      class: normalizeClass([[
        _ctx.nsPager.is("active", _ctx.currentPage === 1),
        _ctx.nsPager.is("disabled", _ctx.disabled)
      ], "number"]),
      "aria-current": _ctx.currentPage === 1,
      tabindex: "0"
    }, " 1 ", 10, _hoisted_1$l)) : createCommentVNode("v-if", true),
    _ctx.showPrevMore ? (openBlock(), createElementBlock("li", {
      key: 1,
      class: normalizeClass([
        "more",
        "btn-quickprev",
        _ctx.nsIcon.b(),
        _ctx.nsPager.is("disabled", _ctx.disabled)
      ]),
      onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.onMouseenter("left")),
      onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.quickPrevHover = false)
    }, [
      _ctx.quickPrevHover ? (openBlock(), createBlock(_component_d_arrow_left, { key: 0 })) : (openBlock(), createBlock(_component_more_filled, { key: 1 }))
    ], 34)) : createCommentVNode("v-if", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pagers, (pager) => {
      return openBlock(), createElementBlock("li", {
        key: pager,
        class: normalizeClass([[
          _ctx.nsPager.is("active", _ctx.currentPage === pager),
          _ctx.nsPager.is("disabled", _ctx.disabled)
        ], "number"]),
        "aria-current": _ctx.currentPage === pager,
        tabindex: "0"
      }, toDisplayString(pager), 11, _hoisted_2$9);
    }), 128)),
    _ctx.showNextMore ? (openBlock(), createElementBlock("li", {
      key: 2,
      class: normalizeClass([
        "more",
        "btn-quicknext",
        _ctx.nsIcon.b(),
        _ctx.nsPager.is("disabled", _ctx.disabled)
      ]),
      onMouseenter: _cache[2] || (_cache[2] = ($event) => _ctx.onMouseenter("right")),
      onMouseleave: _cache[3] || (_cache[3] = ($event) => _ctx.quickNextHover = false)
    }, [
      _ctx.quickNextHover ? (openBlock(), createBlock(_component_d_arrow_right, { key: 0 })) : (openBlock(), createBlock(_component_more_filled, { key: 1 }))
    ], 34)) : createCommentVNode("v-if", true),
    _ctx.pageCount > 1 ? (openBlock(), createElementBlock("li", {
      key: 3,
      class: normalizeClass([[
        _ctx.nsPager.is("active", _ctx.currentPage === _ctx.pageCount),
        _ctx.nsPager.is("disabled", _ctx.disabled)
      ], "number"]),
      "aria-current": _ctx.currentPage === _ctx.pageCount,
      tabindex: "0"
    }, toDisplayString(_ctx.pageCount), 11, _hoisted_3$6)) : createCommentVNode("v-if", true)
  ], 34);
}
var Pager = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);
const isAbsent = (v2) => typeof v2 !== "number";
const paginationProps = buildProps({
  total: Number,
  pageSize: Number,
  defaultPageSize: Number,
  currentPage: Number,
  defaultCurrentPage: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (value) => {
      return typeof value === "number" && Math.trunc(value) === value && value > 4 && value < 22 && value % 2 === 1;
    },
    default: 7
  },
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: definePropType(Array),
    default: () => mutable([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  prevText: {
    type: String,
    default: ""
  },
  nextText: {
    type: String,
    default: ""
  },
  small: Boolean,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean
});
const paginationEmits = {
  "update:current-page": (val) => typeof val === "number",
  "update:page-size": (val) => typeof val === "number",
  "size-change": (val) => typeof val === "number",
  "current-change": (val) => typeof val === "number",
  "prev-click": (val) => typeof val === "number",
  "next-click": (val) => typeof val === "number"
};
const componentName = "ElPagination";
var Pagination$1 = defineComponent({
  name: componentName,
  props: paginationProps,
  emits: paginationEmits,
  setup(props2, { emit, slots }) {
    const { t } = useLocale();
    const ns = useNamespace("pagination");
    const vnodeProps = getCurrentInstance().vnode.props || {};
    const hasCurrentPageListener = "onUpdate:currentPage" in vnodeProps || "onUpdate:current-page" in vnodeProps || "onCurrentChange" in vnodeProps;
    const hasPageSizeListener = "onUpdate:pageSize" in vnodeProps || "onUpdate:page-size" in vnodeProps || "onSizeChange" in vnodeProps;
    const assertValidUsage = computed(() => {
      if (isAbsent(props2.total) && isAbsent(props2.pageCount))
        return false;
      if (!isAbsent(props2.currentPage) && !hasCurrentPageListener)
        return false;
      if (props2.layout.includes("sizes")) {
        if (!isAbsent(props2.pageCount)) {
          if (!hasPageSizeListener)
            return false;
        } else if (!isAbsent(props2.total)) {
          if (!isAbsent(props2.pageSize)) {
            if (!hasPageSizeListener) {
              return false;
            }
          }
        }
      }
      return true;
    });
    const innerPageSize = ref(isAbsent(props2.defaultPageSize) ? 10 : props2.defaultPageSize);
    const innerCurrentPage = ref(isAbsent(props2.defaultCurrentPage) ? 1 : props2.defaultCurrentPage);
    const pageSizeBridge = computed({
      get() {
        return isAbsent(props2.pageSize) ? innerPageSize.value : props2.pageSize;
      },
      set(v2) {
        if (isAbsent(props2.pageSize)) {
          innerPageSize.value = v2;
        }
        if (hasPageSizeListener) {
          emit("update:page-size", v2);
          emit("size-change", v2);
        }
      }
    });
    const pageCountBridge = computed(() => {
      let pageCount = 0;
      if (!isAbsent(props2.pageCount)) {
        pageCount = props2.pageCount;
      } else if (!isAbsent(props2.total)) {
        pageCount = Math.max(1, Math.ceil(props2.total / pageSizeBridge.value));
      }
      return pageCount;
    });
    const currentPageBridge = computed({
      get() {
        return isAbsent(props2.currentPage) ? innerCurrentPage.value : props2.currentPage;
      },
      set(v2) {
        let newCurrentPage = v2;
        if (v2 < 1) {
          newCurrentPage = 1;
        } else if (v2 > pageCountBridge.value) {
          newCurrentPage = pageCountBridge.value;
        }
        if (isAbsent(props2.currentPage)) {
          innerCurrentPage.value = newCurrentPage;
        }
        if (hasCurrentPageListener) {
          emit("update:current-page", newCurrentPage);
          emit("current-change", newCurrentPage);
        }
      }
    });
    watch$1(pageCountBridge, (val) => {
      if (currentPageBridge.value > val)
        currentPageBridge.value = val;
    });
    function handleCurrentChange(val) {
      currentPageBridge.value = val;
    }
    function handleSizeChange(val) {
      pageSizeBridge.value = val;
      const newPageCount = pageCountBridge.value;
      if (currentPageBridge.value > newPageCount) {
        currentPageBridge.value = newPageCount;
      }
    }
    function prev2() {
      if (props2.disabled)
        return;
      currentPageBridge.value -= 1;
      emit("prev-click", currentPageBridge.value);
    }
    function next2() {
      if (props2.disabled)
        return;
      currentPageBridge.value += 1;
      emit("next-click", currentPageBridge.value);
    }
    function addClass2(element, cls) {
      if (element) {
        if (!element.props) {
          element.props = {};
        }
        element.props.class = [element.props.class, cls].join(" ");
      }
    }
    provide(elPaginationKey, {
      pageCount: pageCountBridge,
      disabled: computed(() => props2.disabled),
      currentPage: currentPageBridge,
      changeEvent: handleCurrentChange,
      handleSizeChange
    });
    return () => {
      var _a2, _b2;
      if (!assertValidUsage.value) {
        debugWarn(componentName, t("el.pagination.deprecationWarning"));
        return null;
      }
      if (!props2.layout)
        return null;
      if (props2.hideOnSinglePage && pageCountBridge.value <= 1)
        return null;
      const rootChildren = [];
      const rightWrapperChildren = [];
      const rightWrapperRoot = h$1("div", { class: ns.e("rightwrapper") }, rightWrapperChildren);
      const TEMPLATE_MAP = {
        prev: h$1(Prev, {
          disabled: props2.disabled,
          currentPage: currentPageBridge.value,
          prevText: props2.prevText,
          onClick: prev2
        }),
        jumper: h$1(Jumper),
        pager: h$1(Pager, {
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          pagerCount: props2.pagerCount,
          onChange: handleCurrentChange,
          disabled: props2.disabled
        }),
        next: h$1(Next, {
          disabled: props2.disabled,
          currentPage: currentPageBridge.value,
          pageCount: pageCountBridge.value,
          nextText: props2.nextText,
          onClick: next2
        }),
        sizes: h$1(Sizes, {
          pageSize: pageSizeBridge.value,
          pageSizes: props2.pageSizes,
          popperClass: props2.popperClass,
          disabled: props2.disabled,
          size: props2.small ? "small" : "default"
        }),
        slot: (_b2 = (_a2 = slots == null ? void 0 : slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b2 : null,
        total: h$1(Total, { total: isAbsent(props2.total) ? 0 : props2.total })
      };
      const components = props2.layout.split(",").map((item) => item.trim());
      let haveRightWrapper = false;
      components.forEach((c) => {
        if (c === "->") {
          haveRightWrapper = true;
          return;
        }
        if (!haveRightWrapper) {
          rootChildren.push(TEMPLATE_MAP[c]);
        } else {
          rightWrapperChildren.push(TEMPLATE_MAP[c]);
        }
      });
      addClass2(rootChildren[0], ns.is("first"));
      addClass2(rootChildren[rootChildren.length - 1], ns.is("last"));
      if (haveRightWrapper && rightWrapperChildren.length > 0) {
        addClass2(rightWrapperChildren[0], ns.is("first"));
        addClass2(rightWrapperChildren[rightWrapperChildren.length - 1], ns.is("last"));
        rootChildren.push(rightWrapperRoot);
      }
      return h$1("div", {
        role: "pagination",
        "aria-label": "pagination",
        class: [
          ns.b(),
          ns.is("background", props2.background),
          {
            [ns.m("small")]: props2.small
          }
        ]
      }, rootChildren);
    };
  }
});
const ElPagination = withInstall(Pagination$1);
const progressProps = buildProps({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (val) => val >= 0 && val <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: definePropType(String),
    default: "round"
  },
  textInside: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: true
  },
  color: {
    type: definePropType([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  format: {
    type: definePropType(Function),
    default: (percentage) => `${percentage}%`
  }
});
const _sfc_main$l = defineComponent({
  name: "ElProgress",
  components: {
    ElIcon,
    CircleCheck: circleCheck,
    CircleClose: circleClose,
    Check: check,
    Close: close,
    WarningFilled: warningFilled
  },
  props: progressProps,
  setup(props2) {
    const ns = useNamespace("progress");
    const barStyle = computed(() => ({
      width: `${props2.percentage}%`,
      animationDuration: `${props2.duration}s`,
      backgroundColor: getCurrentColor(props2.percentage)
    }));
    const relativeStrokeWidth = computed(() => (props2.strokeWidth / props2.width * 100).toFixed(1));
    const radius = computed(() => {
      if (props2.type === "circle" || props2.type === "dashboard") {
        return Number.parseInt(`${50 - Number.parseFloat(relativeStrokeWidth.value) / 2}`, 10);
      } else {
        return 0;
      }
    });
    const trackPath = computed(() => {
      const r = radius.value;
      const isDashboard = props2.type === "dashboard";
      return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
    });
    const perimeter = computed(() => 2 * Math.PI * radius.value);
    const rate = computed(() => props2.type === "dashboard" ? 0.75 : 1);
    const strokeDashoffset = computed(() => {
      const offset2 = -1 * perimeter.value * (1 - rate.value) / 2;
      return `${offset2}px`;
    });
    const trailPathStyle = computed(() => ({
      strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value
    }));
    const circlePathStyle = computed(() => ({
      strokeDasharray: `${perimeter.value * rate.value * (props2.percentage / 100)}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease"
    }));
    const stroke = computed(() => {
      let ret;
      if (props2.color) {
        ret = getCurrentColor(props2.percentage);
      } else {
        switch (props2.status) {
          case "success":
            ret = "#13ce66";
            break;
          case "exception":
            ret = "#ff4949";
            break;
          case "warning":
            ret = "#e6a23c";
            break;
          default:
            ret = "#20a0ff";
        }
      }
      return ret;
    });
    const statusIcon = computed(() => {
      if (props2.status === "warning") {
        return warningFilled;
      }
      if (props2.type === "line") {
        return props2.status === "success" ? circleCheck : circleClose;
      } else {
        return props2.status === "success" ? check : close;
      }
    });
    const progressTextSize = computed(() => {
      return props2.type === "line" ? 12 + props2.strokeWidth * 0.4 : props2.width * 0.111111 + 2;
    });
    const content = computed(() => props2.format(props2.percentage));
    const getCurrentColor = (percentage) => {
      var _a2;
      const { color: color2 } = props2;
      if (typeof color2 === "function") {
        return color2(percentage);
      } else if (typeof color2 === "string") {
        return color2;
      } else {
        const span = 100 / color2.length;
        const seriesColors = color2.map((seriesColor, index2) => {
          if (typeof seriesColor === "string") {
            return {
              color: seriesColor,
              percentage: (index2 + 1) * span
            };
          }
          return seriesColor;
        });
        const colors = seriesColors.sort((a2, b2) => a2.percentage - b2.percentage);
        for (const color22 of colors) {
          if (color22.percentage > percentage)
            return color22.color;
        }
        return (_a2 = colors[colors.length - 1]) == null ? void 0 : _a2.color;
      }
    };
    const slotData = computed(() => {
      return {
        percentage: props2.percentage
      };
    });
    return {
      ns,
      barStyle,
      relativeStrokeWidth,
      radius,
      trackPath,
      perimeter,
      rate,
      strokeDashoffset,
      trailPathStyle,
      circlePathStyle,
      stroke,
      statusIcon,
      progressTextSize,
      content,
      slotData
    };
  }
});
const _hoisted_1$k = ["aria-valuenow"];
const _hoisted_2$8 = { viewBox: "0 0 100 100" };
const _hoisted_3$5 = ["d", "stroke-width"];
const _hoisted_4$4 = ["d", "stroke", "stroke-linecap", "stroke-width"];
const _hoisted_5$4 = { key: 0 };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      _ctx.ns.b(),
      _ctx.ns.m(_ctx.type),
      _ctx.ns.is(_ctx.status),
      {
        [_ctx.ns.m("without-text")]: !_ctx.showText,
        [_ctx.ns.m("text-inside")]: _ctx.textInside
      }
    ]),
    role: "progressbar",
    "aria-valuenow": _ctx.percentage,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [
    _ctx.type === "line" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.ns.b("bar"))
    }, [
      createElementVNode("div", {
        class: normalizeClass(_ctx.ns.be("bar", "outer")),
        style: normalizeStyle$1({ height: `${_ctx.strokeWidth}px` })
      }, [
        createElementVNode("div", {
          class: normalizeClass([
            _ctx.ns.be("bar", "inner"),
            { [_ctx.ns.bem("bar", "inner", "indeterminate")]: _ctx.indeterminate }
          ]),
          style: normalizeStyle$1(_ctx.barStyle)
        }, [
          (_ctx.showText || _ctx.$slots.default) && _ctx.textInside ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.ns.be("bar", "innerText"))
          }, [
            renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)), () => [
              createElementVNode("span", null, toDisplayString(_ctx.content), 1)
            ])
          ], 2)) : createCommentVNode("v-if", true)
        ], 6)
      ], 6)
    ], 2)) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(_ctx.ns.b("circle")),
      style: normalizeStyle$1({ height: `${_ctx.width}px`, width: `${_ctx.width}px` })
    }, [
      (openBlock(), createElementBlock("svg", _hoisted_2$8, [
        createElementVNode("path", {
          class: normalizeClass(_ctx.ns.be("circle", "track")),
          d: _ctx.trackPath,
          stroke: "var(--el-fill-color-light, #e5e9f2)",
          "stroke-width": _ctx.relativeStrokeWidth,
          fill: "none",
          style: normalizeStyle$1(_ctx.trailPathStyle)
        }, null, 14, _hoisted_3$5),
        createElementVNode("path", {
          class: normalizeClass(_ctx.ns.be("circle", "path")),
          d: _ctx.trackPath,
          stroke: _ctx.stroke,
          fill: "none",
          "stroke-linecap": _ctx.strokeLinecap,
          "stroke-width": _ctx.percentage ? _ctx.relativeStrokeWidth : 0,
          style: normalizeStyle$1(_ctx.circlePathStyle)
        }, null, 14, _hoisted_4$4)
      ]))
    ], 6)),
    (_ctx.showText || _ctx.$slots.default) && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(_ctx.ns.e("text")),
      style: normalizeStyle$1({ fontSize: `${_ctx.progressTextSize}px` })
    }, [
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.slotData)), () => [
        !_ctx.status ? (openBlock(), createElementBlock("span", _hoisted_5$4, toDisplayString(_ctx.content), 1)) : (openBlock(), createBlock(_component_el_icon, { key: 1 }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.statusIcon)))
          ]),
          _: 1
        }))
      ])
    ], 6)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$k);
}
var Progress = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const ElProgress = withInstall(Progress);
const switchProps = buildProps({
  modelValue: {
    type: [Boolean, String, Number],
    default: false
  },
  value: {
    type: [Boolean, String, Number],
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  width: {
    type: Number,
    default: 40
  },
  inlinePrompt: {
    type: Boolean,
    default: false
  },
  activeIcon: {
    type: iconPropType,
    default: ""
  },
  inactiveIcon: {
    type: iconPropType,
    default: ""
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeColor: {
    type: String,
    default: ""
  },
  inactiveColor: {
    type: String,
    default: ""
  },
  borderColor: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: true
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: false
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  id: String,
  loading: {
    type: Boolean,
    default: false
  },
  beforeChange: {
    type: definePropType(Function)
  },
  size: {
    type: String,
    validator: isValidComponentSize
  }
});
const switchEmits = {
  [UPDATE_MODEL_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
  [CHANGE_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val),
  [INPUT_EVENT]: (val) => isBoolean(val) || isString(val) || isNumber(val)
};
const COMPONENT_NAME = "ElSwitch";
const _sfc_main$k = defineComponent({
  name: COMPONENT_NAME,
  components: { ElIcon, Loading: loading },
  props: switchProps,
  emits: switchEmits,
  setup(props2, { emit }) {
    const { formItem } = useFormItem();
    const switchDisabled = useDisabled$1(computed(() => props2.loading));
    const ns = useNamespace("switch");
    const switchSize = useSize();
    const isModelValue = ref(props2.modelValue !== false);
    const input = ref();
    const core = ref();
    const switchKls = computed(() => [
      ns.b(),
      ns.m(switchSize.value),
      ns.is("disabled", switchDisabled.value),
      ns.is("checked", checked2.value)
    ]);
    watch$1(() => props2.modelValue, () => {
      isModelValue.value = true;
    });
    watch$1(() => props2.value, () => {
      isModelValue.value = false;
    });
    const actualValue = computed(() => {
      return isModelValue.value ? props2.modelValue : props2.value;
    });
    const checked2 = computed(() => actualValue.value === props2.activeValue);
    if (![props2.activeValue, props2.inactiveValue].includes(actualValue.value)) {
      emit(UPDATE_MODEL_EVENT, props2.inactiveValue);
      emit(CHANGE_EVENT, props2.inactiveValue);
      emit(INPUT_EVENT, props2.inactiveValue);
    }
    watch$1(checked2, () => {
      var _a2;
      input.value.checked = checked2.value;
      if (props2.activeColor || props2.inactiveColor) {
        setBackgroundColor();
      }
      if (props2.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
      }
    });
    const handleChange = () => {
      const val = checked2.value ? props2.inactiveValue : props2.activeValue;
      emit(UPDATE_MODEL_EVENT, val);
      emit(CHANGE_EVENT, val);
      emit(INPUT_EVENT, val);
      nextTick$1(() => {
        input.value.checked = checked2.value;
      });
    };
    const switchValue = () => {
      if (switchDisabled.value)
        return;
      const { beforeChange } = props2;
      if (!beforeChange) {
        handleChange();
        return;
      }
      const shouldChange = beforeChange();
      const isExpectType = [
        isPromise(shouldChange),
        isBoolean(shouldChange)
      ].some((i) => i);
      if (!isExpectType) {
        throwError(COMPONENT_NAME, "beforeChange must return type `Promise<boolean>` or `boolean`");
      }
      if (isPromise(shouldChange)) {
        shouldChange.then((result) => {
          if (result) {
            handleChange();
          }
        }).catch((e2) => {
        });
      } else if (shouldChange) {
        handleChange();
      }
    };
    const setBackgroundColor = () => {
      const newColor = checked2.value ? props2.activeColor : props2.inactiveColor;
      const coreEl = core.value;
      if (props2.borderColor)
        coreEl.style.borderColor = props2.borderColor;
      else if (!props2.borderColor)
        coreEl.style.borderColor = newColor;
      coreEl.style.backgroundColor = newColor;
      coreEl.children[0].style.color = newColor;
    };
    const focus = () => {
      var _a2, _b2;
      (_b2 = (_a2 = input.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b2.call(_a2);
    };
    onMounted(() => {
      if (props2.activeColor || props2.inactiveColor || props2.borderColor) {
        setBackgroundColor();
      }
      input.value.checked = checked2.value;
    });
    return {
      ns,
      input,
      core,
      switchDisabled,
      checked: checked2,
      switchKls,
      handleChange,
      switchValue,
      focus
    };
  }
});
const _hoisted_1$j = ["aria-checked", "aria-disabled"];
const _hoisted_2$7 = ["id", "name", "true-value", "false-value", "disabled"];
const _hoisted_3$4 = ["aria-hidden"];
const _hoisted_4$3 = ["aria-hidden"];
const _hoisted_5$3 = ["aria-hidden"];
const _hoisted_6$2 = ["aria-hidden"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  const _component_loading = resolveComponent("loading");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.switchKls),
    role: "switch",
    "aria-checked": _ctx.checked,
    "aria-disabled": _ctx.switchDisabled,
    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["prevent"]))
  }, [
    createElementVNode("input", {
      id: _ctx.id,
      ref: "input",
      class: normalizeClass(_ctx.ns.e("input")),
      type: "checkbox",
      name: _ctx.name,
      "true-value": _ctx.activeValue,
      "false-value": _ctx.inactiveValue,
      disabled: _ctx.switchDisabled,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args)),
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.switchValue && _ctx.switchValue(...args), ["enter"]))
    }, null, 42, _hoisted_2$7),
    !_ctx.inlinePrompt && (_ctx.inactiveIcon || _ctx.inactiveText) ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass([
        _ctx.ns.e("label"),
        _ctx.ns.em("label", "left"),
        _ctx.ns.is("active", !_ctx.checked)
      ])
    }, [
      _ctx.inactiveIcon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
        ]),
        _: 1
      })) : createCommentVNode("v-if", true),
      !_ctx.inactiveIcon && _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
        key: 1,
        "aria-hidden": _ctx.checked
      }, toDisplayString(_ctx.inactiveText), 9, _hoisted_3$4)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true),
    createElementVNode("span", {
      ref: "core",
      class: normalizeClass(_ctx.ns.e("core")),
      style: normalizeStyle$1({ width: (_ctx.width || 40) + "px" })
    }, [
      _ctx.inlinePrompt ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.ns.e("inner"))
      }, [
        _ctx.activeIcon || _ctx.inactiveIcon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _ctx.activeIcon ? (openBlock(), createBlock(_component_el_icon, {
            key: 0,
            class: normalizeClass([_ctx.ns.is("icon"), _ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")])
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : createCommentVNode("v-if", true),
          _ctx.inactiveIcon ? (openBlock(), createBlock(_component_el_icon, {
            key: 1,
            class: normalizeClass([_ctx.ns.is("icon"), !_ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")])
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.inactiveIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : createCommentVNode("v-if", true)
        ], 64)) : _ctx.activeText || _ctx.inactiveIcon ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          _ctx.activeText ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass([_ctx.ns.is("text"), _ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")]),
            "aria-hidden": !_ctx.checked
          }, toDisplayString(_ctx.activeText.substring(0, 3)), 11, _hoisted_4$3)) : createCommentVNode("v-if", true),
          _ctx.inactiveText ? (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass([_ctx.ns.is("text"), !_ctx.checked ? _ctx.ns.is("show") : _ctx.ns.is("hide")]),
            "aria-hidden": _ctx.checked
          }, toDisplayString(_ctx.inactiveText.substring(0, 3)), 11, _hoisted_5$3)) : createCommentVNode("v-if", true)
        ], 64)) : createCommentVNode("v-if", true)
      ], 2)) : createCommentVNode("v-if", true),
      createElementVNode("div", {
        class: normalizeClass(_ctx.ns.e("action"))
      }, [
        _ctx.loading ? (openBlock(), createBlock(_component_el_icon, {
          key: 0,
          class: normalizeClass(_ctx.ns.is("loading"))
        }, {
          default: withCtx(() => [
            createVNode$1(_component_loading)
          ]),
          _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", true)
      ], 2)
    ], 6),
    !_ctx.inlinePrompt && (_ctx.activeIcon || _ctx.activeText) ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass([
        _ctx.ns.e("label"),
        _ctx.ns.em("label", "right"),
        _ctx.ns.is("active", _ctx.checked)
      ])
    }, [
      _ctx.activeIcon ? (openBlock(), createBlock(_component_el_icon, { key: 0 }, {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.activeIcon)))
        ]),
        _: 1
      })) : createCommentVNode("v-if", true),
      !_ctx.activeIcon && _ctx.activeText ? (openBlock(), createElementBlock("span", {
        key: 1,
        "aria-hidden": !_ctx.checked
      }, toDisplayString(_ctx.activeText), 9, _hoisted_6$2)) : createCommentVNode("v-if", true)
    ], 2)) : createCommentVNode("v-if", true)
  ], 10, _hoisted_1$j);
}
var Switch$1 = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
const ElSwitch = withInstall(Switch$1);
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml;
function escapeHtml(string) {
  var str = "" + string;
  var match = matchHtmlRegExp.exec(str);
  if (!match) {
    return str;
  }
  var escape;
  var html2 = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match.index; index2 < str.length; index2++) {
    switch (str.charCodeAt(index2)) {
      case 34:
        escape = "&quot;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html2 += str.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html2 += escape;
  }
  return lastIndex !== index2 ? html2 + str.substring(lastIndex, index2) : html2;
}
const getCell = function(event) {
  let cell = event.target;
  while (cell && cell.tagName.toUpperCase() !== "HTML") {
    if (cell.tagName.toUpperCase() === "TD") {
      return cell;
    }
    cell = cell.parentNode;
  }
  return null;
};
const isObject = function(obj) {
  return obj !== null && typeof obj === "object";
};
const orderBy = function(array, sortKey, reverse, sortMethod, sortBy) {
  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
    return array;
  }
  if (typeof reverse === "string") {
    reverse = reverse === "descending" ? -1 : 1;
  } else {
    reverse = reverse && reverse < 0 ? -1 : 1;
  }
  const getKey = sortMethod ? null : function(value, index2) {
    if (sortBy) {
      if (!Array.isArray(sortBy)) {
        sortBy = [sortBy];
      }
      return sortBy.map((by) => {
        if (typeof by === "string") {
          return get(value, by);
        } else {
          return by(value, index2, array);
        }
      });
    }
    if (sortKey !== "$key") {
      if (isObject(value) && "$value" in value)
        value = value.$value;
    }
    return [isObject(value) ? get(value, sortKey) : value];
  };
  const compare2 = function(a2, b2) {
    if (sortMethod) {
      return sortMethod(a2.value, b2.value);
    }
    for (let i = 0, len2 = a2.key.length; i < len2; i++) {
      if (a2.key[i] < b2.key[i]) {
        return -1;
      }
      if (a2.key[i] > b2.key[i]) {
        return 1;
      }
    }
    return 0;
  };
  return array.map((value, index2) => {
    return {
      value,
      index: index2,
      key: getKey ? getKey(value, index2) : null
    };
  }).sort((a2, b2) => {
    let order2 = compare2(a2, b2);
    if (!order2) {
      order2 = a2.index - b2.index;
    }
    return order2 * +reverse;
  }).map((item) => item.value);
};
const getColumnById = function(table, columnId) {
  let column = null;
  table.columns.forEach((item) => {
    if (item.id === columnId) {
      column = item;
    }
  });
  return column;
};
const getColumnByKey = function(table, columnKey) {
  let column = null;
  for (let i = 0; i < table.columns.length; i++) {
    const item = table.columns[i];
    if (item.columnKey === columnKey) {
      column = item;
      break;
    }
  }
  return column;
};
const getColumnByCell = function(table, cell, namespace) {
  const matches = (cell.className || "").match(new RegExp(`${namespace}-table_[^\\s]+`, "gm"));
  if (matches) {
    return getColumnById(table, matches[0]);
  }
  return null;
};
const getRowIdentity = (row, rowKey) => {
  if (!row)
    throw new Error("Row is required when get row identity");
  if (typeof rowKey === "string") {
    if (!rowKey.includes(".")) {
      return `${row[rowKey]}`;
    }
    const key2 = rowKey.split(".");
    let current = row;
    for (const element of key2) {
      current = current[element];
    }
    return `${current}`;
  } else if (typeof rowKey === "function") {
    return rowKey.call(null, row);
  }
};
const getKeysMap = function(array, rowKey) {
  const arrayMap2 = {};
  (array || []).forEach((row, index2) => {
    arrayMap2[getRowIdentity(row, rowKey)] = { row, index: index2 };
  });
  return arrayMap2;
};
function mergeOptions(defaults2, config) {
  const options = {};
  let key2;
  for (key2 in defaults2) {
    options[key2] = defaults2[key2];
  }
  for (key2 in config) {
    if (hasOwn(config, key2)) {
      const value = config[key2];
      if (typeof value !== "undefined") {
        options[key2] = value;
      }
    }
  }
  return options;
}
function parseWidth(width) {
  if (width === "")
    return width;
  if (width !== void 0) {
    width = Number.parseInt(width, 10);
    if (Number.isNaN(width)) {
      width = "";
    }
  }
  return width;
}
function parseMinWidth(minWidth) {
  if (minWidth === "")
    return minWidth;
  if (minWidth !== void 0) {
    minWidth = parseWidth(minWidth);
    if (Number.isNaN(minWidth)) {
      minWidth = 80;
    }
  }
  return minWidth;
}
function parseHeight(height) {
  if (typeof height === "number") {
    return height;
  }
  if (typeof height === "string") {
    if (/^\d+(?:px)?$/.test(height)) {
      return Number.parseInt(height, 10);
    } else {
      return height;
    }
  }
  return null;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function toggleRowStatus(statusArr, row, newVal) {
  let changed = false;
  const index2 = statusArr.indexOf(row);
  const included = index2 !== -1;
  const addRow = () => {
    statusArr.push(row);
    changed = true;
  };
  const removeRow = () => {
    statusArr.splice(index2, 1);
    changed = true;
  };
  if (typeof newVal === "boolean") {
    if (newVal && !included) {
      addRow();
    } else if (!newVal && included) {
      removeRow();
    }
  } else {
    if (included) {
      removeRow();
    } else {
      addRow();
    }
  }
  return changed;
}
function walkTreeNode(root2, cb, childrenKey = "children", lazyKey = "hasChildren") {
  const isNil2 = (array) => !(Array.isArray(array) && array.length);
  function _walker(parent2, children2, level) {
    cb(parent2, children2, level);
    children2.forEach((item) => {
      if (item[lazyKey]) {
        cb(item, null, level + 1);
        return;
      }
      const children22 = item[childrenKey];
      if (!isNil2(children22)) {
        _walker(item, children22, level + 1);
      }
    });
  }
  root2.forEach((item) => {
    if (item[lazyKey]) {
      cb(item, null, 0);
      return;
    }
    const children2 = item[childrenKey];
    if (!isNil2(children2)) {
      _walker(item, children2, 0);
    }
  });
}
let removePopper;
function createTablePopper(trigger2, popperContent, popperOptions2, tooltipEffect) {
  const { nextZIndex } = useZIndex();
  function renderContent() {
    const isLight = tooltipEffect === "light";
    const content2 = document.createElement("div");
    content2.className = `el-popper ${isLight ? "is-light" : "is-dark"}`;
    popperContent = escapeHtml_1(popperContent);
    content2.innerHTML = popperContent;
    content2.style.zIndex = String(nextZIndex());
    document.body.appendChild(content2);
    return content2;
  }
  function renderArrow() {
    const arrow22 = document.createElement("div");
    arrow22.className = "el-popper__arrow";
    return arrow22;
  }
  function showPopper() {
    popperInstance && popperInstance.update();
  }
  removePopper = function removePopper2() {
    try {
      popperInstance && popperInstance.destroy();
      content && document.body.removeChild(content);
      off(trigger2, "mouseenter", showPopper);
      off(trigger2, "mouseleave", removePopper2);
    } catch (e2) {
    }
  };
  let popperInstance = null;
  const content = renderContent();
  const arrow2 = renderArrow();
  content.appendChild(arrow2);
  popperInstance = createPopper(trigger2, content, __spreadValues({
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 8]
        }
      },
      {
        name: "arrow",
        options: {
          element: arrow2,
          padding: 10
        }
      }
    ]
  }, popperOptions2));
  on(trigger2, "mouseenter", showPopper);
  on(trigger2, "mouseleave", removePopper);
  return popperInstance;
}
const isFixedColumn = (index2, fixed, store, realColumns) => {
  let start2 = 0;
  let after = index2;
  if (realColumns) {
    if (realColumns[index2].colSpan > 1) {
      return {};
    }
    for (let i = 0; i < index2; i++) {
      start2 += realColumns[i].colSpan;
    }
    after = start2 + realColumns[index2].colSpan - 1;
  } else {
    start2 = index2;
  }
  let fixedLayout;
  const columns = store.states.columns;
  switch (fixed) {
    case "left":
      if (after < store.states.fixedLeafColumnsLength.value) {
        fixedLayout = "left";
      }
      break;
    case "right":
      if (start2 >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
        fixedLayout = "right";
      }
      break;
    default:
      if (after < store.states.fixedLeafColumnsLength.value) {
        fixedLayout = "left";
      } else if (start2 >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
        fixedLayout = "right";
      }
  }
  return fixedLayout ? {
    direction: fixedLayout,
    start: start2,
    after
  } : {};
};
const getFixedColumnsClass = (namespace, index2, fixed, store, realColumns) => {
  const classes2 = [];
  const { direction, start: start2 } = isFixedColumn(index2, fixed, store, realColumns);
  if (direction) {
    const isLeft = direction === "left";
    classes2.push(`${namespace}-fixed-column--${direction}`);
    if (isLeft && start2 === store.states.fixedLeafColumnsLength.value - 1) {
      classes2.push("is-last-column");
    } else if (!isLeft && start2 === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {
      classes2.push("is-first-column");
    }
  }
  return classes2;
};
function getOffset(offset2, column) {
  return offset2 + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);
}
const getFixedColumnOffset = (index2, fixed, store, realColumns) => {
  const { direction, start: start2 = 0 } = isFixedColumn(index2, fixed, store, realColumns);
  if (!direction) {
    return;
  }
  const styles2 = {};
  const isLeft = direction === "left";
  const columns = store.states.columns.value;
  if (isLeft) {
    styles2.left = columns.slice(0, index2).reduce(getOffset, 0);
  } else {
    styles2.right = columns.slice(start2 + 1).reverse().reduce(getOffset, 0);
  }
  return styles2;
};
const ensurePosition = (style, key2) => {
  if (!style)
    return;
  if (!Number.isNaN(style[key2])) {
    style[key2] = `${style[key2]}px`;
  }
};
function useExpand(watcherData) {
  const instance = getCurrentInstance();
  const defaultExpandAll = ref(false);
  const expandRows = ref([]);
  const updateExpandRows = () => {
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    if (defaultExpandAll.value) {
      expandRows.value = data.slice();
    } else if (rowKey) {
      const expandRowsMap = getKeysMap(expandRows.value, rowKey);
      expandRows.value = data.reduce((prev2, row) => {
        const rowId = getRowIdentity(row, rowKey);
        const rowInfo = expandRowsMap[rowId];
        if (rowInfo) {
          prev2.push(row);
        }
        return prev2;
      }, []);
    } else {
      expandRows.value = [];
    }
  };
  const toggleRowExpansion = (row, expanded) => {
    const changed = toggleRowStatus(expandRows.value, row, expanded);
    if (changed) {
      instance.emit("expand-change", row, expandRows.value.slice());
    }
  };
  const setExpandRowKeys = (rowKeys) => {
    instance.store.assertRowKey();
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    const keysMap = getKeysMap(data, rowKey);
    expandRows.value = rowKeys.reduce((prev2, cur) => {
      const info = keysMap[cur];
      if (info) {
        prev2.push(info.row);
      }
      return prev2;
    }, []);
  };
  const isRowExpanded = (row) => {
    const rowKey = watcherData.rowKey.value;
    if (rowKey) {
      const expandMap = getKeysMap(expandRows.value, rowKey);
      return !!expandMap[getRowIdentity(row, rowKey)];
    }
    return expandRows.value.includes(row);
  };
  return {
    updateExpandRows,
    toggleRowExpansion,
    setExpandRowKeys,
    isRowExpanded,
    states: {
      expandRows,
      defaultExpandAll
    }
  };
}
function useCurrent(watcherData) {
  const instance = getCurrentInstance();
  const _currentRowKey = ref(null);
  const currentRow = ref(null);
  const setCurrentRowKey = (key2) => {
    instance.store.assertRowKey();
    _currentRowKey.value = key2;
    setCurrentRowByKey(key2);
  };
  const restoreCurrentRowKey = () => {
    _currentRowKey.value = null;
  };
  const setCurrentRowByKey = (key2) => {
    const { data, rowKey } = watcherData;
    let _currentRow = null;
    if (rowKey.value) {
      _currentRow = (unref(data) || []).find((item) => getRowIdentity(item, rowKey.value) === key2);
    }
    currentRow.value = _currentRow;
    instance.emit("current-change", currentRow.value, null);
  };
  const updateCurrentRow = (_currentRow) => {
    const oldCurrentRow = currentRow.value;
    if (_currentRow && _currentRow !== oldCurrentRow) {
      currentRow.value = _currentRow;
      instance.emit("current-change", currentRow.value, oldCurrentRow);
      return;
    }
    if (!_currentRow && oldCurrentRow) {
      currentRow.value = null;
      instance.emit("current-change", null, oldCurrentRow);
    }
  };
  const updateCurrentRowData = () => {
    const rowKey = watcherData.rowKey.value;
    const data = watcherData.data.value || [];
    const oldCurrentRow = currentRow.value;
    if (!data.includes(oldCurrentRow) && oldCurrentRow) {
      if (rowKey) {
        const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
        setCurrentRowByKey(currentRowKey);
      } else {
        currentRow.value = null;
      }
      if (currentRow.value === null) {
        instance.emit("current-change", null, oldCurrentRow);
      }
    } else if (_currentRowKey.value) {
      setCurrentRowByKey(_currentRowKey.value);
      restoreCurrentRowKey();
    }
  };
  return {
    setCurrentRowKey,
    restoreCurrentRowKey,
    setCurrentRowByKey,
    updateCurrentRow,
    updateCurrentRowData,
    states: {
      _currentRowKey,
      currentRow
    }
  };
}
function useTree(watcherData) {
  const expandRowKeys = ref([]);
  const treeData = ref({});
  const indent = ref(16);
  const lazy = ref(false);
  const lazyTreeNodeMap = ref({});
  const lazyColumnIdentifier = ref("hasChildren");
  const childrenColumnName = ref("children");
  const instance = getCurrentInstance();
  const normalizedData = computed(() => {
    if (!watcherData.rowKey.value)
      return {};
    const data = watcherData.data.value || [];
    return normalize2(data);
  });
  const normalizedLazyNode = computed(() => {
    const rowKey = watcherData.rowKey.value;
    const keys2 = Object.keys(lazyTreeNodeMap.value);
    const res = {};
    if (!keys2.length)
      return res;
    keys2.forEach((key2) => {
      if (lazyTreeNodeMap.value[key2].length) {
        const item = { children: [] };
        lazyTreeNodeMap.value[key2].forEach((row) => {
          const currentRowKey = getRowIdentity(row, rowKey);
          item.children.push(currentRowKey);
          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
            res[currentRowKey] = { children: [] };
          }
        });
        res[key2] = item;
      }
    });
    return res;
  });
  const normalize2 = (data) => {
    const rowKey = watcherData.rowKey.value;
    const res = {};
    walkTreeNode(data, (parent2, children2, level) => {
      const parentId = getRowIdentity(parent2, rowKey);
      if (Array.isArray(children2)) {
        res[parentId] = {
          children: children2.map((row) => getRowIdentity(row, rowKey)),
          level
        };
      } else if (lazy.value) {
        res[parentId] = {
          children: [],
          lazy: true,
          level
        };
      }
    }, childrenColumnName.value, lazyColumnIdentifier.value);
    return res;
  };
  const updateTreeData = (ifChangeExpandRowKeys = false, ifExpandAll = ((_a2) => (_a2 = instance.store) == null ? void 0 : _a2.states.defaultExpandAll.value)()) => {
    var _a2;
    const nested = normalizedData.value;
    const normalizedLazyNode_ = normalizedLazyNode.value;
    const keys2 = Object.keys(nested);
    const newTreeData = {};
    if (keys2.length) {
      const oldTreeData = unref(treeData);
      const rootLazyRowKeys = [];
      const getExpanded = (oldValue, key2) => {
        if (ifChangeExpandRowKeys) {
          if (expandRowKeys.value) {
            return ifExpandAll || expandRowKeys.value.includes(key2);
          } else {
            return !!(ifExpandAll || (oldValue == null ? void 0 : oldValue.expanded));
          }
        } else {
          const included = ifExpandAll || expandRowKeys.value && expandRowKeys.value.includes(key2);
          return !!((oldValue == null ? void 0 : oldValue.expanded) || included);
        }
      };
      keys2.forEach((key2) => {
        const oldValue = oldTreeData[key2];
        const newValue = __spreadValues({}, nested[key2]);
        newValue.expanded = getExpanded(oldValue, key2);
        if (newValue.lazy) {
          const { loaded = false, loading: loading2 = false } = oldValue || {};
          newValue.loaded = !!loaded;
          newValue.loading = !!loading2;
          rootLazyRowKeys.push(key2);
        }
        newTreeData[key2] = newValue;
      });
      const lazyKeys = Object.keys(normalizedLazyNode_);
      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
        lazyKeys.forEach((key2) => {
          const oldValue = oldTreeData[key2];
          const lazyNodeChildren = normalizedLazyNode_[key2].children;
          if (rootLazyRowKeys.includes(key2)) {
            if (newTreeData[key2].children.length !== 0) {
              throw new Error("[ElTable]children must be an empty array.");
            }
            newTreeData[key2].children = lazyNodeChildren;
          } else {
            const { loaded = false, loading: loading2 = false } = oldValue || {};
            newTreeData[key2] = {
              lazy: true,
              loaded: !!loaded,
              loading: !!loading2,
              expanded: getExpanded(oldValue, key2),
              children: lazyNodeChildren,
              level: ""
            };
          }
        });
      }
    }
    treeData.value = newTreeData;
    (_a2 = instance.store) == null ? void 0 : _a2.updateTableScrollY();
  };
  watch$1(() => expandRowKeys.value, () => {
    updateTreeData(true);
  });
  watch$1(() => normalizedData.value, () => {
    updateTreeData();
  });
  watch$1(() => normalizedLazyNode.value, () => {
    updateTreeData();
  });
  const updateTreeExpandKeys = (value) => {
    expandRowKeys.value = value;
    updateTreeData();
  };
  const toggleTreeExpansion = (row, expanded) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id = getRowIdentity(row, rowKey);
    const data = id && treeData.value[id];
    if (id && data && "expanded" in data) {
      const oldExpanded = data.expanded;
      expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
      treeData.value[id].expanded = expanded;
      if (oldExpanded !== expanded) {
        instance.emit("expand-change", row, expanded);
      }
      instance.store.updateTableScrollY();
    }
  };
  const loadOrToggle = (row) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id = getRowIdentity(row, rowKey);
    const data = treeData.value[id];
    if (lazy.value && data && "loaded" in data && !data.loaded) {
      loadData(row, id, data);
    } else {
      toggleTreeExpansion(row, void 0);
    }
  };
  const loadData = (row, key2, treeNode) => {
    const { load } = instance.props;
    if (load && !treeData.value[key2].loaded) {
      treeData.value[key2].loading = true;
      load(row, treeNode, (data) => {
        if (!Array.isArray(data)) {
          throw new TypeError("[ElTable] data must be an array");
        }
        treeData.value[key2].loading = false;
        treeData.value[key2].loaded = true;
        treeData.value[key2].expanded = true;
        if (data.length) {
          lazyTreeNodeMap.value[key2] = data;
        }
        instance.emit("expand-change", row, true);
      });
    }
  };
  return {
    loadData,
    loadOrToggle,
    toggleTreeExpansion,
    updateTreeExpandKeys,
    updateTreeData,
    normalize: normalize2,
    states: {
      expandRowKeys,
      treeData,
      indent,
      lazy,
      lazyTreeNodeMap,
      lazyColumnIdentifier,
      childrenColumnName
    }
  };
}
const sortData = (data, states) => {
  const sortingColumn = states.sortingColumn;
  if (!sortingColumn || typeof sortingColumn.sortable === "string") {
    return data;
  }
  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};
const doFlattenColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.children) {
      result.push.apply(result, doFlattenColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
function useWatcher$1() {
  var _a2;
  const instance = getCurrentInstance();
  const { size: tableSize } = toRefs((_a2 = instance.proxy) == null ? void 0 : _a2.$props);
  const rowKey = ref(null);
  const data = ref([]);
  const _data = ref([]);
  const isComplex = ref(false);
  const _columns = ref([]);
  const originColumns = ref([]);
  const columns = ref([]);
  const fixedColumns = ref([]);
  const rightFixedColumns = ref([]);
  const leafColumns = ref([]);
  const fixedLeafColumns = ref([]);
  const rightFixedLeafColumns = ref([]);
  const leafColumnsLength = ref(0);
  const fixedLeafColumnsLength = ref(0);
  const rightFixedLeafColumnsLength = ref(0);
  const isAllSelected = ref(false);
  const selection = ref([]);
  const reserveSelection = ref(false);
  const selectOnIndeterminate = ref(false);
  const selectable = ref(null);
  const filters = ref({});
  const filteredData = ref(null);
  const sortingColumn = ref(null);
  const sortProp = ref(null);
  const sortOrder = ref(null);
  const hoverRow = ref(null);
  watch$1(data, () => instance.state && scheduleLayout(false), {
    deep: true
  });
  const assertRowKey = () => {
    if (!rowKey.value)
      throw new Error("[ElTable] prop row-key is required");
  };
  const updateColumns = () => {
    fixedColumns.value = _columns.value.filter((column) => column.fixed === true || column.fixed === "left");
    rightFixedColumns.value = _columns.value.filter((column) => column.fixed === "right");
    if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === "selection" && !_columns.value[0].fixed) {
      _columns.value[0].fixed = true;
      fixedColumns.value.unshift(_columns.value[0]);
    }
    const notFixedColumns = _columns.value.filter((column) => !column.fixed);
    originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
    const leafColumns2 = doFlattenColumns(notFixedColumns);
    const fixedLeafColumns2 = doFlattenColumns(fixedColumns.value);
    const rightFixedLeafColumns2 = doFlattenColumns(rightFixedColumns.value);
    leafColumnsLength.value = leafColumns2.length;
    fixedLeafColumnsLength.value = fixedLeafColumns2.length;
    rightFixedLeafColumnsLength.value = rightFixedLeafColumns2.length;
    columns.value = [].concat(fixedLeafColumns2).concat(leafColumns2).concat(rightFixedLeafColumns2);
    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
  };
  const scheduleLayout = (needUpdateColumns, immediate = false) => {
    if (needUpdateColumns) {
      updateColumns();
    }
    if (immediate) {
      instance.state.doLayout();
    } else {
      instance.state.debouncedUpdateLayout();
    }
  };
  const isSelected = (row) => {
    return selection.value.includes(row);
  };
  const clearSelection = () => {
    isAllSelected.value = false;
    const oldSelection = selection.value;
    if (oldSelection.length) {
      selection.value = [];
      instance.emit("selection-change", []);
    }
  };
  const cleanSelection = () => {
    let deleted;
    if (rowKey.value) {
      deleted = [];
      const selectedMap = getKeysMap(selection.value, rowKey.value);
      const dataMap = getKeysMap(data.value, rowKey.value);
      for (const key2 in selectedMap) {
        if (hasOwn(selectedMap, key2) && !dataMap[key2]) {
          deleted.push(selectedMap[key2].row);
        }
      }
    } else {
      deleted = selection.value.filter((item) => !data.value.includes(item));
    }
    if (deleted.length) {
      const newSelection = selection.value.filter((item) => !deleted.includes(item));
      selection.value = newSelection;
      instance.emit("selection-change", newSelection.slice());
    }
  };
  const getSelectionRows = () => {
    return (selection.value || []).slice();
  };
  const toggleRowSelection = (row, selected = void 0, emitChange = true) => {
    const changed = toggleRowStatus(selection.value, row, selected);
    if (changed) {
      const newSelection = (selection.value || []).slice();
      if (emitChange) {
        instance.emit("select", newSelection, row);
      }
      instance.emit("selection-change", newSelection);
    }
  };
  const _toggleAllSelection = () => {
    var _a22, _b2;
    const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
    isAllSelected.value = value;
    let selectionChanged = false;
    let childrenCount = 0;
    const rowKey2 = (_b2 = (_a22 = instance == null ? void 0 : instance.store) == null ? void 0 : _a22.states) == null ? void 0 : _b2.rowKey.value;
    data.value.forEach((row, index2) => {
      const rowIndex = index2 + childrenCount;
      if (selectable.value) {
        if (selectable.value.call(null, row, rowIndex) && toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      } else {
        if (toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      }
      childrenCount += getChildrenCount(getRowIdentity(row, rowKey2));
    });
    if (selectionChanged) {
      instance.emit("selection-change", selection.value ? selection.value.slice() : []);
    }
    instance.emit("select-all", selection.value);
  };
  const updateSelectionByRowKey = () => {
    const selectedMap = getKeysMap(selection.value, rowKey.value);
    data.value.forEach((row) => {
      const rowId = getRowIdentity(row, rowKey.value);
      const rowInfo = selectedMap[rowId];
      if (rowInfo) {
        selection.value[rowInfo.index] = row;
      }
    });
  };
  const updateAllSelected = () => {
    var _a22, _b2, _c2;
    if (((_a22 = data.value) == null ? void 0 : _a22.length) === 0) {
      isAllSelected.value = false;
      return;
    }
    let selectedMap;
    if (rowKey.value) {
      selectedMap = getKeysMap(selection.value, rowKey.value);
    }
    const isSelected2 = function(row) {
      if (selectedMap) {
        return !!selectedMap[getRowIdentity(row, rowKey.value)];
      } else {
        return selection.value.includes(row);
      }
    };
    let isAllSelected_ = true;
    let selectedCount = 0;
    let childrenCount = 0;
    for (let i = 0, j = (data.value || []).length; i < j; i++) {
      const keyProp = (_c2 = (_b2 = instance == null ? void 0 : instance.store) == null ? void 0 : _b2.states) == null ? void 0 : _c2.rowKey.value;
      const rowIndex = i + childrenCount;
      const item = data.value[i];
      const isRowSelectable = selectable.value && selectable.value.call(null, item, rowIndex);
      if (!isSelected2(item)) {
        if (!selectable.value || isRowSelectable) {
          isAllSelected_ = false;
          break;
        }
      } else {
        selectedCount++;
      }
      childrenCount += getChildrenCount(getRowIdentity(item, keyProp));
    }
    if (selectedCount === 0)
      isAllSelected_ = false;
    isAllSelected.value = isAllSelected_;
  };
  const getChildrenCount = (rowKey2) => {
    var _a22;
    if (!instance || !instance.store)
      return 0;
    const { treeData } = instance.store.states;
    let count2 = 0;
    const children2 = (_a22 = treeData.value[rowKey2]) == null ? void 0 : _a22.children;
    if (children2) {
      count2 += children2.length;
      children2.forEach((childKey) => {
        count2 += getChildrenCount(childKey);
      });
    }
    return count2;
  };
  const updateFilters = (columns2, values) => {
    if (!Array.isArray(columns2)) {
      columns2 = [columns2];
    }
    const filters_ = {};
    columns2.forEach((col) => {
      filters.value[col.id] = values;
      filters_[col.columnKey || col.id] = values;
    });
    return filters_;
  };
  const updateSort = (column, prop, order2) => {
    if (sortingColumn.value && sortingColumn.value !== column) {
      sortingColumn.value.order = null;
    }
    sortingColumn.value = column;
    sortProp.value = prop;
    sortOrder.value = order2;
  };
  const execFilter = () => {
    let sourceData = unref(_data);
    Object.keys(filters.value).forEach((columnId) => {
      const values = filters.value[columnId];
      if (!values || values.length === 0)
        return;
      const column = getColumnById({
        columns: columns.value
      }, columnId);
      if (column && column.filterMethod) {
        sourceData = sourceData.filter((row) => {
          return values.some((value) => column.filterMethod.call(null, value, row, column));
        });
      }
    });
    filteredData.value = sourceData;
  };
  const execSort = () => {
    data.value = sortData(filteredData.value, {
      sortingColumn: sortingColumn.value,
      sortProp: sortProp.value,
      sortOrder: sortOrder.value
    });
  };
  const execQuery = (ignore = void 0) => {
    if (!(ignore && ignore.filter)) {
      execFilter();
    }
    execSort();
  };
  const clearFilter = (columnKeys) => {
    const { tableHeaderRef } = instance.refs;
    if (!tableHeaderRef)
      return;
    const panels = Object.assign({}, tableHeaderRef.filterPanels);
    const keys2 = Object.keys(panels);
    if (!keys2.length)
      return;
    if (typeof columnKeys === "string") {
      columnKeys = [columnKeys];
    }
    if (Array.isArray(columnKeys)) {
      const columns_ = columnKeys.map((key2) => getColumnByKey({
        columns: columns.value
      }, key2));
      keys2.forEach((key2) => {
        const column = columns_.find((col) => col.id === key2);
        if (column) {
          column.filteredValue = [];
        }
      });
      instance.store.commit("filterChange", {
        column: columns_,
        values: [],
        silent: true,
        multi: true
      });
    } else {
      keys2.forEach((key2) => {
        const column = columns.value.find((col) => col.id === key2);
        if (column) {
          column.filteredValue = [];
        }
      });
      filters.value = {};
      instance.store.commit("filterChange", {
        column: {},
        values: [],
        silent: true
      });
    }
  };
  const clearSort = () => {
    if (!sortingColumn.value)
      return;
    updateSort(null, null, null);
    instance.store.commit("changeSortCondition", {
      silent: true
    });
  };
  const {
    setExpandRowKeys,
    toggleRowExpansion,
    updateExpandRows,
    states: expandStates,
    isRowExpanded
  } = useExpand({
    data,
    rowKey
  });
  const {
    updateTreeExpandKeys,
    toggleTreeExpansion,
    updateTreeData,
    loadOrToggle,
    states: treeStates
  } = useTree({
    data,
    rowKey
  });
  const {
    updateCurrentRowData,
    updateCurrentRow,
    setCurrentRowKey,
    states: currentData
  } = useCurrent({
    data,
    rowKey
  });
  const setExpandRowKeysAdapter = (val) => {
    setExpandRowKeys(val);
    updateTreeExpandKeys(val);
  };
  const toggleRowExpansionAdapter = (row, expanded) => {
    const hasExpandColumn = columns.value.some(({ type }) => type === "expand");
    if (hasExpandColumn) {
      toggleRowExpansion(row, expanded);
    } else {
      toggleTreeExpansion(row, expanded);
    }
  };
  return {
    assertRowKey,
    updateColumns,
    scheduleLayout,
    isSelected,
    clearSelection,
    cleanSelection,
    getSelectionRows,
    toggleRowSelection,
    _toggleAllSelection,
    toggleAllSelection: null,
    updateSelectionByRowKey,
    updateAllSelected,
    updateFilters,
    updateCurrentRow,
    updateSort,
    execFilter,
    execSort,
    execQuery,
    clearFilter,
    clearSort,
    toggleRowExpansion,
    setExpandRowKeysAdapter,
    setCurrentRowKey,
    toggleRowExpansionAdapter,
    isRowExpanded,
    updateExpandRows,
    updateCurrentRowData,
    loadOrToggle,
    updateTreeData,
    states: __spreadValues(__spreadValues(__spreadValues({
      tableSize,
      rowKey,
      data,
      _data,
      isComplex,
      _columns,
      originColumns,
      columns,
      fixedColumns,
      rightFixedColumns,
      leafColumns,
      fixedLeafColumns,
      rightFixedLeafColumns,
      leafColumnsLength,
      fixedLeafColumnsLength,
      rightFixedLeafColumnsLength,
      isAllSelected,
      selection,
      reserveSelection,
      selectOnIndeterminate,
      selectable,
      filters,
      filteredData,
      sortingColumn,
      sortProp,
      sortOrder,
      hoverRow
    }, expandStates), treeStates), currentData)
  };
}
function replaceColumn(array, column) {
  return array.map((item) => {
    var _a2;
    if (item.id === column.id) {
      return column;
    } else if ((_a2 = item.children) == null ? void 0 : _a2.length) {
      item.children = replaceColumn(item.children, column);
    }
    return item;
  });
}
function sortColumn(array) {
  array.forEach((item) => {
    var _a2, _b2;
    item.no = (_a2 = item.getColumnIndex) == null ? void 0 : _a2.call(item);
    if ((_b2 = item.children) == null ? void 0 : _b2.length) {
      sortColumn(item.children);
    }
  });
  array.sort((cur, pre) => cur.no - pre.no);
}
function useStore() {
  const instance = getCurrentInstance();
  const watcher = useWatcher$1();
  const ns = useNamespace("table");
  const mutations = {
    setData(states, data) {
      const dataInstanceChanged = unref(states._data) !== data;
      states.data.value = data;
      states._data.value = data;
      instance.store.execQuery();
      instance.store.updateCurrentRowData();
      instance.store.updateExpandRows();
      instance.store.updateTreeData(instance.store.states.defaultExpandAll.value);
      if (unref(states.reserveSelection)) {
        instance.store.assertRowKey();
        instance.store.updateSelectionByRowKey();
      } else {
        if (dataInstanceChanged) {
          instance.store.clearSelection();
        } else {
          instance.store.cleanSelection();
        }
      }
      instance.store.updateAllSelected();
      if (instance.$ready) {
        instance.store.scheduleLayout();
      }
    },
    insertColumn(states, column, parent2) {
      const array = unref(states._columns);
      let newColumns = [];
      if (!parent2) {
        array.push(column);
        newColumns = array;
      } else {
        if (parent2 && !parent2.children) {
          parent2.children = [];
        }
        parent2.children.push(column);
        newColumns = replaceColumn(array, parent2);
      }
      sortColumn(newColumns);
      states._columns.value = newColumns;
      if (column.type === "selection") {
        states.selectable.value = column.selectable;
        states.reserveSelection.value = column.reserveSelection;
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    removeColumn(states, column, parent2) {
      const array = unref(states._columns) || [];
      if (parent2) {
        parent2.children.splice(parent2.children.findIndex((item) => item.id === column.id), 1);
        if (parent2.children.length === 0) {
          delete parent2.children;
        }
        states._columns.value = replaceColumn(array, parent2);
      } else {
        const index2 = array.indexOf(column);
        if (index2 > -1) {
          array.splice(index2, 1);
          states._columns.value = array;
        }
      }
      if (instance.$ready) {
        instance.store.updateColumns();
        instance.store.scheduleLayout();
      }
    },
    sort(states, options) {
      const { prop, order: order2, init: init2 } = options;
      if (prop) {
        const column = unref(states.columns).find((column2) => column2.property === prop);
        if (column) {
          column.order = order2;
          instance.store.updateSort(column, prop, order2);
          instance.store.commit("changeSortCondition", { init: init2 });
        }
      }
    },
    changeSortCondition(states, options) {
      const { sortingColumn: column, sortProp: prop, sortOrder: order2 } = states;
      if (unref(order2) === null) {
        states.sortingColumn.value = null;
        states.sortProp.value = null;
      }
      const ingore = { filter: true };
      instance.store.execQuery(ingore);
      if (!options || !(options.silent || options.init)) {
        instance.emit("sort-change", {
          column: unref(column),
          prop: unref(prop),
          order: unref(order2)
        });
      }
      instance.store.updateTableScrollY();
    },
    filterChange(_states, options) {
      const { column, values, silent } = options;
      const newFilters = instance.store.updateFilters(column, values);
      instance.store.execQuery();
      if (!silent) {
        instance.emit("filter-change", newFilters);
      }
      instance.store.updateTableScrollY();
    },
    toggleAllSelection() {
      instance.store.toggleAllSelection();
    },
    rowSelectedChanged(_states, row) {
      instance.store.toggleRowSelection(row);
      instance.store.updateAllSelected();
    },
    setHoverRow(states, row) {
      states.hoverRow.value = row;
    },
    setCurrentRow(_states, row) {
      instance.store.updateCurrentRow(row);
    }
  };
  const commit = function(name, ...args) {
    const mutations2 = instance.store.mutations;
    if (mutations2[name]) {
      mutations2[name].apply(instance, [instance.store.states].concat(args));
    } else {
      throw new Error(`Action not found: ${name}`);
    }
  };
  const updateTableScrollY = function() {
    nextTick$1(() => instance.layout.updateScrollY.apply(instance.layout));
  };
  return __spreadProps(__spreadValues({
    ns
  }, watcher), {
    mutations,
    commit,
    updateTableScrollY
  });
}
const InitialStateMap = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  data: "data",
  ["treeProps.hasChildren"]: {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  ["treeProps.children"]: {
    key: "childrenColumnName",
    default: "children"
  }
};
function createStore(table, props2) {
  if (!table) {
    throw new Error("Table is required.");
  }
  const store = useStore();
  store.toggleAllSelection = debounce$1(store._toggleAllSelection, 10);
  Object.keys(InitialStateMap).forEach((key2) => {
    handleValue(getArrKeysValue(props2, key2), key2, store);
  });
  proxyTableProps(store, props2);
  return store;
}
function proxyTableProps(store, props2) {
  Object.keys(InitialStateMap).forEach((key2) => {
    watch$1(() => getArrKeysValue(props2, key2), (value) => {
      handleValue(value, key2, store);
    });
  });
}
function handleValue(value, propsKey, store) {
  let newVal = value;
  let storeKey = InitialStateMap[propsKey];
  if (typeof InitialStateMap[propsKey] === "object") {
    storeKey = storeKey.key;
    newVal = newVal || InitialStateMap[propsKey].default;
  }
  store.states[storeKey].value = newVal;
}
function getArrKeysValue(props2, keys2) {
  if (keys2.includes(".")) {
    const keyList = keys2.split(".");
    let value = props2;
    keyList.forEach((key2) => {
      value = value[key2];
    });
    return value;
  } else {
    return props2[keys2];
  }
}
class TableLayout {
  constructor(options) {
    this.observers = [];
    this.table = null;
    this.store = null;
    this.columns = [];
    this.fit = true;
    this.showHeader = true;
    this.height = ref(null);
    this.scrollX = ref(false);
    this.scrollY = ref(false);
    this.bodyWidth = ref(null);
    this.fixedWidth = ref(null);
    this.rightFixedWidth = ref(null);
    this.tableHeight = ref(null);
    this.headerHeight = ref(44);
    this.appendHeight = ref(0);
    this.footerHeight = ref(44);
    this.viewportHeight = ref(null);
    this.bodyHeight = ref(null);
    this.bodyScrollHeight = ref(0);
    this.fixedBodyHeight = ref(null);
    this.gutterWidth = 0;
    for (const name in options) {
      if (hasOwn(options, name)) {
        if (isRef(this[name])) {
          this[name].value = options[name];
        } else {
          this[name] = options[name];
        }
      }
    }
    if (!this.table) {
      throw new Error("Table is required for Table Layout");
    }
    if (!this.store) {
      throw new Error("Store is required for Table Layout");
    }
  }
  updateScrollY() {
    const height = this.height.value;
    if (height === null)
      return false;
    const bodyWrapper = this.table.refs.bodyWrapper;
    if (this.table.vnode.el && bodyWrapper) {
      let scrollY = true;
      const prevScrollY = this.scrollY.value;
      if (this.bodyHeight.value === null) {
        scrollY = false;
      } else {
        scrollY = bodyWrapper.scrollHeight > this.bodyHeight.value;
      }
      this.scrollY.value = scrollY;
      return prevScrollY !== scrollY;
    }
    return false;
  }
  setHeight(value, prop = "height") {
    if (!isClient)
      return;
    const el = this.table.vnode.el;
    value = parseHeight(value);
    this.height.value = Number(value);
    if (!el && (value || value === 0))
      return nextTick$1(() => this.setHeight(value, prop));
    if (typeof value === "number") {
      el.style[prop] = `${value}px`;
      this.updateElsHeight();
    } else if (typeof value === "string") {
      el.style[prop] = value;
      this.updateElsHeight();
    }
  }
  setMaxHeight(value) {
    this.setHeight(value, "max-height");
  }
  getFlattenColumns() {
    const flattenColumns = [];
    const columns = this.table.store.states.columns.value;
    columns.forEach((column) => {
      if (column.isColumnGroup) {
        flattenColumns.push.apply(flattenColumns, column.columns);
      } else {
        flattenColumns.push(column);
      }
    });
    return flattenColumns;
  }
  updateElsHeight() {
    var _a2, _b2;
    if (!this.table.$ready)
      return nextTick$1(() => this.updateElsHeight());
    const {
      tableWrapper,
      headerWrapper,
      appendWrapper,
      footerWrapper,
      tableHeader,
      tableBody
    } = this.table.refs;
    if (tableWrapper && tableWrapper.style.display === "none") {
      return;
    }
    const { tableLayout } = this.table.props;
    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;
    if (this.showHeader && !headerWrapper && tableLayout === "fixed") {
      return;
    }
    const headerTrElm = tableHeader ? tableHeader : null;
    const noneHeader = this.headerDisplayNone(headerTrElm);
    const headerWrapperOffsetHeight = (headerWrapper == null ? void 0 : headerWrapper.offsetHeight) || 0;
    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapperOffsetHeight;
    if (this.showHeader && !noneHeader && headerWrapperOffsetHeight > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {
      return nextTick$1(() => this.updateElsHeight());
    }
    const tableHeight = this.tableHeight.value = (_b2 = (_a2 = this.table) == null ? void 0 : _a2.vnode.el) == null ? void 0 : _b2.clientHeight;
    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;
    if (this.height.value !== null) {
      if (this.bodyHeight.value === null) {
        requestAnimationFrame(() => this.updateElsHeight());
      }
      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
      this.bodyScrollHeight.value = tableBody == null ? void 0 : tableBody.scrollHeight;
    }
    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;
    this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;
    this.updateScrollY();
    this.notifyObservers("scrollable");
  }
  headerDisplayNone(elm) {
    if (!elm)
      return true;
    let headerChild = elm;
    while (headerChild.tagName !== "DIV") {
      if (getComputedStyle(headerChild).display === "none") {
        return true;
      }
      headerChild = headerChild.parentElement;
    }
    return false;
  }
  updateColumnsWidth() {
    if (!isClient)
      return;
    const fit = this.fit;
    const bodyWidth = this.table.vnode.el.clientWidth;
    let bodyMinWidth = 0;
    const flattenColumns = this.getFlattenColumns();
    const flexColumns = flattenColumns.filter((column) => typeof column.width !== "number");
    flattenColumns.forEach((column) => {
      if (typeof column.width === "number" && column.realWidth)
        column.realWidth = null;
    });
    if (flexColumns.length > 0 && fit) {
      flattenColumns.forEach((column) => {
        bodyMinWidth += Number(column.width || column.minWidth || 80);
      });
      if (bodyMinWidth <= bodyWidth) {
        this.scrollX.value = false;
        const totalFlexWidth = bodyWidth - bodyMinWidth;
        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;
        } else {
          const allColumnsWidth = flexColumns.reduce((prev2, column) => prev2 + Number(column.minWidth || 80), 0);
          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
          let noneFirstWidth = 0;
          flexColumns.forEach((column, index2) => {
            if (index2 === 0)
              return;
            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);
            noneFirstWidth += flexWidth;
            column.realWidth = Number(column.minWidth || 80) + flexWidth;
          });
          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
        }
      } else {
        this.scrollX.value = true;
        flexColumns.forEach((column) => {
          column.realWidth = Number(column.minWidth);
        });
      }
      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
      this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else {
      flattenColumns.forEach((column) => {
        if (!column.width && !column.minWidth) {
          column.realWidth = 80;
        } else {
          column.realWidth = Number(column.width || column.minWidth);
        }
        bodyMinWidth += column.realWidth;
      });
      this.scrollX.value = bodyMinWidth > bodyWidth;
      this.bodyWidth.value = bodyMinWidth;
    }
    const fixedColumns = this.store.states.fixedColumns.value;
    if (fixedColumns.length > 0) {
      let fixedWidth = 0;
      fixedColumns.forEach((column) => {
        fixedWidth += Number(column.realWidth || column.width);
      });
      this.fixedWidth.value = fixedWidth;
    }
    const rightFixedColumns = this.store.states.rightFixedColumns.value;
    if (rightFixedColumns.length > 0) {
      let rightFixedWidth = 0;
      rightFixedColumns.forEach((column) => {
        rightFixedWidth += Number(column.realWidth || column.width);
      });
      this.rightFixedWidth.value = rightFixedWidth;
    }
    this.notifyObservers("columns");
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  removeObserver(observer) {
    const index2 = this.observers.indexOf(observer);
    if (index2 !== -1) {
      this.observers.splice(index2, 1);
    }
  }
  notifyObservers(event) {
    const observers = this.observers;
    observers.forEach((observer) => {
      var _a2, _b2;
      switch (event) {
        case "columns":
          (_a2 = observer.state) == null ? void 0 : _a2.onColumnsChange(this);
          break;
        case "scrollable":
          (_b2 = observer.state) == null ? void 0 : _b2.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${event}.`);
      }
    });
  }
}
const { CheckboxGroup: ElCheckboxGroup } = ElCheckbox;
const _sfc_main$j = defineComponent({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox,
    ElCheckboxGroup,
    ElScrollbar,
    ElTooltip,
    ElIcon,
    ArrowDown: arrowDown,
    ArrowUp: arrowUp
  },
  directives: { ClickOutside },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const { t } = useLocale();
    const ns = useNamespace("table-filter");
    const parent2 = instance == null ? void 0 : instance.parent;
    if (!parent2.filterPanels.value[props2.column.id]) {
      parent2.filterPanels.value[props2.column.id] = instance;
    }
    const tooltipVisible = ref(false);
    const tooltip = ref(null);
    const filters = computed(() => {
      return props2.column && props2.column.filters;
    });
    const filterValue = computed({
      get: () => {
        var _a2;
        return (((_a2 = props2.column) == null ? void 0 : _a2.filteredValue) || [])[0];
      },
      set: (value) => {
        if (filteredValue.value) {
          if (typeof value !== "undefined" && value !== null) {
            filteredValue.value.splice(0, 1, value);
          } else {
            filteredValue.value.splice(0, 1);
          }
        }
      }
    });
    const filteredValue = computed({
      get() {
        if (props2.column) {
          return props2.column.filteredValue || [];
        }
        return [];
      },
      set(value) {
        if (props2.column) {
          props2.upDataColumn("filteredValue", value);
        }
      }
    });
    const multiple = computed(() => {
      if (props2.column) {
        return props2.column.filterMultiple;
      }
      return true;
    });
    const isActive = (filter2) => {
      return filter2.value === filterValue.value;
    };
    const hidden = () => {
      tooltipVisible.value = false;
    };
    const showFilterPanel = (e2) => {
      e2.stopPropagation();
      tooltipVisible.value = !tooltipVisible.value;
    };
    const hideFilterPanel = () => {
      tooltipVisible.value = false;
    };
    const handleConfirm = () => {
      confirmFilter(filteredValue.value);
      hidden();
    };
    const handleReset = () => {
      filteredValue.value = [];
      confirmFilter(filteredValue.value);
      hidden();
    };
    const handleSelect = (_filterValue) => {
      filterValue.value = _filterValue;
      if (typeof _filterValue !== "undefined" && _filterValue !== null) {
        confirmFilter(filteredValue.value);
      } else {
        confirmFilter([]);
      }
      hidden();
    };
    const confirmFilter = (filteredValue2) => {
      props2.store.commit("filterChange", {
        column: props2.column,
        values: filteredValue2
      });
      props2.store.updateAllSelected();
    };
    watch$1(tooltipVisible, (value) => {
      if (props2.column) {
        props2.upDataColumn("filterOpened", value);
      }
    }, {
      immediate: true
    });
    const popperPaneRef = computed(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = tooltip.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b2.contentRef;
    });
    return {
      tooltipVisible,
      multiple,
      filteredValue,
      filterValue,
      filters,
      handleConfirm,
      handleReset,
      handleSelect,
      isActive,
      t,
      ns,
      showFilterPanel,
      hideFilterPanel,
      popperPaneRef,
      tooltip
    };
  }
});
const _hoisted_1$i = { key: 0 };
const _hoisted_2$6 = ["disabled"];
const _hoisted_3$3 = ["label", "onClick"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_arrow_up = resolveComponent("arrow-up");
  const _component_arrow_down = resolveComponent("arrow-down");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_tooltip = resolveComponent("el-tooltip");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createBlock(_component_el_tooltip, {
    ref: "tooltip",
    visible: _ctx.tooltipVisible,
    "onUpdate:visible": _cache[5] || (_cache[5] = ($event) => _ctx.tooltipVisible = $event),
    offset: 0,
    placement: _ctx.placement,
    "show-arrow": false,
    "stop-popper-mouse-event": false,
    "append-to-body": "",
    effect: "light",
    pure: "",
    "popper-class": _ctx.ns.b(),
    persistent: ""
  }, {
    content: withCtx(() => [
      _ctx.multiple ? (openBlock(), createElementBlock("div", _hoisted_1$i, [
        createElementVNode("div", {
          class: normalizeClass(_ctx.ns.e("content"))
        }, [
          createVNode$1(_component_el_scrollbar, {
            "wrap-class": _ctx.ns.e("wrap")
          }, {
            default: withCtx(() => [
              createVNode$1(_component_el_checkbox_group, {
                modelValue: _ctx.filteredValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.filteredValue = $event),
                class: normalizeClass(_ctx.ns.e("checkbox-group"))
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter2) => {
                    return openBlock(), createBlock(_component_el_checkbox, {
                      key: filter2.value,
                      label: filter2.value
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(filter2.text), 1)
                      ]),
                      _: 2
                    }, 1032, ["label"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue", "class"])
            ]),
            _: 1
          }, 8, ["wrap-class"])
        ], 2),
        createElementVNode("div", {
          class: normalizeClass(_ctx.ns.e("bottom"))
        }, [
          createElementVNode("button", {
            class: normalizeClass({ [_ctx.ns.is("disabled")]: _ctx.filteredValue.length === 0 }),
            disabled: _ctx.filteredValue.length === 0,
            type: "button",
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleConfirm && _ctx.handleConfirm(...args))
          }, toDisplayString(_ctx.t("el.table.confirmFilter")), 11, _hoisted_2$6),
          createElementVNode("button", {
            type: "button",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleReset && _ctx.handleReset(...args))
          }, toDisplayString(_ctx.t("el.table.resetFilter")), 1)
        ], 2)
      ])) : (openBlock(), createElementBlock("ul", {
        key: 1,
        class: normalizeClass(_ctx.ns.e("list"))
      }, [
        createElementVNode("li", {
          class: normalizeClass([
            _ctx.ns.e("list-item"),
            {
              [_ctx.ns.is("active")]: _ctx.filterValue === void 0 || _ctx.filterValue === null
            }
          ]),
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleSelect(null))
        }, toDisplayString(_ctx.t("el.table.clearFilter")), 3),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filters, (filter2) => {
          return openBlock(), createElementBlock("li", {
            key: filter2.value,
            class: normalizeClass([_ctx.ns.e("list-item"), _ctx.ns.is("active", _ctx.isActive(filter2))]),
            label: filter2.value,
            onClick: ($event) => _ctx.handleSelect(filter2.value)
          }, toDisplayString(filter2.text), 11, _hoisted_3$3);
        }), 128))
      ], 2))
    ]),
    default: withCtx(() => [
      withDirectives((openBlock(), createElementBlock("span", {
        class: normalizeClass([
          `${_ctx.ns.namespace.value}-table__column-filter-trigger`,
          `${_ctx.ns.namespace.value}-none-outline`
        ]),
        onClick: _cache[4] || (_cache[4] = (...args) => _ctx.showFilterPanel && _ctx.showFilterPanel(...args))
      }, [
        createVNode$1(_component_el_icon, null, {
          default: withCtx(() => [
            _ctx.column.filterOpened ? (openBlock(), createBlock(_component_arrow_up, { key: 0 })) : (openBlock(), createBlock(_component_arrow_down, { key: 1 }))
          ]),
          _: 1
        })
      ], 2)), [
        [_directive_click_outside, _ctx.hideFilterPanel, _ctx.popperPaneRef]
      ])
    ]),
    _: 1
  }, 8, ["visible", "placement", "popper-class"]);
}
var FilterPanel = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
function useLayoutObserver(root2) {
  const instance = getCurrentInstance();
  onBeforeMount(() => {
    tableLayout.value.addObserver(instance);
  });
  onMounted(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUpdated(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUnmounted(() => {
    tableLayout.value.removeObserver(instance);
  });
  const tableLayout = computed(() => {
    const layout2 = root2.layout;
    if (!layout2) {
      throw new Error("Can not find table layout.");
    }
    return layout2;
  });
  const onColumnsChange = (layout2) => {
    var _a2;
    const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col")) || [];
    if (!cols.length)
      return;
    const flattenColumns = layout2.getFlattenColumns();
    const columnsMap = {};
    flattenColumns.forEach((column) => {
      columnsMap[column.id] = column;
    });
    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      const name = col.getAttribute("name");
      const column = columnsMap[name];
      if (column) {
        col.setAttribute("width", column.realWidth || column.width);
      }
    }
  };
  const onScrollableChange = (layout2) => {
    var _a2, _b2;
    const cols = ((_a2 = root2.vnode.el) == null ? void 0 : _a2.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let i = 0, j = cols.length; i < j; i++) {
      const col = cols[i];
      col.setAttribute("width", layout2.scrollY.value ? layout2.gutterWidth : "0");
    }
    const ths = ((_b2 = root2.vnode.el) == null ? void 0 : _b2.querySelectorAll("th.gutter")) || [];
    for (let i = 0, j = ths.length; i < j; i++) {
      const th = ths[i];
      th.style.width = layout2.scrollY.value ? `${layout2.gutterWidth}px` : "0";
      th.style.display = layout2.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: tableLayout.value,
    onColumnsChange,
    onScrollableChange
  };
}
const TABLE_INJECTION_KEY = Symbol("ElTable");
function useEvent(props2, emit) {
  const instance = getCurrentInstance();
  const parent2 = inject(TABLE_INJECTION_KEY);
  const handleFilterClick = (event) => {
    event.stopPropagation();
    return;
  };
  const handleHeaderClick = (event, column) => {
    if (!column.filters && column.sortable) {
      handleSortClick(event, column, false);
    } else if (column.filterable && !column.sortable) {
      handleFilterClick(event);
    }
    parent2 == null ? void 0 : parent2.emit("header-click", column, event);
  };
  const handleHeaderContextMenu = (event, column) => {
    parent2 == null ? void 0 : parent2.emit("header-contextmenu", column, event);
  };
  const draggingColumn = ref(null);
  const dragging = ref(false);
  const dragState = ref({});
  const handleMouseDown = (event, column) => {
    if (!isClient)
      return;
    if (column.children && column.children.length > 0)
      return;
    if (draggingColumn.value && props2.border) {
      dragging.value = true;
      const table = parent2;
      emit("set-drag-visible", true);
      const tableEl = table == null ? void 0 : table.vnode.el;
      const tableLeft = tableEl.getBoundingClientRect().left;
      const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
      const columnRect = columnEl.getBoundingClientRect();
      const minLeft = columnRect.left - tableLeft + 30;
      addClass(columnEl, "noclick");
      dragState.value = {
        startMouseLeft: event.clientX,
        startLeft: columnRect.right - tableLeft,
        startColumnLeft: columnRect.left - tableLeft,
        tableLeft
      };
      const resizeProxy = table == null ? void 0 : table.refs.resizeProxy;
      resizeProxy.style.left = `${dragState.value.startLeft}px`;
      document.onselectstart = function() {
        return false;
      };
      document.ondragstart = function() {
        return false;
      };
      const handleMouseMove2 = (event2) => {
        const deltaLeft = event2.clientX - dragState.value.startMouseLeft;
        const proxyLeft = dragState.value.startLeft + deltaLeft;
        resizeProxy.style.left = `${Math.max(minLeft, proxyLeft)}px`;
      };
      const handleMouseUp = () => {
        if (dragging.value) {
          const { startColumnLeft, startLeft } = dragState.value;
          const finalLeft = Number.parseInt(resizeProxy.style.left, 10);
          const columnWidth = finalLeft - startColumnLeft;
          column.width = column.realWidth = columnWidth;
          table == null ? void 0 : table.emit("header-dragend", column.width, startLeft - startColumnLeft, column, event);
          requestAnimationFrame(() => {
            props2.store.scheduleLayout(false, true);
          });
          document.body.style.cursor = "";
          dragging.value = false;
          draggingColumn.value = null;
          dragState.value = {};
          emit("set-drag-visible", false);
        }
        document.removeEventListener("mousemove", handleMouseMove2);
        document.removeEventListener("mouseup", handleMouseUp);
        document.onselectstart = null;
        document.ondragstart = null;
        setTimeout(() => {
          removeClass(columnEl, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", handleMouseMove2);
      document.addEventListener("mouseup", handleMouseUp);
    }
  };
  const handleMouseMove = (event, column) => {
    if (column.children && column.children.length > 0)
      return;
    let target = event.target;
    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }
    if (!column || !column.resizable)
      return;
    if (!dragging.value && props2.border) {
      const rect = target.getBoundingClientRect();
      const bodyStyle = document.body.style;
      if (rect.width > 12 && rect.right - event.pageX < 8) {
        bodyStyle.cursor = "col-resize";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "col-resize";
        }
        draggingColumn.value = column;
      } else if (!dragging.value) {
        bodyStyle.cursor = "";
        if (hasClass(target, "is-sortable")) {
          target.style.cursor = "pointer";
        }
        draggingColumn.value = null;
      }
    }
  };
  const handleMouseOut = () => {
    if (!isClient)
      return;
    document.body.style.cursor = "";
  };
  const toggleOrder = ({ order: order2, sortOrders }) => {
    if (order2 === "")
      return sortOrders[0];
    const index2 = sortOrders.indexOf(order2 || null);
    return sortOrders[index2 > sortOrders.length - 2 ? 0 : index2 + 1];
  };
  const handleSortClick = (event, column, givenOrder) => {
    event.stopPropagation();
    const order2 = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
    let target = event.target;
    while (target && target.tagName !== "TH") {
      target = target.parentNode;
    }
    if (target && target.tagName === "TH") {
      if (hasClass(target, "noclick")) {
        removeClass(target, "noclick");
        return;
      }
    }
    if (!column.sortable)
      return;
    const states = props2.store.states;
    let sortProp = states.sortProp.value;
    let sortOrder;
    const sortingColumn = states.sortingColumn.value;
    if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
      if (sortingColumn) {
        sortingColumn.order = null;
      }
      states.sortingColumn.value = column;
      sortProp = column.property;
    }
    if (!order2) {
      sortOrder = column.order = null;
    } else {
      sortOrder = column.order = order2;
    }
    states.sortProp.value = sortProp;
    states.sortOrder.value = sortOrder;
    parent2 == null ? void 0 : parent2.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick,
    handleHeaderContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseOut,
    handleSortClick,
    handleFilterClick
  };
}
function useStyle$2(props2) {
  const parent2 = inject(TABLE_INJECTION_KEY);
  const ns = useNamespace("table");
  const getHeaderRowStyle = (rowIndex) => {
    const headerRowStyle = parent2 == null ? void 0 : parent2.props.headerRowStyle;
    if (typeof headerRowStyle === "function") {
      return headerRowStyle.call(null, { rowIndex });
    }
    return headerRowStyle;
  };
  const getHeaderRowClass = (rowIndex) => {
    const classes2 = [];
    const headerRowClassName = parent2 == null ? void 0 : parent2.props.headerRowClassName;
    if (typeof headerRowClassName === "string") {
      classes2.push(headerRowClassName);
    } else if (typeof headerRowClassName === "function") {
      classes2.push(headerRowClassName.call(null, { rowIndex }));
    }
    return classes2.join(" ");
  };
  const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
    var _a2;
    let headerCellStyles = (_a2 = parent2 == null ? void 0 : parent2.props.headerCellStyle) != null ? _a2 : {};
    if (typeof headerCellStyles === "function") {
      headerCellStyles = headerCellStyles.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }
    const fixedStyle = column.isSubColumn ? null : getFixedColumnOffset(columnIndex, column.fixed, props2.store, row);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return Object.assign({}, headerCellStyles, fixedStyle);
  };
  const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
    const fixedClasses = column.isSubColumn ? [] : getFixedColumnsClass(ns.b(), columnIndex, column.fixed, props2.store, row);
    const classes2 = [
      column.id,
      column.order,
      column.headerAlign,
      column.className,
      column.labelClassName,
      ...fixedClasses
    ];
    if (!column.children) {
      classes2.push("is-leaf");
    }
    if (column.sortable) {
      classes2.push("is-sortable");
    }
    const headerCellClassName = parent2 == null ? void 0 : parent2.props.headerCellClassName;
    if (typeof headerCellClassName === "string") {
      classes2.push(headerCellClassName);
    } else if (typeof headerCellClassName === "function") {
      classes2.push(headerCellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }
    classes2.push(ns.e("cell"));
    return classes2.filter((className) => Boolean(className)).join(" ");
  };
  return {
    getHeaderRowStyle,
    getHeaderRowClass,
    getHeaderCellStyle,
    getHeaderCellClass
  };
}
const getAllColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.children) {
      result.push(column);
      result.push.apply(result, getAllColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};
const convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent2) => {
    if (parent2) {
      column.level = parent2.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children) {
      let colSpan = 0;
      column.children.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column.level = 1;
    traverse(column, void 0);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllColumns(originColumns);
  allColumns.forEach((column) => {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
      column.children.forEach((col) => col.isSubColumn = true);
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function useUtils$1(props2) {
  const parent2 = inject(TABLE_INJECTION_KEY);
  const columnRows = computed(() => {
    return convertToRows(props2.store.states.originColumns.value);
  });
  const isGroup = computed(() => {
    const result = columnRows.value.length > 1;
    if (result && parent2) {
      parent2.state.isGroup.value = true;
    }
    return result;
  });
  const toggleAllSelection = (event) => {
    event.stopPropagation();
    parent2 == null ? void 0 : parent2.store.commit("toggleAllSelection");
  };
  return {
    isGroup,
    toggleAllSelection,
    columnRows
  };
}
var TableHeader = defineComponent({
  name: "ElTableHeader",
  components: {
    ElCheckbox
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props2, { emit }) {
    const instance = getCurrentInstance();
    const parent2 = inject(TABLE_INJECTION_KEY);
    const ns = useNamespace("table");
    const filterPanels = ref({});
    const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent2);
    onMounted(async () => {
      await nextTick$1();
      await nextTick$1();
      const { prop, order: order2 } = props2.defaultSort;
      parent2 == null ? void 0 : parent2.store.commit("sort", { prop, order: order2, init: true });
    });
    const {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick
    } = useEvent(props2, emit);
    const {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass
    } = useStyle$2(props2);
    const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props2);
    instance.state = {
      onColumnsChange,
      onScrollableChange
    };
    instance.filterPanels = filterPanels;
    return {
      ns,
      filterPanels,
      onColumnsChange,
      onScrollableChange,
      columnRows,
      getHeaderRowClass,
      getHeaderRowStyle,
      getHeaderCellClass,
      getHeaderCellStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick,
      isGroup,
      toggleAllSelection
    };
  },
  render() {
    const {
      ns,
      isGroup,
      columnRows,
      getHeaderCellStyle,
      getHeaderCellClass,
      getHeaderRowClass,
      getHeaderRowStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleSortClick,
      handleMouseOut,
      store,
      $parent
    } = this;
    let rowSpan = 1;
    return h$1("thead", {
      class: { [ns.is("group")]: isGroup }
    }, columnRows.map((subColumns, rowIndex) => h$1("tr", {
      class: getHeaderRowClass(rowIndex),
      key: rowIndex,
      style: getHeaderRowStyle(rowIndex)
    }, subColumns.map((column, cellIndex) => {
      if (column.rowSpan > rowSpan) {
        rowSpan = column.rowSpan;
      }
      return h$1("th", {
        class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
        colspan: column.colSpan,
        key: `${column.id}-thead`,
        rowspan: column.rowSpan,
        style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
        onClick: ($event) => handleHeaderClick($event, column),
        onContextmenu: ($event) => handleHeaderContextMenu($event, column),
        onMousedown: ($event) => handleMouseDown($event, column),
        onMousemove: ($event) => handleMouseMove($event, column),
        onMouseout: handleMouseOut
      }, [
        h$1("div", {
          class: [
            "cell",
            column.filteredValue && column.filteredValue.length > 0 ? "highlight" : "",
            column.labelClassName
          ]
        }, [
          column.renderHeader ? column.renderHeader({
            column,
            $index: cellIndex,
            store,
            _self: $parent
          }) : column.label,
          column.sortable && h$1("span", {
            onClick: ($event) => handleSortClick($event, column),
            class: "caret-wrapper"
          }, [
            h$1("i", {
              onClick: ($event) => handleSortClick($event, column, "ascending"),
              class: "sort-caret ascending"
            }),
            h$1("i", {
              onClick: ($event) => handleSortClick($event, column, "descending"),
              class: "sort-caret descending"
            })
          ]),
          column.filterable && h$1(FilterPanel, {
            store,
            placement: column.filterPlacement || "bottom-start",
            column,
            upDataColumn: (key2, value) => {
              column[key2] = value;
            }
          })
        ])
      ]);
    }))));
  }
});
function useEvents(props2) {
  const parent2 = inject(TABLE_INJECTION_KEY);
  const tooltipContent = ref("");
  const tooltipTrigger = ref(h$1("div"));
  const handleEvent = (event, row, name) => {
    var _a2;
    const table = parent2;
    const cell = getCell(event);
    let column;
    const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
    if (cell) {
      column = getColumnByCell({
        columns: props2.store.states.columns.value
      }, cell, namespace);
      if (column) {
        table == null ? void 0 : table.emit(`cell-${name}`, row, column, cell, event);
      }
    }
    table == null ? void 0 : table.emit(`row-${name}`, row, column, event);
  };
  const handleDoubleClick = (event, row) => {
    handleEvent(event, row, "dblclick");
  };
  const handleClick = (event, row) => {
    props2.store.commit("setCurrentRow", row);
    handleEvent(event, row, "click");
  };
  const handleContextMenu = (event, row) => {
    handleEvent(event, row, "contextmenu");
  };
  const handleMouseEnter = debounce$1((index2) => {
    props2.store.commit("setHoverRow", index2);
  }, 30);
  const handleMouseLeave = debounce$1(() => {
    props2.store.commit("setHoverRow", null);
  }, 30);
  const handleCellMouseEnter = (event, row) => {
    var _a2;
    const table = parent2;
    const cell = getCell(event);
    const namespace = (_a2 = table == null ? void 0 : table.vnode.el) == null ? void 0 : _a2.dataset.prefix;
    if (cell) {
      const column = getColumnByCell({
        columns: props2.store.states.columns.value
      }, cell, namespace);
      const hoverState = table.hoverState = { cell, column, row };
      table == null ? void 0 : table.emit("cell-mouse-enter", hoverState.row, hoverState.column, hoverState.cell, event);
    }
    const cellChild = event.target.querySelector(".cell");
    if (!(hasClass(cellChild, `${namespace}-tooltip`) && cellChild.childNodes.length)) {
      return;
    }
    const range = document.createRange();
    range.setStart(cellChild, 0);
    range.setEnd(cellChild, cellChild.childNodes.length);
    const rangeWidth = range.getBoundingClientRect().width;
    const padding = (Number.parseInt(getStyle(cellChild, "paddingLeft"), 10) || 0) + (Number.parseInt(getStyle(cellChild, "paddingRight"), 10) || 0);
    if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
      createTablePopper(cell, cell.innerText || cell.textContent, {
        placement: "top",
        strategy: "fixed"
      }, row.tooltipEffect);
    }
  };
  const handleCellMouseLeave = (event) => {
    const cell = getCell(event);
    if (!cell)
      return;
    const oldHoverState = parent2 == null ? void 0 : parent2.hoverState;
    parent2 == null ? void 0 : parent2.emit("cell-mouse-leave", oldHoverState == null ? void 0 : oldHoverState.row, oldHoverState == null ? void 0 : oldHoverState.column, oldHoverState == null ? void 0 : oldHoverState.cell, event);
  };
  return {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  };
}
function useStyles(props2) {
  const parent2 = inject(TABLE_INJECTION_KEY);
  const ns = useNamespace("table");
  const getRowStyle = (row, rowIndex) => {
    const rowStyle = parent2 == null ? void 0 : parent2.props.rowStyle;
    if (typeof rowStyle === "function") {
      return rowStyle.call(null, {
        row,
        rowIndex
      });
    }
    return rowStyle || null;
  };
  const getRowClass = (row, rowIndex) => {
    const classes2 = [ns.e("row")];
    if ((parent2 == null ? void 0 : parent2.props.highlightCurrentRow) && row === props2.store.states.currentRow.value) {
      classes2.push("current-row");
    }
    if (props2.stripe && rowIndex % 2 === 1) {
      classes2.push(ns.em("row", "striped"));
    }
    const rowClassName = parent2 == null ? void 0 : parent2.props.rowClassName;
    if (typeof rowClassName === "string") {
      classes2.push(rowClassName);
    } else if (typeof rowClassName === "function") {
      classes2.push(rowClassName.call(null, {
        row,
        rowIndex
      }));
    }
    return classes2;
  };
  const getCellStyle = (rowIndex, columnIndex, row, column) => {
    const cellStyle = parent2 == null ? void 0 : parent2.props.cellStyle;
    let cellStyles = cellStyle != null ? cellStyle : {};
    if (typeof cellStyle === "function") {
      cellStyles = cellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }
    const fixedStyle = column.isSubColumn ? null : getFixedColumnOffset(columnIndex, props2 == null ? void 0 : props2.fixed, props2.store);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return Object.assign({}, cellStyles, fixedStyle);
  };
  const getCellClass = (rowIndex, columnIndex, row, column) => {
    const fixedClasses = column.isSubColumn ? [] : getFixedColumnsClass(ns.b(), columnIndex, props2 == null ? void 0 : props2.fixed, props2.store);
    const classes2 = [column.id, column.align, column.className, ...fixedClasses];
    const cellClassName = parent2 == null ? void 0 : parent2.props.cellClassName;
    if (typeof cellClassName === "string") {
      classes2.push(cellClassName);
    } else if (typeof cellClassName === "function") {
      classes2.push(cellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }
    classes2.push(ns.e("cell"));
    return classes2.filter((className) => Boolean(className)).join(" ");
  };
  const getSpan = (row, column, rowIndex, columnIndex) => {
    let rowspan = 1;
    let colspan = 1;
    const fn2 = parent2 == null ? void 0 : parent2.props.spanMethod;
    if (typeof fn2 === "function") {
      const result = fn2({
        row,
        column,
        rowIndex,
        columnIndex
      });
      if (Array.isArray(result)) {
        rowspan = result[0];
        colspan = result[1];
      } else if (typeof result === "object") {
        rowspan = result.rowspan;
        colspan = result.colspan;
      }
    }
    return { rowspan, colspan };
  };
  const getColspanRealWidth = (columns, colspan, index2) => {
    if (colspan < 1) {
      return columns[index2].realWidth;
    }
    const widthArr = columns.map(({ realWidth, width }) => realWidth || width).slice(index2, index2 + colspan);
    return Number(widthArr.reduce((acc, width) => Number(acc) + Number(width), -1));
  };
  return {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  };
}
function useRender$1(props2) {
  const parent2 = inject(TABLE_INJECTION_KEY);
  const {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipContent,
    tooltipTrigger
  } = useEvents(props2);
  const {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  } = useStyles(props2);
  const firstDefaultColumnIndex = computed(() => {
    return props2.store.states.columns.value.findIndex(({ type }) => type === "default");
  });
  const getKeyOfRow = (row, index2) => {
    const rowKey = parent2.props.rowKey;
    if (rowKey) {
      return getRowIdentity(row, rowKey);
    }
    return index2;
  };
  const rowRender = (row, $index, treeRowData, expanded = false) => {
    const { tooltipEffect, store } = props2;
    const { indent, columns } = store.states;
    const rowClasses = getRowClass(row, $index);
    let display = true;
    if (treeRowData) {
      rowClasses.push(`el-table__row--level-${treeRowData.level}`);
      display = treeRowData.display;
    }
    const displayStyle = display ? null : {
      display: "none"
    };
    return h$1("tr", {
      style: [displayStyle, getRowStyle(row, $index)],
      class: rowClasses,
      key: getKeyOfRow(row, $index),
      onDblclick: ($event) => handleDoubleClick($event, row),
      onClick: ($event) => handleClick($event, row),
      onContextmenu: ($event) => handleContextMenu($event, row),
      onMouseenter: () => handleMouseEnter($index),
      onMouseleave: handleMouseLeave
    }, columns.value.map((column, cellIndex) => {
      const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
      if (!rowspan || !colspan) {
        return null;
      }
      const columnData = __spreadValues({}, column);
      columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex);
      const data = {
        store: props2.store,
        _self: props2.context || parent2,
        column: columnData,
        row,
        $index,
        cellIndex,
        expanded
      };
      if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
        data.treeNode = {
          indent: treeRowData.level * indent.value,
          level: treeRowData.level
        };
        if (typeof treeRowData.expanded === "boolean") {
          data.treeNode.expanded = treeRowData.expanded;
          if ("loading" in treeRowData) {
            data.treeNode.loading = treeRowData.loading;
          }
          if ("noLazyChildren" in treeRowData) {
            data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
          }
        }
      }
      const baseKey = `${$index},${cellIndex}`;
      const patchKey = columnData.columnKey || columnData.rawColumnKey || "";
      const tdChildren = cellChildren(cellIndex, column, data);
      return h$1("td", {
        style: getCellStyle($index, cellIndex, row, column),
        class: getCellClass($index, cellIndex, row, column),
        key: `${patchKey}${baseKey}`,
        rowspan,
        colspan,
        onMouseenter: ($event) => handleCellMouseEnter($event, __spreadProps(__spreadValues({}, row), { tooltipEffect })),
        onMouseleave: handleCellMouseLeave
      }, [tdChildren]);
    }));
  };
  const cellChildren = (cellIndex, column, data) => {
    return column.renderCell(data);
  };
  const wrappedRowRender = (row, $index) => {
    const store = props2.store;
    const { isRowExpanded, assertRowKey } = store;
    const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } = store.states;
    const columns = store.states.columns.value;
    const hasExpandColumn = columns.some(({ type }) => type === "expand");
    if (hasExpandColumn) {
      const expanded = isRowExpanded(row);
      const tr = rowRender(row, $index, void 0, expanded);
      const renderExpanded = parent2.renderExpanded;
      if (expanded) {
        if (!renderExpanded) {
          console.error("[Element Error]renderExpanded is required.");
          return tr;
        }
        return [
          [
            tr,
            h$1("tr", {
              key: `expanded-row__${tr.key}`
            }, [
              h$1("td", {
                colspan: columns.length,
                class: "el-table__cell el-table__expanded-cell"
              }, [renderExpanded({ row, $index, store, expanded })])
            ])
          ]
        ];
      } else {
        return [[tr]];
      }
    } else if (Object.keys(treeData.value).length) {
      assertRowKey();
      const key2 = getRowIdentity(row, rowKey.value);
      let cur = treeData.value[key2];
      let treeRowData = null;
      if (cur) {
        treeRowData = {
          expanded: cur.expanded,
          level: cur.level,
          display: true
        };
        if (typeof cur.lazy === "boolean") {
          if (typeof cur.loaded === "boolean" && cur.loaded) {
            treeRowData.noLazyChildren = !(cur.children && cur.children.length);
          }
          treeRowData.loading = cur.loading;
        }
      }
      const tmp = [rowRender(row, $index, treeRowData)];
      if (cur) {
        let i = 0;
        const traverse = (children2, parent22) => {
          if (!(children2 && children2.length && parent22))
            return;
          children2.forEach((node) => {
            const innerTreeRowData = {
              display: parent22.display && parent22.expanded,
              level: parent22.level + 1,
              expanded: false,
              noLazyChildren: false,
              loading: false
            };
            const childKey = getRowIdentity(node, rowKey.value);
            if (childKey === void 0 || childKey === null) {
              throw new Error("For nested data item, row-key is required.");
            }
            cur = __spreadValues({}, treeData.value[childKey]);
            if (cur) {
              innerTreeRowData.expanded = cur.expanded;
              cur.level = cur.level || innerTreeRowData.level;
              cur.display = !!(cur.expanded && innerTreeRowData.display);
              if (typeof cur.lazy === "boolean") {
                if (typeof cur.loaded === "boolean" && cur.loaded) {
                  innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }
                innerTreeRowData.loading = cur.loading;
              }
            }
            i++;
            tmp.push(rowRender(node, $index + i, innerTreeRowData));
            if (cur) {
              const nodes2 = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
              traverse(nodes2, cur);
            }
          });
        };
        cur.display = true;
        const nodes = lazyTreeNodeMap.value[key2] || row[childrenColumnName.value];
        traverse(nodes, cur);
      }
      return tmp;
    } else {
      return rowRender(row, $index, void 0);
    }
  };
  return {
    wrappedRowRender,
    tooltipContent,
    tooltipTrigger
  };
}
const defaultProps$2 = {
  store: {
    required: true,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var TableBody = defineComponent({
  name: "ElTableBody",
  props: defaultProps$2,
  setup(props2) {
    const instance = getCurrentInstance();
    const parent2 = inject(TABLE_INJECTION_KEY);
    const ns = useNamespace("table");
    const { wrappedRowRender, tooltipContent, tooltipTrigger } = useRender$1(props2);
    const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent2);
    watch$1(props2.store.states.hoverRow, (newVal, oldVal) => {
      if (!props2.store.states.isComplex.value || !isClient)
        return;
      let raf = window.requestAnimationFrame;
      if (!raf) {
        raf = (fn2) => window.setTimeout(fn2, 16);
      }
      raf(() => {
        var _a2;
        const rows = (_a2 = instance == null ? void 0 : instance.vnode.el) == null ? void 0 : _a2.querySelectorAll(`.${ns.e("row")}`);
        const oldRow = rows[oldVal];
        const newRow = rows[newVal];
        if (oldRow) {
          removeClass(oldRow, "hover-row");
        }
        if (newRow) {
          addClass(newRow, "hover-row");
        }
      });
    });
    onUnmounted(() => {
      var _a2;
      (_a2 = removePopper) == null ? void 0 : _a2();
    });
    onUpdated(() => {
      var _a2;
      (_a2 = removePopper) == null ? void 0 : _a2();
    });
    return {
      ns,
      onColumnsChange,
      onScrollableChange,
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger
    };
  },
  render() {
    const { wrappedRowRender, store } = this;
    const data = store.states.data.value || [];
    return h$1("tbody", {}, [
      data.reduce((acc, row) => {
        return acc.concat(wrappedRowRender(row, acc.length));
      }, [])
    ]);
  }
});
function hColgroup(props2) {
  const isAuto = props2.tableLayout === "auto";
  let columns = props2.columns || [];
  if (isAuto) {
    if (columns.every((column) => column.width === void 0)) {
      columns = [];
    }
  }
  const getPropsData = (column) => {
    const propsData = {
      key: `${props2.tableLayout}_${column.id}`,
      style: {},
      name: void 0
    };
    if (isAuto) {
      propsData.style = {
        width: `${column.width}px`
      };
    } else {
      propsData.name = column.id;
    }
    return propsData;
  };
  return h$1("colgroup", {}, columns.map((column) => h$1("col", getPropsData(column))));
}
hColgroup.props = ["columns", "tableLayout"];
function useMapState() {
  const table = inject(TABLE_INJECTION_KEY);
  const store = table == null ? void 0 : table.store;
  const leftFixedLeafCount = computed(() => {
    return store.states.fixedLeafColumnsLength.value;
  });
  const rightFixedLeafCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  const columnsCount = computed(() => {
    return store.states.columns.value.length;
  });
  const leftFixedCount = computed(() => {
    return store.states.fixedColumns.value.length;
  });
  const rightFixedCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  return {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns: store.states.columns
  };
}
function useStyle$1(props2) {
  const { columns } = useMapState();
  const ns = useNamespace("table");
  const getCellClasses = (columns2, cellIndex) => {
    const column = columns2[cellIndex];
    const classes2 = [
      ns.e("cell"),
      column.id,
      column.align,
      column.labelClassName,
      ...getFixedColumnsClass(ns.b(), cellIndex, column.fixed, props2.store)
    ];
    if (column.className) {
      classes2.push(column.className);
    }
    if (!column.children) {
      classes2.push(ns.is("leaf"));
    }
    return classes2;
  };
  const getCellStyles = (column, cellIndex) => {
    const fixedStyle = getFixedColumnOffset(cellIndex, column.fixed, props2.store);
    ensurePosition(fixedStyle, "left");
    ensurePosition(fixedStyle, "right");
    return fixedStyle;
  };
  return {
    getCellClasses,
    getCellStyles,
    columns
  };
}
var TableFooter = defineComponent({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: true,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => {
        return {
          prop: "",
          order: ""
        };
      }
    }
  },
  setup(props2) {
    const { getCellClasses, getCellStyles, columns } = useStyle$1(props2);
    const ns = useNamespace("table");
    return {
      ns,
      getCellClasses,
      getCellStyles,
      columns
    };
  },
  render() {
    const {
      columns,
      getCellStyles,
      getCellClasses,
      summaryMethod,
      sumText,
      ns
    } = this;
    const data = this.store.states.data.value;
    let sums = [];
    if (summaryMethod) {
      sums = summaryMethod({
        columns,
        data
      });
    } else {
      columns.forEach((column, index2) => {
        if (index2 === 0) {
          sums[index2] = sumText;
          return;
        }
        const values = data.map((item) => Number(item[column.property]));
        const precisions = [];
        let notNumber = true;
        values.forEach((value) => {
          if (!Number.isNaN(+value)) {
            notNumber = false;
            const decimal = `${value}`.split(".")[1];
            precisions.push(decimal ? decimal.length : 0);
          }
        });
        const precision = Math.max.apply(null, precisions);
        if (!notNumber) {
          sums[index2] = values.reduce((prev2, curr) => {
            const value = Number(curr);
            if (!Number.isNaN(+value)) {
              return Number.parseFloat((prev2 + curr).toFixed(Math.min(precision, 20)));
            } else {
              return prev2;
            }
          }, 0);
        } else {
          sums[index2] = "";
        }
      });
    }
    return h$1("table", {
      class: ns.e("footer"),
      cellspacing: "0",
      cellpadding: "0",
      border: "0"
    }, [
      hColgroup({
        columns
      }),
      h$1("tbody", [
        h$1("tr", {}, [
          ...columns.map((column, cellIndex) => h$1("td", {
            key: cellIndex,
            colspan: column.colSpan,
            rowspan: column.rowSpan,
            class: getCellClasses(columns, cellIndex),
            style: getCellStyles(column, cellIndex)
          }, [
            h$1("div", {
              class: ["cell", column.labelClassName]
            }, [sums[cellIndex]])
          ]))
        ])
      ])
    ]);
  }
});
function useUtils(store) {
  const setCurrentRow = (row) => {
    store.commit("setCurrentRow", row);
  };
  const getSelectionRows = () => {
    return store.getSelectionRows();
  };
  const toggleRowSelection = (row, selected) => {
    store.toggleRowSelection(row, selected, false);
    store.updateAllSelected();
  };
  const clearSelection = () => {
    store.clearSelection();
  };
  const clearFilter = (columnKeys) => {
    store.clearFilter(columnKeys);
  };
  const toggleAllSelection = () => {
    store.commit("toggleAllSelection");
  };
  const toggleRowExpansion = (row, expanded) => {
    store.toggleRowExpansionAdapter(row, expanded);
  };
  const clearSort = () => {
    store.clearSort();
  };
  const sort2 = (prop, order2) => {
    store.commit("sort", { prop, order: order2 });
  };
  return {
    setCurrentRow,
    getSelectionRows,
    toggleRowSelection,
    clearSelection,
    clearFilter,
    toggleAllSelection,
    toggleRowExpansion,
    clearSort,
    sort: sort2
  };
}
function useStyle(props2, layout2, store, table) {
  const isHidden = ref(false);
  const renderExpanded = ref(null);
  const resizeProxyVisible = ref(false);
  const setDragVisible = (visible) => {
    resizeProxyVisible.value = visible;
  };
  const resizeState = ref({
    width: null,
    height: null
  });
  const isGroup = ref(false);
  const scrollbarViewStyle = {
    display: "inline-block",
    verticalAlign: "middle"
  };
  const tableWidth = ref();
  watchEffect(() => {
    layout2.setHeight(props2.height);
  });
  watchEffect(() => {
    layout2.setMaxHeight(props2.maxHeight);
  });
  watch$1(() => [props2.currentRowKey, store.states.rowKey], ([currentRowKey, rowKey]) => {
    if (!unref(rowKey))
      return;
    store.setCurrentRowKey(`${currentRowKey}`);
  }, {
    immediate: true
  });
  watch$1(() => props2.data, (data) => {
    table.store.commit("setData", data);
  }, {
    immediate: true,
    deep: true
  });
  watchEffect(() => {
    if (props2.expandRowKeys) {
      store.setExpandRowKeysAdapter(props2.expandRowKeys);
    }
  });
  const handleMouseLeave = () => {
    table.store.commit("setHoverRow", null);
    if (table.hoverState)
      table.hoverState = null;
  };
  const handleHeaderFooterMousewheel = (event, data) => {
    const { pixelX, pixelY } = data;
    if (Math.abs(pixelX) >= Math.abs(pixelY)) {
      table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
    }
  };
  const shouldUpdateHeight = computed(() => {
    return props2.height || props2.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
  });
  const tableBodyStyles = computed(() => {
    return {
      width: layout2.bodyWidth.value ? `${layout2.bodyWidth.value}px` : ""
    };
  });
  const doLayout = () => {
    if (shouldUpdateHeight.value) {
      layout2.updateElsHeight();
    }
    layout2.updateColumnsWidth();
    requestAnimationFrame(syncPostion);
  };
  onMounted(async () => {
    await nextTick$1();
    store.updateColumns();
    bindEvents();
    requestAnimationFrame(doLayout);
    resizeState.value = {
      width: tableWidth.value = table.vnode.el.offsetWidth,
      height: table.vnode.el.offsetHeight
    };
    store.states.columns.value.forEach((column) => {
      if (column.filteredValue && column.filteredValue.length) {
        table.store.commit("filterChange", {
          column,
          values: column.filteredValue,
          silent: true
        });
      }
    });
    table.$ready = true;
  });
  const setScrollClassByEl = (el, className) => {
    if (!el)
      return;
    const classList = Array.from(el.classList).filter((item) => !item.startsWith("is-scrolling-"));
    classList.push(layout2.scrollX.value ? className : "is-scrolling-none");
    el.className = classList.join(" ");
  };
  const setScrollClass = (className) => {
    const { tableWrapper } = table.refs;
    setScrollClassByEl(tableWrapper, className);
  };
  const hasScrollClass = (className) => {
    const { tableWrapper } = table.refs;
    if (tableWrapper && tableWrapper.classList.contains(className)) {
      return true;
    }
    return false;
  };
  const syncPostion = function() {
    if (!table.refs.scrollBarRef)
      return;
    if (!layout2.scrollX.value) {
      const scrollingNoneClass = "is-scrolling-none";
      if (!hasScrollClass(scrollingNoneClass)) {
        setScrollClass(scrollingNoneClass);
      }
      return;
    }
    const scrollContainer = table.refs.scrollBarRef.wrap$;
    if (!scrollContainer)
      return;
    const { scrollLeft, offsetWidth, scrollWidth } = scrollContainer;
    const { headerWrapper, footerWrapper } = table.refs;
    if (headerWrapper)
      headerWrapper.scrollLeft = scrollLeft;
    if (footerWrapper)
      footerWrapper.scrollLeft = scrollLeft;
    const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
    if (scrollLeft >= maxScrollLeftPosition) {
      setScrollClass("is-scrolling-right");
    } else if (scrollLeft === 0) {
      setScrollClass("is-scrolling-left");
    } else {
      setScrollClass("is-scrolling-middle");
    }
  };
  const bindEvents = () => {
    var _a2;
    if (!table.refs.scrollBarRef)
      return;
    (_a2 = table.refs.scrollBarRef.wrap$) == null ? void 0 : _a2.addEventListener("scroll", syncPostion, {
      passive: true
    });
    if (props2.fit) {
      addResizeListener(table.vnode.el, resizeListener);
    } else {
      on(window, "resize", doLayout);
    }
  };
  onBeforeUnmount(() => {
    unbindEvents();
  });
  const unbindEvents = () => {
    var _a2;
    (_a2 = table.refs.scrollBarRef.wrap$) == null ? void 0 : _a2.removeEventListener("scroll", syncPostion, true);
    if (props2.fit) {
      removeResizeListener(table.vnode.el, resizeListener);
    } else {
      off(window, "resize", doLayout);
    }
  };
  const resizeListener = () => {
    if (!table.$ready)
      return;
    let shouldUpdateLayout = false;
    const el = table.vnode.el;
    const { width: oldWidth, height: oldHeight } = resizeState.value;
    const width = tableWidth.value = el.offsetWidth;
    if (oldWidth !== width) {
      shouldUpdateLayout = true;
    }
    const height2 = el.offsetHeight;
    if ((props2.height || shouldUpdateHeight.value) && oldHeight !== height2) {
      shouldUpdateLayout = true;
    }
    if (shouldUpdateLayout) {
      resizeState.value = {
        width,
        height: height2
      };
      doLayout();
    }
  };
  const tableSize = useSize();
  const bodyWidth = computed(() => {
    const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout2;
    return bodyWidth_.value ? `${bodyWidth_.value - (scrollY.value ? gutterWidth : 0)}px` : "";
  });
  const tableLayout = computed(() => {
    if (props2.maxHeight)
      return "fixed";
    return props2.tableLayout;
  });
  function calcMaxHeight(maxHeight, footerHeight, headerHeight) {
    const parsedMaxHeight = parseHeight(maxHeight);
    const tableHeaderHeight = props2.showHeader ? headerHeight : 0;
    if (parsedMaxHeight === null)
      return;
    if (isString(parsedMaxHeight)) {
      return `calc(${parsedMaxHeight} - ${footerHeight}px - ${tableHeaderHeight}px)`;
    }
    return parsedMaxHeight - footerHeight - tableHeaderHeight;
  }
  const height = computed(() => {
    const headerHeight = layout2.headerHeight.value || 0;
    const bodyHeight2 = layout2.bodyHeight.value;
    const footerHeight = layout2.footerHeight.value || 0;
    if (props2.height) {
      return bodyHeight2 ? bodyHeight2 : void 0;
    } else if (props2.maxHeight) {
      return calcMaxHeight(props2.maxHeight, footerHeight, headerHeight);
    }
    return void 0;
  });
  const bodyHeight = computed(() => {
    const headerHeight = layout2.headerHeight.value || 0;
    const bodyHeight2 = layout2.bodyHeight.value;
    const footerHeight = layout2.footerHeight.value || 0;
    if (props2.height) {
      return {
        height: bodyHeight2 ? `${bodyHeight2}px` : ""
      };
    } else if (props2.maxHeight) {
      const maxHeight = calcMaxHeight(props2.maxHeight, footerHeight, headerHeight);
      if (maxHeight !== null) {
        return {
          "max-height": `${maxHeight}${isNumber(maxHeight) ? "px" : ""}`
        };
      }
    }
    return {};
  });
  const emptyBlockStyle = computed(() => {
    if (props2.data && props2.data.length)
      return null;
    let height2 = "100%";
    if (layout2.appendHeight.value) {
      height2 = `calc(100% - ${layout2.appendHeight.value}px)`;
    }
    return {
      width: tableWidth.value ? `${tableWidth.value}px` : "",
      height: height2
    };
  });
  const handleFixedMousewheel = (event, data) => {
    const bodyWrapper = table.refs.bodyWrapper;
    if (Math.abs(data.spinY) > 0) {
      const currentScrollTop = bodyWrapper.scrollTop;
      if (data.pixelY < 0 && currentScrollTop !== 0) {
        event.preventDefault();
      }
      if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
        event.preventDefault();
      }
      bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
    } else {
      bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
    }
  };
  const fixedHeight = computed(() => {
    if (props2.maxHeight) {
      if (props2.showSummary) {
        return {
          bottom: 0
        };
      }
      return {
        bottom: layout2.scrollX.value && props2.data.length ? `${layout2.gutterWidth}px` : ""
      };
    } else {
      if (props2.showSummary) {
        return {
          height: layout2.tableHeight.value ? `${layout2.tableHeight.value}px` : ""
        };
      }
      return {
        height: layout2.viewportHeight.value ? `${layout2.viewportHeight.value}px` : ""
      };
    }
  });
  const fixedBodyHeight = computed(() => {
    if (props2.height) {
      return {
        height: layout2.fixedBodyHeight.value ? `${layout2.fixedBodyHeight.value}px` : ""
      };
    } else if (props2.maxHeight) {
      let maxHeight = parseHeight(props2.maxHeight);
      if (typeof maxHeight === "number") {
        maxHeight = layout2.scrollX.value ? maxHeight - layout2.gutterWidth : maxHeight;
        if (props2.showHeader) {
          maxHeight -= layout2.headerHeight.value;
        }
        maxHeight -= layout2.footerHeight.value;
        return {
          "max-height": `${maxHeight}px`
        };
      }
    }
    return {};
  });
  return {
    isHidden,
    renderExpanded,
    setDragVisible,
    isGroup,
    handleMouseLeave,
    handleHeaderFooterMousewheel,
    tableSize,
    bodyHeight,
    height,
    emptyBlockStyle,
    handleFixedMousewheel,
    fixedHeight,
    fixedBodyHeight,
    resizeProxyVisible,
    bodyWidth,
    resizeState,
    doLayout,
    tableBodyStyles,
    tableLayout,
    scrollbarViewStyle
  };
}
var defaultProps$1 = {
  data: {
    type: Array,
    default: () => {
      return [];
    }
  },
  size: String,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: true
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: true
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: true
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => {
      return {
        hasChildren: "hasChildren",
        children: "children"
      };
    }
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: Object,
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: {
    type: Boolean,
    default: false
  }
};
const useScrollbar = () => {
  const scrollBarRef = ref();
  const scrollTo = (options, yCoord) => {
    const scrollbar = scrollBarRef.value;
    if (scrollbar) {
      scrollbar.scrollTo(options, yCoord);
    }
  };
  const setScrollPosition = (position2, offset2) => {
    const scrollbar = scrollBarRef.value;
    if (scrollbar && isNumber(offset2) && ["Top", "Left"].includes(position2)) {
      scrollbar[`setScroll${position2}`](offset2);
    }
  };
  const setScrollTop = (top2) => setScrollPosition("Top", top2);
  const setScrollLeft = (left2) => setScrollPosition("Left", left2);
  return {
    scrollBarRef,
    scrollTo,
    setScrollTop,
    setScrollLeft
  };
};
let tableIdSeed = 1;
const _sfc_main$i = defineComponent({
  name: "ElTable",
  directives: {
    Mousewheel
  },
  components: {
    TableHeader,
    TableBody,
    TableFooter,
    ElScrollbar,
    hColgroup
  },
  props: defaultProps$1,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change"
  ],
  setup(props2) {
    const { t } = useLocale();
    const ns = useNamespace("table");
    const table = getCurrentInstance();
    provide(TABLE_INJECTION_KEY, table);
    const store = createStore(table, props2);
    table.store = store;
    const layout2 = new TableLayout({
      store: table.store,
      table,
      fit: props2.fit,
      showHeader: props2.showHeader
    });
    table.layout = layout2;
    const isEmpty2 = computed(() => (store.states.data.value || []).length === 0);
    const {
      setCurrentRow,
      getSelectionRows,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      sort: sort2
    } = useUtils(store);
    const {
      isHidden,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      bodyHeight,
      height,
      emptyBlockStyle,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      doLayout,
      tableBodyStyles,
      tableLayout,
      scrollbarViewStyle
    } = useStyle(props2, layout2, store, table);
    const { scrollBarRef, scrollTo, setScrollLeft, setScrollTop } = useScrollbar();
    const debouncedUpdateLayout = debounce$1(doLayout, 50);
    const tableId = `el-table_${tableIdSeed++}`;
    table.tableId = tableId;
    table.state = {
      isGroup,
      resizeState,
      doLayout,
      debouncedUpdateLayout
    };
    const computedSumText = computed(() => props2.sumText || t("el.table.sumText"));
    const computedEmptyText = computed(() => {
      return props2.emptyText || t("el.table.emptyText");
    });
    return {
      ns,
      layout: layout2,
      store,
      handleHeaderFooterMousewheel,
      handleMouseLeave,
      tableId,
      tableSize,
      isHidden,
      isEmpty: isEmpty2,
      renderExpanded,
      resizeProxyVisible,
      resizeState,
      isGroup,
      bodyWidth,
      bodyHeight,
      height,
      tableBodyStyles,
      emptyBlockStyle,
      debouncedUpdateLayout,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      setCurrentRow,
      getSelectionRows,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      doLayout,
      sort: sort2,
      t,
      setDragVisible,
      context: table,
      computedSumText,
      computedEmptyText,
      tableLayout,
      scrollbarViewStyle,
      scrollBarRef,
      scrollTo,
      setScrollLeft,
      setScrollTop
    };
  }
});
const _hoisted_1$h = ["data-prefix"];
const _hoisted_2$5 = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hColgroup = resolveComponent("hColgroup");
  const _component_table_header = resolveComponent("table-header");
  const _component_table_body = resolveComponent("table-body");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_table_footer = resolveComponent("table-footer");
  const _directive_mousewheel = resolveDirective("mousewheel");
  return openBlock(), createElementBlock("div", {
    ref: "tableWrapper",
    class: normalizeClass([
      {
        [_ctx.ns.m("fit")]: _ctx.fit,
        [_ctx.ns.m("striped")]: _ctx.stripe,
        [_ctx.ns.m("border")]: _ctx.border || _ctx.isGroup,
        [_ctx.ns.m("hidden")]: _ctx.isHidden,
        [_ctx.ns.m("group")]: _ctx.isGroup,
        [_ctx.ns.m("fluid-height")]: _ctx.maxHeight,
        [_ctx.ns.m("scrollable-x")]: _ctx.layout.scrollX.value,
        [_ctx.ns.m("scrollable-y")]: _ctx.layout.scrollY.value,
        [_ctx.ns.m("enable-row-hover")]: !_ctx.store.states.isComplex.value,
        [_ctx.ns.m("enable-row-transition")]: (_ctx.store.states.data.value || []).length !== 0 && (_ctx.store.states.data.value || []).length < 100,
        "has-footer": _ctx.showSummary
      },
      _ctx.ns.m(_ctx.tableSize),
      _ctx.className,
      _ctx.ns.b(),
      _ctx.ns.m(`layout-${_ctx.tableLayout}`)
    ]),
    style: normalizeStyle$1(_ctx.style),
    "data-prefix": _ctx.ns.namespace.value,
    onMouseleave: _cache[0] || (_cache[0] = ($event) => _ctx.handleMouseLeave())
  }, [
    createElementVNode("div", {
      class: normalizeClass(_ctx.ns.e("inner-wrapper"))
    }, [
      createElementVNode("div", _hoisted_2$5, [
        renderSlot(_ctx.$slots, "default")
      ], 512),
      _ctx.showHeader && _ctx.tableLayout === "fixed" ? withDirectives((openBlock(), createElementBlock("div", {
        key: 0,
        ref: "headerWrapper",
        class: normalizeClass(_ctx.ns.e("header-wrapper"))
      }, [
        createElementVNode("table", {
          ref: "tableHeader",
          class: normalizeClass(_ctx.ns.e("header")),
          style: normalizeStyle$1(_ctx.tableBodyStyles),
          border: "0",
          cellpadding: "0",
          cellspacing: "0"
        }, [
          createVNode$1(_component_hColgroup, {
            columns: _ctx.store.states.columns.value,
            "table-layout": _ctx.tableLayout
          }, null, 8, ["columns", "table-layout"]),
          createVNode$1(_component_table_header, {
            ref: "tableHeaderRef",
            border: _ctx.border,
            "default-sort": _ctx.defaultSort,
            store: _ctx.store,
            onSetDragVisible: _ctx.setDragVisible
          }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])
        ], 6)
      ], 2)), [
        [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
      ]) : createCommentVNode("v-if", true),
      createElementVNode("div", {
        ref: "bodyWrapper",
        style: normalizeStyle$1(_ctx.bodyHeight),
        class: normalizeClass(_ctx.ns.e("body-wrapper"))
      }, [
        createVNode$1(_component_el_scrollbar, {
          ref: "scrollBarRef",
          height: _ctx.maxHeight ? void 0 : _ctx.height,
          "max-height": _ctx.maxHeight ? _ctx.height : void 0,
          "view-style": _ctx.scrollbarViewStyle,
          always: _ctx.scrollbarAlwaysOn
        }, {
          default: withCtx(() => [
            createElementVNode("table", {
              ref: "tableBody",
              class: normalizeClass(_ctx.ns.e("body")),
              cellspacing: "0",
              cellpadding: "0",
              border: "0",
              style: normalizeStyle$1({
                width: _ctx.bodyWidth,
                tableLayout: _ctx.tableLayout
              })
            }, [
              createVNode$1(_component_hColgroup, {
                columns: _ctx.store.states.columns.value,
                "table-layout": _ctx.tableLayout
              }, null, 8, ["columns", "table-layout"]),
              _ctx.showHeader && _ctx.tableLayout === "auto" ? (openBlock(), createBlock(_component_table_header, {
                key: 0,
                border: _ctx.border,
                "default-sort": _ctx.defaultSort,
                store: _ctx.store,
                onSetDragVisible: _ctx.setDragVisible
              }, null, 8, ["border", "default-sort", "store", "onSetDragVisible"])) : createCommentVNode("v-if", true),
              createVNode$1(_component_table_body, {
                context: _ctx.context,
                highlight: _ctx.highlightCurrentRow,
                "row-class-name": _ctx.rowClassName,
                "tooltip-effect": _ctx.tooltipEffect,
                "row-style": _ctx.rowStyle,
                store: _ctx.store,
                stripe: _ctx.stripe
              }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "row-style", "store", "stripe"])
            ], 6),
            _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "emptyBlock",
              style: normalizeStyle$1(_ctx.emptyBlockStyle),
              class: normalizeClass(_ctx.ns.e("empty-block"))
            }, [
              createElementVNode("span", {
                class: normalizeClass(_ctx.ns.e("empty-text"))
              }, [
                renderSlot(_ctx.$slots, "empty", {}, () => [
                  createTextVNode(toDisplayString(_ctx.computedEmptyText), 1)
                ])
              ], 2)
            ], 6)) : createCommentVNode("v-if", true),
            _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
              key: 1,
              ref: "appendWrapper",
              class: normalizeClass(_ctx.ns.e("append-wrapper"))
            }, [
              renderSlot(_ctx.$slots, "append")
            ], 2)) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 8, ["height", "max-height", "view-style", "always"])
      ], 6),
      _ctx.border || _ctx.isGroup ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.ns.e("border-left-patch"))
      }, null, 2)) : createCommentVNode("v-if", true)
    ], 2),
    _ctx.showSummary ? withDirectives((openBlock(), createElementBlock("div", {
      key: 0,
      ref: "footerWrapper",
      class: normalizeClass(_ctx.ns.e("footer-wrapper"))
    }, [
      createVNode$1(_component_table_footer, {
        border: _ctx.border,
        "default-sort": _ctx.defaultSort,
        store: _ctx.store,
        style: normalizeStyle$1(_ctx.tableBodyStyles),
        "sum-text": _ctx.computedSumText,
        "summary-method": _ctx.summaryMethod
      }, null, 8, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
    ], 2)), [
      [vShow, !_ctx.isEmpty],
      [_directive_mousewheel, _ctx.handleHeaderFooterMousewheel]
    ]) : createCommentVNode("v-if", true),
    withDirectives(createElementVNode("div", {
      ref: "resizeProxy",
      class: normalizeClass(_ctx.ns.e("column-resize-proxy"))
    }, null, 2), [
      [vShow, _ctx.resizeProxyVisible]
    ])
  ], 46, _hoisted_1$h);
}
var Table = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
const defaultClassNames = {
  selection: "table-column--selection",
  expand: "table__expand-column"
};
const cellStarts = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
};
const getDefaultClassName = (type) => {
  return defaultClassNames[type] || "";
};
const cellForced = {
  selection: {
    renderHeader({ store }) {
      function isDisabled() {
        return store.states.data.value && store.states.data.value.length === 0;
      }
      return h$1(ElCheckbox, {
        disabled: isDisabled(),
        size: store.states.tableSize.value,
        indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
        "onUpdate:modelValue": store.toggleAllSelection,
        modelValue: store.states.isAllSelected.value
      });
    },
    renderCell({
      row,
      column,
      store,
      $index
    }) {
      return h$1(ElCheckbox, {
        disabled: column.selectable ? !column.selectable.call(null, row, $index) : false,
        size: store.states.tableSize.value,
        onChange: () => {
          store.commit("rowSelectedChanged", row);
        },
        onClick: (event) => event.stopPropagation(),
        modelValue: store.isSelected(row)
      });
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader({ column }) {
      return column.label || "#";
    },
    renderCell({
      column,
      $index
    }) {
      let i = $index + 1;
      const index2 = column.index;
      if (typeof index2 === "number") {
        i = $index + index2;
      } else if (typeof index2 === "function") {
        i = index2($index);
      }
      return h$1("div", {}, [i]);
    },
    sortable: false
  },
  expand: {
    renderHeader({ column }) {
      return column.label || "";
    },
    renderCell({
      row,
      store,
      expanded
    }) {
      const { ns } = store;
      const classes2 = [ns.e("expand-icon")];
      if (expanded) {
        classes2.push(ns.em("expand-icon", "expanded"));
      }
      const callback = function(e2) {
        e2.stopPropagation();
        store.toggleRowExpansion(row);
      };
      return h$1("div", {
        class: classes2,
        onClick: callback
      }, {
        default: () => {
          return [
            h$1(ElIcon, null, {
              default: () => {
                return [h$1(arrowRight)];
              }
            })
          ];
        }
      });
    },
    sortable: false,
    resizable: false
  }
};
function defaultRenderCell({
  row,
  column,
  $index
}) {
  var _a2;
  const property2 = column.property;
  const value = property2 && getProp(row, property2).value;
  if (column && column.formatter) {
    return column.formatter(row, column, value, $index);
  }
  return ((_a2 = value == null ? void 0 : value.toString) == null ? void 0 : _a2.call(value)) || "";
}
function treeCellPrefix({
  row,
  treeNode,
  store
}, createPlacehoder = false) {
  const { ns } = store;
  if (!treeNode) {
    if (createPlacehoder) {
      return [
        h$1("span", {
          class: ns.e("placeholder")
        })
      ];
    }
    return null;
  }
  const ele = [];
  const callback = function(e2) {
    e2.stopPropagation();
    store.loadOrToggle(row);
  };
  if (treeNode.indent) {
    ele.push(h$1("span", {
      class: ns.e("indent"),
      style: { "padding-left": `${treeNode.indent}px` }
    }));
  }
  if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
    const expandClasses = [
      ns.e("expand-icon"),
      treeNode.expanded ? ns.em("expand-icon", "expanded") : ""
    ];
    let icon = arrowRight;
    if (treeNode.loading) {
      icon = loading;
    }
    ele.push(h$1("div", {
      class: expandClasses,
      onClick: callback
    }, {
      default: () => {
        return [
          h$1(ElIcon, { class: { [ns.is("loading")]: treeNode.loading } }, {
            default: () => [h$1(icon)]
          })
        ];
      }
    }));
  } else {
    ele.push(h$1("span", {
      class: ns.e("placeholder")
    }));
  }
  return ele;
}
function getAllAliases(props2, aliases) {
  return props2.reduce((prev2, cur) => {
    prev2[cur] = cur;
    return prev2;
  }, aliases);
}
function useWatcher(owner, props_) {
  const instance = getCurrentInstance();
  const registerComplexWatchers = () => {
    const props2 = ["fixed"];
    const aliases = {
      realWidth: "width",
      realMinWidth: "minWidth"
    };
    const allAliases = getAllAliases(props2, aliases);
    Object.keys(allAliases).forEach((key2) => {
      const columnKey = aliases[key2];
      if (hasOwn(props_, columnKey)) {
        watch$1(() => props_[columnKey], (newVal) => {
          let value = newVal;
          if (columnKey === "width" && key2 === "realWidth") {
            value = parseWidth(newVal);
          }
          if (columnKey === "minWidth" && key2 === "realMinWidth") {
            value = parseMinWidth(newVal);
          }
          instance.columnConfig.value[columnKey] = value;
          instance.columnConfig.value[key2] = value;
          const updateColumns = columnKey === "fixed";
          owner.value.store.scheduleLayout(updateColumns);
        });
      }
    });
  };
  const registerNormalWatchers = () => {
    const props2 = [
      "label",
      "filters",
      "filterMultiple",
      "sortable",
      "index",
      "formatter",
      "className",
      "labelClassName",
      "showOverflowTooltip"
    ];
    const aliases = {
      property: "prop",
      align: "realAlign",
      headerAlign: "realHeaderAlign"
    };
    const allAliases = getAllAliases(props2, aliases);
    Object.keys(allAliases).forEach((key2) => {
      const columnKey = aliases[key2];
      if (hasOwn(props_, columnKey)) {
        watch$1(() => props_[columnKey], (newVal) => {
          instance.columnConfig.value[key2] = newVal;
        });
      }
    });
  };
  return {
    registerComplexWatchers,
    registerNormalWatchers
  };
}
function useRender(props2, slots, owner) {
  const instance = getCurrentInstance();
  const columnId = ref("");
  const isSubColumn = ref(false);
  const realAlign = ref();
  const realHeaderAlign = ref();
  const ns = useNamespace("table");
  watchEffect(() => {
    realAlign.value = props2.align ? `is-${props2.align}` : null;
    realAlign.value;
  });
  watchEffect(() => {
    realHeaderAlign.value = props2.headerAlign ? `is-${props2.headerAlign}` : realAlign.value;
    realHeaderAlign.value;
  });
  const columnOrTableParent = computed(() => {
    let parent2 = instance.vnode.vParent || instance.parent;
    while (parent2 && !parent2.tableId && !parent2.columnId) {
      parent2 = parent2.vnode.vParent || parent2.parent;
    }
    return parent2;
  });
  const hasTreeColumn = computed(() => {
    const { store } = instance.parent;
    if (!store)
      return false;
    const { treeData } = store.states;
    const treeDataValue = treeData.value;
    return treeDataValue && Object.keys(treeDataValue).length > 0;
  });
  const realWidth = ref(parseWidth(props2.width));
  const realMinWidth = ref(parseMinWidth(props2.minWidth));
  const setColumnWidth = (column) => {
    if (realWidth.value)
      column.width = realWidth.value;
    if (realMinWidth.value) {
      column.minWidth = realMinWidth.value;
    }
    if (!column.minWidth) {
      column.minWidth = 80;
    }
    column.realWidth = Number(column.width === void 0 ? column.minWidth : column.width);
    return column;
  };
  const setColumnForcedProps = (column) => {
    const type = column.type;
    const source = cellForced[type] || {};
    Object.keys(source).forEach((prop) => {
      const value = source[prop];
      if (prop !== "className" && value !== void 0) {
        column[prop] = value;
      }
    });
    const className = getDefaultClassName(type);
    if (className) {
      const forceClass = `${unref(ns.namespace)}-${className}`;
      column.className = column.className ? `${column.className} ${forceClass}` : forceClass;
    }
    return column;
  };
  const checkSubColumn = (children2) => {
    if (Array.isArray(children2)) {
      children2.forEach((child) => check2(child));
    } else {
      check2(children2);
    }
    function check2(item) {
      var _a2;
      if (((_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.name) === "ElTableColumn") {
        item.vParent = instance;
      }
    }
  };
  const setColumnRenders = (column) => {
    if (props2.renderHeader)
      ;
    else if (column.type !== "selection") {
      column.renderHeader = (scope) => {
        instance.columnConfig.value["label"];
        const renderHeader = slots.header;
        return renderHeader ? renderHeader(scope) : column.label;
      };
    }
    let originRenderCell = column.renderCell;
    const hasTreeColumnValue = hasTreeColumn.value;
    if (column.type === "expand") {
      column.renderCell = (data) => h$1("div", {
        class: "cell"
      }, [originRenderCell(data)]);
      owner.value.renderExpanded = (data) => {
        return slots.default ? slots.default(data) : slots.default;
      };
    } else {
      originRenderCell = originRenderCell || defaultRenderCell;
      column.renderCell = (data) => {
        let children2 = null;
        if (slots.default) {
          const vnodes = slots.default(data);
          children2 = vnodes.some((v2) => v2.type !== Comment) ? vnodes : originRenderCell(data);
        } else {
          children2 = originRenderCell(data);
        }
        const shouldCreatePlaceholder = hasTreeColumnValue && data.cellIndex === 0;
        const prefix = treeCellPrefix(data, shouldCreatePlaceholder);
        const props22 = {
          class: "cell",
          style: {}
        };
        if (column.showOverflowTooltip) {
          props22.class = `${props22.class} ${unref(ns.namespace)}-tooltip`;
          props22.style = {
            width: `${(data.column.realWidth || Number(data.column.width)) - 1}px`
          };
        }
        checkSubColumn(children2);
        return h$1("div", props22, [prefix, children2]);
      };
    }
    return column;
  };
  const getPropsData = (...propsKey) => {
    return propsKey.reduce((prev2, cur) => {
      if (Array.isArray(cur)) {
        cur.forEach((key2) => {
          prev2[key2] = props2[key2];
        });
      }
      return prev2;
    }, {});
  };
  const getColumnElIndex = (children2, child) => {
    return Array.prototype.indexOf.call(children2, child);
  };
  return {
    columnId,
    realAlign,
    isSubColumn,
    realHeaderAlign,
    columnOrTableParent,
    setColumnWidth,
    setColumnForcedProps,
    setColumnRenders,
    getPropsData,
    getColumnElIndex
  };
}
var defaultProps = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: false
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: true
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showTooltipWhenOverflow: Boolean,
  showOverflowTooltip: Boolean,
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: true
  },
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => {
      return ["ascending", "descending", null];
    },
    validator: (val) => {
      return val.every((order2) => ["ascending", "descending", null].includes(order2));
    }
  }
};
let columnIdSeed = 1;
var ElTableColumn$1 = defineComponent({
  name: "ElTableColumn",
  components: {
    ElCheckbox
  },
  props: defaultProps,
  setup(props2, { slots }) {
    const instance = getCurrentInstance();
    const columnConfig = ref({});
    const owner = computed(() => {
      let parent22 = instance.parent;
      while (parent22 && !parent22.tableId) {
        parent22 = parent22.parent;
      }
      return parent22;
    });
    const { registerNormalWatchers, registerComplexWatchers } = useWatcher(owner, props2);
    const {
      columnId,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex,
      realAlign
    } = useRender(props2, slots, owner);
    const parent2 = columnOrTableParent.value;
    columnId.value = `${parent2.tableId || parent2.columnId}_column_${columnIdSeed++}`;
    onBeforeMount(() => {
      isSubColumn.value = owner.value !== parent2;
      const type = props2.type || "default";
      const sortable = props2.sortable === "" ? true : props2.sortable;
      const defaults2 = __spreadProps(__spreadValues({}, cellStarts[type]), {
        id: columnId.value,
        type,
        property: props2.prop || props2.property,
        align: realAlign,
        headerAlign: realHeaderAlign,
        showOverflowTooltip: props2.showOverflowTooltip || props2.showTooltipWhenOverflow,
        filterable: props2.filters || props2.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        isColumnGroup: false,
        isSubColumn: false,
        filterOpened: false,
        sortable,
        index: props2.index,
        rawColumnKey: instance.vnode.key
      });
      const basicProps = [
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ];
      const sortProps = ["sortMethod", "sortBy", "sortOrders"];
      const selectProps = ["selectable", "reserveSelection"];
      const filterProps = [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement"
      ];
      let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
      column = mergeOptions(defaults2, column);
      const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
      column = chains(column);
      columnConfig.value = column;
      registerNormalWatchers();
      registerComplexWatchers();
    });
    onMounted(() => {
      var _a2;
      const parent22 = columnOrTableParent.value;
      const children2 = isSubColumn.value ? parent22.vnode.el.children : (_a2 = parent22.refs.hiddenColumns) == null ? void 0 : _a2.children;
      const getColumnIndex = () => getColumnElIndex(children2 || [], instance.vnode.el);
      columnConfig.value.getColumnIndex = getColumnIndex;
      const columnIndex = getColumnIndex();
      columnIndex > -1 && owner.value.store.commit("insertColumn", columnConfig.value, isSubColumn.value ? parent22.columnConfig.value : null);
    });
    onBeforeUnmount(() => {
      owner.value.store.commit("removeColumn", columnConfig.value, isSubColumn.value ? parent2.columnConfig.value : null);
    });
    instance.columnId = columnId.value;
    instance.columnConfig = columnConfig;
    return;
  },
  render() {
    var _a2, _b2, _c2;
    try {
      const renderDefault = (_b2 = (_a2 = this.$slots).default) == null ? void 0 : _b2.call(_a2, {
        row: {},
        column: {},
        $index: -1
      });
      const children2 = [];
      if (Array.isArray(renderDefault)) {
        for (const childNode of renderDefault) {
          if (((_c2 = childNode.type) == null ? void 0 : _c2.name) === "ElTableColumn" || childNode.shapeFlag & 2) {
            children2.push(childNode);
          } else if (childNode.type === Fragment && Array.isArray(childNode.children)) {
            childNode.children.forEach((vnode2) => {
              if ((vnode2 == null ? void 0 : vnode2.patchFlag) !== 1024 && !isString(vnode2 == null ? void 0 : vnode2.children)) {
                children2.push(vnode2);
              }
            });
          }
        }
      }
      const vnode = h$1("div", children2);
      return vnode;
    } catch (e2) {
      return h$1("div", []);
    }
  }
});
const ElTable = withInstall(Table, {
  TableColumn: ElTableColumn$1
});
const ElTableColumn = withNoopInstall(ElTableColumn$1);
const SCOPE$1 = "ElUpload";
class UploadAjaxError extends Error {
  constructor(message2, status, method, url) {
    super(message2);
    this.name = "UploadAjaxError";
    this.status = status;
    this.method = method;
    this.url = url;
  }
}
function getError(action, option, xhr) {
  let msg;
  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to ${option.method} ${action} ${xhr.status}`;
  }
  return new UploadAjaxError(msg, xhr.status, option.method, action);
}
function getBody(xhr) {
  const text2 = xhr.responseText || xhr.response;
  if (!text2) {
    return text2;
  }
  try {
    return JSON.parse(text2);
  } catch (e2) {
    return text2;
  }
}
const ajaxUpload = (option) => {
  if (typeof XMLHttpRequest === "undefined")
    throwError(SCOPE$1, "XMLHttpRequest is undefined");
  const xhr = new XMLHttpRequest();
  const action = option.action;
  if (xhr.upload) {
    xhr.upload.addEventListener("progress", (evt) => {
      const progressEvt = evt;
      progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;
      option.onProgress(progressEvt);
    });
  }
  const formData = new FormData();
  if (option.data) {
    for (const [key2, value] of Object.entries(option.data)) {
      if (Array.isArray(value))
        formData.append(key2, ...value);
      else
        formData.append(key2, value);
    }
  }
  formData.append(option.filename, option.file, option.file.name);
  xhr.addEventListener("error", () => {
    option.onError(getError(action, option, xhr));
  });
  xhr.addEventListener("load", () => {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr));
    }
    option.onSuccess(getBody(xhr));
  });
  xhr.open(option.method, action, true);
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = option.headers || {};
  if (headers instanceof Headers) {
    headers.forEach((value, key2) => xhr.setRequestHeader(key2, value));
  } else {
    for (const [key2, value] of Object.entries(headers)) {
      if (isNil(value))
        continue;
      xhr.setRequestHeader(key2, String(value));
    }
  }
  xhr.send(formData);
  return xhr;
};
const uploadListTypes = ["text", "picture", "picture-card"];
let fileId = 1;
const genFileId = () => Date.now() + fileId++;
const uploadBaseProps = buildProps({
  action: {
    type: String,
    required: true
  },
  headers: {
    type: definePropType(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: Object,
    default: () => mutable({})
  },
  multiple: {
    type: Boolean,
    default: false
  },
  name: {
    type: String,
    default: "file"
  },
  drag: {
    type: Boolean,
    default: false
  },
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: true
  },
  accept: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: "select"
  },
  fileList: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  autoUpload: {
    type: Boolean,
    default: true
  },
  listType: {
    type: String,
    values: uploadListTypes,
    default: "text"
  },
  httpRequest: {
    type: definePropType(Function),
    default: ajaxUpload
  },
  disabled: Boolean,
  limit: Number
});
const uploadProps = buildProps(__spreadProps(__spreadValues({}, uploadBaseProps), {
  beforeUpload: {
    type: definePropType(Function),
    default: NOOP
  },
  beforeRemove: {
    type: definePropType(Function)
  },
  onRemove: {
    type: definePropType(Function),
    default: NOOP
  },
  onChange: {
    type: definePropType(Function),
    default: NOOP
  },
  onPreview: {
    type: definePropType(Function),
    default: NOOP
  },
  onSuccess: {
    type: definePropType(Function),
    default: NOOP
  },
  onProgress: {
    type: definePropType(Function),
    default: NOOP
  },
  onError: {
    type: definePropType(Function),
    default: NOOP
  },
  onExceed: {
    type: definePropType(Function),
    default: NOOP
  }
}));
const uploadListProps = buildProps({
  files: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  disabled: {
    type: Boolean,
    default: false
  },
  handlePreview: {
    type: definePropType(Function),
    default: NOOP
  },
  listType: {
    type: String,
    values: uploadListTypes,
    default: "text"
  }
});
const uploadListEmits = {
  remove: (file) => !!file
};
const _hoisted_1$g = ["onKeydown"];
const _hoisted_2$4 = ["src"];
const _hoisted_3$2 = ["onClick"];
const _hoisted_4$2 = ["onClick"];
const _hoisted_5$2 = ["onClick"];
const __default__$3 = {
  name: "ElUploadList"
};
const _sfc_main$h = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$3), {
  props: uploadListProps,
  emits: uploadListEmits,
  setup(__props, { emit }) {
    const props2 = __props;
    const { t } = useLocale();
    const nsUpload = useNamespace("upload");
    const nsIcon = useNamespace("icon");
    const nsList = useNamespace("list");
    const focusing = ref(false);
    const handleClick = (file) => {
      props2.handlePreview(file);
    };
    const onFileClicked = (e2) => {
      e2.target.focus();
    };
    const handleRemove = (file) => {
      emit("remove", file);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(TransitionGroup, {
        tag: "ul",
        class: normalizeClass([
          unref(nsUpload).b("list"),
          unref(nsUpload).bm("list", _ctx.listType),
          unref(nsUpload).is("disabled", _ctx.disabled)
        ]),
        name: unref(nsList).b()
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
            return openBlock(), createElementBlock("li", {
              key: file.uid || file.name,
              class: normalizeClass([
                unref(nsUpload).be("list", "item"),
                unref(nsUpload).is(file.status),
                { focusing: focusing.value }
              ]),
              tabindex: "0",
              onKeydown: withKeys(($event) => !_ctx.disabled && handleRemove(file), ["delete"]),
              onFocus: _cache[0] || (_cache[0] = ($event) => focusing.value = true),
              onBlur: _cache[1] || (_cache[1] = ($event) => focusing.value = false),
              onClick: onFileClicked
            }, [
              renderSlot(_ctx.$slots, "default", { file }, () => [
                _ctx.listType === "picture" || file.status !== "uploading" && _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("img", {
                  key: 0,
                  class: normalizeClass(unref(nsUpload).be("list", "item-thumbnail")),
                  src: file.url,
                  alt: ""
                }, null, 10, _hoisted_2$4)) : createCommentVNode("v-if", true),
                _ctx.listType !== "picture" && (file.status === "uploading" || _ctx.listType !== "picture-card") ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(unref(nsUpload).be("list", "item-info"))
                }, [
                  createElementVNode("a", {
                    class: normalizeClass(unref(nsUpload).be("list", "item-name")),
                    onClick: ($event) => handleClick(file)
                  }, [
                    createVNode$1(unref(ElIcon), {
                      class: normalizeClass(unref(nsIcon).m("document"))
                    }, {
                      default: withCtx(() => [
                        createVNode$1(unref(document$1))
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    createTextVNode(" " + toDisplayString(file.name), 1)
                  ], 10, _hoisted_3$2),
                  file.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                    key: 0,
                    type: _ctx.listType === "picture-card" ? "circle" : "line",
                    "stroke-width": _ctx.listType === "picture-card" ? 6 : 2,
                    percentage: Number(file.percentage),
                    style: normalizeStyle$1(_ctx.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                  }, null, 8, ["type", "stroke-width", "percentage", "style"])) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true),
                createElementVNode("label", {
                  class: normalizeClass(unref(nsUpload).be("list", "item-status-label"))
                }, [
                  _ctx.listType === "text" ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("circle-check")])
                  }, {
                    default: withCtx(() => [
                      createVNode$1(unref(circleCheck))
                    ]),
                    _: 1
                  }, 8, ["class"])) : ["picture-card", "picture"].includes(_ctx.listType) ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 1,
                    class: normalizeClass([unref(nsIcon).m("upload-success"), unref(nsIcon).m("check")])
                  }, {
                    default: withCtx(() => [
                      createVNode$1(unref(check))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 2),
                !_ctx.disabled ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 2,
                  class: normalizeClass(unref(nsIcon).m("close")),
                  onClick: ($event) => handleRemove(file)
                }, {
                  default: withCtx(() => [
                    createVNode$1(unref(close))
                  ]),
                  _: 2
                }, 1032, ["class", "onClick"])) : createCommentVNode("v-if", true),
                createCommentVNode(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
                createCommentVNode(" This is a bug which needs to be fixed "),
                createCommentVNode(" TODO: Fix the incorrect navigation interaction "),
                !_ctx.disabled ? (openBlock(), createElementBlock("i", {
                  key: 3,
                  class: normalizeClass(unref(nsIcon).m("close-tip"))
                }, toDisplayString(unref(t)("el.upload.deleteTip")), 3)) : createCommentVNode("v-if", true),
                _ctx.listType === "picture-card" ? (openBlock(), createElementBlock("span", {
                  key: 4,
                  class: normalizeClass(unref(nsUpload).be("list", "item-actions"))
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(nsUpload).be("list", "item-preview")),
                    onClick: ($event) => _ctx.handlePreview(file)
                  }, [
                    createVNode$1(unref(ElIcon), {
                      class: normalizeClass(unref(nsIcon).m("zoom-in"))
                    }, {
                      default: withCtx(() => [
                        createVNode$1(unref(zoomIn))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, _hoisted_4$2),
                  !_ctx.disabled ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    class: normalizeClass(unref(nsUpload).be("list", "item-delete")),
                    onClick: ($event) => handleRemove(file)
                  }, [
                    createVNode$1(unref(ElIcon), {
                      class: normalizeClass(unref(nsIcon).m("delete"))
                    }, {
                      default: withCtx(() => [
                        createVNode$1(unref(_delete))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, _hoisted_5$2)) : createCommentVNode("v-if", true)
                ], 2)) : createCommentVNode("v-if", true)
              ])
            ], 42, _hoisted_1$g);
          }), 128)),
          renderSlot(_ctx.$slots, "append")
        ]),
        _: 3
      }, 8, ["class", "name"]);
    };
  }
}));
var UploadList = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const uploadDraggerProps = buildProps({
  disabled: {
    type: Boolean,
    default: false
  }
});
const uploadDraggerEmits = {
  file: (file) => isArray(file)
};
const _hoisted_1$f = ["onDrop", "onDragover"];
const __default__$2 = {
  name: "ElUploadDrag"
};
const _sfc_main$g = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$2), {
  props: uploadDraggerProps,
  emits: uploadDraggerEmits,
  setup(__props, { emit }) {
    const props2 = __props;
    const COMPONENT_NAME2 = "ElUploadDrag";
    const uploaderContext = inject(uploadContextKey);
    if (!uploaderContext) {
      throwError(COMPONENT_NAME2, "usage: <el-upload><el-upload-dragger /></el-upload>");
    }
    const ns = useNamespace("upload");
    const dragover = ref(false);
    const onDrop = (e2) => {
      if (props2.disabled)
        return;
      dragover.value = false;
      const files2 = Array.from(e2.dataTransfer.files);
      const accept = uploaderContext.accept.value;
      if (!accept) {
        emit("file", files2);
        return;
      }
      const filesFiltered = files2.filter((file) => {
        const { type, name } = file;
        const extension = name.includes(".") ? `.${name.split(".").pop()}` : "";
        const baseType = type.replace(/\/.*$/, "");
        return accept.split(",").map((type2) => type2.trim()).filter((type2) => type2).some((acceptedType) => {
          if (acceptedType.startsWith(".")) {
            return extension === acceptedType;
          }
          if (/\/\*$/.test(acceptedType)) {
            return baseType === acceptedType.replace(/\/\*$/, "");
          }
          if (/^[^/]+\/[^/]+$/.test(acceptedType)) {
            return type === acceptedType;
          }
          return false;
        });
      });
      emit("file", filesFiltered);
    };
    const onDragover = () => {
      if (!props2.disabled)
        dragover.value = true;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([unref(ns).b("dragger"), unref(ns).is("dragover", dragover.value)]),
        onDrop: withModifiers(onDrop, ["prevent"]),
        onDragover: withModifiers(onDragover, ["prevent"]),
        onDragleave: _cache[0] || (_cache[0] = withModifiers(($event) => dragover.value = false, ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 42, _hoisted_1$f);
    };
  }
}));
var UploadDragger = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const uploadContentProps = buildProps(__spreadProps(__spreadValues({}, uploadBaseProps), {
  fileList: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  beforeUpload: {
    type: definePropType(Function),
    default: NOOP
  },
  onRemove: {
    type: definePropType(Function),
    default: NOOP
  },
  onStart: {
    type: definePropType(Function),
    default: NOOP
  },
  onSuccess: {
    type: definePropType(Function),
    default: NOOP
  },
  onProgress: {
    type: definePropType(Function),
    default: NOOP
  },
  onError: {
    type: definePropType(Function),
    default: NOOP
  },
  onExceed: {
    type: definePropType(Function),
    default: NOOP
  }
}));
const _hoisted_1$e = ["onKeydown"];
const _hoisted_2$3 = ["name", "multiple", "accept"];
const __default__$1 = {
  name: "ElUploadContent",
  inheritAttrs: false
};
const _sfc_main$f = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$1), {
  props: uploadContentProps,
  setup(__props, { expose }) {
    const props2 = __props;
    const ns = useNamespace("upload");
    const requests = shallowRef({});
    const inputRef = shallowRef();
    const uploadFiles = (files2) => {
      if (files2.length === 0)
        return;
      const { autoUpload, limit, fileList, multiple, onStart, onExceed } = props2;
      if (limit && fileList.length + files2.length > limit) {
        onExceed(files2, fileList);
        return;
      }
      if (!multiple) {
        files2 = files2.slice(0, 1);
      }
      for (const file of files2) {
        const rawFile = file;
        rawFile.uid = genFileId();
        onStart(rawFile);
        if (autoUpload)
          upload2(rawFile);
      }
    };
    const upload2 = async (rawFile) => {
      inputRef.value.value = "";
      if (!props2.beforeUpload) {
        return doUpload(rawFile);
      }
      let hookResult;
      try {
        hookResult = await props2.beforeUpload(rawFile);
      } catch (e2) {
        hookResult = false;
      }
      if (hookResult === false) {
        props2.onRemove(rawFile);
        return;
      }
      let file = rawFile;
      if (hookResult instanceof Blob) {
        if (hookResult instanceof File) {
          file = hookResult;
        } else {
          file = new File([hookResult], rawFile.name, {
            type: rawFile.type
          });
        }
        for (const key2 of Object.keys(rawFile)) {
          file[key2] = rawFile[key2];
        }
      }
      doUpload(rawFile);
    };
    const doUpload = (rawFile) => {
      const {
        headers,
        data,
        method,
        withCredentials,
        name: filename,
        action,
        onProgress,
        onSuccess,
        onError,
        httpRequest
      } = props2;
      const { uid: uid2 } = rawFile;
      const options = {
        headers: headers || {},
        withCredentials,
        file: rawFile,
        data,
        method,
        filename,
        action,
        onProgress: (evt) => {
          onProgress(evt, rawFile);
        },
        onSuccess: (res) => {
          onSuccess(res, rawFile);
          delete requests.value[uid2];
        },
        onError: (err) => {
          onError(err, rawFile);
          delete requests.value[uid2];
        }
      };
      const request = httpRequest(options);
      requests.value[uid2] = request;
      if (request instanceof Promise) {
        request.then(options.onSuccess, options.onError);
      }
    };
    const handleChange = (e2) => {
      const files2 = e2.target.files;
      if (!files2)
        return;
      uploadFiles(Array.from(files2));
    };
    const handleClick = () => {
      if (!props2.disabled) {
        inputRef.value.value = "";
        inputRef.value.click();
      }
    };
    const handleKeydown = () => {
      handleClick();
    };
    const abort = (file) => {
      const _reqs = entriesOf(requests.value).filter(file ? ([uid2]) => String(file.uid) === uid2 : () => true);
      _reqs.forEach(([uid2, req]) => {
        if (req instanceof XMLHttpRequest)
          req.abort();
        delete requests.value[uid2];
      });
    };
    expose({
      abort,
      upload: upload2
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([unref(ns).b(), unref(ns).m(_ctx.listType)]),
        tabindex: "0",
        onClick: handleClick,
        onKeydown: withKeys(withModifiers(handleKeydown, ["self"]), ["enter", "space"])
      }, [
        _ctx.drag ? (openBlock(), createBlock(UploadDragger, {
          key: 0,
          disabled: _ctx.disabled,
          onFile: uploadFiles
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["disabled"])) : renderSlot(_ctx.$slots, "default", { key: 1 }),
        createElementVNode("input", {
          ref_key: "inputRef",
          ref: inputRef,
          class: normalizeClass(unref(ns).e("input")),
          name: _ctx.name,
          multiple: _ctx.multiple,
          accept: _ctx.accept,
          type: "file",
          onChange: handleChange
        }, null, 42, _hoisted_2$3)
      ], 42, _hoisted_1$e);
    };
  }
}));
var UploadContent = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const SCOPE = "ElUpload";
const revokeObjectURL = (file) => {
  var _a2;
  if ((_a2 = file.url) == null ? void 0 : _a2.startsWith("blob:")) {
    URL.revokeObjectURL(file.url);
  }
};
const useHandlers = (props2, uploadRef) => {
  const uploadFiles = ref([]);
  const getFile = (rawFile) => uploadFiles.value.find((file) => file.uid === rawFile.uid);
  function abort(file) {
    var _a2;
    (_a2 = uploadRef.value) == null ? void 0 : _a2.abort(file);
  }
  function clearFiles(states = ["ready", "uploading", "success", "fail"]) {
    uploadFiles.value = uploadFiles.value.filter((row) => !states.includes(row.status));
  }
  const handleError = (err, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    file.status = "fail";
    uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
    props2.onError(err, file, uploadFiles.value);
    props2.onChange(file, uploadFiles.value);
  };
  const handleProgress = (evt, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    props2.onProgress(evt, file, uploadFiles.value);
    file.status = "uploading";
    file.percentage = Math.round(evt.percent);
  };
  const handleSuccess = (response, rawFile) => {
    const file = getFile(rawFile);
    if (!file)
      return;
    file.status = "success";
    file.response = response;
    props2.onSuccess(response, file, uploadFiles.value);
    props2.onChange(file, uploadFiles.value);
  };
  const handleStart = (file) => {
    const uploadFile = {
      name: file.name,
      percentage: 0,
      status: "ready",
      size: file.size,
      raw: file,
      uid: file.uid
    };
    if (props2.listType === "picture-card" || props2.listType === "picture") {
      try {
        uploadFile.url = URL.createObjectURL(file);
      } catch (err) {
        debugWarn(SCOPE, err.message);
        props2.onError(err, uploadFile, uploadFiles.value);
      }
    }
    uploadFiles.value.push(uploadFile);
    props2.onChange(uploadFile, uploadFiles.value);
  };
  const handleRemove = async (file, rawFile) => {
    if (rawFile) {
      useDeprecated({
        scope: SCOPE,
        from: "handleRemove second argument",
        version: "2.2",
        replacement: "first argument `file`",
        ref: "https://element-plus.org/en-US/component/upload.html#methods"
      }, true);
    }
    const _file = rawFile || file;
    const uploadFile = _file instanceof File ? getFile(_file) : _file;
    if (!uploadFile)
      throwError(SCOPE, "file to be removed not found");
    const doRemove = (file2) => {
      abort(file2);
      const fileList = uploadFiles.value;
      fileList.splice(fileList.indexOf(file2), 1);
      props2.onRemove(file2, fileList);
      revokeObjectURL(file2);
    };
    if (props2.beforeRemove) {
      const before = await props2.beforeRemove(uploadFile, uploadFiles.value);
      if (before !== false)
        doRemove(uploadFile);
    } else {
      doRemove(uploadFile);
    }
  };
  function submit() {
    uploadFiles.value.filter(({ status }) => status === "ready").forEach(({ raw }) => {
      var _a2;
      return raw && ((_a2 = uploadRef.value) == null ? void 0 : _a2.upload(raw));
    });
  }
  watch$1(() => props2.listType, (val) => {
    if (val !== "picture-card" && val !== "picture") {
      return;
    }
    uploadFiles.value = uploadFiles.value.map((file) => {
      const { raw, url } = file;
      if (!url && raw) {
        try {
          file.url = URL.createObjectURL(raw);
        } catch (err) {
          props2.onError(err, file, uploadFiles.value);
        }
      }
      return file;
    });
  });
  watch$1(() => props2.fileList, (fileList) => {
    for (const file of fileList) {
      file.uid || (file.uid = genFileId());
      file.status || (file.status = "success");
    }
    uploadFiles.value = fileList;
  }, { immediate: true, deep: true });
  return {
    abort,
    clearFiles,
    handleError,
    handleProgress,
    handleStart,
    handleSuccess,
    handleRemove,
    submit,
    uploadFiles
  };
};
const __default__ = {
  name: "ElUpload"
};
const _sfc_main$e = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__), {
  props: uploadProps,
  setup(__props, { expose }) {
    const props2 = __props;
    const slots = useSlots();
    const disabled = useDisabled$1();
    const uploadRef = shallowRef();
    const {
      abort,
      submit,
      clearFiles,
      uploadFiles,
      handleStart,
      handleError,
      handleRemove,
      handleSuccess,
      handleProgress
    } = useHandlers(props2, uploadRef);
    const isPictureCard = computed(() => props2.listType === "picture-card");
    const uploadContentProps2 = computed(() => __spreadProps(__spreadValues({}, props2), {
      onStart: handleStart,
      onProgress: handleProgress,
      onSuccess: handleSuccess,
      onError: handleError,
      onRemove: handleRemove
    }));
    onBeforeUnmount(() => {
      uploadFiles.value.forEach(({ url }) => {
        if (url == null ? void 0 : url.startsWith("blob:"))
          URL.revokeObjectURL(url);
      });
    });
    provide(uploadContextKey, {
      accept: toRef(props2, "accept")
    });
    expose({
      abort,
      submit,
      clearFiles,
      handleStart,
      handleRemove
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
          key: 0,
          disabled: unref(disabled),
          "list-type": _ctx.listType,
          files: unref(uploadFiles),
          "handle-preview": _ctx.onPreview,
          onRemove: unref(handleRemove)
        }, createSlots({
          append: withCtx(() => [
            _ctx.listType === "picture-card" ? (openBlock(), createBlock(UploadContent, mergeProps({
              key: 0,
              ref_key: "uploadRef",
              ref: uploadRef
            }, unref(uploadContentProps2)), {
              default: withCtx(() => [
                unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
                !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
              ]),
              _: 3
            }, 16)) : createCommentVNode("v-if", true)
          ]),
          _: 2
        }, [
          _ctx.$slots.file ? {
            name: "default",
            fn: withCtx(({ file }) => [
              renderSlot(_ctx.$slots, "file", { file })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true),
        _ctx.listType !== "picture-card" ? (openBlock(), createBlock(UploadContent, mergeProps({
          key: 1,
          ref_key: "uploadRef",
          ref: uploadRef
        }, unref(uploadContentProps2)), {
          default: withCtx(() => [
            unref(slots).trigger ? renderSlot(_ctx.$slots, "trigger", { key: 0 }) : createCommentVNode("v-if", true),
            !unref(slots).trigger && unref(slots).default ? renderSlot(_ctx.$slots, "default", { key: 1 }) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16)) : createCommentVNode("v-if", true),
        _ctx.$slots.trigger ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "tip"),
        !unref(isPictureCard) && _ctx.showFileList ? (openBlock(), createBlock(UploadList, {
          key: 3,
          disabled: unref(disabled),
          "list-type": _ctx.listType,
          files: unref(uploadFiles),
          "handle-preview": _ctx.onPreview,
          onRemove: unref(handleRemove)
        }, createSlots({ _: 2 }, [
          _ctx.$slots.file ? {
            name: "default",
            fn: withCtx(({ file }) => [
              renderSlot(_ctx.$slots, "file", { file })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "handle-preview", "onRemove"])) : createCommentVNode("v-if", true)
      ]);
    };
  }
}));
var Upload$1 = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const ElUpload = withInstall(Upload$1);
var index_vue_vue_type_style_index_0_scoped_true_lang$d = "";
const _hoisted_1$d = { class: "d-cascader" };
const _sfc_main$d = {
  props: {
    modelValue: Array,
    options: { type: Array, default: () => [] },
    showAllLevels: { type: Boolean, default: () => {
      return true;
    } }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const props2 = __props;
    const modelValue = computed({
      get: () => props2.modelValue,
      set: (value) => {
        emit("update:modelValue", value);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$d, [
        createVNode$1(unref(ElCascader), {
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          options: __props.options,
          "show-all-levels": __props.showAllLevels
        }, null, 8, ["modelValue", "options", "show-all-levels"])
      ]);
    };
  }
};
var Cascader = /* @__PURE__ */ _export_sfc$2(_sfc_main$d, [["__scopeId", "data-v-0ffbdf9a"]]);
const CascaderPlugin = {
  install(app) {
    app.component("d-cascader", Cascader);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$c = "";
var index_vue_vue_type_style_index_1_lang$1 = "";
const _hoisted_1$c = { class: "d-select" };
const _sfc_main$c = {
  props: {
    modelValue: [String, Array],
    options: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  emits: ["update:modelValue", "change"],
  setup(__props, { emit }) {
    const props2 = __props;
    const attrs = useAttrs$1();
    let privateProps = reactive({
      disabled: false,
      multiple: false,
      clearable: false,
      filterable: false,
      placeholder: "\u8BF7\u9009\u62E9",
      value: "value",
      label: "label",
      "collapse-tags": false
    });
    const modelValue = computed({
      get: () => props2.modelValue,
      set: (value) => {
        emit("update:modelValue", value);
        emit("change", value);
      }
    });
    let setSelectProps = (propsTitle) => {
      if (attrs[propsTitle] !== void 0) {
        privateProps[propsTitle] = attrs[propsTitle];
      }
    };
    onMounted(() => {
      nextTick$1(() => {
        for (const key2 in attrs) {
          setSelectProps(key2);
        }
        if (privateProps.multiple !== false) {
          modelValue.value = [];
        }
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        createVNode$1(unref(ElSelect), {
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          placeholder: unref(privateProps).placeholder,
          disabled: unref(privateProps).disabled,
          multiple: unref(privateProps).multiple,
          clearable: unref(privateProps).clearable,
          "collapse-tags": unref(privateProps)["collapse-tags"],
          filterable: unref(privateProps).filterable
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (item) => {
              return openBlock(), createBlock(unref(ElOption), {
                key: item[unref(privateProps).value],
                label: item[unref(privateProps).label],
                value: item[unref(privateProps).value]
              }, null, 8, ["label", "value"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "placeholder", "disabled", "multiple", "clearable", "collapse-tags", "filterable"])
      ]);
    };
  }
};
var Select = /* @__PURE__ */ _export_sfc$2(_sfc_main$c, [["__scopeId", "data-v-81043cc0"]]);
const SelectPlugin = {
  install(app) {
    app.component("d-select", Select);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$b = "";
const _hoisted_1$b = { class: "d-tooltip" };
const _sfc_main$b = {
  props: {
    placement: {
      type: String,
      default: () => {
        return "right";
      }
    },
    popperClass: {
      type: String,
      default: () => {
        return "";
      }
    },
    content: {
      type: String,
      default: () => {
        return "";
      }
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$b, [
        createVNode$1(unref(ElTooltip), {
          placement: __props.placement,
          "popper-class": __props.popperClass,
          effect: "dark",
          content: __props.content
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "content", {}, void 0, true)
          ]),
          _: 3
        }, 8, ["placement", "popper-class", "content"])
      ]);
    };
  }
};
var Tooltip = /* @__PURE__ */ _export_sfc$2(_sfc_main$b, [["__scopeId", "data-v-1566ff62"]]);
const TooltipPlugin = {
  install(app) {
    app.component("d-tooltip", Tooltip);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$a = "";
const _hoisted_1$a = { class: "d-transfer" };
const _hoisted_2$2 = { class: "left_transfer" };
const _hoisted_3$1 = { class: "search_box" };
const _hoisted_4$1 = { class: "table_box" };
const _hoisted_5$1 = { class: "icon_btn" };
const _hoisted_6$1 = { class: "right_transfer" };
const _hoisted_7 = { class: "search_box" };
const _hoisted_8 = { class: "table_box" };
const _hoisted_9 = /* @__PURE__ */ createTextVNode("> ");
const _sfc_main$a = {
  props: {
    leftData: {
      type: Array,
      default: () => {
        return [];
      }
    },
    rightData: {
      type: Array,
      default: () => {
        return [];
      }
    },
    compareId: {
      type: String,
      default: () => {
        return "id";
      }
    },
    tableProp: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  emits: ["update:leftData", "update:rightData"],
  setup(__props, { emit }) {
    const props2 = __props;
    const attrs = useAttrs$1();
    let privateProps = reactive({
      "select-prop": {
        label: "label",
        value: "value",
        placeholder: "\u8BF7\u9009\u62E9",
        name: "\u5DF2\u9009\u57FA\u7AD9"
      }
    });
    let maxHeight = ref(200);
    let modelValue = ref("");
    let leftEle = ref(null);
    let rightEle = ref(null);
    let toNotSelectEle = ref(null);
    let toSelectEle = ref(null);
    let leftData = computed({
      get: () => props2.leftData,
      set: (value) => {
        emit("update:leftData", value);
      }
    });
    let rightData = computed({
      get: () => props2.rightData,
      set: (value) => {
        emit("update:rightData", value);
      }
    });
    let leftSelections = ref([]);
    let rightSelections = ref([]);
    let handleSelectionChange = (event, tableType) => {
      switch (tableType) {
        case "notSelectedTable":
          leftSelections.value = event;
          if (event.length > 0) {
            toSelectEle.value.className = "active";
          } else {
            toSelectEle.value.className = "";
          }
          break;
        case "selectedTable":
          rightSelections.value = event;
          if (event.length > 0) {
            toNotSelectEle.value.className = "active";
          } else {
            toNotSelectEle.value.className = "";
          }
          break;
      }
    };
    let toNotSelected = () => {
      if (rightSelections.value.length > 0) {
        let removeSelected = [];
        for (let i = 0; i < rightData.value.length; i++) {
          let hasSelected = rightSelections.value.findIndex((item) => {
            return item[props2.compareId] === rightData.value[i][props2.compareId];
          });
          if (hasSelected !== -1) {
            removeSelected.push(rightData.value[i]);
            rightData.value.splice(i, 1);
            i--;
          }
        }
        leftData.value.push(...removeSelected);
      }
    };
    let toSelected = () => {
      if (leftSelections.value.length > 0) {
        modelValue.value = "";
        let addSelected = [];
        for (let i = 0; i < leftData.value.length; i++) {
          let hasSelected = leftSelections.value.findIndex((item) => {
            return item[props2.compareId] === leftData.value[i][props2.compareId];
          });
          if (hasSelected !== -1) {
            addSelected.push(leftData.value[i]);
            leftData.value.splice(i, 1);
            i--;
          }
        }
        rightData.value.push(...addSelected);
      }
    };
    let changeSelect = (selectValue) => {
      let findIndex = leftData.value.findIndex((item) => {
        return item[privateProps["select-prop"].value] === selectValue;
      });
      if (findIndex !== -1) {
        let selectList = leftData.value.splice(findIndex, 1);
        leftData.value.unshift(...selectList);
        leftEle.value.setScrollTop(0);
      }
    };
    let setSelectProps = (propsTitle) => {
      if (attrs[propsTitle] !== void 0) {
        console.log(attrs[propsTitle]);
        privateProps[propsTitle] = attrs[propsTitle];
        console.log(privateProps[propsTitle]);
      }
    };
    onBeforeMount(() => {
      for (const key2 in attrs) {
        switch (key2) {
          case "select-prop":
            Object.assign(privateProps["select-prop"], attrs[key2]);
            break;
          default:
            setSelectProps(key2);
            break;
        }
      }
    });
    onMounted(() => {
      nextTick$1(() => {
        maxHeight.value = Array.from(document.querySelectorAll(".left_transfer .table_box"))[0].clientHeight - 15;
        if (privateProps.multiple !== false) {
          modelValue.value = [];
        }
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        createElementVNode("div", _hoisted_2$2, [
          createElementVNode("div", _hoisted_3$1, [
            createVNode$1(unref(ElSelect), {
              modelValue: unref(modelValue),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : modelValue = $event),
              clearable: "",
              filterable: "",
              onChange: unref(changeSelect),
              placeholder: unref(privateProps)["select-prop"].placeholder
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(leftData), (item) => {
                  return openBlock(), createBlock(unref(ElOption), {
                    key: item[unref(privateProps)["select-prop"].value],
                    label: item[unref(privateProps)["select-prop"].label],
                    value: item[unref(privateProps)["select-prop"].value]
                  }, null, 8, ["label", "value"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["modelValue", "onChange", "placeholder"])
          ]),
          createElementVNode("div", _hoisted_4$1, [
            createVNode$1(unref(ElTable), {
              ref_key: "leftEle",
              ref: leftEle,
              data: unref(leftData),
              style: { "width": "100%" },
              height: unref(maxHeight),
              onSelectionChange: _cache[1] || (_cache[1] = ($event) => unref(handleSelectionChange)($event, "notSelectedTable"))
            }, {
              default: withCtx(() => [
                createVNode$1(unref(ElTableColumn), {
                  type: "selection",
                  width: "55"
                }),
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.tableProp, (item) => {
                  return openBlock(), createBlock(unref(ElTableColumn), {
                    prop: item.prop,
                    label: item.label,
                    key: item.label,
                    width: item.width ? item.width : "auto"
                  }, null, 8, ["prop", "label", "width"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["data", "height"])
          ])
        ]),
        createElementVNode("div", _hoisted_5$1, [
          createElementVNode("span", {
            ref_key: "toNotSelectEle",
            ref: toNotSelectEle,
            onClick: _cache[2] || (_cache[2] = (...args) => unref(toNotSelected) && unref(toNotSelected)(...args))
          }, [
            createVNode$1(unref(ElIcon), null, {
              default: withCtx(() => [
                createVNode$1(unref(arrowLeft))
              ]),
              _: 1
            })
          ], 512),
          createElementVNode("span", {
            ref_key: "toSelectEle",
            ref: toSelectEle,
            onClick: _cache[3] || (_cache[3] = (...args) => unref(toSelected) && unref(toSelected)(...args))
          }, [
            createVNode$1(unref(ElIcon), null, {
              default: withCtx(() => [
                createVNode$1(unref(arrowRight))
              ]),
              _: 1
            })
          ], 512)
        ]),
        createElementVNode("div", _hoisted_6$1, [
          createElementVNode("div", _hoisted_7, toDisplayString(unref(privateProps)["select-prop"].name) + "\uFF1A" + toDisplayString(unref(rightData).length), 1),
          createElementVNode("div", _hoisted_8, [
            createVNode$1(unref(ElTable), {
              ref_key: "rightEle",
              ref: rightEle,
              data: unref(rightData),
              style: { "width": "100%" },
              height: unref(maxHeight),
              onSelectionChange: _cache[4] || (_cache[4] = ($event) => unref(handleSelectionChange)($event, "selectedTable"))
            }, {
              default: withCtx(() => [
                _hoisted_9,
                createVNode$1(unref(ElTableColumn), {
                  type: "selection",
                  width: "55"
                }),
                (openBlock(true), createElementBlock(Fragment, null, renderList(__props.tableProp, (item) => {
                  return openBlock(), createBlock(unref(ElTableColumn), {
                    prop: item.prop,
                    label: item.label,
                    key: item.label,
                    width: item.width ? item.width : "auto"
                  }, null, 8, ["prop", "label", "width"]);
                }), 128))
              ]),
              _: 1
            }, 8, ["data", "height"])
          ])
        ])
      ]);
    };
  }
};
var Transfer = /* @__PURE__ */ _export_sfc$2(_sfc_main$a, [["__scopeId", "data-v-cd5fcef0"]]);
const TransferPlugin = {
  install(app) {
    app.component("d-transfer", Transfer);
  }
};
var _imports_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAABHNCSVQICAgIfAhkiAAAAKJJREFUKFNjZCARMILUZ+RUOPxjYrCfNamjEZv+tLyKBqZ/DAdmTOk4ANYAEmBkYKhn+M+wYObkjkRkTWl5FQsYGRji////VzhrctcEsAaoJrAEsia4YgaGhbMmdSSA1ME1oGv6z8jACDYZSTGGBhRNDAwM6IoJasDmJ6xOApkMNQ3FTyg2YPMgTAzZJpRgxeZmrMEKjjjGfwagcCYq4khJHQCN1WgN3+m8pgAAAABJRU5ErkJggg==";
var index_vue_vue_type_style_index_0_scoped_true_lang$9 = "";
const _withScopeId = (n) => (pushScopeId("data-v-61c8a4a2"), n = n(), popScopeId(), n);
const _hoisted_1$9 = { class: "d-dialog private_dialog" };
const _hoisted_2$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("img", {
  src: _imports_0,
  alt: "\u5173\u95ED"
}, null, -1));
const _hoisted_3 = [
  _hoisted_2$1
];
const _hoisted_4 = { class: "dialog_content" };
const _hoisted_5 = /* @__PURE__ */ createTextVNode("\u53D6\u6D88");
const _hoisted_6 = /* @__PURE__ */ createTextVNode("\u786E\u5B9A");
const _sfc_main$9 = {
  props: {
    visible: { type: Boolean, default: () => {
      return false;
    } },
    disabled: { type: Boolean, default: () => {
      return true;
    } },
    titleName: { type: String, default: () => {
      return "";
    } },
    customClass: { type: String, default: () => {
      return "";
    } },
    openDelay: { type: Number, default: () => {
      return 0;
    } },
    closeDelay: { type: Number, default: () => {
      return 0;
    } },
    modal: { type: Boolean, default: () => {
      return true;
    } },
    closeOnClickModal: { type: Boolean, default: () => {
      return true;
    } },
    draggable: { type: Boolean, default: () => {
      return false;
    } }
  },
  emits: ["update:visible", "click"],
  setup(__props, { emit }) {
    const props2 = __props;
    useSlots();
    const visible = computed({
      get: () => props2.visible,
      set: (value) => {
        emit("update:visible", value);
      }
    });
    watch$1(visible, (newItem, oldItem) => {
      if (newItem) {
        nextTick$1(() => {
          let elBox = Array.from(document.querySelectorAll(".private_dialog .el-dialog"))[0];
          elBox.style.top = `calc(50% - ${elBox.clientHeight / 2 + "px"})`;
        });
      }
    });
    let closeDialog = () => {
      visible.value = false;
    };
    let submitForm = () => {
      emit("click", true);
    };
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        createVNode$1(unref(ElDialog), {
          modelValue: unref(visible),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(visible) ? visible.value = $event : null),
          center: "",
          title: __props.titleName,
          modal: __props.modal,
          "custom-class": __props.customClass,
          "close-on-click-modal": __props.closeOnClickModal,
          draggable: __props.draggable,
          "open-delay": __props.openDelay,
          "close-delay": __props.closeDelay
        }, {
          title: withCtx(() => [
            createElementVNode("span", null, toDisplayString(__props.titleName), 1),
            createElementVNode("span", {
              class: "header_close",
              onClick: _cache[0] || (_cache[0] = (...args) => unref(closeDialog) && unref(closeDialog)(...args))
            }, _hoisted_3)
          ]),
          footer: withCtx(() => [
            createVNode$1(unref(ElButton), {
              onClick: unref(closeDialog),
              class: "button_info"
            }, {
              default: withCtx(() => [
                _hoisted_5
              ]),
              _: 1
            }, 8, ["onClick"]),
            createVNode$1(unref(ElButton), {
              onClick: unref(submitForm),
              disabled: __props.disabled,
              class: "button_primary"
            }, {
              default: withCtx(() => [
                _hoisted_6
              ]),
              _: 1
            }, 8, ["onClick", "disabled"])
          ]),
          default: withCtx(() => [
            createElementVNode("div", _hoisted_4, [
              renderSlot(_ctx.$slots, "content", {}, void 0, true)
            ])
          ]),
          _: 3
        }, 8, ["modelValue", "title", "modal", "custom-class", "close-on-click-modal", "draggable", "open-delay", "close-delay"])
      ]);
    };
  }
};
var Dialog = /* @__PURE__ */ _export_sfc$2(_sfc_main$9, [["__scopeId", "data-v-61c8a4a2"]]);
const DialogPlugin = {
  install(app) {
    app.component("d-dialog", Dialog);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$8 = "";
const _hoisted_1$8 = { class: "d-pagination" };
const _sfc_main$8 = {
  props: {
    total: {
      type: Number,
      default: () => {
        return 100;
      }
    },
    layout: {
      type: String,
      default: () => {
        return "total, sizes, prev, pager, next, jumper";
      }
    },
    pageSize: {
      type: Number,
      default: () => {
        return 5;
      }
    },
    currentPage: {
      type: Number,
      default: () => {
        return 1;
      }
    },
    pageSizes: {
      type: Array,
      default: () => {
        return [5, 10, 15, 20];
      }
    }
  },
  emits: ["size-change", "current-change"],
  setup(__props, { emit }) {
    let onSizeChange = (val) => {
      emit("size-change", val);
    };
    let onCurrentChange = (val) => {
      emit("current-change", val);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        createVNode$1(unref(ElPagination), {
          currentPage: __props.currentPage,
          "onUpdate:currentPage": _cache[0] || (_cache[0] = ($event) => isRef(currentPage) ? currentPage.value = $event : null),
          "page-size": __props.pageSize,
          "onUpdate:page-size": _cache[1] || (_cache[1] = ($event) => isRef(pageSize) ? pageSize.value = $event : null),
          "page-sizes": __props.pageSizes,
          layout: __props.layout,
          total: __props.total,
          onSizeChange: unref(onSizeChange),
          onCurrentChange: unref(onCurrentChange)
        }, null, 8, ["currentPage", "page-size", "page-sizes", "layout", "total", "onSizeChange", "onCurrentChange"])
      ]);
    };
  }
};
var Pagination = /* @__PURE__ */ _export_sfc$2(_sfc_main$8, [["__scopeId", "data-v-71f04c66"]]);
const PaginationPlugin = {
  install(app) {
    app.component("d-pagination", Pagination);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$7 = "";
const _hoisted_1$7 = { class: "d-input" };
const _sfc_main$7 = {
  props: {
    modelValue: [String, Number],
    type: { type: String, default: () => {
      return "text";
    } },
    maxlength: [String, Number],
    minlength: [Number],
    max: [Number],
    min: [Number],
    step: [Number],
    placeholder: { type: String, default: () => {
      return "\u8BF7\u8F93\u5165\u5185\u5BB9";
    } },
    disabled: { type: Boolean, default: () => {
      return false;
    } },
    clearable: { type: Boolean, default: () => {
      return false;
    } },
    showPassword: { type: Boolean, default: () => {
      return false;
    } },
    spaceable: { type: Boolean, default: () => {
      return false;
    } },
    suffixIcon: [String, Object],
    prefixIcon: [String, Object]
  },
  emits: ["update:modelValue", "input", "clear", "blur", "focus", "change"],
  setup(__props, { emit }) {
    const props2 = __props;
    let slots = useSlots();
    const modelValue = computed({
      get: () => props2.modelValue,
      set: (value) => {
        if (typeof value === "string") {
          if (props2.spaceable) {
            value = value.replaceAll(" ", "");
          }
        }
        emit("update:modelValue", value);
      }
    });
    let inputClick = (value) => {
      emit("input", value);
    };
    let clearClick = () => {
      emit("clear", true);
    };
    let blurClick = () => {
      emit("blur", true);
    };
    let changeClick = () => {
      emit("change", true);
    };
    let focusClick = () => {
      emit("focus", true);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        __props.type === "number" ? (openBlock(), createBlock(unref(ElInputNumber), {
          key: 0,
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          max: __props.max,
          min: __props.min,
          step: __props.step
        }, null, 8, ["modelValue", "max", "min", "step"])) : (openBlock(), createBlock(unref(ElInput), {
          key: 1,
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          type: __props.type,
          placeholder: __props.placeholder,
          disabled: __props.disabled,
          "suffix-icon": __props.suffixIcon,
          "prefix-icon": __props.prefixIcon,
          clearable: __props.clearable,
          "show-password": __props.showPassword,
          onInput: unref(inputClick),
          onClear: unref(clearClick),
          onBlur: unref(blurClick),
          onChange: unref(changeClick),
          onFocus: unref(focusClick)
        }, createSlots({ _: 2 }, [
          unref(slots).suffixSlot ? {
            name: "suffix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "suffixSlot", {}, void 0, true)
            ])
          } : void 0,
          unref(slots).prefixSlot ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefixSlot", {}, void 0, true)
            ])
          } : void 0,
          unref(slots).prependSlot ? {
            name: "prepend",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prependSlot", {}, void 0, true)
            ])
          } : void 0,
          unref(slots).appendSlot ? {
            name: "append",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "appendSlot", {}, void 0, true)
            ])
          } : void 0
        ]), 1032, ["modelValue", "type", "placeholder", "disabled", "suffix-icon", "prefix-icon", "clearable", "show-password", "onInput", "onClear", "onBlur", "onChange", "onFocus"]))
      ]);
    };
  }
};
var Input = /* @__PURE__ */ _export_sfc$2(_sfc_main$7, [["__scopeId", "data-v-24a54b61"]]);
const InputPlugin = {
  install(app) {
    app.component("d-input", Input);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$6 = "";
var index_vue_vue_type_style_index_1_lang = "";
const _hoisted_1$6 = { class: "d-data-picker" };
const _sfc_main$6 = {
  props: {
    modelValue: [String, Array],
    disabledDate: Function,
    type: { type: String, default: (value) => {
      return "date";
    } },
    editable: { type: Boolean, default: (value) => {
      return false;
    } },
    disabled: { type: Boolean, default: (value) => {
      return false;
    } },
    readonly: { type: Boolean, default: (value) => {
      return false;
    } },
    clearable: { type: Boolean, default: (value) => {
      return true;
    } },
    placeholder: { type: String, default: () => {
      return "\u8BF7\u9009\u62E9\u65F6\u95F4";
    } },
    format: { type: String, default: () => {
      return "YYYY-MM-DD";
    } },
    valueFormat: { type: String, default: () => {
      return "YYYY-MM-DD";
    } },
    unlinkPanels: { type: Boolean, default: () => {
      return false;
    } },
    rangeSeparator: { type: String, default: () => {
      return "~";
    } },
    shortcuts: { type: Array, default: () => {
      return [];
    } },
    startPlaceholder: { type: String, default: () => {
      return "\u5F00\u59CB\u65F6\u95F4";
    } },
    endPlaceholder: { type: String, default: () => {
      return "\u7ED3\u675F\u65F6\u95F4";
    } }
  },
  emits: ["update:modelValue", "change", "calendar-change", "panel-change"],
  setup(__props, { emit }) {
    const props2 = __props;
    const modelValue = computed({
      get: () => props2.modelValue,
      set: (value) => {
        emit("update:modelValue", value);
      }
    });
    let calendarChange = (item) => {
      emit("calendar-change", item);
    };
    let panelChange = (item) => {
      emit("panel-change", item);
    };
    let getTime2 = (item) => {
      emit("change", item);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createVNode$1(unref(ElDatePicker), {
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          type: __props.type,
          placeholder: __props.placeholder,
          "start-placeholder": __props.startPlaceholder,
          "end-placeholder": __props.endPlaceholder,
          editable: __props.editable,
          clearable: __props.clearable,
          disabled: __props.disabled,
          readonly: __props.readonly,
          "range-separator": __props.rangeSeparator,
          format: __props.format,
          "value-format": __props.valueFormat,
          unlinkPanels: __props.unlinkPanels,
          shortcuts: __props.shortcuts,
          "disabled-date": __props.disabledDate,
          onChange: unref(getTime2),
          onCalendarChange: unref(calendarChange),
          onPanelChange: unref(panelChange)
        }, null, 8, ["modelValue", "type", "placeholder", "start-placeholder", "end-placeholder", "editable", "clearable", "disabled", "readonly", "range-separator", "format", "value-format", "unlinkPanels", "shortcuts", "disabled-date", "onChange", "onCalendarChange", "onPanelChange"])
      ]);
    };
  }
};
var DataPicker = /* @__PURE__ */ _export_sfc$2(_sfc_main$6, [["__scopeId", "data-v-2b5cf9e4"]]);
const DataPickerPlugin = {
  install(app) {
    app.component("d-data-picker", DataPicker);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$5 = "";
const _hoisted_1$5 = { class: "d-button" };
const _sfc_main$5 = {
  props: {
    type: { type: String, default: () => {
      return "";
    } },
    text: { type: String, default: () => {
      return "\u6309\u94AE";
    } },
    btnType: { type: String, default: () => {
      return "";
    } },
    disabled: { type: Boolean, default: () => {
      return false;
    } },
    icon: [String, Object]
  },
  setup(__props) {
    let slots = useSlots();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        createVNode$1(unref(ElButton), {
          type: __props.type,
          disabled: __props.disabled,
          btnType: __props.btnType,
          icon: __props.icon
        }, {
          default: withCtx(() => [
            unref(slots).content ? renderSlot(_ctx.$slots, "content", { key: 0 }, void 0, true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(__props.text), 1)
            ], 64))
          ]),
          _: 3
        }, 8, ["type", "disabled", "btnType", "icon"])
      ]);
    };
  }
};
var Button = /* @__PURE__ */ _export_sfc$2(_sfc_main$5, [["__scopeId", "data-v-41ee52d0"]]);
const ButtonPlugin = {
  install(app) {
    app.component("d-button", Button);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$4 = "";
const _hoisted_1$4 = { class: "d-checkbox" };
const _sfc_main$4 = {
  props: {
    modelValue: [Object, Array],
    options: { type: Array, default: () => [] }
  },
  emits: ["update:modelValue", "change", "change-all"],
  setup(__props, { emit }) {
    const props2 = __props;
    const modelValue = computed({
      get: () => props2.modelValue,
      set: (value) => {
        emit("update:modelValue", value);
      }
    });
    let changeItem = (visible, item) => {
      emit("change", visible, item);
    };
    let changeAll = (checkLisy) => {
      emit("change-all", checkLisy);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        __props.options.length !== 0 ? (openBlock(), createBlock(unref(ElCheckboxGroup$1), {
          key: 0,
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          onChange: unref(changeAll)
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (item) => {
              return openBlock(), createBlock(unref(ElCheckbox), {
                label: item.label,
                key: item.label,
                disabled: item.disabled,
                onChange: ($event) => unref(changeItem)($event, item)
              }, {
                default: withCtx(() => [
                  item.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(item.value), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(item.label), 1)
                  ], 64))
                ]),
                _: 2
              }, 1032, ["label", "disabled", "onChange"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "onChange"])) : (openBlock(), createBlock(unref(ElCheckbox), {
          key: 1,
          modelValue: unref(modelValue).check,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(modelValue).check = $event),
          label: unref(modelValue).label,
          disabled: unref(modelValue).disabled,
          onChange: _cache[2] || (_cache[2] = ($event) => unref(changeItem)($event, unref(modelValue)))
        }, {
          default: withCtx(() => [
            unref(modelValue).value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(unref(modelValue).value), 1)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(unref(modelValue).label), 1)
            ], 64))
          ]),
          _: 1
        }, 8, ["modelValue", "label", "disabled"]))
      ]);
    };
  }
};
var Checkbox = /* @__PURE__ */ _export_sfc$2(_sfc_main$4, [["__scopeId", "data-v-2ac4a3bc"]]);
const CheckboxPlugin = {
  install(app) {
    app.component("d-checkbox", Checkbox);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$3 = "";
const _hoisted_1$3 = { class: "d-radio" };
const _sfc_main$3 = {
  props: {
    modelValue: [String, Number, Boolean],
    label: [String, Number, Boolean],
    value: [String, Number, Boolean],
    options: { type: Array, default: () => [] },
    disabled: { type: Boolean, default: () => false }
  },
  emits: ["update:modelValue", "change"],
  setup(__props, { emit }) {
    const props2 = __props;
    const modelValue = computed({
      get: () => props2.modelValue,
      set: (value) => {
        emit("update:modelValue", value);
      }
    });
    let changeItem = (label) => {
      emit("change", label);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        __props.options.length !== 0 ? (openBlock(), createBlock(unref(ElRadioGroup), {
          key: 0,
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          onChange: unref(changeItem)
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (item) => {
              return openBlock(), createBlock(unref(ElRadio), {
                label: item.label,
                key: item.label,
                disabled: item.disabled
              }, {
                default: withCtx(() => [
                  item.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(item.value), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(item.label), 1)
                  ], 64))
                ]),
                _: 2
              }, 1032, ["label", "disabled"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue", "onChange"])) : (openBlock(), createBlock(unref(ElRadio), {
          key: 1,
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          label: __props.label,
          value: __props.value,
          disabled: __props.disabled,
          onChange: unref(changeItem)
        }, {
          default: withCtx(() => [
            __props.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(__props.value), 1)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(__props.label), 1)
            ], 64))
          ]),
          _: 1
        }, 8, ["modelValue", "label", "value", "disabled", "onChange"]))
      ]);
    };
  }
};
var Radio = /* @__PURE__ */ _export_sfc$2(_sfc_main$3, [["__scopeId", "data-v-7f82e0bc"]]);
const RadioPlugin = {
  install(app) {
    app.component("d-radio", Radio);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$2 = "";
const _hoisted_1$2 = { class: "d-switch" };
const _sfc_main$2 = {
  props: {
    modelValue: { type: Boolean, default: () => {
      return false;
    } },
    disabled: { type: Boolean, default: () => false },
    inlinePrompt: { type: Boolean, default: () => false },
    loading: { type: Boolean, default: () => false },
    width: { type: Number, default: () => 36 },
    activeColor: { type: String, default: () => "#0455DA" },
    inactiveColor: { type: String, default: () => "#dcdfe6" },
    activeText: { type: String, default: () => "" },
    inactiveText: { type: String, default: () => "" }
  },
  emits: ["update:modelValue", "change"],
  setup(__props, { emit }) {
    const props2 = __props;
    const modelValue = computed({
      get: () => props2.modelValue,
      set: (value) => {
        emit("update:modelValue", value);
      }
    });
    let changeItem = (value) => {
      emit("change", value);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createVNode$1(unref(ElSwitch), {
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          disabled: __props.disabled,
          loading: __props.loading,
          "inline-prompt": __props.inlinePrompt,
          width: __props.width,
          "active-color": __props.activeColor,
          "inactive-color": __props.inactiveColor,
          "active-text": __props.activeText,
          "inactive-text": __props.inactiveText,
          onChange: unref(changeItem)
        }, null, 8, ["modelValue", "disabled", "loading", "inline-prompt", "width", "active-color", "inactive-color", "active-text", "inactive-text", "onChange"])
      ]);
    };
  }
};
var Switch = /* @__PURE__ */ _export_sfc$2(_sfc_main$2, [["__scopeId", "data-v-32d077e7"]]);
const SwitchPlugin = {
  install(app) {
    app.component("d-switch", Switch);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang$1 = "";
const _hoisted_1$1 = { class: "d-upload" };
const _hoisted_2 = /* @__PURE__ */ createTextVNode("\u9009\u62E9\u6587\u4EF6");
const _sfc_main$1 = {
  props: {
    modelValue: [String, Number],
    action: { type: String, default: "http://siteops.uat2.dpi.net.cn:8088/file/upload" },
    limit: { type: Number, default: 1 },
    showFileList: { type: Boolean, default: false },
    onSuccess: Function,
    onRemove: Function,
    beforeRemove: Function,
    onExceed: Function,
    onChange: Function
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createVNode$1(unref(ElUpload), {
          class: "upload-demo",
          action: __props.action,
          "on-success": __props.onSuccess,
          "on-remove": __props.onRemove,
          "before-remove": __props.beforeRemove,
          limit: __props.limit,
          "on-exceed": __props.onExceed,
          "on-change": __props.onChange,
          "show-file-list": __props.showFileList
        }, {
          default: withCtx(() => [
            createVNode$1(unref(ElButton), { type: "primary" }, {
              default: withCtx(() => [
                _hoisted_2
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["action", "on-success", "on-remove", "before-remove", "limit", "on-exceed", "on-change", "show-file-list"])
      ]);
    };
  }
};
var Upload = /* @__PURE__ */ _export_sfc$2(_sfc_main$1, [["__scopeId", "data-v-34de161f"]]);
const UploadPlugin = {
  install(app) {
    app.component("d-upload", Upload);
  }
};
var index_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1 = { class: "d-icon" };
const _sfc_main = {
  props: {
    size: { type: Number, default: () => {
      return 16;
    } },
    color: { type: String, default: () => {
      return "#0E1D38";
    } },
    class: { type: String, default: () => {
      return "";
    } }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode$1(unref(ElIcon), {
          size: __props.size,
          color: __props.color
        }, {
          default: withCtx(() => [
            props2.class === "AddLocation" ? (openBlock(), createBlock(unref(addLocation), { key: 0 })) : createCommentVNode("", true),
            props2.class === "Aim" ? (openBlock(), createBlock(unref(aim), { key: 1 })) : createCommentVNode("", true),
            props2.class === "AlarmClock" ? (openBlock(), createBlock(unref(alarmClock), { key: 2 })) : createCommentVNode("", true),
            props2.class === "Apple" ? (openBlock(), createBlock(unref(apple), { key: 3 })) : createCommentVNode("", true),
            props2.class === "ArrowDownBold" ? (openBlock(), createBlock(unref(arrowDownBold), { key: 4 })) : createCommentVNode("", true),
            props2.class === "ArrowDown" ? (openBlock(), createBlock(unref(arrowDown), { key: 5 })) : createCommentVNode("", true),
            props2.class === "ArrowLeftBold" ? (openBlock(), createBlock(unref(arrowLeftBold), { key: 6 })) : createCommentVNode("", true),
            props2.class === "ArrowLeft" ? (openBlock(), createBlock(unref(arrowLeft), { key: 7 })) : createCommentVNode("", true),
            props2.class === "ArrowRightBold" ? (openBlock(), createBlock(unref(arrowRightBold), { key: 8 })) : createCommentVNode("", true),
            props2.class === "ArrowRight" ? (openBlock(), createBlock(unref(arrowRight), { key: 9 })) : createCommentVNode("", true),
            props2.class === "ArrowUpBold" ? (openBlock(), createBlock(unref(arrowUpBold), { key: 10 })) : createCommentVNode("", true),
            props2.class === "Avatar" ? (openBlock(), createBlock(unref(avatar), { key: 11 })) : createCommentVNode("", true),
            props2.class === "Back" ? (openBlock(), createBlock(unref(back), { key: 12 })) : createCommentVNode("", true),
            props2.class === "Baseball" ? (openBlock(), createBlock(unref(baseball), { key: 13 })) : createCommentVNode("", true),
            props2.class === "Basketball" ? (openBlock(), createBlock(unref(basketball), { key: 14 })) : createCommentVNode("", true),
            props2.class === "Bell" ? (openBlock(), createBlock(unref(bell), { key: 15 })) : createCommentVNode("", true),
            props2.class === "BellFilled" ? (openBlock(), createBlock(unref(bellFilled), { key: 16 })) : createCommentVNode("", true),
            props2.class === "Bicycle" ? (openBlock(), createBlock(unref(bicycle), { key: 17 })) : createCommentVNode("", true),
            props2.class === "Bottom" ? (openBlock(), createBlock(unref(bottom$1), { key: 18 })) : createCommentVNode("", true),
            props2.class === "BottomLeft" ? (openBlock(), createBlock(unref(bottomLeft), { key: 19 })) : createCommentVNode("", true),
            props2.class === "BottomRight" ? (openBlock(), createBlock(unref(bottomRight), { key: 20 })) : createCommentVNode("", true),
            props2.class === "Bowl" ? (openBlock(), createBlock(unref(bowl), { key: 21 })) : createCommentVNode("", true),
            props2.class === "Box" ? (openBlock(), createBlock(unref(box), { key: 22 })) : createCommentVNode("", true),
            props2.class === "Briefcase" ? (openBlock(), createBlock(unref(briefcase), { key: 23 })) : createCommentVNode("", true),
            props2.class === "Brush" ? (openBlock(), createBlock(unref(brush), { key: 24 })) : createCommentVNode("", true),
            props2.class === "BrushFilled" ? (openBlock(), createBlock(unref(brushFilled), { key: 25 })) : createCommentVNode("", true),
            props2.class === "Burger" ? (openBlock(), createBlock(unref(burger), { key: 26 })) : createCommentVNode("", true),
            props2.class === "Calendar" ? (openBlock(), createBlock(unref(calendar), { key: 27 })) : createCommentVNode("", true),
            props2.class === "Camera" ? (openBlock(), createBlock(unref(camera), { key: 28 })) : createCommentVNode("", true),
            props2.class === "CameraFilled" ? (openBlock(), createBlock(unref(cameraFilled), { key: 29 })) : createCommentVNode("", true),
            props2.class === "CaretBottom" ? (openBlock(), createBlock(unref(caretBottom), { key: 30 })) : createCommentVNode("", true),
            props2.class === "CaretLeft" ? (openBlock(), createBlock(unref(caretLeft), { key: 31 })) : createCommentVNode("", true),
            props2.class === "CaretRight" ? (openBlock(), createBlock(unref(caretRight), { key: 32 })) : createCommentVNode("", true),
            props2.class === "CaretTop" ? (openBlock(), createBlock(unref(caretTop), { key: 33 })) : createCommentVNode("", true),
            props2.class === "Cellphone" ? (openBlock(), createBlock(unref(cellphone), { key: 34 })) : createCommentVNode("", true),
            props2.class === "ChatDotRound" ? (openBlock(), createBlock(unref(chatDotRound), { key: 35 })) : createCommentVNode("", true),
            props2.class === "ChatDotSquare" ? (openBlock(), createBlock(unref(chatDotSquare), { key: 36 })) : createCommentVNode("", true),
            props2.class === "ChatLineRound" ? (openBlock(), createBlock(unref(chatLineRound), { key: 37 })) : createCommentVNode("", true),
            props2.class === "ChatLineSquare" ? (openBlock(), createBlock(unref(chatLineSquare), { key: 38 })) : createCommentVNode("", true),
            props2.class === "ChatRound" ? (openBlock(), createBlock(unref(chatRound), { key: 39 })) : createCommentVNode("", true),
            props2.class === "ChatSquare" ? (openBlock(), createBlock(unref(chatSquare), { key: 40 })) : createCommentVNode("", true),
            props2.class === "Check" ? (openBlock(), createBlock(unref(check), { key: 41 })) : createCommentVNode("", true),
            props2.class === "Checked" ? (openBlock(), createBlock(unref(checked), { key: 42 })) : createCommentVNode("", true),
            props2.class === "Cherry" ? (openBlock(), createBlock(unref(cherry), { key: 43 })) : createCommentVNode("", true),
            props2.class === "Chicken" ? (openBlock(), createBlock(unref(chicken), { key: 44 })) : createCommentVNode("", true),
            props2.class === "CircleCheck" ? (openBlock(), createBlock(unref(circleCheck), { key: 45 })) : createCommentVNode("", true),
            props2.class === "CircleCheckFilled" ? (openBlock(), createBlock(unref(circleCheckFilled), { key: 46 })) : createCommentVNode("", true),
            props2.class === "CircleClose" ? (openBlock(), createBlock(unref(circleClose), { key: 47 })) : createCommentVNode("", true),
            props2.class === "CircleCloseFilled" ? (openBlock(), createBlock(unref(circleCloseFilled), { key: 48 })) : createCommentVNode("", true),
            props2.class === "CirclePlus" ? (openBlock(), createBlock(unref(circlePlus), { key: 49 })) : createCommentVNode("", true),
            props2.class === "CirclePlusFilled" ? (openBlock(), createBlock(unref(circlePlusFilled), { key: 50 })) : createCommentVNode("", true),
            props2.class === "Clock" ? (openBlock(), createBlock(unref(clock), { key: 51 })) : createCommentVNode("", true),
            props2.class === "Close" ? (openBlock(), createBlock(unref(close), { key: 52 })) : createCommentVNode("", true),
            props2.class === "CloseBold" ? (openBlock(), createBlock(unref(closeBold), { key: 53 })) : createCommentVNode("", true),
            props2.class === "Cloudy" ? (openBlock(), createBlock(unref(cloudy), { key: 54 })) : createCommentVNode("", true),
            props2.class === "Coffee" ? (openBlock(), createBlock(unref(coffee), { key: 55 })) : createCommentVNode("", true),
            props2.class === "CoffeeCup" ? (openBlock(), createBlock(unref(coffeeCup), { key: 56 })) : createCommentVNode("", true),
            props2.class === "Coin" ? (openBlock(), createBlock(unref(coin), { key: 57 })) : createCommentVNode("", true),
            props2.class === "ColdDrink" ? (openBlock(), createBlock(unref(coldDrink), { key: 58 })) : createCommentVNode("", true),
            props2.class === "Collection" ? (openBlock(), createBlock(unref(collection), { key: 59 })) : createCommentVNode("", true),
            props2.class === "CollectionTag" ? (openBlock(), createBlock(unref(collectionTag), { key: 60 })) : createCommentVNode("", true),
            props2.class === "Comment" ? (openBlock(), createBlock(unref(comment), { key: 61 })) : createCommentVNode("", true),
            props2.class === "Compass" ? (openBlock(), createBlock(unref(compass), { key: 62 })) : createCommentVNode("", true),
            props2.class === "Connection" ? (openBlock(), createBlock(unref(connection), { key: 63 })) : createCommentVNode("", true),
            props2.class === "Coordinate" ? (openBlock(), createBlock(unref(coordinate), { key: 64 })) : createCommentVNode("", true),
            props2.class === "CopyDocument" ? (openBlock(), createBlock(unref(copyDocument), { key: 65 })) : createCommentVNode("", true),
            props2.class === "Cpu" ? (openBlock(), createBlock(unref(cpu), { key: 66 })) : createCommentVNode("", true),
            props2.class === "CreditCard" ? (openBlock(), createBlock(unref(creditCard), { key: 67 })) : createCommentVNode("", true),
            props2.class === "Crop" ? (openBlock(), createBlock(unref(crop), { key: 68 })) : createCommentVNode("", true),
            props2.class === "DArrowLeft" ? (openBlock(), createBlock(unref(dArrowLeft), { key: 69 })) : createCommentVNode("", true),
            props2.class === "DArrowRight" ? (openBlock(), createBlock(unref(dArrowRight), { key: 70 })) : createCommentVNode("", true),
            props2.class === "DCaret" ? (openBlock(), createBlock(unref(dCaret), { key: 71 })) : createCommentVNode("", true),
            props2.class === "DataAnalysis" ? (openBlock(), createBlock(unref(dataAnalysis), { key: 72 })) : createCommentVNode("", true),
            props2.class === "DataBoard" ? (openBlock(), createBlock(unref(dataBoard), { key: 73 })) : createCommentVNode("", true),
            props2.class === "DataLine" ? (openBlock(), createBlock(unref(dataLine), { key: 74 })) : createCommentVNode("", true),
            props2.class === "Delete" ? (openBlock(), createBlock(unref(_delete), { key: 75 })) : createCommentVNode("", true),
            props2.class === "DeleteFilled" ? (openBlock(), createBlock(unref(deleteFilled), { key: 76 })) : createCommentVNode("", true),
            props2.class === "DeleteLocation" ? (openBlock(), createBlock(unref(deleteLocation), { key: 77 })) : createCommentVNode("", true),
            props2.class === "Dessert" ? (openBlock(), createBlock(unref(dessert), { key: 78 })) : createCommentVNode("", true),
            props2.class === "Discount" ? (openBlock(), createBlock(unref(discount), { key: 79 })) : createCommentVNode("", true),
            props2.class === "Dish" ? (openBlock(), createBlock(unref(dish), { key: 80 })) : createCommentVNode("", true),
            props2.class === "DishDot" ? (openBlock(), createBlock(unref(dishDot), { key: 81 })) : createCommentVNode("", true),
            props2.class === "Document" ? (openBlock(), createBlock(unref(document$1), { key: 82 })) : createCommentVNode("", true),
            props2.class === "DocumentAdd" ? (openBlock(), createBlock(unref(documentAdd), { key: 83 })) : createCommentVNode("", true),
            props2.class === "DocumentChecked" ? (openBlock(), createBlock(unref(documentChecked), { key: 84 })) : createCommentVNode("", true),
            props2.class === "DocumentCopy" ? (openBlock(), createBlock(unref(documentCopy), { key: 85 })) : createCommentVNode("", true),
            props2.class === "DocumentDelete" ? (openBlock(), createBlock(unref(documentDelete), { key: 86 })) : createCommentVNode("", true),
            props2.class === "DocumentRemove" ? (openBlock(), createBlock(unref(documentRemove), { key: 87 })) : createCommentVNode("", true),
            props2.class === "Download" ? (openBlock(), createBlock(unref(download), { key: 88 })) : createCommentVNode("", true),
            props2.class === "Drizzling" ? (openBlock(), createBlock(unref(drizzling), { key: 89 })) : createCommentVNode("", true),
            props2.class === "Edit" ? (openBlock(), createBlock(unref(edit), { key: 90 })) : createCommentVNode("", true),
            props2.class === "EditPen" ? (openBlock(), createBlock(unref(editPen), { key: 91 })) : createCommentVNode("", true),
            props2.class === "Eleme" ? (openBlock(), createBlock(unref(eleme), { key: 92 })) : createCommentVNode("", true),
            props2.class === "ElemeFilled" ? (openBlock(), createBlock(unref(elemeFilled), { key: 93 })) : createCommentVNode("", true),
            props2.class === "ElementPlus" ? (openBlock(), createBlock(unref(elementPlus), { key: 94 })) : createCommentVNode("", true),
            props2.class === "Expand" ? (openBlock(), createBlock(unref(expand), { key: 95 })) : createCommentVNode("", true),
            props2.class === "Failed" ? (openBlock(), createBlock(unref(failed), { key: 96 })) : createCommentVNode("", true),
            props2.class === "Female" ? (openBlock(), createBlock(unref(female), { key: 97 })) : createCommentVNode("", true),
            props2.class === "Files" ? (openBlock(), createBlock(unref(files), { key: 98 })) : createCommentVNode("", true),
            props2.class === "Film" ? (openBlock(), createBlock(unref(film), { key: 99 })) : createCommentVNode("", true),
            props2.class === "Filter" ? (openBlock(), createBlock(unref(filter), { key: 100 })) : createCommentVNode("", true),
            props2.class === "Finished" ? (openBlock(), createBlock(unref(finished), { key: 101 })) : createCommentVNode("", true),
            props2.class === "FirstAidKit" ? (openBlock(), createBlock(unref(firstAidKit), { key: 102 })) : createCommentVNode("", true),
            props2.class === "Flag" ? (openBlock(), createBlock(unref(flag), { key: 103 })) : createCommentVNode("", true),
            props2.class === "Fold" ? (openBlock(), createBlock(unref(fold), { key: 104 })) : createCommentVNode("", true),
            props2.class === "Folder" ? (openBlock(), createBlock(unref(folder), { key: 105 })) : createCommentVNode("", true),
            props2.class === "FolderAdd" ? (openBlock(), createBlock(unref(folderAdd), { key: 106 })) : createCommentVNode("", true),
            props2.class === "FolderChecked" ? (openBlock(), createBlock(unref(folderChecked), { key: 107 })) : createCommentVNode("", true),
            props2.class === "FolderDelete" ? (openBlock(), createBlock(unref(folderDelete), { key: 108 })) : createCommentVNode("", true),
            props2.class === "FolderOpened" ? (openBlock(), createBlock(unref(folderOpened), { key: 109 })) : createCommentVNode("", true),
            props2.class === "FolderRemove" ? (openBlock(), createBlock(unref(folderRemove), { key: 110 })) : createCommentVNode("", true),
            props2.class === "Food" ? (openBlock(), createBlock(unref(food), { key: 111 })) : createCommentVNode("", true),
            props2.class === "Football" ? (openBlock(), createBlock(unref(football), { key: 112 })) : createCommentVNode("", true),
            props2.class === "ForkSpoon" ? (openBlock(), createBlock(unref(forkSpoon), { key: 113 })) : createCommentVNode("", true),
            props2.class === "Fries" ? (openBlock(), createBlock(unref(fries), { key: 114 })) : createCommentVNode("", true),
            props2.class === "FullScreen" ? (openBlock(), createBlock(unref(fullScreen), { key: 115 })) : createCommentVNode("", true),
            props2.class === "Goblet" ? (openBlock(), createBlock(unref(goblet), { key: 116 })) : createCommentVNode("", true),
            props2.class === "GobletFull" ? (openBlock(), createBlock(unref(gobletFull), { key: 117 })) : createCommentVNode("", true),
            props2.class === "GobletSquare" ? (openBlock(), createBlock(unref(gobletSquare), { key: 118 })) : createCommentVNode("", true),
            props2.class === "GobletSquareFull" ? (openBlock(), createBlock(unref(gobletSquareFull), { key: 119 })) : createCommentVNode("", true),
            props2.class === "Goods" ? (openBlock(), createBlock(unref(goods), { key: 120 })) : createCommentVNode("", true),
            props2.class === "GoodsFilled" ? (openBlock(), createBlock(unref(goodsFilled), { key: 121 })) : createCommentVNode("", true),
            props2.class === "Grape" ? (openBlock(), createBlock(unref(grape), { key: 122 })) : createCommentVNode("", true),
            props2.class === "Grid" ? (openBlock(), createBlock(unref(grid), { key: 123 })) : createCommentVNode("", true),
            props2.class === "Guide" ? (openBlock(), createBlock(unref(guide), { key: 124 })) : createCommentVNode("", true),
            props2.class === "Headset" ? (openBlock(), createBlock(unref(headset), { key: 125 })) : createCommentVNode("", true),
            props2.class === "Help" ? (openBlock(), createBlock(unref(help), { key: 126 })) : createCommentVNode("", true),
            props2.class === "HelpFilled" ? (openBlock(), createBlock(unref(helpFilled), { key: 127 })) : createCommentVNode("", true),
            props2.class === "Hide" ? (openBlock(), createBlock(unref(hide$2), { key: 128 })) : createCommentVNode("", true),
            props2.class === "Histogram" ? (openBlock(), createBlock(unref(histogram), { key: 129 })) : createCommentVNode("", true),
            props2.class === "HomeFilled" ? (openBlock(), createBlock(unref(homeFilled), { key: 130 })) : createCommentVNode("", true),
            props2.class === "HotWater" ? (openBlock(), createBlock(unref(hotWater), { key: 131 })) : createCommentVNode("", true),
            props2.class === "House" ? (openBlock(), createBlock(unref(house), { key: 132 })) : createCommentVNode("", true),
            props2.class === "IceCream" ? (openBlock(), createBlock(unref(iceCream), { key: 133 })) : createCommentVNode("", true),
            props2.class === "IceCreamRound" ? (openBlock(), createBlock(unref(iceCreamRound), { key: 134 })) : createCommentVNode("", true),
            props2.class === "IceCreamSquare" ? (openBlock(), createBlock(unref(iceCreamSquare), { key: 135 })) : createCommentVNode("", true),
            props2.class === "IceDrink" ? (openBlock(), createBlock(unref(iceDrink), { key: 136 })) : createCommentVNode("", true),
            props2.class === "IceTea" ? (openBlock(), createBlock(unref(iceTea), { key: 137 })) : createCommentVNode("", true),
            props2.class === "InfoFilled" ? (openBlock(), createBlock(unref(infoFilled), { key: 138 })) : createCommentVNode("", true),
            props2.class === "Iphone" ? (openBlock(), createBlock(unref(iphone), { key: 139 })) : createCommentVNode("", true),
            props2.class === "Key" ? (openBlock(), createBlock(unref(key), { key: 140 })) : createCommentVNode("", true),
            props2.class === "KnifeFork" ? (openBlock(), createBlock(unref(knifeFork), { key: 141 })) : createCommentVNode("", true),
            props2.class === "Lightning" ? (openBlock(), createBlock(unref(lightning), { key: 142 })) : createCommentVNode("", true),
            props2.class === "Link" ? (openBlock(), createBlock(unref(link), { key: 143 })) : createCommentVNode("", true),
            props2.class === "List" ? (openBlock(), createBlock(unref(list), { key: 144 })) : createCommentVNode("", true),
            props2.class === "Loading" ? (openBlock(), createBlock(unref(loading), { key: 145 })) : createCommentVNode("", true),
            props2.class === "Location" ? (openBlock(), createBlock(unref(location), { key: 146 })) : createCommentVNode("", true),
            props2.class === "LocationFilled" ? (openBlock(), createBlock(unref(locationFilled), { key: 147 })) : createCommentVNode("", true),
            props2.class === "LocationInformation" ? (openBlock(), createBlock(unref(locationInformation), { key: 148 })) : createCommentVNode("", true),
            props2.class === "Lock" ? (openBlock(), createBlock(unref(lock), { key: 149 })) : createCommentVNode("", true),
            props2.class === "Lollipop" ? (openBlock(), createBlock(unref(lollipop), { key: 150 })) : createCommentVNode("", true),
            props2.class === "MagicStick" ? (openBlock(), createBlock(unref(magicStick), { key: 151 })) : createCommentVNode("", true),
            props2.class === "Magnet" ? (openBlock(), createBlock(unref(magnet), { key: 152 })) : createCommentVNode("", true),
            props2.class === "Male" ? (openBlock(), createBlock(unref(male), { key: 153 })) : createCommentVNode("", true),
            props2.class === "Management" ? (openBlock(), createBlock(unref(management), { key: 154 })) : createCommentVNode("", true),
            props2.class === "MapLocation" ? (openBlock(), createBlock(unref(mapLocation), { key: 155 })) : createCommentVNode("", true),
            props2.class === "Medal" ? (openBlock(), createBlock(unref(medal), { key: 156 })) : createCommentVNode("", true),
            props2.class === "Menu" ? (openBlock(), createBlock(unref(menu), { key: 157 })) : createCommentVNode("", true),
            props2.class === "Message" ? (openBlock(), createBlock(unref(message), { key: 158 })) : createCommentVNode("", true),
            props2.class === "MessageBox" ? (openBlock(), createBlock(unref(messageBox), { key: 159 })) : createCommentVNode("", true),
            props2.class === "Mic" ? (openBlock(), createBlock(unref(mic), { key: 160 })) : createCommentVNode("", true),
            props2.class === "Microphone" ? (openBlock(), createBlock(unref(microphone), { key: 161 })) : createCommentVNode("", true),
            props2.class === "MilkTea" ? (openBlock(), createBlock(unref(milkTea), { key: 162 })) : createCommentVNode("", true),
            props2.class === "Minus" ? (openBlock(), createBlock(unref(minus), { key: 163 })) : createCommentVNode("", true),
            props2.class === "Money" ? (openBlock(), createBlock(unref(money), { key: 164 })) : createCommentVNode("", true),
            props2.class === "Monitor" ? (openBlock(), createBlock(unref(monitor), { key: 165 })) : createCommentVNode("", true),
            props2.class === "Moon" ? (openBlock(), createBlock(unref(moon), { key: 166 })) : createCommentVNode("", true),
            props2.class === "MoonNight" ? (openBlock(), createBlock(unref(moonNight), { key: 167 })) : createCommentVNode("", true),
            props2.class === "More" ? (openBlock(), createBlock(unref(more), { key: 168 })) : createCommentVNode("", true),
            props2.class === "MoreFilled" ? (openBlock(), createBlock(unref(moreFilled), { key: 169 })) : createCommentVNode("", true),
            props2.class === "MostlyCloudy" ? (openBlock(), createBlock(unref(mostlyCloudy), { key: 170 })) : createCommentVNode("", true),
            props2.class === "Mouse" ? (openBlock(), createBlock(unref(mouse), { key: 171 })) : createCommentVNode("", true),
            props2.class === "Mug" ? (openBlock(), createBlock(unref(mug), { key: 172 })) : createCommentVNode("", true),
            props2.class === "Mute" ? (openBlock(), createBlock(unref(mute), { key: 173 })) : createCommentVNode("", true),
            props2.class === "MuteNotification" ? (openBlock(), createBlock(unref(muteNotification), { key: 174 })) : createCommentVNode("", true),
            props2.class === "NoSmoking" ? (openBlock(), createBlock(unref(noSmoking), { key: 175 })) : createCommentVNode("", true),
            props2.class === "Notebook" ? (openBlock(), createBlock(unref(notebook), { key: 176 })) : createCommentVNode("", true),
            props2.class === "Notification" ? (openBlock(), createBlock(unref(notification), { key: 177 })) : createCommentVNode("", true),
            props2.class === "Odometer" ? (openBlock(), createBlock(unref(odometer), { key: 178 })) : createCommentVNode("", true),
            props2.class === "OfficeBuilding" ? (openBlock(), createBlock(unref(officeBuilding), { key: 179 })) : createCommentVNode("", true),
            props2.class === "Open" ? (openBlock(), createBlock(unref(open), { key: 180 })) : createCommentVNode("", true),
            props2.class === "Operation" ? (openBlock(), createBlock(unref(operation), { key: 181 })) : createCommentVNode("", true),
            props2.class === "Opportunity" ? (openBlock(), createBlock(unref(opportunity), { key: 182 })) : createCommentVNode("", true),
            props2.class === "Orange" ? (openBlock(), createBlock(unref(orange), { key: 183 })) : createCommentVNode("", true),
            props2.class === "Paperclip" ? (openBlock(), createBlock(unref(paperclip), { key: 184 })) : createCommentVNode("", true),
            props2.class === "PartlyCloudy" ? (openBlock(), createBlock(unref(partlyCloudy), { key: 185 })) : createCommentVNode("", true),
            props2.class === "Pear" ? (openBlock(), createBlock(unref(pear), { key: 186 })) : createCommentVNode("", true),
            props2.class === "Phone" ? (openBlock(), createBlock(unref(phone), { key: 187 })) : createCommentVNode("", true),
            props2.class === "PhoneFilled" ? (openBlock(), createBlock(unref(phoneFilled), { key: 188 })) : createCommentVNode("", true),
            props2.class === "Picture" ? (openBlock(), createBlock(unref(picture), { key: 189 })) : createCommentVNode("", true),
            props2.class === "PictureFilled" ? (openBlock(), createBlock(unref(pictureFilled), { key: 190 })) : createCommentVNode("", true),
            props2.class === "PictureRounded" ? (openBlock(), createBlock(unref(pictureRounded), { key: 191 })) : createCommentVNode("", true),
            props2.class === "PieChart" ? (openBlock(), createBlock(unref(pieChart), { key: 192 })) : createCommentVNode("", true),
            props2.class === "Place" ? (openBlock(), createBlock(unref(place), { key: 193 })) : createCommentVNode("", true),
            props2.class === "Platform" ? (openBlock(), createBlock(unref(platform), { key: 194 })) : createCommentVNode("", true),
            props2.class === "Plus" ? (openBlock(), createBlock(unref(plus), { key: 195 })) : createCommentVNode("", true),
            props2.class === "Pointer" ? (openBlock(), createBlock(unref(pointer), { key: 196 })) : createCommentVNode("", true),
            props2.class === "Position" ? (openBlock(), createBlock(unref(position), { key: 197 })) : createCommentVNode("", true),
            props2.class === "Postcard" ? (openBlock(), createBlock(unref(postcard), { key: 198 })) : createCommentVNode("", true),
            props2.class === "Pouring" ? (openBlock(), createBlock(unref(pouring), { key: 199 })) : createCommentVNode("", true),
            props2.class === "Present" ? (openBlock(), createBlock(unref(present), { key: 200 })) : createCommentVNode("", true),
            props2.class === "PriceTag" ? (openBlock(), createBlock(unref(priceTag), { key: 201 })) : createCommentVNode("", true),
            props2.class === "Printer" ? (openBlock(), createBlock(unref(printer), { key: 202 })) : createCommentVNode("", true),
            props2.class === "Promotion" ? (openBlock(), createBlock(unref(promotion), { key: 203 })) : createCommentVNode("", true),
            props2.class === "QuestionFilled" ? (openBlock(), createBlock(unref(questionFilled), { key: 204 })) : createCommentVNode("", true),
            props2.class === "Rank" ? (openBlock(), createBlock(unref(rank), { key: 205 })) : createCommentVNode("", true),
            props2.class === "Reading" ? (openBlock(), createBlock(unref(reading), { key: 206 })) : createCommentVNode("", true),
            props2.class === "ReadingLamp" ? (openBlock(), createBlock(unref(readingLamp), { key: 207 })) : createCommentVNode("", true),
            props2.class === "Refresh" ? (openBlock(), createBlock(unref(refresh), { key: 208 })) : createCommentVNode("", true),
            props2.class === "RefreshLeft" ? (openBlock(), createBlock(unref(refreshLeft), { key: 209 })) : createCommentVNode("", true),
            props2.class === "RefreshRight" ? (openBlock(), createBlock(unref(refreshRight), { key: 210 })) : createCommentVNode("", true),
            props2.class === "Refrigerator" ? (openBlock(), createBlock(unref(refrigerator), { key: 211 })) : createCommentVNode("", true),
            props2.class === "Remove" ? (openBlock(), createBlock(unref(remove), { key: 212 })) : createCommentVNode("", true),
            props2.class === "RemoveFilled" ? (openBlock(), createBlock(unref(removeFilled), { key: 213 })) : createCommentVNode("", true),
            props2.class === "Right" ? (openBlock(), createBlock(unref(right$1), { key: 214 })) : createCommentVNode("", true),
            props2.class === "ScaleToOriginal" ? (openBlock(), createBlock(unref(scaleToOriginal), { key: 215 })) : createCommentVNode("", true),
            props2.class === "School" ? (openBlock(), createBlock(unref(school), { key: 216 })) : createCommentVNode("", true),
            props2.class === "Scissor" ? (openBlock(), createBlock(unref(scissor), { key: 217 })) : createCommentVNode("", true),
            props2.class === "Search" ? (openBlock(), createBlock(unref(search), { key: 218 })) : createCommentVNode("", true),
            props2.class === "Select" ? (openBlock(), createBlock(unref(select), { key: 219 })) : createCommentVNode("", true),
            props2.class === "Sell" ? (openBlock(), createBlock(unref(sell), { key: 220 })) : createCommentVNode("", true),
            props2.class === "SemiSelect" ? (openBlock(), createBlock(unref(semiSelect), { key: 221 })) : createCommentVNode("", true),
            props2.class === "Service" ? (openBlock(), createBlock(unref(service), { key: 222 })) : createCommentVNode("", true),
            props2.class === "SetUp" ? (openBlock(), createBlock(unref(setUp), { key: 223 })) : createCommentVNode("", true),
            props2.class === "Setting" ? (openBlock(), createBlock(unref(setting), { key: 224 })) : createCommentVNode("", true),
            props2.class === "Share" ? (openBlock(), createBlock(unref(share), { key: 225 })) : createCommentVNode("", true),
            props2.class === "Ship" ? (openBlock(), createBlock(unref(ship), { key: 226 })) : createCommentVNode("", true),
            props2.class === "Shop" ? (openBlock(), createBlock(unref(shop), { key: 227 })) : createCommentVNode("", true),
            props2.class === "ShoppingBag" ? (openBlock(), createBlock(unref(shoppingBag), { key: 228 })) : createCommentVNode("", true),
            props2.class === "ShoppingCart" ? (openBlock(), createBlock(unref(shoppingCart), { key: 229 })) : createCommentVNode("", true),
            props2.class === "ShoppingCartFull" ? (openBlock(), createBlock(unref(shoppingCartFull), { key: 230 })) : createCommentVNode("", true),
            props2.class === "Smoking" ? (openBlock(), createBlock(unref(smoking), { key: 231 })) : createCommentVNode("", true),
            props2.class === "Soccer" ? (openBlock(), createBlock(unref(soccer), { key: 232 })) : createCommentVNode("", true),
            props2.class === "SoldOut" ? (openBlock(), createBlock(unref(soldOut), { key: 233 })) : createCommentVNode("", true),
            props2.class === "Sort" ? (openBlock(), createBlock(unref(sort), { key: 234 })) : createCommentVNode("", true),
            props2.class === "SortDown" ? (openBlock(), createBlock(unref(sortDown), { key: 235 })) : createCommentVNode("", true),
            props2.class === "SortUp" ? (openBlock(), createBlock(unref(sortUp), { key: 236 })) : createCommentVNode("", true),
            props2.class === "Stamp" ? (openBlock(), createBlock(unref(stamp), { key: 237 })) : createCommentVNode("", true),
            props2.class === "Star" ? (openBlock(), createBlock(unref(star), { key: 238 })) : createCommentVNode("", true),
            props2.class === "StarFilled" ? (openBlock(), createBlock(unref(starFilled), { key: 239 })) : createCommentVNode("", true),
            props2.class === "Stopwatch" ? (openBlock(), createBlock(unref(stopwatch), { key: 240 })) : createCommentVNode("", true),
            props2.class === "SuccessFilled" ? (openBlock(), createBlock(unref(successFilled), { key: 241 })) : createCommentVNode("", true),
            props2.class === "Sugar" ? (openBlock(), createBlock(unref(sugar), { key: 242 })) : createCommentVNode("", true),
            props2.class === "Suitcase" ? (openBlock(), createBlock(unref(suitcase), { key: 243 })) : createCommentVNode("", true),
            props2.class === "Sunny" ? (openBlock(), createBlock(unref(sunny), { key: 244 })) : createCommentVNode("", true),
            props2.class === "Sunrise" ? (openBlock(), createBlock(unref(sunrise), { key: 245 })) : createCommentVNode("", true),
            props2.class === "Sunset" ? (openBlock(), createBlock(unref(sunset), { key: 246 })) : createCommentVNode("", true),
            props2.class === "Switch" ? (openBlock(), createBlock(unref(_switch), { key: 247 })) : createCommentVNode("", true),
            props2.class === "SwitchButton" ? (openBlock(), createBlock(unref(switchButton), { key: 248 })) : createCommentVNode("", true),
            props2.class === "TakeawayBox" ? (openBlock(), createBlock(unref(takeawayBox), { key: 249 })) : createCommentVNode("", true),
            props2.class === "Ticket" ? (openBlock(), createBlock(unref(ticket), { key: 250 })) : createCommentVNode("", true),
            props2.class === "Tickets" ? (openBlock(), createBlock(unref(tickets), { key: 251 })) : createCommentVNode("", true),
            props2.class === "Timer" ? (openBlock(), createBlock(unref(timer), { key: 252 })) : createCommentVNode("", true),
            props2.class === "ToiletPaper" ? (openBlock(), createBlock(unref(toiletPaper), { key: 253 })) : createCommentVNode("", true),
            props2.class === "Tools" ? (openBlock(), createBlock(unref(tools), { key: 254 })) : createCommentVNode("", true),
            props2.class === "Top" ? (openBlock(), createBlock(unref(top$1), { key: 255 })) : createCommentVNode("", true),
            props2.class === "TopLeft" ? (openBlock(), createBlock(unref(topLeft), { key: 256 })) : createCommentVNode("", true),
            props2.class === "TopRight" ? (openBlock(), createBlock(unref(topRight), { key: 257 })) : createCommentVNode("", true),
            props2.class === "TrendCharts" ? (openBlock(), createBlock(unref(trendCharts), { key: 258 })) : createCommentVNode("", true),
            props2.class === "Trophy" ? (openBlock(), createBlock(unref(trophy), { key: 259 })) : createCommentVNode("", true),
            props2.class === "TurnOff" ? (openBlock(), createBlock(unref(turnOff), { key: 260 })) : createCommentVNode("", true),
            props2.class === "Umbrella" ? (openBlock(), createBlock(unref(umbrella), { key: 261 })) : createCommentVNode("", true),
            props2.class === "Unlock" ? (openBlock(), createBlock(unref(unlock), { key: 262 })) : createCommentVNode("", true),
            props2.class === "Upload" ? (openBlock(), createBlock(unref(upload), { key: 263 })) : createCommentVNode("", true),
            props2.class === "UploadFilled" ? (openBlock(), createBlock(unref(uploadFilled), { key: 264 })) : createCommentVNode("", true),
            props2.class === "User" ? (openBlock(), createBlock(unref(user), { key: 265 })) : createCommentVNode("", true),
            props2.class === "UserFilled" ? (openBlock(), createBlock(unref(userFilled), { key: 266 })) : createCommentVNode("", true),
            props2.class === "Van" ? (openBlock(), createBlock(unref(van), { key: 267 })) : createCommentVNode("", true),
            props2.class === "VideoCamera" ? (openBlock(), createBlock(unref(videoCamera), { key: 268 })) : createCommentVNode("", true),
            props2.class === "VideoCameraFilled" ? (openBlock(), createBlock(unref(videoCameraFilled), { key: 269 })) : createCommentVNode("", true),
            props2.class === "VideoPause" ? (openBlock(), createBlock(unref(videoPause), { key: 270 })) : createCommentVNode("", true),
            props2.class === "VideoPlay" ? (openBlock(), createBlock(unref(videoPlay), { key: 271 })) : createCommentVNode("", true),
            props2.class === "View" ? (openBlock(), createBlock(unref(view), { key: 272 })) : createCommentVNode("", true),
            props2.class === "Wallet" ? (openBlock(), createBlock(unref(wallet), { key: 273 })) : createCommentVNode("", true),
            props2.class === "WalletFilled" ? (openBlock(), createBlock(unref(walletFilled), { key: 274 })) : createCommentVNode("", true),
            props2.class === "Warning" ? (openBlock(), createBlock(unref(warning), { key: 275 })) : createCommentVNode("", true),
            props2.class === "WarningFilled" ? (openBlock(), createBlock(unref(warningFilled), { key: 276 })) : createCommentVNode("", true),
            props2.class === "Watch" ? (openBlock(), createBlock(unref(watch), { key: 277 })) : createCommentVNode("", true),
            props2.class === "Watermelon" ? (openBlock(), createBlock(unref(watermelon), { key: 278 })) : createCommentVNode("", true),
            props2.class === "WindPower" ? (openBlock(), createBlock(unref(windPower), { key: 279 })) : createCommentVNode("", true),
            props2.class === "ZoomIn" ? (openBlock(), createBlock(unref(zoomIn), { key: 280 })) : createCommentVNode("", true),
            props2.class === "ZoomOut" ? (openBlock(), createBlock(unref(zoomOut), { key: 281 })) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["size", "color"])
      ]);
    };
  }
};
var Icon = /* @__PURE__ */ _export_sfc$2(_sfc_main, [["__scopeId", "data-v-0362df1b"]]);
const IconPlugin = {
  install(app) {
    app.component("d-icon", Icon);
  }
};
const DPlugin = {
  install(app) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    (_a2 = CountToPlugin.install) == null ? void 0 : _a2.call(CountToPlugin, app);
    (_b2 = EnChartPlugin.install) == null ? void 0 : _b2.call(EnChartPlugin, app);
    (_c2 = AlarmInfoPlugin.install) == null ? void 0 : _c2.call(AlarmInfoPlugin, app);
    (_d = CascaderPlugin.install) == null ? void 0 : _d.call(CascaderPlugin, app);
    (_e = SelectPlugin.install) == null ? void 0 : _e.call(SelectPlugin, app);
    (_f = TooltipPlugin.install) == null ? void 0 : _f.call(TooltipPlugin, app);
    (_g = TransferPlugin.install) == null ? void 0 : _g.call(TransferPlugin, app);
    (_h = DialogPlugin.install) == null ? void 0 : _h.call(DialogPlugin, app);
    (_i = PaginationPlugin.install) == null ? void 0 : _i.call(PaginationPlugin, app);
    (_j = InputPlugin.install) == null ? void 0 : _j.call(InputPlugin, app);
    (_k = DataPickerPlugin.install) == null ? void 0 : _k.call(DataPickerPlugin, app);
    (_l = ButtonPlugin.install) == null ? void 0 : _l.call(ButtonPlugin, app);
    (_m = CheckboxPlugin.install) == null ? void 0 : _m.call(CheckboxPlugin, app);
    (_n = RadioPlugin.install) == null ? void 0 : _n.call(RadioPlugin, app);
    (_o = SwitchPlugin.install) == null ? void 0 : _o.call(SwitchPlugin, app);
    (_p = UploadPlugin.install) == null ? void 0 : _p.call(UploadPlugin, app);
    (_q = IconPlugin.install) == null ? void 0 : _q.call(IconPlugin, app);
  }
};
export { _sfc_main$5x as AlarmInfo, AlarmInfoPlugin, Button, ButtonPlugin, Cascader, CascaderPlugin, Checkbox, CheckboxPlugin, CountTo, CountToPlugin, DataPicker, DataPickerPlugin, Dialog, DialogPlugin, EnChart, EnChartPlugin, Icon, IconPlugin, Input, InputPlugin, Pagination, PaginationPlugin, Radio, RadioPlugin, Select, SelectPlugin, Switch, SwitchPlugin, Tooltip, TooltipPlugin, Transfer, TransferPlugin, Upload, UploadPlugin, DPlugin as default };
